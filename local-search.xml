<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>双胞胎DFS与BFS</title>
    <link href="/2020/09/27/2020-8-12-dfs-bfs/"/>
    <url>/2020/09/27/2020-8-12-dfs-bfs/</url>
    
    <content type="html"><![CDATA[<h1 id="专题-DFS-amp-BFS"><a href="#专题-DFS-amp-BFS" class="headerlink" title="专题:DFS&amp;BFS"></a>专题:DFS&amp;BFS</h1><blockquote><p> DFS:深度优先搜索，BFS：广度优先搜索，是最频繁被考察的算法知识点之一。我们来找一些例题专门研究一下。</p></blockquote><p>二叉树里面的三种遍历既可以用DFS（递归写法），也可以用BFS（迭代+栈），而层序遍历对应的就是BFS。</p><p>在图论中，DFS是万金油算法，其衍生的如Dijisktra(优先队列)，SPFA算法是<strong>最短路</strong>的主流算法。</p><p>下面介绍一类二维矩阵中典型的「岛屿问题」，来加深理解，在整体DFS框架中又隐藏一些彩蛋，加以利用的话可以极大的优化算法。</p><ul><li><a href="https://leetcode-cn.com/problems/number-of-islands/">L200. 岛屿数量</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/surrounded-regions/">L130.被围绕的区域 (Medium)</a></li><li><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> （Medium）</li><li><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a> （Hard）</li></ul><hr><h2 id="1-被围绕的区域"><a href="#1-被围绕的区域" class="headerlink" title="1.被围绕的区域"></a>1.被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span></code></pre><p>运行你的函数后，矩阵变为：</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span></code></pre><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><hr><p><strong>思路</strong>：常规的想法是在矩阵中找到所有湖然后判断其是否与边界0相连，显然，这不是一个很好的注意，有可能一开碰到边界，也有可能最后找到边界，也有可能中间碰到边界。</p><p>所以此时需要换一种思路，我们找到一个「DFS触发条件」，以减少任务量，一种思路是从四个边界出发，如果为<code>&#39;O&#39;</code>，则进入DFS，将所有的<code>&#39;O&#39;</code>改为<code>&#39;A&#39;</code>，之后遍历完之后，将所有剩余的<code>&#39;O&#39;</code>改为<code>&#39;X&#39;</code>即可。</p><h2 id="2-岛屿的数量"><a href="#2-岛屿的数量" class="headerlink" title="2. 岛屿的数量"></a>2. 岛屿的数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:</p><pre><code class="hljs prolog">[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]]输出: <span class="hljs-number">1</span></code></pre><p>示例 2:</p><pre><code class="hljs prolog">输入:[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>]]输出: <span class="hljs-number">3</span></code></pre><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><hr><p><strong>思路：</strong>同样地，我们判断一个岛屿与哪些1相连是很困难的，因此需要转换思路，我们把「DFS触发条件」设定为<code>grid[x][y]==&#39;1&#39;</code>，此时岛屿数量加1，把遍历过的点改为0.即可。</p><p><strong>时间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。</p><p><strong>空间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 $M×N$。</p><h2 id="3-最大人工岛（Hard）"><a href="#3-最大人工岛（Hard）" class="headerlink" title="3. 最大人工岛（Hard）"></a>3. 最大人工岛（Hard）</h2><p>在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。</p><p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]输出: <span class="hljs-number">3</span>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，最终连通两个小岛得到面积为 <span class="hljs-number">3</span> 的岛屿。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]输出: <span class="hljs-number">4</span>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。</code></pre><p>示例 3:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]输出: <span class="hljs-number">4</span>解释: 没有<span class="hljs-number">0</span>可以让我们变成<span class="hljs-number">1</span>，面积依然为 <span class="hljs-number">4</span>。</code></pre><p>说明:</p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= grid.length = grid[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">50</span><span class="hljs-symbol">0 </span>&lt;= grid[i][j] &lt;= <span class="hljs-number">1</span></code></pre><hr><p>在解这道题之前，我们需要想到一些边界情况;</p><ol><li>全为陆地，则无法填海，<code>maxArea = m*n</code>,m,n分别为地图横纵尺寸。</li><li>全为海洋，则仍可以填岛，<code>maxArea = 1</code>.</li><li>只有一座连通岛，那么此时填充的作用仅仅是扩大面积而不是连通相邻的岛，<code>maxArea = maxArea+1</code>.</li></ol><p>那么如何填充使得面积最大，这个通过题目的简单例子是无法感受到的，比如下面这种情况</p><script type="math/tex; mode=display">[[0,0,1,0,0,0,0,1,0,0,0,0,0],\\ [0,0,0,0,0,0,0,1,1,1,0,0,0],\\ [0,1,1,0,1,0,0,0,0,0,0,0,0],\\ [0,1,0,0,1,1,0,0,1,0,1,0,0],\\ [0,1,0,0,1,1,0,0,1,1,1,0,0],\\ [0,0,0,0,0,0,0,0,0,@,*,0,0],\\ [0,0,0,0,0,0,0,1,1,1,0,0,0],\\ [0,0,0,0,0,0,0,1,1,0,0,0,0]]\\</script><p>（1）<code>@=0,*=0</code>,此时可以把@变为1，最大面积为<code>5+5+1=11</code>。</p><p>（2）<code>@=0,*=1</code>,此时可以把@变为1或者*下方的0变为1，最大面积为<code>6+5+1=12</code>。</p><p><strong>思路</strong>：把连通岛编号<code>index(&gt;=2)</code>。统计每个人工岛的最大面积（通过dfs）。然后再遍历地图，把所有为<code>0</code>的地方，<u>研究其是否连接<em>至少</em>两个岛，即上下左右方向链接不同<code>index</code>的岛屿。</u></p><p>这样的话，我们就能兼顾所有情况。C++代码如下。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m,n,maxArea,index;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; base_area;<span class="hljs-comment">//基础面积哈希表</span>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; d = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">outRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> (x&gt;=m||y&gt;=n||x&lt;<span class="hljs-number">0</span>||y&lt;<span class="hljs-number">0</span>) ;<span class="hljs-comment">//越界检查</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> &amp;area)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//找到至少两个index不相等的岛屿，并统计它们的面积</span>        <span class="hljs-keyword">int</span> base_index = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(!outRange(x+d[i][<span class="hljs-number">0</span>],y+d[i][<span class="hljs-number">1</span>])&amp;&amp;grid[x+d[i][<span class="hljs-number">0</span>]][y+d[i][<span class="hljs-number">1</span>]])             &#123;                base_index = grid[x+d[i][<span class="hljs-number">0</span>]][y+d[i][<span class="hljs-number">1</span>]];                <span class="hljs-keyword">if</span>(!count(temp.begin(),temp.end(),base_index))area += base_area[base_index];                temp[i] = base_index;            &#125;        &#125;                            &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> &amp;area)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">// cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot;,y:&quot;&lt;&lt;y&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(outRange(x,y)|| grid[x][y]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;        grid[x][y] = index;<span class="hljs-comment">//已经走过的陆地标记为index</span>        area+=<span class="hljs-number">1</span>;        dfs(x+<span class="hljs-number">1</span>,y,grid,area);         dfs(x<span class="hljs-number">-1</span>,y,grid,area);         dfs(x,y+<span class="hljs-number">1</span>,grid,area);         dfs(x,y<span class="hljs-number">-1</span>,grid,area);             &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!grid.size()||!grid[<span class="hljs-number">0</span>].size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = grid.size();        n = grid[<span class="hljs-number">0</span>].size();        maxArea = <span class="hljs-number">0</span>;        index = <span class="hljs-number">2</span>;        <span class="hljs-comment">//1.研究基础未填岛情况，把各个岛屿的面积保存再哈希表中</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;            dfs(i,j,grid,area);            base_area[index] = area;            <span class="hljs-built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,area:&quot;</span>&lt;&lt;base_area[index]&lt;&lt;<span class="hljs-built_in">endl</span>;            index++;               maxArea = max(maxArea,area);        &#125;        <span class="hljs-comment">//2.研究填岛情况，遍历所有的0</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)        &#123;<span class="hljs-comment">//如果&lt;u&gt;研究其是否连接*至少*两个岛，即上下左右方向链接不同`index`的岛屿</span>            <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;            connect(i,j,grid,area);            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,area:&quot;</span>&lt;&lt;area&lt;&lt;<span class="hljs-built_in">endl</span>;            maxArea = max(area,maxArea);        &#125;        <span class="hljs-comment">//研究几种需要填岛的特殊情况</span>        <span class="hljs-comment">//1.没有陆地 maxArea==0</span>        <span class="hljs-comment">//2.最大面积岛屿旁边没有相邻岛maxArea!=0, max_fillArea==0</span>        <span class="hljs-keyword">if</span>(maxArea==(m*n)) <span class="hljs-keyword">return</span> m*n;        <span class="hljs-keyword">return</span> maxArea+<span class="hljs-number">1</span>;<span class="hljs-comment">//没有海洋或没有岛</span>    &#125;&#125;;</code></pre><p>时间和空间可以根据代码进行分析。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DFS</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法I 决策树</title>
    <link href="/2020/09/27/ML4_DecisionTree/"/>
    <url>/2020/09/27/ML4_DecisionTree/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习算法I-决策树"><a href="#机器学习算法I-决策树" class="headerlink" title="机器学习算法I: 决策树"></a>机器学习算法I: 决策树</h1><p>决策树的基本算法是「<strong>分而治之</strong>」。</p><p>设有训练集$D$以及属性集$A$. 函数<code>TreeGenerate(D,A)</code>算法如下：</p><ul><li><p>我们生成树节点node，若D中样本全部属于同一类别C.就将node标记为C类叶节点。</p></li><li><p>如果A为空集或者D中样本在A上取值相同，那么将node标记为叶节点，其类别标记为D中样本数最多的类。然后返回。</p></li><li><p>从A中选择最优划分属性$a^*$.</p></li><li><p>对最优划分属性的每个子属性$a_i$:</p><ul><li>为node生成一个分支，令$D_v$表示$D$在$a^*$上取值为$a_i$的样本子集；<ul><li>如果$D_v$为空，那么将分支节点标记为叶节点，其类别标记为$D$中样本最多的类。并返回。</li><li>以$TreeGenrate(D_v,A/(a_*))为分支节点$</li></ul></li></ul><p>最后输出一棵以node为根节点的决策树。</p></li></ul><h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><p>如何选择最优划分属性？我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即纯度（purity）越来越高。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k=1,2,..n)$，则$D$的信息熵定义为</p><script type="math/tex; mode=display">Entropy(D)=-\sum_\limits{k=1}^{n}p_k\log_2 p_k</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>决策树</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必须掌握数据结构-二叉树</title>
    <link href="/2020/09/23/2020-9-23-binary_tree/"/>
    <url>/2020/09/23/2020-9-23-binary_tree/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs markdown">&#123;% note success %&#125;二叉树&#123;% endnote %&#125;</code></pre><h1 id="二叉树相关算法"><a href="#二叉树相关算法" class="headerlink" title="二叉树相关算法"></a>二叉树相关算法</h1><blockquote><p>一看到二叉树，基本上可以确定是DFS或者BFS了，比较单调，但是也有一些很复杂的题目。二叉树，根据实际需要，演变为二叉搜索树，2-3-4树，平衡树（红黑树、AVL树），在计算机系统中占据重要地位。</p></blockquote><p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 $n(n&gt;0)$ 个有限节点组成一个具有层次关系的集合。</p><p><img src="\img\binary_1.png" alt=""></p><p>把它叫做「树」是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>它具有以下的特点：</p><ul><li>每个节点都只有有限个子节点或无子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li><li>树里面没有环路。</li></ul><p>我们将介绍</p><ul><li>二叉树的表示</li><li><p>二叉树的遍历</p></li><li><p>二叉树序列化以及反序列化</p></li><li>树形dp</li><li>最近公共祖先（LCA）</li><li>二叉平衡树</li><li>二叉树路径求和</li></ul><hr><p><strong>部分题目</strong></p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">968.二叉树监控（Hard）</a></li><li>124.二叉树最大路径（Hard）</li><li>99.恢复二叉搜索树（Hard）</li><li>297.二叉树序列化与反序列化</li><li><ol><li>从中序遍历和前序遍历构造二叉树</li></ol></li><li><ol><li>从中序遍历和后序遍历构造二叉树</li></ol></li><li><ol><li>二叉树最近公共祖先</li></ol></li><li><ol><li>从先序遍历还原二叉树（Hard）</li></ol></li></ul><hr><h2 id="二叉树的表示"><a href="#二叉树的表示" class="headerlink" title="二叉树的表示"></a>二叉树的表示</h2><p>我们一般采用结构体或者类来表示树节点。一棵树由其根节点<strong>唯一</strong>的表示。</p><p>C++</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;    TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;</code></pre><p>Java</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> TreeNode left;    <span class="hljs-keyword">public</span> TreeNode right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">this</span>(x, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, TreeNode _left, TreeNode _right)</span></span>&#123;        val = x;        left = _left;        right = _right;    &#125;&#125;</code></pre><p>python</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span></code></pre><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>由许多方法可以帮我们完成遍历：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）、层序遍历。</p><p>采用递归是非常trivial的。我们思考迭代的方式。</p><p><strong>前序遍历</strong></p><ol><li>首先申请一个新的栈，记为stack；</li><li>声明一个结点treeNode，让其指向node结点；</li><li>如果treeNode的不为空，将treeNode的值打印，并将treeNode入栈，然后让treeNode指向treeNode的右结点，</li><li>重复步骤3，直到treenode为空；</li><li>然后出栈，让treeNode指向treeNode的右孩子</li><li>重复步骤3，直到stack为空.</li></ol><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;            <span class="hljs-comment">//迭代访问节点的左孩子，并入栈</span>            <span class="hljs-keyword">while</span>(treeNode != <span class="hljs-keyword">null</span>)&#123;                System.out.print(treeNode.data+<span class="hljs-string">&quot; &quot;</span>);                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-comment">//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                treeNode = stack.pop();                treeNode = treeNode.rightChild;            &#125;        &#125;    &#125;</code></pre><p><strong>中序遍历</strong></p><p><em>*对于一棵二叉搜索树而言，其中序遍历是非递减的。</em>，这可以成为许多题目的key。</p><p>例如：<code>[5,3,7,2,4,6,8]</code>，其中序遍历（根左右）为<code>[2,3,4,5,6,7,8]</code>，前序遍历（左根右）<code>[5,3,2,4,7,6,8]</code>，后序（左右根）遍历<code>[2,4,3,6,8,7,5]</code></p><ul><li>算法</li></ul><ol><li>申请一个新栈，记为stack，申请一个变量cur，初始时令treeNode为头节点；</li><li>先把treeNode节点压入栈中，对以treeNode节点为头的整棵子树来说，依次把整棵树的左子树压入栈中，即不断令treeNode=treeNode.leftChild，然后重复步骤2；</li><li>不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点记为treeNode，打印node的值，并让treeNode= treeNode.right，然后继续重复步骤2；</li><li>当stack为空并且cur为空时结束。</li></ol><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;            <span class="hljs-keyword">while</span>(treeNode != <span class="hljs-keyword">null</span>)&#123;                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                treeNode = stack.pop();                System.out.print(treeNode.data+<span class="hljs-string">&quot; &quot;</span>);                treeNode = treeNode.rightChild;            &#125;        &#125;    &#125;</code></pre><p><strong>后序遍历</strong></p><p>我们需要一个标记位来记忆我们此时节点上一个节点，具体看代码注释</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        TreeNode lastVisit = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//标记每次遍历最后一次访问的节点</span>        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<span class="hljs-comment">//节点不为空，结点入栈，并且指向下一个左孩子</span>            <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span>)&#123;                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-comment">//栈不为空</span>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                <span class="hljs-comment">//出栈</span>                treeNode = stack.pop();                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 这块就是判断treeNode是否有右孩子，</span><span class="hljs-comment">                 * 如果没有输出treeNode.data，让lastVisit指向treeNode，并让treeNode为空</span><span class="hljs-comment">                 * 如果有右孩子，将当前节点继续入栈，treeNode指向它的右孩子,继续重复循环</span><span class="hljs-comment">                 */</span>                <span class="hljs-keyword">if</span>(treeNode.rightChild == <span class="hljs-keyword">null</span> || treeNode.rightChild == lastVisit) &#123;                    System.out.print(treeNode.data + <span class="hljs-string">&quot; &quot;</span>);                    lastVisit = treeNode;                    treeNode  = <span class="hljs-keyword">null</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    stack.push(treeNode);                    treeNode = treeNode.rightChild;                &#125;            &#125;        &#125;    &#125;</code></pre><p><strong>层序遍历</strong></p><p>层序遍历比较简单</p><ol><li>首先申请一个新的队列，记为queue；</li><li>将头结点head压入queue中；</li><li>每次从queue中出队，记为node，然后打印node值，如果node左孩子不为空，则将左孩子入队；如果node的右孩子不为空，则将右孩子入队；</li><li>重复步骤3，直到queue为空。</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelorder</span><span class="hljs-params">(TreeNode *root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; postorder;    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;    q.push(root);    TreeNode *node;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> num_node = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> q_size = q.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; q_size;i++)        &#123;            node = q.front();            postorder.emplace_back(node-&gt;val);            <span class="hljs-keyword">if</span>(node-&gt;left) q.push(node-&gt;left);            <span class="hljs-keyword">if</span>(node-&gt;right) q.push(node-&gt;right);            <span class="hljs-keyword">delete</span> node;            q.pop();         &#125;    &#125;    <span class="hljs-keyword">return</span> postorder;&#125;</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li><p>从前序遍历和中序遍历构造二叉树</p></li><li><p>从后序遍历和中序遍历构造二叉树</p></li></ol><p>我们要知道，中序遍历作用是确定左右子树与根节点的相对位置。我们建立一个哈希表记录中序遍历所有节点的位置，然后在前序遍历寻找，直到遇到叶子节点。</p><hr><h2 id="二叉树序列化和反序列化"><a href="#二叉树序列化和反序列化" class="headerlink" title="二叉树序列化和反序列化"></a>二叉树序列化和反序列化</h2><blockquote><p>我们需要将字符串转化为树或者反过来就需要序列化和反序列化。</p></blockquote><h4 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h4><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>示例:</strong> </p><pre><code class="hljs lsl">你可以将以下二叉树：    <span class="hljs-number">1</span>   / \  <span class="hljs-number">2</span>   <span class="hljs-number">3</span>     / \    <span class="hljs-number">4</span>   <span class="hljs-number">5</span>序列化为 <span class="hljs-string">&quot;[1,2,3,null,null,4,5]&quot;</span></code></pre><p><strong>提示:</strong> 这与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://leetcode-cn.com/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>说明:</strong> 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><hr><p><strong>C++代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; res&#123;root&#125;;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_Q;<span class="hljs-comment">//用于从树中解析出数字到res数组中</span>        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;[&quot;</span>;        node_Q.push(root);        <span class="hljs-keyword">while</span> (!node_Q.empty())        &#123;            TreeNode *node = node_Q.front();node_Q.pop();            <span class="hljs-keyword">if</span> (node-&gt;left)            &#123;                node_Q.push(node-&gt;left);                res.push_back(node-&gt;left);            &#125;<span class="hljs-keyword">else</span>                res.push_back(<span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">if</span> (node-&gt;right)            &#123;                node_Q.push(node-&gt;right);                res.push_back(node-&gt;right);            &#125;<span class="hljs-keyword">else</span>                res.push_back(<span class="hljs-literal">NULL</span>);        &#125;        <span class="hljs-keyword">while</span>(!res.back()) res.pop_back();<span class="hljs-comment">//去掉多余的NULL</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c:res)             <span class="hljs-keyword">if</span>(c) &#123;s += to_string(c-&gt;val);s+=<span class="hljs-string">&quot;,&quot;</span>;&#125;            <span class="hljs-keyword">else</span>  s += <span class="hljs-string">&quot;null,&quot;</span>;        s.pop_back();        s+=<span class="hljs-string">&quot;]&quot;</span>;        <span class="hljs-keyword">return</span> s;    &#125;        <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;        <span class="hljs-comment">//data forms like &quot;[72,1,4,6,null,5,3,null,null,null,null,null,2]&quot;</span>        <span class="hljs-comment">//时间复杂度：O(n),空间复杂度O(3n)</span>        <span class="hljs-keyword">if</span>(!data.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; data_list;        <span class="hljs-built_in">string</span> num;        <span class="hljs-keyword">bool</span> num_flag = <span class="hljs-literal">false</span>;        <span class="hljs-comment">//将字符串转换为只含有数字和Null的数组,考虑负号和多位数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.size();i++)        &#123;            <span class="hljs-keyword">if</span>((data[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;data[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)||data[i]==<span class="hljs-string">&#x27;-&#x27;</span>)            &#123;                num += data[i];                num_flag = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i] == <span class="hljs-string">&#x27;n&#x27;</span>)            &#123;                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;                data_list.push_back(<span class="hljs-string">&quot;null&quot;</span>);                i += <span class="hljs-number">3</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num_flag) &#123;data_list.push_back(num);num = <span class="hljs-string">&quot;&quot;</span>;num_flag = <span class="hljs-literal">false</span>;&#125;        &#125;        TreeNode *root = <span class="hljs-keyword">new</span> TreeNode(stoi(data_list[<span class="hljs-number">0</span>]));        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_Q; <span class="hljs-comment">//用于装载所有不为null的节点</span>        data_list.erase(data_list.begin());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c: data_list)             <span class="hljs-keyword">if</span> (c!=<span class="hljs-string">&quot;null&quot;</span>) node_Q.push(<span class="hljs-keyword">new</span> TreeNode(stoi(c)));            <span class="hljs-keyword">else</span> node_Q.push(<span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_stack; <span class="hljs-comment">//用于构建树结构</span>        node_stack.push(root);        <span class="hljs-keyword">while</span> (!node_stack.empty())        &#123;            TreeNode * node = node_stack.front();node_stack.pop();            <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (!node_Q.empty())             &#123;                node-&gt;left = node_Q.front();node_Q.pop();                node_stack.push(node-&gt;left);            &#125;            <span class="hljs-keyword">else</span> node-&gt;left = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">if</span> (!node_Q.empty())             &#123;                    node-&gt;right = node_Q.front();node_Q.pop();                node_stack.push(node-&gt;right);            &#125;            <span class="hljs-keyword">else</span> node-&gt;right = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p><strong>Java代码</strong></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNodeHelper</span></span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root The root node of a binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The level traversal serialization of this binary tree. For the syntax of serialization,</span><span class="hljs-comment">     * check https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation</span><span class="hljs-comment">     * or https://support.leetcode-cn.com/hc/kb/article/1194353/.</span><span class="hljs-comment">     * If the root node contains any circle, it will return &quot;Error! Cycle found in the binary tree!&quot;.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">treeNodeToString</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;        &#125;        StringBuilder SB = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);        Deque&lt;TreeNode&gt; BFS = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        HashSet&lt;TreeNode&gt; memo = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        BFS.offer(root);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        TreeNode cur;        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span>)&#123;            cur = BFS.poll();            <span class="hljs-keyword">if</span> (memo.contains(cur))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error! Cycle found in the binary tree!&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (cur != <span class="hljs-keyword">null</span>)&#123;                --cnt;                SB.append(Integer.toString(cur.val));                SB.append(<span class="hljs-string">&#x27;,&#x27;</span>);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)&#123;                    ++cnt;                &#125;                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)&#123;                    ++cnt;                &#125;                BFS.offer(cur.left);                BFS.offer(cur.right);                memo.add(cur);            &#125;            <span class="hljs-keyword">else</span>&#123;                SB.append(<span class="hljs-string">&quot;null,&quot;</span>);            &#125;        &#125;        SB.setCharAt(SB.length()-<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;]&#x27;</span>);        <span class="hljs-keyword">return</span> SB.toString();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input a level traversal serialization of a VALID binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The root node of the deserialized binary tree. if the input is not valid,</span><span class="hljs-comment">     * the result is undefined. To check the validity, you need these codes:</span><span class="hljs-comment">     * input = input.trim(); input = input.substring(1, input.length()-1)</span><span class="hljs-comment">     * if (input.charAt(0) == &#x27;[&#x27;) Then it may be a valid serialization.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">stringToTreeNode</span><span class="hljs-params">(String input)</span></span>&#123;        input = input.trim();        input = input.substring(<span class="hljs-number">1</span>, input.length()-<span class="hljs-number">1</span>);        String[] nodes = input.split(<span class="hljs-string">&quot;,&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length = nodes.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i)&#123;            nodes[i] = nodes[i].trim();        &#125;        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">true</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[<span class="hljs-number">0</span>]));            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            TreeNode ret = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[<span class="hljs-number">0</span>]));            Deque&lt;TreeNode&gt; BFS = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            BFS.offer(ret);            <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;            TreeNode cur;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                cur = BFS.poll();                <span class="hljs-keyword">if</span> (++idx &gt;= length)&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">false</span>)&#123;                    cur.left = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[idx]));                    BFS.offer(cur.left);                &#125;                <span class="hljs-keyword">if</span> (++idx &gt;= length)&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">false</span>)&#123;                    cur.right = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[idx]));                    BFS.offer(cur.right);                &#125;            &#125;            <span class="hljs-keyword">return</span> ret;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input the treeNode you want to implement deep copy of a binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> If the input treeNode represents a valid binary tree, return a deep copy;</span><span class="hljs-comment">     * if the input treeNode is null or it doesn&#x27;t represent a valid binary tree, return null;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">TreeNodeDeepCopy</span><span class="hljs-params">(TreeNode input)</span></span>&#123;        <span class="hljs-keyword">if</span> (input == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        String copyStr = TreeNodeHelper.treeNodeToString(input);        <span class="hljs-keyword">if</span> (copyStr.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;[&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//It means the input TreeNode is not valid, so return a null pointer;</span>        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> TreeNodeHelper.stringToTreeNode(copyStr);        &#125;    &#125;&#125;</code></pre><p><strong>Python代码</strong>（附带绘图）</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> turtleprintTree_switch = <span class="hljs-literal">True</span><span class="hljs-keyword">if</span> printTree_switch:    t = turtle.Turtle()    t.penup()    t.speed(<span class="hljs-string">&#x27;fast&#x27;</span>)<span class="hljs-comment">#&#x27;fastest&#x27; &#x27;fast&#x27; &#x27;normal&#x27; &#x27;slow&#x27; &#x27;slowest&#x27;</span>    t.shape(<span class="hljs-string">&#x27;turtle&#x27;</span>)<span class="hljs-comment">#arrow&quot;, &quot;turtle&quot;, &quot;circle&quot;, &quot;square&quot;, &quot;triangle&quot;, &quot;classic&quot;</span><span class="hljs-comment"># Definition for a binary tree node.</span>null = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>         self.val = x         self.left = <span class="hljs-literal">None</span>         self.right = <span class="hljs-literal">None</span><span class="hljs-comment">#___________________________Visualize a tree___________________________________</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">printTree</span>():</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,tree</span>):</span>        self.radius = <span class="hljs-number">50</span>        self.level = <span class="hljs-number">0</span>        self.branch_length = <span class="hljs-number">4</span>*self.radius        self.node_memo = &#123;&#125;        self.draw_binary_tree(tree,(<span class="hljs-number">0</span>,<span class="hljs-number">300</span>),self.level)            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_node</span>(<span class="hljs-params">self,data,start_pos</span>):</span>        <span class="hljs-comment"># draw the node</span>        (x,y) = start_pos        length = len(str(data))        t.setx(x);t.sety(y)        t.pendown()        t.setheading(<span class="hljs-number">0</span>)        t.circle(self.radius)        t.penup();t.goto(x-length/<span class="hljs-number">2</span>*<span class="hljs-number">16</span>,y+self.radius<span class="hljs-number">-8</span>);t.pendown()        t.write(data, font=(<span class="hljs-string">&quot;Arial&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;normal&quot;</span>))        t.penup()        t.setx(x)        t.sety(y)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_branch</span>(<span class="hljs-params">self,start_pos,orient,level</span>):</span>        <span class="hljs-comment">#draw the branch</span>        (x,y) = start_pos        t.setx(x);t.sety(y)        t.pendown()        t.setheading(<span class="hljs-number">180</span>)        <span class="hljs-keyword">if</span> orient == <span class="hljs-string">&#x27;left&#x27;</span>:            t.left(<span class="hljs-number">15</span>+<span class="hljs-number">20</span>*level)            t.forward(self.branch_length-level*<span class="hljs-number">20</span>)        <span class="hljs-keyword">elif</span> orient == <span class="hljs-string">&#x27;right&#x27;</span>:            t.left(<span class="hljs-number">180</span>-(<span class="hljs-number">15</span>+<span class="hljs-number">20</span>*level))            t.forward(self.branch_length-level*<span class="hljs-number">20</span>)        t.penup()        <span class="hljs-keyword">return</span> t.pos()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_binary_tree</span>(<span class="hljs-params">self,p,start_pos,level</span>):</span>        (x,y) = start_pos        self.node_memo[p] = (x,y+self.radius)        <span class="hljs-keyword">if</span> p!=<span class="hljs-literal">None</span>:            level+=<span class="hljs-number">1</span>            print(<span class="hljs-string">&quot;level:&quot;</span>,level)            self.draw_node(p.val,(x,y))            <span class="hljs-keyword">if</span> p.left!=<span class="hljs-literal">None</span>:                (x1,y1) = self.draw_branch((x,y),<span class="hljs-string">&#x27;left&#x27;</span>,level)                self.draw_binary_tree(p.left,(x1,y1<span class="hljs-number">-2</span>*self.radius),level)                        <span class="hljs-keyword">if</span> p.right!=<span class="hljs-literal">None</span>:                (x2,y2)=self.draw_branch((x,y),<span class="hljs-string">&#x27;right&#x27;</span>,level)                self.draw_binary_tree(p.right,(x2,y2<span class="hljs-number">-2</span>*self.radius),level)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_coord</span>(<span class="hljs-params">self,node</span>)-&gt;tuple:</span>        <span class="hljs-comment">#return the coord of the node circle centre</span>        <span class="hljs-keyword">return</span> self.node_memo[node]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_line</span>(<span class="hljs-params">self,coord1, coord2,pensize=<span class="hljs-number">5</span>,pen_color=<span class="hljs-string">&#x27;red&#x27;</span></span>):</span> <span class="hljs-comment">#from 1 to 2</span>        (x,y) = coord1          t.penup()        t.pensize(pensize)        t.pencolor(pen_color)        t.setx(x);t.sety(y)        t.pendown()        t.goto(coord2[<span class="hljs-number">0</span>],coord2[<span class="hljs-number">1</span>])        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">thank_turtle</span>():</span><span class="hljs-comment"># used when tree drawing ends</span>    turtle.done()<span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><span class="hljs-string">        </span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>        res = [(root.val, root)]        node_Q = deque()        node_Q.appendleft((root.val, root))        node = root        <span class="hljs-keyword">while</span> node_Q:            tup = node_Q.popleft()            a = tup[<span class="hljs-number">0</span>]; node = tup[<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> node.left:                node_Q.append((node.left.val, node.left))                res.append((node.left.val, node.left))            <span class="hljs-keyword">else</span>:                res.append((<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">None</span>))            <span class="hljs-keyword">if</span> node.right:                node_Q.append((node.right.val, node.right))                res.append((node.right.val, node.right))            <span class="hljs-keyword">else</span>:                res.append((<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">None</span>))        <span class="hljs-comment"># remove redundant nones and stringify it</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:             node = res[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: res.pop()            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span>        ret = []        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:             <span class="hljs-keyword">if</span> r != <span class="hljs-string">&#x27;null&#x27;</span>:                ret.append(str(r[<span class="hljs-number">0</span>]))            <span class="hljs-keyword">else</span>:                ret.append(r[<span class="hljs-number">0</span>])         <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>+<span class="hljs-string">&#x27;,&#x27;</span>.join(ret)+<span class="hljs-string">&#x27;]&#x27;</span>                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><span class="hljs-string">        </span><span class="hljs-string">        :type data: str</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment"># first we have to transform the string to a list </span>        <span class="hljs-comment"># and supplement the missing none</span>        <span class="hljs-comment"># it&#x27;s totally a reversal process of serialization</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        deserial =  data[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)        root = TreeNode(deserial[<span class="hljs-number">0</span>])        node_Q = deque()        <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> deserial[<span class="hljs-number">1</span>:]:             <span class="hljs-keyword">if</span> i!=<span class="hljs-string">&#x27;null&#x27;</span>: node_Q.append(TreeNode(int(i)))            <span class="hljs-keyword">else</span>: node_Q.append(<span class="hljs-literal">None</span>)        node_stack = deque()        node_stack.append(root)        <span class="hljs-keyword">while</span> node_stack:            node = node_stack.popleft()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> node_Q:                 node.left = node_Q.popleft()                node_stack.append(node.left)            <span class="hljs-keyword">else</span>: node.left = <span class="hljs-literal">None</span>            <span class="hljs-keyword">if</span> node_Q:                 node.right = node_Q.popleft()                node_stack.append(node.right)            <span class="hljs-keyword">else</span>: node.right = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> root</code></pre><hr><h2 id="树形dp（竞赛难度）"><a href="#树形dp（竞赛难度）" class="headerlink" title="树形dp（竞赛难度）"></a>树形dp（竞赛难度）</h2><p> 一般来说树形dp在设状态转移方程时都可以用f[i][]表示i这颗子树怎么怎么样的最优解，实现时一般都是用子树更新父亲（即从下向上更新），那么首先应该考虑的是一个一个子树的更新父亲还是把所有子树都算完了在更新父亲？这就要因题而异了，一般来说有两种情况：    1. <strong>需要把所有子树的信息都掌握之后再更新子树的就需要把所有子树都算完了在更新父亲</strong>。</p><ol><li><strong>而像树上背包这样的问题就需要一个一个的更新，每次都用一个子树更新已经更新完的子树+父亲，最后就可以将这一部分的子树更新完了，再继续往上更新，最后根节点就是答案。</strong></li></ol><p>其实上面的两种情况可以总结成一种情况就是一个个子树更新父亲，一般来说第一种情况应用更多，也能解决第二情况的问题，只不过如果符合第二种情况的时候用第二种可以速度更快一点，毕竟你省了一遍循环嘛。</p><ul><li><p>有依赖的背包问题（见相应专题）</p></li><li><ol><li>监控二叉树</li></ol><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2></li></ul><h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h4><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">1</span>解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="img"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">2</span>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><hr><p>假设根节点为$root$,其左右子节点分别为$left$,$right$。</p><ul><li>如果根节点处放摄像头，那么左右子节点不需要放摄像头。</li><li>如果根节点处不放摄像头，则左右节点之一必须要放摄像头。</li></ul><p>通过以上的分析，二叉树节点主要有三种状态：</p><ol><li>根节点处必须放摄像头的条件下，覆盖整棵树需要的摄像头数目。</li><li>覆盖整颗树需要的摄像头数目，无论$root$是否放摄像头。</li><li>覆盖两颗子树需要的摄像头数目，无论$root$是否被覆盖到。</li></ol><p>设三种状态下需要的摄像头数量分别为$a,b,c$。那么一定有$a\ge b\ge c$。</p><p>设左子树的对应上述状态变量分别为$l_a,l_b,l_c$,右子树的对应上述状态变量分别为$r_a,r_b,r_c$,那么有：</p><ul><li>$a = l_c+r_c+1$</li><li>$b=min(a,min(l_a+r_b,l_b+r_a))$，左子树和右子树肯定有一个根节点有摄像头，另一个没有，如果两个都有，则说明产生冗余，不是最优解。</li><li>$c=min(a,l_b+r_b)$,对c而言，要保证两颗子树均被覆盖，要么root放摄像头,那么等于$a$，要么不放，即为$l_b+r_b$。</li></ul><p>对于边界条件的判断。</p><p>如果该节点为<code>null</code>那么相当于无论用多少个摄像头都无法覆盖$a=INT_MAX,b=0,c=0$</p><hr><p><strong>代码</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_MAX = <span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">int</span> res;    <span class="hljs-keyword">int</span>[] dfs(TreeNode root)    &#123;<span class="hljs-comment">//返回a,b,c</span>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;INT_MAX,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span>[]l = dfs(root.left);        <span class="hljs-keyword">int</span>[]r = dfs(root.right);        <span class="hljs-keyword">int</span> l_a = l[<span class="hljs-number">0</span>], r_a = r[<span class="hljs-number">0</span>], l_b = l[<span class="hljs-number">1</span>], r_b = r[<span class="hljs-number">1</span>], l_c = l[<span class="hljs-number">2</span>], r_c = r[<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span> a = l_c + r_c + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = Math.min(a,Math.min(l_a+r_b,l_b+r_a));        <span class="hljs-keyword">int</span> c = Math.min(a,l_b + r_b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b,c&#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> dfs(root)[<span class="hljs-number">1</span>];    &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析最小生成树</title>
    <link href="/2020/09/18/2020-9-12-minimal-Spanning-tree/"/>
    <url>/2020/09/18/2020-9-12-minimal-Spanning-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树的两种方法（Kruskal算法和Prim算法）"><a href="#最小生成树的两种方法（Kruskal算法和Prim算法）" class="headerlink" title="最小生成树的两种方法（Kruskal算法和Prim算法）"></a>最小生成树的两种方法（Kruskal算法和Prim算法）</h1><hr><ul><li><ol><li><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点最小费用</a></li></ol></li></ul><blockquote><p>最小生成树（$Minimal  Spanning  Tree,MST$）：有 n 个结点的<a href="https://baike.baidu.com/item/连通图/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。比较常用的有两种算法：$Kruskal$算法和$Prim$算法。</p></blockquote><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>被称为“加边法”，初始最小生成树的边数是0，每迭代一次就寻找满足条件的最小代价边，加入到最小生成树集合中去。</p><ol><li>把图中所有边按照<strong>从小到大</strong>的顺序排序。</li><li>把图中$n$个顶点看成独立的$n$棵树组成的森林。</li><li>按权值从小到大选择边，所选的边连接的两个顶点$u_i,v_i$应该属于两个不同的树（否则会形成环），则称为最小生成树的一条边，并将这两棵树作为一棵树。</li><li>重复<code>3.</code>。直到所有的顶点都在一棵树内，或者有$n-1$条边为止。</li></ol><p><img src="\img\kruskal.jpg" alt="MST示意图"></p><p>和并查集的概念非常相似。Kruskal算法可以看成是基于并查集的贪心算法。    </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> res,n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;<span class="hljs-keyword">public</span>:    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">int</span> e1, e2;<span class="hljs-comment">//两个端点的编号</span>        <span class="hljs-keyword">int</span> Mahattan_dis;<span class="hljs-comment">//曼哈顿距离</span>        edge(<span class="hljs-keyword">int</span> e1,<span class="hljs-keyword">int</span> e2, <span class="hljs-keyword">int</span> m):e1(e1),e2(e2),Mahattan_dis(m)&#123;&#125;        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> edge&amp; other) <span class="hljs-keyword">const</span>        &#123;            <span class="hljs-keyword">return</span> Mahattan_dis &lt; other.Mahattan_dis;        &#125;    &#125;;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mahattan</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);    &#125;            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = points.size();    init(n);    <span class="hljs-built_in">vector</span>&lt;edge&gt; edges;    res  = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n;j++)    &#123;        edges.emplace_back(i,j,Mahattan(points,i,j));     &#125;       sort(edges.begin(),edges.end());<span class="hljs-comment">//按从小到大排序</span>    <span class="hljs-keyword">int</span> num = n;<span class="hljs-comment">//独立的子树的个数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)    &#123;        <span class="hljs-keyword">if</span>(merge(e.e1,e.e2))        &#123;            res += e.Mahattan_dis;            num--;        &#125;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//最后只有一个连通图则返回</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)             fa.emplace_back(i);     &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(fa[x] == x)             <span class="hljs-keyword">return</span> x;        fa[x] = find(fa[x]);         <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//合并的两条边必须是不同子树</span>        <span class="hljs-keyword">int</span> x = find(i),y = find(j);        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        fa[x] = y;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre><blockquote><p>细节：为了使得自定义结构体edge能够进行排序操作，我们不能把数组edges写成<code>vector&lt;edge*&gt; edges</code>这样的话是对指针指向的地址进行排序，而不是对曼哈顿距离排序。</p></blockquote><p>时间复杂度：$O(V^2)$,$V$为边的个数，等于$N-1$。</p><p>空间复杂度：$O(N)$, 包括并查集用的父数组和自定义数据结构edge。</p><hr><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>此算法又被称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树之中，算法从某一个顶点开始，逐渐扩散覆盖整个网络。比较适合<strong>稠密网络</strong>。</p><ol><li>图的所有顶点集合为V；初始令集合$u=s,v=V-u$.</li><li>在两个集合$u,v$所构成的边中，选择一条代价最小的边。</li><li>重复上述步骤，直到最小生成树有$n-1$条边，或者只有一棵树为止。</li></ol><p><img src="\img\prim.jpg" alt="这里写图片描述"></p><p>我们注意到我们每次添加的都是最小边，因此可以用小顶堆来存储。 Prim算法更像是Dijkstra算法。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> res,n;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mahattan</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; data;    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;left, T <span class="hljs-keyword">const</span> &amp;right)</span></span><span class="hljs-function">        </span>&#123;        <span class="hljs-comment">// 以y比较。输出结果为y较大的在前y相同时，先进入队列的元素在前。</span>            <span class="hljs-keyword">return</span> (left.second &gt; right.second); <span class="hljs-comment">// left.first在后面，顶部元素first最大</span>        &#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;    <span class="hljs-comment">//Prim 算法又被称为加点法</span>    <span class="hljs-keyword">int</span> n = points.size();    res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//任选一个点作为起始点，没有必要构建边，</span>    <span class="hljs-comment">//遍历小顶堆，每次从中取出代价最小的边，（需判断点是否已经取过，需要标记列表）</span>    <span class="hljs-comment">//若最后只有一个树，或者 小顶堆为空，说明已构建完MST</span>    <span class="hljs-built_in">priority_queue</span>&lt;data,<span class="hljs-built_in">vector</span>&lt;data&gt;,cmp&lt;data&gt;&gt; lheap;<span class="hljs-comment">//p1:点序号，p2:Mahattan距离，</span>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, edge = <span class="hljs-number">0</span>;    lheap.push(data(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span>(!lheap.empty() )    &#123;        <span class="hljs-keyword">int</span> next = lheap.top().first;        <span class="hljs-keyword">if</span>(vis[next]) &#123;lheap.pop();<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//如果访问过则直接跳过</span>        vis[next] = <span class="hljs-literal">true</span>; edge+=<span class="hljs-number">1</span>;        res += lheap.top().second;        lheap.pop();        <span class="hljs-keyword">if</span>(edge == n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果边的数量达到n则break</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            lheap.push(data(i,Mahattan(points,i,next)));        &#125;              &#125;    <span class="hljs-keyword">return</span> res;      &#125;   &#125;;</code></pre><p>时间复杂度：$O(N^2)$, N为点的个数。</p><p>空间复杂度：$O(N)$,需要一个优先队列来存储所有的可能边。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>MST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂内存中堆和栈的区别</title>
    <link href="/2020/09/18/CS_heap_stack/"/>
    <url>/2020/09/18/CS_heap_stack/</url>
    
    <content type="html"><![CDATA[<h1 id="弄懂内存中堆和栈的区别"><a href="#弄懂内存中堆和栈的区别" class="headerlink" title="弄懂内存中堆和栈的区别"></a>弄懂内存中堆和栈的区别</h1><blockquote><p>知识的<a href="https://blog.csdn.net/myqq1418/article/details/81584761">传送门</a></p></blockquote><p><strong>栈区</strong>($stack$)：由编译器自动分配释放，存放函数的参数值，以及局部变量的值，其操作方式类似数据结构的栈。</p><p><strong>堆区</strong>($heap$)：一般由程序员分配释放，若程序不释放，会被操作系统回收。其操作方式类似于数据结构的链表。</p><p><strong>全局区</strong>($static$)：全局变量和静态变量的存储在一起，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><p><strong>文字常量区</strong>：常量和字符串等。</p><p><strong>程序代码区</strong>：程序的二进制代码。</p><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p><img src="\img\heap_1.png" alt="image-20200918200847502"></p><p><img src="\img\heap_2.png" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局初始化区</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局初始化区</span><span class="hljs-keyword">char</span> *p1; <span class="hljs-comment">//全局未初始化区</span>main() &#123;    <span class="hljs-keyword">int</span> b; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> *p2; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> *p3 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//123456\0在常量区，p3在栈上。</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局（静态）初始化区</span>    p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//堆区，程序员自己申请，new也是的</span>    p2 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    <span class="hljs-comment">//分配得来得10和20字节的区域就在堆区。</span>    <span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存 - 堆</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java八大数据类型以及封装类</title>
    <link href="/2020/09/18/Java_notes/"/>
    <url>/2020/09/18/Java_notes/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>Java基础学习</p>          </div><span class="label label-java">text</span><h1 id="Java八大数据类型以及封装类"><a href="#Java八大数据类型以及封装类" class="headerlink" title="Java八大数据类型以及封装类"></a>Java八大数据类型以及封装类</h1><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者<a href="http://lib.csdn.net/base/operatingsystem">操作系统</a>的改变而改变。</p><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>short：16位，最<a href="http://lib.csdn.net/base/hadoop">大数据</a>存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>boolean：只有true和false两个取值。</p><p>char：16位，存储Unicode码，用单引号赋值。</p><div class="table-container"><table><thead><tr><th>单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th><th>void</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td><td>—</td></tr><tr><td>封装器类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Void</td></tr></tbody></table></div><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>$(byte，short，char)—int—long—float—double$</p><h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><p>X转字符串</p><ul><li>调用类转换方法：<code>X.toString()</code></li><li>自动类型转换：<code>X+&quot;&quot;</code></li><li>使用String方法，<code>String.ValueOf(X)</code></li></ul><p>转字符</p><ul><li>调用类转换方法：<code>X.toCharArray()</code></li></ul><p>字符串转X</p><p>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p><p>例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue()</p><p>②静态parseXXX方法</p><pre><code class="hljs Java">String s = <span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-keyword">byte</span> b = Byte.parseByte( s );<span class="hljs-keyword">short</span> t = Short.parseShort( s );<span class="hljs-keyword">int</span> i = Integer.parseInt( s );<span class="hljs-keyword">long</span> l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );</code></pre><h1 id="Java引用类型"><a href="#Java引用类型" class="headerlink" title="Java引用类型"></a>Java引用类型</h1><p>Java有 5种引用类型（对象类型）：类 (Class) 接口(Interface) 数组 (List/ArrayList)枚举(enum) 标注</p><p>引用类型：底层结构和基本类型差别较大</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪婪却巧妙的贪心算法</title>
    <link href="/2020/09/02/2020-8-25-greedy/"/>
    <url>/2020/09/02/2020-8-25-greedy/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法及其应用"><a href="#贪心算法及其应用" class="headerlink" title="贪心算法及其应用"></a>贪心算法及其应用</h1><ul><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></li><li><a href="https://leetcode-cn.com/problems/jump-game-ii/">45.跳跃游戏II</a></li><li><a href="https://leetcode-cn.com/problems/jump-game/">55.跳跃游戏</a></li></ul><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p></blockquote><h2 id="最长上升序列"><a href="#最长上升序列" class="headerlink" title="最长上升序列"></a>最长上升序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]输出: <span class="hljs-number">4</span> 解释: 最长的上升子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 $O(n^2)$ 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p><hr><p>考虑一个简单的贪心，如果我们要求上升子序列尽可能长，那么要求序列上升的尽可能慢，因此要求每次最后加的数尽可能小。</p><p>基于以上思路，我们维护一个数组$d[i]$，表示长度为$i$的上升子序列末尾元素的最小值，用$len$记录目前最长上升长度。起始$d[1]=nums[0]$。</p><p>同时我们可以注意到，$d[i]$是关于$i$单调递增的。因为如果$d[j]\ge d[i]$且$j&lt;i$,我们考虑从长度为$i$的最长上升序列的末尾删除$i-j$个元素，那么这个序列的长度变为$j$，且第$j$个元素必然小于$d[i]$，也就小于$d[j]$.那么我们就找到一个长度为$j$的最长上升序列。且末尾元素比$d[j]$小，从而产生矛盾，单调性得证。</p><p>我们遍历数组，并更新$d[]$和$len$的值。如果$nums[i]&gt;d[len]$则更新$len+=1$，否则在$d[1…len]$中找到满足$d[i-1]&lt;nums[j]&lt;d[i]$的下标，并更新$d[i]=nums[j]$。</p><p>由于$d[]$单调，我们可以采用二分查找的方法，优化算法时间复杂度至$O(N\log N)$。</p><ul><li>设当前已求得最长上升子序列长度为$len$，初始为1，从前往后遍历数组$nums$，在遍历到$nums[i]$时：<ul><li>若$nums[i]&gt;d[len]$，直接加入到d数组末尾，$len+=1$.</li><li>否则，在d数组二分查找，找到第一个比$nums[i]$小的数$d[k]$，并更新$d[k+1] = nums[i]。$</li></ul></li></ul><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//最长子序列长度，可以通过dp</span>        <span class="hljs-comment">//同时利用哈希表，搜索过的空间就不搜索了</span>        <span class="hljs-comment">//注意，下一个较大元素可能不选，反而总长度会更长</span>        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//包含nums[i-1]，且以之为结束的最大子串长度</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;        d[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)        &#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; d[len]) d[++len]=nums[i];            <span class="hljs-keyword">else</span> <span class="hljs-comment">//在d进行二分查找,找到第一个比nums[i]小的数nums[k]</span>            &#123;                <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>,l = <span class="hljs-number">0</span>,r = len;                <span class="hljs-keyword">while</span>(l&lt;=r)                &#123;                    <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(nums[i] &gt; d[mid])                    &#123;                        k = mid;                        l = mid+<span class="hljs-number">1</span>;                    &#125;                     <span class="hljs-keyword">else</span> r = mid<span class="hljs-number">-1</span>;                &#125;                 d[k+<span class="hljs-number">1</span>] = nums[i];                         &#125;        &#125;        <span class="hljs-keyword">return</span> len;                &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学和信号应用于解题</title>
    <link href="/2020/09/02/2020-8-25-math/"/>
    <url>/2020/09/02/2020-8-25-math/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hi这里数学仅仅指数论和几何以及离散数学，没有谁用高等数学出题的，不过你也可以试试，让面试官刮目相看。我们重点研究一些很经典的数学问题。</p></blockquote><h1 id="利用数学、信号理论解题"><a href="#利用数学、信号理论解题" class="headerlink" title="利用数学、信号理论解题"></a>利用数学、信号理论解题</h1><blockquote><p>包括但不限于数论，几何，排列组合等。。。</p><p>LC上有很多题目是和数学相关的，如果我们有一定的数学基础，那么解起题来事半功倍！</p></blockquote><ul><li><ol><li><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/">圆和矩形是否有重叠</a></li></ol></li><li>求质因数（GCD）</li><li>快速幂算法</li><li>FFT算法</li><li>Java bitCount的实现</li></ul><h2 id="质因数求解"><a href="#质因数求解" class="headerlink" title="质因数求解"></a>质因数求解</h2><p>设$ R = \sqrt{A}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+1$个不同的质因数。质因数为本身的只有一个，非本身的质因数一定比$R$小，最多$R$个。</p><p><strong>策略</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)<span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>) &#123;...&#125;</code></pre><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><p>交替递归，可以有效减小迭代次数。$(a,b)\rightarrow ( b,a\%b)$直到有一个数为0.</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">return</span> gcd(b, a % b);&#125;</code></pre><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote><p><a href="https://blog.csdn.net/qq_19782019/article/details/85621386">https://blog.csdn.net/qq_19782019/article/details/85621386</a></p></blockquote><p>我们思考一个问题，求$2^{100}$的最后三位数。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fastPower</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % <span class="hljs-number">1000</span>;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="FFT算法"><a href="#FFT算法" class="headerlink" title="FFT算法"></a>FFT算法</h2><hr><h2 id="1-完全平方数"><a href="#1-完全平方数" class="headerlink" title="1. 完全平方数"></a>1. 完全平方数</h2><p>1770年，<a href="[https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem](https://en.wikipedia.org/wiki/Lagrange&#39;s_four-square_theorem">Lagrange</a>)证明了一个定理，被称为四平方数定理，它指出每个自然数都能表示为四个平方整数之和：</p><script type="math/tex; mode=display">p=a_0^2+a_1^2+a_2^2+a_3^2</script><p>这就规定了问题的上限，即最大的平方数个数是4.</p><p>注意，这里0也被当成完全平方数。</p><p>后来1797年，<a href="https://en.wikipedia.org/wiki/Adrien-Marie_Legendre">Legendre</a>用他的三平方定理完成了四平方定理，正整数可以表示为三个平方和的一个特殊条件：</p><script type="math/tex; mode=display">n\ne 4^k(8m+7) \Leftrightarrow p=a_0^2+a_1^2+a_2^2</script><p>在我们分解为（底部情况）三平方数之前，还有两种特例需要检查：</p><ol><li><p>该数本身是一个完全平方数 即<code>n=(int)(sqrt(n)*sqrt(n))</code></p></li><li><p>如果一个数可以分解为两个平方数之和，不幸的是，我们只能通过枚举来找到这样的数。</p></li></ol><p><strong>算法：</strong></p><ol><li><p>检查该数是否为完全平方数</p></li><li><p>如果该数可以表示为$n == 4^k(8m+7)$，那么可以确切的说，答案肯定为4；</p></li></ol><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) n /= <span class="hljs-number">4</span>;<span class="hljs-keyword">if</span>((n<span class="hljs-number">-7</span>)%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>) res = <span class="hljs-number">4</span>;</code></pre><ol><li>我们看该数，是否能由更少的完全平方数组成。</li></ol><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n<span class="hljs-number">-1</span>;k &gt;= <span class="hljs-number">1</span>;k--)&#123;    <span class="hljs-keyword">if</span>(isPerfectSquare(n*n-k*k)) res = <span class="hljs-number">2</span>;&#125;</code></pre><p><strong>代码：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> n == ((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n))*((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//一些很特殊的情况12 = 2^2+2^2+2^2; 18 = 3^2+3^2;1000= 30^2+10^2;61=5^2+6^2</span>    <span class="hljs-keyword">if</span>(isPerfectSquare(n)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> nn = n;    <span class="hljs-comment">//判断是否为四平方数</span>    <span class="hljs-keyword">while</span>(nn%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) nn/=<span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span>((nn<span class="hljs-number">-7</span>)%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n<span class="hljs-number">-1</span>;k &gt;= <span class="hljs-number">1</span>;k--)    <span class="hljs-keyword">if</span>(isPerfectSquare(k))    &#123;        <span class="hljs-comment">// printf(&quot;%d:\n&quot;,k);</span>        <span class="hljs-keyword">if</span>(isPerfectSquare(n-k)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>： 最好的情况下是$O(1)$，比如$n$是完全平方数, 最坏$O(N)$，即该数有两个平方数组成。</li><li><strong>空间复杂度</strong>:   $O(1)$，常数级别空间占用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>几何</tag>
      
      <tag>信号理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>貌似很难懂的DSA是什么？</title>
    <link href="/2020/09/02/2020-9-2-fsm/"/>
    <url>/2020/09/02/2020-9-2-fsm/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是确定有限状态自动机（Deterministic-State-Automata）？"><a href="#什么是确定有限状态自动机（Deterministic-State-Automata）？" class="headerlink" title="什么是确定有限状态自动机（Deterministic State Automata）？"></a>什么是确定有限状态自动机（Deterministic State Automata）？</h1><p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p><ul><li>有一个特殊的状态，被称作「初始状态」。</li><li>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</li></ul><p>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p><p>一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。</p><p>自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。</p><p>自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。</p><hr><p><strong>例题：</strong></p><ul><li><ol><li><a href="">有效的数字</a>(Hard)</li></ol></li><li>剑指Offer 20. <a href="">表示数值的字符串</a>(Medium)</li></ul><hr><p>以 剑指Offer 20. <a href="">表示数值的字符串</a>(Medium) 为例。</p><blockquote><p> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p></blockquote><hr><p><strong>思路与算法</strong></p><p>根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p><ol><li>起始的空格</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点</li><li>小数部分</li><li>字符$E$</li><li>指数部分的符号位</li><li>指数的整数部分</li><li>结束的空格</li></ol><p>下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。</p><p>最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：</p><p><img src="\img\image-fsa.png" alt="image-20200902111512582"></p><p>在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 \text{e}e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。</p><hr><p><strong>代码</strong>：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">enum</span> state    &#123;        STATE_INIT,        <span class="hljs-comment">// STATE_SPACE,</span>        STATE_SIGN,        STATE_INTEGER,        STATE_POINT_INT,        STATE_POINT_NOT_INT,        STATE_DECIMAL,        STATE_EXP,        STATE_EXP_SIGN,        STATE_EXP_INT,        STATE_END,    &#125;;    <span class="hljs-keyword">enum</span> charType    &#123;        CHAR_NUM,        CHAR_SPACE,        CHAR_POINT,        CHAR_EXP,        CHAR_SIGN,        CHAR_INVALID,    &#125;;    <span class="hljs-function">charType <span class="hljs-title">getCharType</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_NUM;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span> CHAR_SPACE;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_POINT;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;E&#x27;</span>||ch == <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_EXP;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;+&#x27;</span>||ch==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_SIGN;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CHAR_INVALID;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">int</span> len = s.length();        state sta = STATE_INIT;        <span class="hljs-comment">//用哈希表存储状态转移方程</span>        <span class="hljs-built_in">unordered_map</span>&lt;state,<span class="hljs-built_in">unordered_map</span>&lt;charType,state&gt;&gt; transfer&#123;            &#123;                STATE_INIT, &#123;&#123;CHAR_SPACE,STATE_INIT&#125;,                            &#123;CHAR_SIGN, STATE_SIGN&#125;,                            &#123;CHAR_NUM, STATE_INTEGER&#125;,                            &#123;CHAR_POINT,STATE_POINT_NOT_INT&#125;            &#125;&#125;,            &#123;                STATE_SIGN,&#123;&#123;CHAR_NUM, STATE_INTEGER&#125;,                           &#123;CHAR_POINT, STATE_POINT_NOT_INT&#125;,            &#125;&#125;,            &#123;                STATE_DECIMAL,  &#123;&#123;CHAR_NUM, STATE_DECIMAL&#125;,                                &#123;CHAR_EXP, STATE_EXP&#125;,                                &#123;CHAR_SPACE, STATE_END&#125;            &#125;&#125;,            &#123;                STATE_INTEGER,  &#123;&#123;CHAR_NUM, STATE_INTEGER&#125;,                                &#123;CHAR_EXP,STATE_EXP&#125;,                                &#123;CHAR_POINT,STATE_POINT_INT&#125;,                                &#123;CHAR_SPACE,STATE_END&#125;            &#125;&#125;,            &#123;                STATE_POINT_NOT_INT,&#123;&#123;CHAR_NUM, STATE_DECIMAL&#125;            &#125;&#125;,            &#123;                STATE_POINT_INT,&#123;&#123;CHAR_SPACE,STATE_END&#125;,                                &#123;CHAR_NUM,STATE_DECIMAL&#125;,                                &#123;CHAR_EXP,STATE_EXP&#125;            &#125;&#125;,            &#123;                STATE_EXP,  &#123;&#123;CHAR_SIGN, STATE_EXP_SIGN&#125;,                            &#123;CHAR_NUM, STATE_EXP_INT&#125;            &#125;&#125;,            &#123;                STATE_EXP_SIGN,&#123;&#123;CHAR_NUM, STATE_EXP_INT&#125;            &#125;&#125;,            &#123;                STATE_EXP_INT,&#123;&#123;CHAR_NUM,STATE_EXP_INT&#125;,                                &#123;CHAR_SPACE,STATE_END&#125;&#125;            &#125;,            &#123;                STATE_END,&#123;&#123;CHAR_SPACE,STATE_END&#125;,&#125;            &#125;        &#125;;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)        &#123;            charType ct = getCharType(s[i]);            <span class="hljs-comment">//如果是非法状态，直接返回false</span>                    <span class="hljs-keyword">if</span>(!transfer[sta].count(ct)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            sta = transfer[sta][ct];                    &#125;         <span class="hljs-keyword">return</span> sta == STATE_END || sta == STATE_INTEGER || sta == STATE_POINT_INT || sta == STATE_DECIMAL|| sta == STATE_EXP_INT;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>有限自动状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索vs动态规划</title>
    <link href="/2020/08/28/2020-8-28-memorized-search/"/>
    <url>/2020/08/28/2020-8-28-memorized-search/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索vs动态规划"><a href="#记忆化搜索vs动态规划" class="headerlink" title="记忆化搜索vs动态规划"></a>记忆化搜索vs动态规划</h1><ul><li><blockquote><p>记忆化搜索实际上是递归来实现的，但是递归的过程中有许多的结果是被反复计算的，这样会大大降低算法的执行效率。　而记忆化搜索是在递归的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，因此极大的提高了算法的效率。</p></blockquote></li></ul><blockquote><p>记忆化搜索与动态规划区别：记忆化搜索：「<strong>自顶向下</strong>」，动态规划：「<strong>自底向上</strong>」。所有动态规划能解决的问题，记忆化搜索也能解决，唯一要注意的是动态规划不容易超时，但空间占用大，而记忆化搜索因为递归较多，容易TLE。    </p></blockquote><ul><li><a href="">546.移除盒子</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/">312.戳气球</a>(Hard)</li><li><a href="">1575.可行路径数</a>(hard)</li><li><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a>(Medium)（结合状态压缩）</li></ul><hr><h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h2><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code>，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>]输出: <span class="hljs-number">167</span> 解释: nums = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>] --&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>] --&gt;   [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>]   --&gt;  [<span class="hljs-number">8</span>]  --&gt; []     coins =  <span class="hljs-number">3</span>*<span class="hljs-number">1</span>*<span class="hljs-number">5</span>      +  <span class="hljs-number">3</span>*<span class="hljs-number">5</span>*<span class="hljs-number">8</span>    +  <span class="hljs-number">1</span>*<span class="hljs-number">3</span>*<span class="hljs-number">8</span>      + <span class="hljs-number">1</span>*<span class="hljs-number">8</span>*<span class="hljs-number">1</span>   = <span class="hljs-number">167</span></code></pre><hr><p>总的戳破气球操作数一定为<code>n</code>。我们可以倒过来看这些操作，每一次添加一个气球。</p><p>我们定义方法$solve(i,j)$表示将区间$(i,j)$全部填满所能得到的最多的硬币数。这里是一个开区间。当</p><ul><li><p>$i\ge j-1$，$solve(i,j)=0$</p></li><li><p>否则，我们枚举开区间$(i,j)$内的全部位置$mid$，令$mid$为当前区间第一个添加的气球，该操作所能得到的硬币数为  </p></li><li><script type="math/tex; mode=display">nums[mid-1]*nums[mid]*nums[mid+1] ​</script></li><li><p>同时我们递归的计算出分割的两区间对$solve(i,j)$的贡献，这三项最大值，即为$solve(i,j)$的值。这样问题可以转换为求$solve(i,mid)$与$solve(mid,j)$之和。</p></li></ul><p>状态转移方程：</p><script type="math/tex; mode=display">solve(i,j)= \left\{\begin{array}{rrr}0,i \ge j-1\\solve(i,mid)+\\ \max \limits_{i\lt mid \lt j}(nums[mid-1]*nums[mid]*nums[mid+1])+\\ solve(mid,j), otherwise\\\end{array}\right.</script><p>然后我们再看边界条件：</p><blockquote><p>$solve(0,0)=0$</p></blockquote><p>为了避免重复计算，我们存储<code>solve</code>的中间结果。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> n;     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; memo;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//开区间(i,j)内积分最大值,先加mid，再计算最大值</span>                <span class="hljs-keyword">if</span>(i &gt;= j<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span>(memo[i][j]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> memo[i][j];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mid = i+<span class="hljs-number">1</span>; mid &lt; j; mid++)        &#123;            memo[i][j] = max(memo[i][j], nums[i]*nums[mid]*nums[j]+solve(i,mid)+solve(mid,j) );        &#125;        <span class="hljs-keyword">return</span> memo[i][j];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//这一题和移除盒子是同类型题，要靠JOJO奇妙的动态规划来解决</span>        <span class="hljs-comment">//我们要让尽可能大的气球相邻</span>        n = nums.size();        nums.insert(nums.begin(),<span class="hljs-number">1</span>);        nums.emplace_back(<span class="hljs-number">1</span>);        <span class="hljs-keyword">this</span>-&gt;nums = nums;        memo.resize(n+<span class="hljs-number">2</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>));        <span class="hljs-keyword">return</span> solve(<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(n^3)$，其中 $n$ 是气球数量。区间数为 $n^2$，区间迭代复杂度为 O(n)O(n)，最终复杂度为 $O(n^2 \times n) = O(n^3)$</p></li><li><p>空间复杂度：$O(n^2)$，其中 $n$ 是气球数量。缓存大小为区间的个数。</p></li></ul><p><strong>动态规划代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">rec</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>))</span></span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            val[i] = nums[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;                    <span class="hljs-keyword">int</span> sum = val[i] * val[k] * val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = max(rec[i][j], sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];    &#125;&#125;;</code></pre><h2 id="546-移除盒子"><a href="#546-移除盒子" class="headerlink" title="546. 移除盒子"></a>546. 移除盒子</h2><p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。<br>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。<br>当你将所有盒子都去掉之后，求你能获得的最大积分和。</p><p>示例：</p><pre><code class="hljs angelscript">输入：boxes = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">23</span>解释：[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span> 分) ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">1</span>*<span class="hljs-number">1</span>=<span class="hljs-number">1</span> 分) ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span> 分) ----&gt; [] (<span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">4</span> 分)</code></pre><p>提示：</p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= boxes.length &lt;= <span class="hljs-number">100</span><span class="hljs-symbol">1 </span>&lt;= boxes[i] &lt;= <span class="hljs-number">100</span></code></pre><hr><p>这一题的规模比较小，按照官方的尿性，官解的时间复杂度会很大。很神奇的是，这种题目也可以通过动态规划解决。</p><p>用$f(l,r,k)$表示移除区间$[l,r]$加上该区间右边等于$a_r$的$k$个元素组成的序列的最大积分。</p><h2 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h2><hr><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p> <pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]输出：False解释：一开始，玩家<span class="hljs-number">1</span>可以从<span class="hljs-number">1</span>和<span class="hljs-number">2</span>中进行选择。如果他选择 <span class="hljs-number">2</span>（或者 <span class="hljs-number">1</span> ），那么玩家 <span class="hljs-number">2</span> 可以从 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）和 <span class="hljs-number">5</span> 中进行选择。如果玩家 <span class="hljs-number">2</span> 选择了 <span class="hljs-number">5</span> ，那么玩家 <span class="hljs-number">1</span> 则只剩下 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）可选。所以，玩家 <span class="hljs-number">1</span> 的最终分数为 <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>，而玩家 <span class="hljs-number">2</span> 为 <span class="hljs-number">5</span> 。因此，玩家 <span class="hljs-number">1</span> 永远不会成为赢家，返回 False 。</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">233</span>, <span class="hljs-number">7</span>]输出：True解释：玩家 <span class="hljs-number">1</span> 一开始选择 <span class="hljs-number">1</span> 。然后玩家 <span class="hljs-number">2</span> 必须从 <span class="hljs-number">5</span> 和 <span class="hljs-number">7</span> 中进行选择。无论玩家 <span class="hljs-number">2</span> 选择了哪个，玩家 <span class="hljs-number">1</span> 都可以选择 <span class="hljs-number">233</span> 。     最终，玩家 <span class="hljs-number">1</span>（<span class="hljs-number">234</span> 分）比玩家 <span class="hljs-number">2</span>（<span class="hljs-number">12</span> 分）获得更多的分数，所以返回 True，表示玩家 <span class="hljs-number">1</span> 可以成为赢家。</code></pre><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><hr><p>我们用$dp[l][r]$表示闭区间$[l,r]$内，自己「先手」能获得的分数最大值。那么函数<code>dfs(l,r)</code>返回<code>dp[l][r]</code>。并进行记录。</p><p><strong>记忆化搜索</strong> </p><p>$dp[l][r] = sum(l,r) - min(dp[l+1][r],dp[l][r-1])$</p><blockquote><p> 边界条件 $dp[l][l] = nums[l]$; 返回值：$dfs(nums,0,n-1)*2 &gt;= sum(nums,0,n-1)$</p></blockquote><p>时间复杂度：$O(2^n)$</p><p>空间复杂度: $O(n)$，递归的空间复杂度取决于使用了多少栈空间。</p><p><strong>动态规划</strong>    </p><p>$dp[l][r] = max(-dp[l+1][r] + nums[l],-dp[l][r-1]+nums[r])$</p><p>我们先在$nums[l],nums[r]$中进行选择，同时保证对手的$dp[l+1][r]或者dp[l][r-1]$最小。 </p><blockquote><p>边界条件 $dp[l][l] = nums[l]$, 返回值：$dp[0][n-1]&gt;=0$</p></blockquote><p>使用递归存在大量重复计算，时间复杂度很高，因而采用动态规划是更好的选择。<strong>注意</strong>：$i$的遍历要从$n$开始，即反过来。</p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度: $O(n)$，使用滚动数组优化。</p><p><strong>代码（DFS+记忆化搜索）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allsum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//对下标l-r进行求和</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r;i++) sum += nums[i];        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//记忆化搜索，返回l,r使得先手优势最大的值</span>        <span class="hljs-keyword">if</span>(dp[l][r]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[l][r];        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l==r) &#123;dp[l][r]=nums[l];<span class="hljs-keyword">return</span> nums[l];&#125;        dp[l][r] = allsum(nums,l,r) - min(dfs(nums,l+<span class="hljs-number">1</span>,r),dfs(nums,l,r<span class="hljs-number">-1</span>));        <span class="hljs-comment">// printf(&quot;dp[%d][%d]=%d\n&quot;,lr,dp[l][r]);</span>        <span class="hljs-keyword">return</span> dp[l][r];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>&gt;=allsum(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p><strong>代码（DFS+动态规划）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-comment">//表示[i,j]区间的最大值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) dp[i][i] = nums[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n;i &gt;= <span class="hljs-number">0</span>;i--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++)    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n &amp;&amp; j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)    &#123;        dp[i][j] = max(-dp[i+<span class="hljs-number">1</span>][j]+nums[i], -dp[i][j<span class="hljs-number">-1</span>]+nums[j]);        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;    </span>            &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><hr><h4 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a></h4><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到或超过 100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p><p>给定一个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和另一个整数 <code>desiredTotal</code>（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p><p>你可以假设 <code>maxChoosableInteger</code> 不会大于 20， <code>desiredTotal</code> 不会大于 300。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入：</span><span class="hljs-string">maxChoosableInteger</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">desiredTotal</span> <span class="hljs-string">=</span> <span class="hljs-number">11</span><span class="hljs-string">输出：</span><span class="hljs-literal">false</span><span class="hljs-string">解释：</span><span class="hljs-string">无论第一个玩家选择哪个整数，他都会失败。</span><span class="hljs-string">第一个玩家可以选择从</span> <span class="hljs-number">1</span> <span class="hljs-string">到</span> <span class="hljs-number">10</span> <span class="hljs-string">的整数。</span><span class="hljs-string">如果第一个玩家选择</span> <span class="hljs-number">1</span><span class="hljs-string">，那么第二个玩家只能选择从</span> <span class="hljs-number">2</span> <span class="hljs-string">到</span> <span class="hljs-number">10</span> <span class="hljs-string">的整数。</span><span class="hljs-string">第二个玩家可以通过选择整数</span> <span class="hljs-number">10</span><span class="hljs-string">（那么累积和为</span> <span class="hljs-number">11</span> <span class="hljs-string">&gt;=</span> <span class="hljs-string">desiredTotal），从而取得胜利.</span><span class="hljs-string">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span></code></pre><hr><blockquote><p>首先我们弄清稳赢的含义，也就是说在某一个回合，A走完一步后，B发现他无论下哪一步都会输，或者A发现自己无论下哪一步都会赢。这两者都表示A会赢。</p></blockquote><p>这道题目，是和博弈论相关的「先手」，很容易想到的做法是动态规划，但是因为回合数不确定，很难直接写出状态转移方程，这个时候我们可以，另辟蹊径，采用「<strong>记忆化搜索</strong>」，定义一个<code>helper</code>函数，参数分别为记忆化搜索范围<code>int maxChoosableIntegerx</code>，目标<code>int target</code>,状态转移方程组<code>boolean[] dp</code>, 还有状态<code>int state</code>，框架在两分钟内就可以搭好。</p><pre><code class="hljs cpp">state|(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>));<span class="hljs-comment">//表示对state第i位置1</span>state &amp; <span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>);<span class="hljs-comment">//判断state第i位是否为1</span></code></pre><p>我们思考状态压缩，因为最大整数不超过20，这就提示我们可以采用「<strong>状态压缩</strong>」。用$N$位二进制来表示状态，1表示选择，0表示未选，例如<code>1000_010</code>表示选择2和7。这里dp作用是<u>记忆状态</u>，如果在递归时，我们发现<code>dp[state]!=null</code>就可以直接返回<code>dp[state]</code>。</p><p><strong>算法</strong></p><p>我们实际考虑每个回合，先手能否稳赢，这里先手指各个回合。设<code>i</code>为选择的数，如果这个回合<code>target - i &lt;= 0</code>或者下一个回合 <code>helper(N, target - i, dp, state|cur) == false</code> 则表明先手获胜<code>dp[state] = true</code>并返回。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Boolean[] b;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canIWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxChoosableInteger, <span class="hljs-keyword">int</span> desiredTotal)</span> </span>&#123;        <span class="hljs-comment">//这个题属于经典零和博弈问题，要判断先手的玩家能否赢</span>        <span class="hljs-comment">//如果最大整数小于等于目标整数，那么先手玩家一定会赢</span>        <span class="hljs-comment">//记忆化搜索+状态压缩</span>        <span class="hljs-keyword">if</span>(maxChoosableInteger &gt;= desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>+maxChoosableInteger)*maxChoosableInteger &lt; <span class="hljs-number">2</span>*desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        b = <span class="hljs-keyword">new</span> Boolean[<span class="hljs-number">1</span> &lt;&lt; maxChoosableInteger];        <span class="hljs-keyword">return</span> helper(desiredTotal, <span class="hljs-number">0</span>, b , maxChoosableInteger);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> state, Boolean[] dp,<span class="hljs-keyword">int</span> N)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//dp[i]表示选择第i位后的状态</span>        <span class="hljs-keyword">if</span>(dp[state] != <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> dp[state];<span class="hljs-comment">//用类类型代替封装</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = N;i &gt;= <span class="hljs-number">1</span>;i--)        &#123;            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>&lt;&lt;(i-<span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) <span class="hljs-comment">//说明第i位还没用过</span>            &#123;                <span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>&lt;&lt;(i-<span class="hljs-number">1</span>);<span class="hljs-comment">//将第i位置1</span>                <span class="hljs-keyword">if</span>( target &lt;= i || (helper(target - i, state|cur, dp, N) == <span class="hljs-keyword">false</span>)) &#123;                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N!)$</p><p>空间复杂度：$ O(1&lt;&lt;m)$，$m$为最大可选择整数。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论之求解欧拉通路</title>
    <link href="/2020/08/27/2020-8-27-some_tricks/"/>
    <url>/2020/08/27/2020-8-27-some_tricks/</url>
    
    <content type="html"><![CDATA[<h1 id="图论：求解欧拉通路问题"><a href="#图论：求解欧拉通路问题" class="headerlink" title="图论：求解欧拉通路问题"></a>图论：求解欧拉通路问题</h1><ul><li>753.<a href="https://leetcode-cn.com/problems/cracking-the-safe/">破解保险箱</a>(Hard)</li><li>332.<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a>(Medium)</li></ul><p>这类问题在实际生活中经常出现，大致可以抽象为：</p><blockquote><p>给定一个 <em>n</em> 个点 <em>m</em> 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。</p></blockquote><p>这种「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系，下面给出定义：</p><ul><li><p>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</p></li><li><p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</p></li><li><p>具有欧拉回路的无向图称为欧拉图。</p></li></ul><p>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</p><hr><h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a></h3><p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p><p>说明:</p><p>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前<br>所有的机场都用三个大写字母表示（机场代码）。<br>假定所有机票至少存在一种合理的行程。<br>示例 1:</p><pre><code class="hljs prolog">输入: [[<span class="hljs-string">&quot;MUC&quot;</span>, <span class="hljs-string">&quot;LHR&quot;</span>], [<span class="hljs-string">&quot;JFK&quot;</span>, <span class="hljs-string">&quot;MUC&quot;</span>], [<span class="hljs-string">&quot;SFO&quot;</span>, <span class="hljs-string">&quot;SJC&quot;</span>], [<span class="hljs-string">&quot;LHR&quot;</span>, <span class="hljs-string">&quot;SFO&quot;</span>]]输出: [<span class="hljs-string">&quot;JFK&quot;</span>, <span class="hljs-string">&quot;MUC&quot;</span>, <span class="hljs-string">&quot;LHR&quot;</span>, <span class="hljs-string">&quot;SFO&quot;</span>, <span class="hljs-string">&quot;SJC&quot;</span>]</code></pre><p>示例 2:</p><pre><code class="hljs prolog">输入: [[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>],[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>],[<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>],[<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>],[<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]]输出: [<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]解释: 另一种有效的行程是 [<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]。但是它自然排序更大更靠后。</code></pre><hr><p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。</p><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><p>对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p><p>对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</p><p>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p><p>对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且</p><ul><li>恰有一个顶点的出度与入度差为 1；</li><li>恰有一个顶点的入度与出度差为 1；</li><li>所有其他顶点的入度和出度相同。</li></ul><p>让我们考虑下面的这张图：</p><p><img src="https://assets.leetcode-cn.com/solution-static/332/332_fig1.png" alt="Graph1" style="zoom:50%;" /></p><p>我们从起点 \text{JFK}JFK 出发，合法路径有两条：</p><script type="math/tex; mode=display">JFK→AAA→JFK→BBB→JFK\\JFK→BBB→JFK→AAA→JFK</script><p>既然要求字典序最小，那么我们每次应该贪心地选择当前节点所连的节点中字典序最小的那一个，并将其入栈。最后栈中就保存了我们遍历的顺序。</p><p>为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点，每次我们 $O(1) $地找到最小字典序的节点，并 $O(\log m)$ 地删除它。</p><p>然后我们考虑一种特殊情况：</p><p><img src="https://assets.leetcode-cn.com/solution-static/332/332_fig2.png" alt="Graph2"></p><p>当我们先访问 $AAA$时，我们无法回到 $JFK$，这样我们就无法访问剩余的边了。</p><p>也就是说，当我们贪心地选择字典序最小的节点前进时，我们可能先走入「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。</p><hr><h2 id="方法一：-Hierholzer-算法"><a href="#方法一：-Hierholzer-算法" class="headerlink" title="方法一：$Hierholzer$算法"></a>方法一：$Hierholzer$算法</h2><p>寻找欧拉路径的流程:</p><ol><li><p>从起点出发，进行深度优先搜索。</p></li><li><p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</p></li><li><p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p></li></ol><p>当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。</p><p>不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</p><p>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</p><p>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;,<span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-built_in">string</span>&gt;&gt;&gt; node;<span class="hljs-comment">//出发地，目的地</span>    <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> cur)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//先遍历完一个节点，再将节点入栈</span>        <span class="hljs-keyword">while</span>(node.count(cur)&amp;&amp;node[cur].size()&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">string</span> next = node[cur].top();            node[cur].pop();            dfs(next);        &#125;        res.emplace_back(cur);    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!tickets.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-comment">//问题可以变为：遍历一个图所有节点，返回自然排序最小的遍历方式</span>        <span class="hljs-comment">//这意味着我们必须找到所有的组合，并且逐个进行比较</span>        <span class="hljs-comment">//遍历方式，DFS</span>        n = tickets.size();        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:tickets ) node[t[<span class="hljs-number">0</span>]].emplace(t[<span class="hljs-number">1</span>]);                dfs(<span class="hljs-string">&quot;JFK&quot;</span>);        reverse(res.begin(),res.end());        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：$O(m \log m)$，其中 $m$ 是边的数量。对于每一条边我们需要 $O(\log m)$ 地删除它，最终的答案序列长度为 $m+1$，而与 $n$ 无关。</p></li><li><p><strong>空间复杂度</strong>：$O(m)$，其中 $m$ 是边的数量。我们需要存储每一条边</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>求解欧拉通路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买股票问题</title>
    <link href="/2020/08/26/2020-8-26-lotus/"/>
    <url>/2020/08/26/2020-8-26-lotus/</url>
    
    <content type="html"><![CDATA[<h1 id="股票系列问题"><a href="#股票系列问题" class="headerlink" title="股票系列问题"></a>股票系列问题</h1><ol><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>(Easy)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a>(Easy)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a>(Hard)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a>(Hard)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">最佳买卖股票时机含冷冻期</a>(Medium)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a>(Medium)</p></li></ol><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a>(Medium)</p><p>一种常用的方法是将「买入」和「卖出」分开进行考虑：「买入」为负收益，而「卖出」为正收益。在初入股市时，你只有「买入」的权利，只能获得负收益。而当你「买入」之后，你就有了「卖出」的权利，可以获得正收益。显然，我们需要尽可能地降低负收益而提高正收益，因此我们的目标总是将收益值最大化。因此，我们可以使用动态规划的方法，维护在股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p><hr><h3 id="1-最佳买卖股票时机含冷冻期-Medium"><a href="#1-最佳买卖股票时机含冷冻期-Medium" class="headerlink" title="1.最佳买卖股票时机含冷冻期(Medium)"></a><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">1.最佳买卖股票时机含冷冻期</a>(Medium)</strong></h3><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</li></ul><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><hr><ol><li><strong>动态规划</strong></li></ol><p>由于题目规定不能同时进行多笔交易，那么我们便能通过动态规划进行求解：</p><p>我们用$f[i]$表示<strong>第$i$天结束后的「累计最大收益」</strong>，我们会有三种可能的状态：</p><ol><li>第$i$天，处于可以买入状态的最大收益， 记为$f[i][0]$</li><li>买入了一只股票，记为$f[i][1]$</li><li>卖出了一只股票，处于冷冻期，记为$f[i][2]$</li></ol><blockquote><p><strong>这里的「处于冷冻期」指的是在第 i天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</strong></p></blockquote><p>我们分别对三种状态进行分析</p><p><img src="\img\lotus.png" alt="image-20200827124158917"></p><p>状态转移方程为</p><script type="math/tex; mode=display">dp[i][0]=\max(dp[i-1][0],dp[i-1][2])\\dp[i][1]=\max(dp[i-1][0]-price[i-1],dp[i-1][1])\\dp[i][2]=dp[i-1][1]+price[i-1]</script><p>这里需要理解的是，在卖出一只股票后，一定处于冷冻状态，这时候最大利润一定是前一个卖出的状态加上卖出的价格。</p><blockquote><p>边界条件，千万要思考清楚，第二种状态初始值应该为INT_MIN。因为这种状态在逻辑上是不存在的！</p></blockquote><script type="math/tex; mode=display">\begin{array}{lcc}dp[0][0] = 0;\\dp[0][1] = INT\_MIN;\\dp[0][2] = 0;\end{array}</script><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!prices.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//要获得最大利润，利润=\sum（卖出价格-买入价格）</span>        <span class="hljs-keyword">int</span> n = prices.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>,INT_MIN))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = INT_MIN;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ;i++)        &#123;            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);            dp[i][<span class="hljs-number">2</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i<span class="hljs-number">-1</span>];                    <span class="hljs-comment">//printf(&quot;%d,%d,%d,%d\n&quot;,i,dp[i][0],dp[i][1],dp[i][2]);</span>        &#125;        <span class="hljs-keyword">return</span> max(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">2</span>]);    &#125;&#125;;</code></pre><p><strong>优化</strong></p><p>滚动数组【略】</p><ol><li><strong>有限状态自动机解法</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode经典</tag>
      
      <tag>动态规划</tag>
      
      <tag>有限自动状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习I 线性模型</title>
    <link href="/2020/08/23/2020-08-23-ML3/"/>
    <url>/2020/08/23/2020-08-23-ML3/</url>
    
    <content type="html"><![CDATA[<h1 id="三、线性模型"><a href="#三、线性模型" class="headerlink" title="三、线性模型"></a>三、线性模型</h1><p>一元线性模型用向量表示为</p><script type="math/tex; mode=display">f(x)=w^Tx+b</script><p>其中$w$称为权重向量，$b$称为偏置。我们可以利用均方误差，来求得$w$与$b$.</p><script type="math/tex; mode=display">(w^*,b^*)=\arg \min\sum\limits_{i=1}^{m}(f(x_i)-y_i)^2</script><p>均方误差对应于几何中欧氏距离($Euclidean Distance$)。该方法被称为「<strong>最小二乘法</strong>」($least square method$)。</p><p>当然有更一般的形式“多元线性回归”。</p><script type="math/tex; mode=display">f(x_i)=\bf{w}^Tx_i+b</script><p>我们把数据集表示为矩阵$X$</p><script type="math/tex; mode=display">X= \left(\begin{array}{ccc}    x_1^T & 1\\x_2^T &1\\ \quad  ...    \\x_n^T &1    \end{array}\right)</script><p>则：</p><script type="math/tex; mode=display">\hat{\bf{w}}=\arg \min(\bf{y-X\hat{w}})^T(\bf{y-X\hat{w}})</script><p>令$E=(\bf{y-X\hat{w}})^T(\bf{y-X\hat{w}})$，对$w$求导得：</p><script type="math/tex; mode=display">\frac{\partial{E}}{\partial{\bf{w}}}=2\bf{X}^T(X\hat{w}-y)</script><p>当$X^TX$为满秩矩阵时，令$(6)$为$0$得:</p><script type="math/tex; mode=display">\hat{w}^*=\bf(X^TX)^{-1}X^Ty</script><p>然而现实任务中我们遇到的往往是非满秩矩阵，可以解出多个$\hat{w}$,选择哪一个解作为输出，由机器学习算法的归纳偏好决定，一般会引入正则化项($regularization$)。</p><p>为了更方便表示，我们引入“对数线性逻辑回归”：</p><script type="math/tex; mode=display">\ln y = w^Tx+b</script><p>这里的对数值其实是让线性回归模型的预测值与真实标记联系起来的作用。</p><p>一般地，我们考虑单调可微函数$g(.)$</p><script type="math/tex; mode=display">y = g^{-1}(w^Tx+b)</script><p>这里的$g(.)$我们称为联系函数。</p><p><strong>对数几率回归</strong></p><p><img src="\img\sigmoid.jpg" alt="img"></p><script type="math/tex; mode=display">y = \frac{1}{1+e^{-z}}</script><p>我们称之为Sigmoid函数。我们将其作为联系函数则：</p><script type="math/tex; mode=display">y= 1/(1+e\wedge (-w^Tx+b))</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念与公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一句能打败99.99999%的程序员的位操作代码</title>
    <link href="/2020/08/23/2020-8-23-bitoperation/"/>
    <url>/2020/08/23/2020-8-23-bitoperation/</url>
    
    <content type="html"><![CDATA[<h1 id="专题：位操作"><a href="#专题：位操作" class="headerlink" title="专题：位操作"></a>专题：位操作</h1><blockquote><p>位操作是一种很神奇的操作，真的很神奇————Tiancheng Lou</p></blockquote><p>位操作包括：</p><ul><li><p>¬ 取反（NOT）</p></li><li><p>∩ 按位或（OR）</p></li><li><p>⊕ 按位异或（XOR）</p></li><li><p>∪ 按位与（AND）</p></li><li><p><strong>移位</strong></p><ul><li><p>移位是一个二元运算符，用来将一个二进制数中的每一位全部都向一个方向移动指定位，溢出的部分将被舍弃，而空缺的部分填入一定的值。移位又分为</p><ul><li><p>算术移位：在位移运算符之前的数是<u><strong>有符号</strong></u>数，编译产生的汇编指令是算术位移，<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。</p></li><li><p>逻辑移位：在位移运算符（&gt;&gt;和&lt;&lt;）之前的数是<strong><u>无符号</u></strong>数，编译产生的汇编指令是逻辑位移，<code>&gt;&gt;&gt;</code>及<code>&lt;&lt;&lt;</code>。</p></li></ul></li></ul></li></ul><hr><p><strong>题目</strong></p><p>201 <a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/">数字范围按位与</a></p><p>461 <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></p><p>338 <a href="https://leetcode-cn.com/problems/counting-bits">比特位计数</a>（Medium）</p><ol><li>解数独</li></ol><p>树状数组 的LowBit操作</p><p>….</p><hr><p>我们使用长度为9的数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一个整数表示每个数字是否出现过。</p><p>具体地，数$b$ 的二进制表示的第$i$位（从低到高，最低位为第$0$位），当且仅当数字$i+1$已经出现过。例如当 b 的二进制表示为 $(011000100)_2$ 时，就表示数字 3，7，8 已经出现过。</p><p>位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：</p><ul><li><p>某个数中第$k$位为1，表示该位置不能填入数字$k+1$.我们先与上$(11111111)_2=(1FF)_{16}$消除高位的影响，然后对其取反，然后枚举。因为是需要9个bit状态，所以是左移九位。</p></li><li><p>我们可以使用按位异或运算$ \wedge$, 与 $1&lt;&lt;i$异或即可。</p></li><li><p>我们可以用 $b \&amp; (−b) $得到 b 二进制表示中最低位的 1，这是因为 $(−b)$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 如果和 $∼b$ 进行按位与运算，那么会得到 0，但是当 $\sim b$ 增加 1 之后，最低位的连续的 1 都变为 0，而最低位的 0 变为 1，对应到 $b$ 中即为最低位的 1，因此当 $b$ 和 $∼b+1$ 进行按位与运算时，只有最低位的 1 会被保留；</p></li><li><p>我们可以用$b$与最低位的1按位异或，就可以将其从$b$中去除，这样就可以枚举下一个1。同样的，我们可以用$b\&amp;(b-1)$达到同样的效果，这被称为<strong>Brian kernighan算法</strong>。</p><p>具体应用见$\lfloor$回溯算法$\rceil$    </p></li></ul><hr><p>大多数编程语言中，都存在各种内置计算等于 1 的位数函数。如果这是一个项目中的问题，应该直接使用内置函数，而不是重复造轮子。</p><pre><code class="hljs python">bin(x ^ y).count(<span class="hljs-string">&#x27;1&#x27;</span>)</code></pre><pre><code class="hljs C++">binset&lt;<span class="hljs-number">32</span>&gt;(x^y).count();</code></pre><pre><code class="hljs java">Integer.bitCount(x ^ y);</code></pre><p><strong>Brian kernighan算法</strong></p><p>该算法的关键在于我们每次对$number$和$number-1$之间进行按位与操作后，$number$中最右边的1会变成0。</p><script type="math/tex; mode=display">n\&(n-1)</script><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log n)$。和位移方法类似，算法的时间复杂度取决于 $m$ 和 $n$ 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li><li>空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。</li></ul><p><strong>Hamming距离</strong></p><blockquote><p>461 <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></p></blockquote><p>汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。</p><p>两个整数之间的汉明距离是对应位置上数字不同的位数。</p><p><img src="\img\hamming.png" alt="img"></p><p>根据以上定义，提出一种 XOR 的位运算，当且仅当输入位不同时输出为 1。</p><blockquote><p> 计算 x 和 y 之间的汉明距离，可以先计算 x XOR y，然后统计结果中等于 1 的位数。</p></blockquote><p>现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。</p><p><strong>布赖恩·克尼根算法</strong><br>思路</p><blockquote><p> 是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：10001000。</p></blockquote><p>上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。</p><p>这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p><blockquote><p> 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。</p></blockquote><p>基于以上思路，通过 2 次迭代就可以知道 10001000 中 1 的位数，而不需要 8 次。</p><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingDistance</span>(<span class="hljs-params">self, x, y</span>):</span>        xor = x ^ y        distance = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> xor:            distance += <span class="hljs-number">1</span>            <span class="hljs-comment"># remove the rightmost bit of &#x27;1&#x27;</span>​            xor = xor &amp; (xor - <span class="hljs-number">1</span>)​        <span class="hljs-keyword">return</span> distance</code></pre><p>注意：该算法发布在 1988 年 《C 语言编程第二版》的练习中（由 Brian W. Kernighan 和 Dennis M. Ritchie 编写），但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。顺便说一句，可以在上述书籍中找到更多位操作的技巧。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(1)$。与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。但是该方法需要的迭代操作更少。</p></li><li><p>空间复杂度：$O(1)$，与输入无关，使用恒定大小的空间。</p></li></ul><p><strong>动态规划</strong>+<strong>最高有效位</strong></p><p>有一些位操作题目用动态规划解也十分方便和快速。</p><p>比如 338 <a href="https://leetcode-cn.com/problems/counting-bits">比特位计数</a>（Medium）</p><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>假设有一个整数：</p><p>$x = (1001011101)_2 = (605)_{10}<br>    $</p><p>我们已经计算了从 $0$到 $x - 1$ 的全部结果。</p><p>我们知道，$x$与 我们计算过的一个数只有一位之差:</p><p>$x’ = (1011101)_2 = (93)_{10}$<br>它们只在最高有效位上不同。</p><p>让我们以二进制形式检查 $[0, 3]$ 的范围：</p><script type="math/tex; mode=display">0 = (00)\\1 = (01)\\2 = (10)\\3 = (11)</script><p>可以看出， 2 和 3 的二进制形式可以通过给 0 和 1 的二进制形式在前面加上 1 来得到。因此，它们的 pop_count 只相差 1。</p><p>类似的，我们可以使用 $[0, 3]$ 作为蓝本来得到 $[4, 7]$。</p><p>总之，对于pop count $P(x)$，我们有以下的状态转移函数：</p><script type="math/tex; mode=display">P(x + b) = P(x) + 1, b = 2^m > x</script><p>有了状态转移函数，我们可以利用动态规划从 0 开始生成所有结果。</p><p><strong>动态规划 + 最低有效位</strong></p><p>遵循上一方法的相同原则，我们还可以通过最低有效位来获得状态转移函数。</p><p>观察$x$ 和 $x’ = x / 2$的关系：</p><p>$x = (1001011101)_2 = (605)_{10}$</p><p>$x’ = (100101110)_2 = (302)_{10}$<br>可以发现 $x’$与 $x$ 只有一位不同，这是因为$x’$  可以看做 xx 移除最低有效位的结果。</p><p>这样，我们就有了下面的状态转移函数：</p><script type="math/tex; mode=display">P(x) = P(x >> 1) + (x \mod 2)</script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅而巧妙的并查集</title>
    <link href="/2020/08/14/2020-8-14-what-is-UnionSet/"/>
    <url>/2020/08/14/2020-8-14-what-is-UnionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是并查集（UnionSet）"><a href="#什么是并查集（UnionSet）" class="headerlink" title="什么是并查集（UnionSet）"></a>什么是并查集（UnionSet）</h1><ol><li><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></p></li><li><p><a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿的数量</a></p></li><li><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">二维网格中探测环</a></p></li><li><p><a href="https://leetcode-cn.com/problems/evaluate-division/">除法求值</a>（带权值）            </p></li><li><p><a href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a>（无向图）</p></li><li><p><a href="https://leetcode-cn.com/problems/redundant-connection-ii">冗余连接II</a>(Hard)（有向图）</p></li><li><p><a href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a>(DFS,BFS,UnionSet均可以做,DFS,BFS更优)</p></li><li><p><del>句子相似性2(VIP)</del></p></li><li><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">等式方程可满足性</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">连通网络操作次数</a></p></li><li><p><a href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/">按公因数计算最大组件大小</a>（hard）</p></li><li><p><a href="https://leetcode-cn.com/problems/couples-holding-hands/">情侣牵手</a>（Hard）</p></li><li><a href="https://leetcode-cn.com/problems/accounts-merge/">账户合并</a></li></ol><blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/93647900">知乎传送门</a></p></blockquote><p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合之中</li></ul><p>在连通性问题中（如岛屿问题），并查集很有作用。<strong>核心思想</strong>是连通区域内所有点的根节点其实是同一个。将每个点映射为一个数字。先假设每个点的根节点就是它们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋给另一个点的根节点，这样两个点所在的连通区域又相互连通了。</p><p>好的我们一步一步来画板子（ddrdd）：</p><p>并查集的主要操作有：</p><ul><li><code>find(int m)</code> :查找$m$的根节点</li><li><code>isConnected(int m, int n)</code>：判断$m,n$两个点是否在同一个连通区域。</li><li><code>Union(int m, int n)</code>:合并$m,n$两个点所在的连通区域。</li></ul><p><strong>初始化</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> fa[MAXN];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n )</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;i++)        fa[i] = i;&#125;</code></pre><p><strong>查询</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(fa[x]==x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">return</span> find(fa[x]);&#125;</code></pre><p>一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><p><strong>合并</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;fa[find(i)] = find(j);&#125;</code></pre><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者.</p><p><strong>更新</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-keyword">if</span>(fa[i] != i) fa[i] = find(fa[i]);&#125;</code></pre><p>一般在对所有节点merge之后需要整体更新，避免漏掉连通分支。</p><hr><p>初级并查集效率较低，我们需要进行<strong>路径压缩</strong>。</p><p>我们添加元素可能会形成长链，想要从底部寻找根节点会越来越难。路径压缩是这样一种算法，每个元素到根节点的路径尽可能短。</p><p>我们可以在查找的过程中，<u>把沿途每个节点的父节点都设为根节点</u>。</p><p><strong>路径压缩后合并</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x==find(x)? x : (fa[x] = find(fa[x]));&#125;</code></pre><p>我们得到的并查集是这样的，很像一棵二叉树。</p><p><strong>按秩合并</strong></p><p>按路径压缩后的并查集结构仍是毕竟复杂的，比如现在我们有一棵较复杂的树，与一个单元素进行合并：</p><p><img src="/img/dsu_1.jpg" alt=""></p><p>那么是把7作为8的父节点好呢，还是8作为7父节点好呢：</p><p>当然是前者，因为后者会使树的深度加深。所以要<strong>把简单树往复杂树上合并。</strong></p><p>我们用于一个数组<code>rank[]</code>记录每个根节点对应树的深度。一开始，所有节点的秩设为1.合并时比较两个根节点，把秩小的往秩的根节点合并。</p><p><strong>初始化（按秩合并）</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)     &#123;        fa[i] = i;        rank[i] = <span class="hljs-number">1</span>;    &#125; &#125;</code></pre><p><strong>合并（按秩合并）</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = find(i),y = find(j);    <span class="hljs-keyword">if</span>(rank[x] &lt;= rank[y])         fa[x] = y;    <span class="hljs-keyword">else</span>         fa[y] = x;    <span class="hljs-keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)    &#123;<span class="hljs-comment">//如果秩相同，则新节点深度++</span>        rank[y]++;    &#125;   &#125;</code></pre><p>为什么根秩相同，深度要加1呢，如下图，我们有两个秩均为2 的树，现在要合并。</p><p><img src="/img/dsu_2.png" alt="img" style="zoom:67%;" /></p><p>我们把2的父节点设为5，这里深度加1，同样另一种合并方式也会使深度加1.</p><p><img src="\img\dsu_3.png" alt="img" style="zoom:67%;" /></p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；</p><p>2、代表元法：采用 parent 数组实现，以每个结点的根结点作为代表元；</p><p>3、并查集的优化有两种策略：</p><p>（1）<strong>路径压缩</strong>；</p><p>有「隔代压缩」与「完全压缩」。</p><ul><li>「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。</li><li>「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。</li></ul><p><img src="\img\dsu_3.jpg" alt="image.png"></p><p>（2）按秩合并。</p><p>秩也有两种含义：</p><p>秩表示以当前结点为根结点的子树结点总数，即这里的「秩」表示 size 含义；<br>秩表示以当前结点为根结点的子树的高度，即这里的「秩」表示 rank 含义（更合理，因为查询时候的时间性能主要决定于树的高度）。<br>4、如果同时使用「路径压缩」与「按秩合并」，这里的「秩」就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的「参考」。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近 $O(1)$。</p><p><a href="https://www.zhihu.com/question/35090745">为什么并查集在路径压缩之后的时间复杂度是阿克曼函数?</a></p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1559-二维网格图中探测环"><a href="#1559-二维网格图中探测环" class="headerlink" title="1559. 二维网格图中探测环"></a><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">1559. 二维网格图中探测环</a></h4><p>给你一个二维字符网格数组 <code>grid</code> ，大小为 <code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 <strong>相同值</strong> 形成的环。</p><p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值</strong> 。</p><p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> 是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p><p>如果 <code>grid</code> 中有相同值形成的环，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="\img\5482e1.png" alt="img"></p><pre><code class="hljs smalltalk">输入：grid = [[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>]]输出：<span class="hljs-keyword">true</span>解释：如下图所示，有 <span class="hljs-number">2</span> 个用不同颜色标出来的环：</code></pre><p><img src="\img\5482e11.png" alt="img"> </p><hr><p>利用并查集的思想，相同的字母可以形成一个连通区域，从左上角开始，遇到相同字母则进行合并，合并时若发现$x$和$y$与$parent$相同，即形成环。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">250100</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> p[N];    <span class="hljs-keyword">int</span> cnt[N];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (p[x] != x) &#123;            x = find(p[x]);        &#125;        <span class="hljs-keyword">return</span> p[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;            cnt[find(b)] += cnt[find(a)];            p[find(a)] = find(b);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;            p[i] = i;            cnt[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsCycle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = grid.size();        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].size();        init();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>&lt; n &amp;&amp; grid[i][j] == grid[i + <span class="hljs-number">1</span>][j]) &#123;                    <span class="hljs-keyword">if</span> (find(i * m + j) == find((i + <span class="hljs-number">1</span>) * m + j)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        p[find(i * m + j)] = find((i + <span class="hljs-number">1</span>) * m + j);                    &#125;                &#125;                <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i][j] == grid[i][j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">if</span> (find(i * m + j) == find(i * m + j + <span class="hljs-number">1</span>)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        p[find(i * m + j)] = find(i * m + j + <span class="hljs-number">1</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h2 id="685-冗余连接II"><a href="#685-冗余连接II" class="headerlink" title="685. 冗余连接II"></a>685. 冗余连接II</h2><p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N-1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</p><p>树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：</p><ul><li><p>附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；</p></li><li><p>附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。</p></li></ul><blockquote><p><code>parent</code>用于保存上一个指向它的节点，仅此而已。</p></blockquote><p>在遍历图中的所有边之后，根据是否存在导致冲突的边和导致环路出现的边，得到附加的边。</p><ul><li><p>如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。</p></li><li><p>如果有导致冲突的边，记这条边为 $[u,v]$，则有两条边指向 v，另一条边为 $[\textit{parent}[v],v]$需要通过判断是否有导致环路的边决定哪条边是附加的边。</p></li><li><p>如果有导致环路的边，则附加的边不可能是 $[u,v]$（因为 $[u,v] $已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 $[\textit{parent}[v],v]$。</p></li><li><p>如果没有导致环路的边，则附加的边是后被访问到的指向 v 的边，因此附加的边是 $[u,v]$。</p></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;    <span class="hljs-keyword">int</span> conflict;<span class="hljs-comment">//记录具有多个父节点的边编号</span>    <span class="hljs-keyword">int</span> loop;<span class="hljs-comment">//记录生成环路的边编号</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            fa.emplace_back(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>( x == fa[x])        &#123;            <span class="hljs-keyword">return</span> x;        &#125;        fa[x] = find(fa[x]);        <span class="hljs-keyword">return</span> fa[x];    &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;        <span class="hljs-comment">//思路：并查集</span>        <span class="hljs-comment">//此题与全连接I的区别是，无向图变为有向图</span>        <span class="hljs-keyword">int</span> n = edges.size();        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//专门用于保存父节点，与并查集无关</span>        init(n+<span class="hljs-number">1</span>);        conflict = loop = <span class="hljs-number">-1</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;<span class="hljs-comment">//u -&gt; v</span>            <span class="hljs-keyword">int</span> u = edges[i][<span class="hljs-number">0</span>], v = edges[i][<span class="hljs-number">1</span>];             <span class="hljs-keyword">int</span> pu = find(u), pv = find(v);                        <span class="hljs-keyword">if</span>(pv!=v) <span class="hljs-comment">// 说明 e[1]已经有父节点，存在冲突</span>                conflict = i;            <span class="hljs-keyword">else</span>             &#123;                parent[v] = u;                <span class="hljs-keyword">if</span>(pv == pu)<span class="hljs-comment">//表示有环</span>                &#123;                    loop = i;                &#125;                <span class="hljs-keyword">else</span> fa[pv] = pu;                        &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conf:%d,loop:%d\n&quot;</span>,conflict,loop);        <span class="hljs-comment">//接下来需要判断哪个边导致了冗余</span>        <span class="hljs-keyword">if</span>(conflict&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//说明没有冲突，附加的边为环路最后出现的边</span>        &#123;            <span class="hljs-keyword">return</span> edges[loop];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若存在冲突，</span>        &#123;            <span class="hljs-keyword">if</span>(loop &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//没有环</span>            <span class="hljs-keyword">return</span> edges[conflict];            <span class="hljs-keyword">else</span> <span class="hljs-comment">//既有冲突也有环，则不可能是冲突的那一条边</span>            <span class="hljs-keyword">return</span> &#123;parent[edges[conflict][<span class="hljs-number">1</span>]],edges[conflict][<span class="hljs-number">1</span>]&#125;;        &#125;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;    &#125;&#125;;</code></pre><p>时间复杂度: $O(N \log N)$</p><p>空间复杂度：$O(N)$</p><hr><h2 id="952-按公因式计算最大组件的大小"><a href="#952-按公因式计算最大组件的大小" class="headerlink" title="952.按公因式计算最大组件的大小"></a>952.按公因式计算最大组件的大小</h2><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：</p><p>有 <code>A.length</code> 个节点，按从 <code>A[0]</code>到 <code>A[A.length - 1]</code> 标记；<br>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j]</code>之间才有一条边。<br>返回图中最大连通组件的大小。</p><p>示例 1：</p><p>输入：[4,6,15,35]<br>输出：4</p><p><img src="\img\ex1.png" alt="img" style="zoom:33%;" /></p><p>示例 2：</p><p>输入：[20,50,9,63]<br>输出：2</p><p><img src="\img\ex2.png" alt="img" style="zoom:33%;" /></p><p>示例 3：</p><p>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p><p><img src="\img\ex3.png" alt="img" style="zoom:33%;" /></p><p>提示：</p><p><code>1 &lt;= A.length &lt;= 200001 &lt;= A[i] &lt;= 100000</code></p><hr><p>按照并查集的思路求解</p><p>设$W = max(A[i]), R = \sqrt{W}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+A.length$个不同的质因数。质因数为本身的最多$A.length$个，非本身的质因数一定比$R$小，最多$R$个。</p><p>我们可以提取$A$中每个数的质因数，对每个质因数建立索引，然后利用并查集。</p><p><img src="\img\dsu_4.png" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;    <span class="hljs-keyword">int</span> res;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            fa.emplace_back(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//路径压缩</span>        <span class="hljs-keyword">while</span>(x != fa[x])        &#123;            fa[x] = fa[fa[x]];            x = fa[x];        &#125;        <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> x = find(i), y = find(j);        fa[x] = y;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestComponentSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = A.size();    <span class="hljs-comment">//这题是并查集的经典应用</span>    <span class="hljs-comment">//因为A的长度很大，不能采用双重循环遍历</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; factor[n];<span class="hljs-comment">//质因数索引</span>    <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a :A) maxVal = max(maxVal,a);    init(maxVal+<span class="hljs-number">1</span>);    res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:A)    &#123;        <span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)        <span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>)         &#123;            merge(a,i);            merge(a,a/i);        &#125;    &#125;    <span class="hljs-comment">//将A中的数映射为代表元,看那一些出现过</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(maxVal+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)    &#123;        cnt [find(A[i])]++;        res = max(res, cnt [find(A[i])]);    &#125;    <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p>时间复杂度：$O(N \sqrt{W})$，其中 $N$ 是 A 的长度，$W = \max(A[i])$。</p><p>空间复杂度： $O(M)$, 分别用了$fa$和$cnt$数组，$M$表示数组最大值。</p><hr><h2 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a>765. 情侣牵手</h2><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p><p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]输出: <span class="hljs-number">1</span>解释: 我们只需要交换row[<span class="hljs-number">1</span>]和row[<span class="hljs-number">2</span>]的位置即可。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]输出: <span class="hljs-number">0</span>解释: 无需交换座位，所有的情侣都已经可以手牵手了。</code></pre><p><strong>说明:</strong></p><ol><li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li><li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li></ol><hr><ol><li><strong>贪心解法</strong></li></ol><p>我们考虑每队情侣都由奇数编号和偶数编号组成，因为情侣数量有限，我们可以遍历所有情侣中编号为偶数的<code>1,2,4,6...2*N</code>， 对相应的奇数情侣交换，每交换一次则<code>res++</code>。具体地，如果偶数情侣位于偶数位置$i$，则奇数情侣位置一定是$i+1$, 否则，奇数情侣位置为$i-1$。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span>  Map&lt;Integer,Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="hljs-comment">//记录数字的位置</span>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> direct)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> temp, temp2;        temp = memo.get(i+<span class="hljs-number">1</span>);        memo.put(row[memo.get(i)+direct],temp);        memo.put(i+<span class="hljs-number">1</span>,memo.get(i)+direct);        temp2 = row[temp];        row[temp] = row[memo.get(i)+direct] ;        row[memo.get(i)+direct] = temp2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = row.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) memo.put(row[i],i);        <span class="hljs-comment">//我们只移动奇数，如果偶数位置是偶数，那么相邻奇数位置在右边，否则在左边</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i += <span class="hljs-number">2</span>)        &#123;            <span class="hljs-keyword">if</span>(memo.get(i) %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                swap(row,i,<span class="hljs-number">1</span>);                res ++;            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)-<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                swap(row,i,-<span class="hljs-number">1</span>);                res ++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><strong>时间复杂度</strong>:$O(N)$.</p><p>空间复杂度:$O(N)$,使用了一个长度为$N$哈希表。</p><ol><li><strong>并查集</strong></li></ol><p>我们重点放在并查集解法上。</p><p>我们设想一下加入有两对情侣互相坐错了位置，我们至多只需要换一次。<br>如果3对情侣相互坐错了位置，$A1+B2,B1+C2,C1+A2$。他们三个之间形成了一个连通图，我们只需要交换两次。<br>如果4对情侣相互坐错了位置，即这4对情侣不与其他情侣坐在一起，$A1+B2,B1+C2,C1+D2,D1+A2$.他们四个之间形成了一个连通图，他们只需要交换三次并且不用和其他情侣交换，就可以将这四对情侣交换好，<br>以此类推，其实就是假设k对情侣形成一个环状的错误链，我们<strong>最少</strong>需要交换k - 1次就可以将这k对情侣的位置排好。</p><blockquote><p>所以问题转化成$N$对情侣中，有几个这样的错误环。我们可以使用并查集来处理，每次遍历相邻的两个位置，如果他们本来就是情侣，他们处于大小为1的错误环中，只需要交换0次。如果不是情侣，说明他们两对处在同一个错误环中，我们将他们合并（union），将所有的错坐情侣合并和后，答案就是情侣对 - 环个数。<br>这也说明，最差的情况就是所有N对情侣都在一个环中，这时候我们需要$N - 1$调换。<br>最好情况每对情侣已经坐好了，已经有N个大小为1的环，这时候我们需要$N - N$次调换。</p></blockquote><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa,rank;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(x != fa[x]) fa[x] = getfa(fa[x]);        <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> fx = getfa(x),fy = getfa(y);        <span class="hljs-keyword">if</span>(fx != fy)        &#123;            <span class="hljs-keyword">if</span>(rank[fx] &lt; rank[fy])            &#123;                fa[fx] = fy;                rank[fy] += rank[fx];            &#125;<span class="hljs-keyword">else</span>            &#123;                fa[fy] = fx;                rank[fx] += rank[fy];            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; row)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = row.size(),m = n / <span class="hljs-number">2</span>,res = <span class="hljs-number">0</span>,circle = <span class="hljs-number">0</span>;        fa = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>),rank = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++) fa[i] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i += <span class="hljs-number">2</span>)            uni(row[i] / <span class="hljs-number">2</span>,row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>);<span class="hljs-comment">//本来是情侣的话，两者肯定相等，不会合并</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i ++)            <span class="hljs-keyword">if</span>(i == getfa(i))                circle ++;        <span class="hljs-keyword">return</span> m - circle;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习I 基本概念</title>
    <link href="/2020/08/04/2020-05-10-ML1/"/>
    <url>/2020/08/04/2020-05-10-ML1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学完算法，还想更深入一步，那么接触一下机器学习，是很有必要的，你需要知道当下为什么ML这么火，包括自动驾驶，人脸识别等都与之相关。有些甚至基本算法理论无法解释。</p><p>参考周志华《机器学习》</p></blockquote><p><strong>任务：</strong></p><p><strong>分类</strong>（classification）: 预测离散值。</p><p><strong>回归</strong>（regression）:预测连续值。</p><p>一般地，我们对训练集${(x_1,y_1),···,(x_m,y_m)}$进行学习，建立一个从输入空间$\chi$到输出空间$\Upsilon$的映射，对于二分类任务，通常$\Upsilon=\{-1,+1\}或\{0,1\}$；对于多分类任务，$|\Upsilon|&gt;2$,对于回归任务，$\Upsilon=\R,\R$为实数集。</p><p>学习完之后需要进行预测（testing）。</p><p>我们还可以进行<strong>聚类</strong>（clustering）操作，将训练集中数据分成若干组，每组称为一个<strong>簇</strong>（cluster），这些自动形成的簇可能对应一些潜在的概念划分。</p><p>根据训练数据是否有标记，学习任务可以大致分为两类：“<strong>监督学习</strong>”（supervised learning）和 “<strong>无监督学习</strong>”（unsupervised learning），分类和回归属于前者，而聚类属于后者。</p><p><strong>泛化</strong>（generalization），指模型适应新样本的能力。我们可以把学习过程看作是在<code>所有假设</code>（hypothesis）组成的空间中进行搜索的过程，搜索目标是找到与训练集“匹配”的假设。</p><p>书中介绍了NFL定理，即“天下没有免费午餐的定理”。不同的学习算法期望相同。</p><p>最后让我们一睹顶会的风采。</p><p>$ICML$：国际机器学习会议；</p><p>$NIPS$：国际神经信息处理系统会议；</p><p>$COLT$：国际学习理论会议；</p><p>$ECML$：欧洲机器学习会议；</p><p>$ACML$：亚洲机器学习会议；</p><p>然后是<em>顶级</em>期刊：</p><p>$JMLR$: Journal of Machine Learning Research;</p><p>$ML$: Machine Learning;</p><p>$IJCAI$:International Joint Conference on Artificial Intelligence</p><p>$AAAI$：（就是这么AI） Association for the Advance of Artificial Intelligence</p><p>$AI$，$JAIR$,$KDD$,$ICDM$,$CVPR$,以及IEEE一些期刊。</p><blockquote><p>如果能投给一篇，cs人生也算圆满了</p></blockquote><p>第二章：模型评估与选择。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念和公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习II 模型评估与选择</title>
    <link href="/2020/08/04/2020-08-4-ML2/"/>
    <url>/2020/08/04/2020-08-4-ML2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-经验误差与过拟合"><a href="#1-经验误差与过拟合" class="headerlink" title="1. 经验误差与过拟合"></a>1. 经验误差与过拟合</h2><p>学习在训练集上的误差称为“训练误差”，而在新样本上误差称为“泛化误差”。</p><p>实际上，我们通常得不到泛化性能很好的模型，原有有两种：</p><ul><li><strong>过拟合</strong>（overfitting）: 学习能力过于优秀，学到一些非一般的特性。</li><li><strong>欠拟合</strong>（underfitting）：对训练样本的一般性质尚未学好。</li></ul><p>机器学习面临的问题一般是$NP$难问题(<a href="https://blog.csdn.net/qq_21768483/article/details/80430590">什么是NP</a>)，因此只要相信$NP\ne P$那么过拟合将无法避免。</p><p>下面简单介绍从训练集得到测试集的方法：</p><ol><li><strong>留出法</strong>，按照比例从原始数据集分出训练和测试集；</li><li><strong>交叉验证</strong>（cross validation） ：先将数据集$D$划分为$k$个大小相似的互斥子集，即$D=D_1\cup D_2 \cup ···\cup D_j , D_i \cup D_j\ne \oslash$,每个子集$D_i$都尽可能保持数据分布的一致性，即从$D$中通过分层采样得到，然后每次用$k-1$给子集的并集作为训练集，余下的那个子集作为测试集；这样就可以得到$k$组训练/测试集。</li><li><strong>自助法</strong>（bootstrapping）减少训练集规模不同造成的误差。给定包含$m$个样本的数据集$D$，我们对它采样，产生数据集$D’$：每次随机从$D$中挑选一个样本，将其拷贝放入$D’$，然后再将该样本放回初始数据集$D$，这个过程重复$m$次后，我们得到大小为$m$的数据集$D’$，通过自助采样，约有$36.8\%$的样本未出现在采样数据集中，于是我能将$D’$用作训练集，而$D/D’$作为测试集，这适合数据小，难以划分的场景。</li></ol><h2 id="2-调参与最终模型"><a href="#2-调参与最终模型" class="headerlink" title="2. 调参与最终模型"></a>2. 调参与最终模型</h2><p>我们常把学得模型在实际使用中遇到的数据称为<strong>测试数据</strong>。</p><p>模型评估与选择中的数据集称为<strong>验证集</strong>。</p><ul><li><strong>性能度量</strong></li></ul><p>回归任务，最常使用的是均方误差（Mean Squared Error, MSE）.</p><pre><code>                                                             $ E(f;D)=\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;(f(x_i)-y_i)^2$</code></pre><ul><li><strong>错误率与精度</strong></li></ul><p>错误率是分类错误的样本数占样本总数的比例，精度$acc$则是正确的样本数占样本总数的比例。</p><blockquote><p>术语: FP:真正例 FN:假反例 FP:假正例 TN:真反例</p></blockquote><p>查准率$P=\frac{TP}{TP+FP}$，查全率：$R =\frac{TP}{TP+FN}$.</p><p>一般我们采用P-R图像来评价机器学习模型的优劣。若一个曲线包住另一个曲线，则证明前者性能好于后者。“平衡点”（BEP）就是查准率等于查全率的点。</p><p>更常用的是$F1$度量（调和平均）：$F1=\frac{2×P×R}{P+R}$，其原型是加权调和平均$F_\beta=\frac{(1+\beta^2)×P×R}{\beta^2×P+R}$,$\beta$度量了查全率对查准率的相对重要性。为了更好描述不同错误造成影响的大小，我们引入代价敏感 ，$cost_{01}$表示$TN$的代价,$cost_{10}$表示$FP$的代价。正例代价。</p><script type="math/tex; mode=display">P(+)=\frac{p×cost_{01}}{p×cost_{01}+(1-p)×cost_{10}}</script><p>泛化错误率为$\epsilon$,而测试错误率$\hat{\epsilon}$意味着在$m$给测试样本中恰有$\hat{\epsilon}×m$个错误数据。</p><ul><li><p><strong>比较检验</strong></p><ul><li>假设检验</li></ul><p>我们在实际任务中不知道学习器的泛化错误率，但是可以根据测试错误率推出泛化错误率的分布。泛化错误率为$\epsilon$，测试错误率$\hat{\epsilon}$，对于m个测试样本，根据概率论知识，我们知道 学习器测得测试错误率为$\hat{\epsilon}$的概率是</p><script type="math/tex; mode=display">P(\hat{\epsilon};\epsilon)=\binom{m}{\hat{\epsilon}×m}\epsilon^{\hat{\epsilon}×m}(1-\epsilon)^{\hat{\epsilon}(1-m)}</script><p>对$P$求导可知，在$\epsilon=\hat{\epsilon}$时最大，符合二项分布。</p><p><img src="\img\t_test.jpg" alt="n=6、p=0.5时的二项分布及正态近似"></p></li></ul><p>我们可使用“二项检验”($binomial  test$)来对 “$\epsilon\lt \epsilon_0$”进行检验，则在$1-\alpha$（置信度$confidence$）的概率内所能观测到的最大错误概率。若测试错误率$\hat{\epsilon}&lt;{\epsilon}$,即能以$1-\alpha$的置信度认为，学习器错误率不大于$\epsilon_0$</p><ul><li>t 检验</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念和公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抛砖引玉析回溯</title>
    <link href="/2020/08/02/2020-8-2-trackback-demo/"/>
    <url>/2020/08/02/2020-8-2-trackback-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析回溯法"><a href="#浅析回溯法" class="headerlink" title="浅析回溯法"></a>浅析回溯法</h1><blockquote><p>想必大家都玩过一些智力游戏，比如解数独，华容道，魔方，甚至围棋这些。 让我们用计算机去解决这些问题，并且使得时间尽可能短，一种可能的方法是<strong>回溯法</strong>，现在已经有用机器学习中的对抗学习(GAN)以及强化学习(RL)，著名的有AlphaGo以及OpenAI,后者甚至可以在最难的MOBA类游戏战胜人类。</p><p><strong>推荐阅读</strong>Liweiwei1419大佬的「<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级讲解</a>」</p></blockquote><ul><li><ol><li><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a></p></li><li><p><a href="https://leetcode-cn.com/problems/24-game/">24点游戏</a></p></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/n-queens/">N皇后</a></li></ol></li><li><ol><li><a href="">扫雷游戏</a></li></ol></li><li><ol><li><a href="">祖玛游戏</a></li></ol></li></ul><h2 id="679-24点游戏"><a href="#679-24点游戏" class="headerlink" title="679. 24点游戏"></a>679. 24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]输出: True解释: (<span class="hljs-number">8</span><span class="hljs-number">-4</span>) * (<span class="hljs-number">7</span><span class="hljs-number">-1</span>) = <span class="hljs-number">24</span></code></pre><p>示例 2:</p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<span class="hljs-string">输出:</span> <span class="hljs-literal">False</span></code></pre><p>注意:</p><p>`1. 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</p><ol><li>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</li></ol><hr><p>1<strong>.暴力法</strong></p><p>思路：因为此题规模不大，可以采用暴力法，我们先把4个数每一种排列考虑到，然后把每一种计算顺序考虑一下（最多三次运算），括号有两种情况，一个是<code>a*(b-(c/d))</code>，另一种是<code>(a+b)\*(c+d)</code>这里是举例子。最后是精度问题保证<code>|res-24.0|&lt;1e-5</code>即可。</p><p><strong>回溯法</strong></p><p>一共有四个数，三种操作。首先从四个数有序的选出两个数，有$4×3=12$种方法，并选择加减乘除不同的，用得到的结果取代选出的两个数字。</p><p>在剩下3个数有序选择2个数字，有6种方法，并选择四种运算符之一。</p><p>最后剩下2个数字，有两种不同的顺序，并选择4种运算操作之一。因此共有$12×4×6×4×2×4=9216$种选法。</p><p>实现时，有一些细节需要注意：</p><ul><li><p>除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 2424 时应考虑精度误差，这道题中，误差小于 $10^{-6}$  可以认为是相等。</p></li><li><p>进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 0 时应考虑精度误差，这道题中，当一个数字的绝对值小于 $10^{-6}$  时，可以认为该数字等于 0。</p></li></ul><p>还有一个可以优化的点。</p><p>加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 22 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> TARGET = <span class="hljs-number">24</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> EPSILON = <span class="hljs-number">1e-6</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> ADD = <span class="hljs-number">0</span>, MULTIPLY = <span class="hljs-number">1</span>, SUBTRACT = <span class="hljs-number">2</span>, DIVIDE = <span class="hljs-number">3</span>;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgePoint24</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; l;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;num : nums) &#123;            l.emplace_back(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(num));<span class="hljs-comment">//转为double</span>        &#125;        <span class="hljs-keyword">return</span> solve(l);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; &amp;l)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l.size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (l.size() == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(l[<span class="hljs-number">0</span>] - TARGET) &lt; EPSILON;        &#125;        <span class="hljs-keyword">int</span> size = l.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;                <span class="hljs-keyword">if</span> (i != j) &#123;                    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; list2 = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; size; k++) &#123;                        <span class="hljs-keyword">if</span> (k != i &amp;&amp; k != j) &#123;                            list2.emplace_back(l[k]);                        &#125;                    &#125;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;                        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span> &amp;&amp; i &gt; j) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        <span class="hljs-keyword">if</span> (k == ADD) &#123;                            list2.emplace_back(l[i] + l[j]);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == MULTIPLY) &#123;                            list2.emplace_back(l[i] * l[j]);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == SUBTRACT) &#123;                            list2.emplace_back(l[i] - l[j]);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == DIVIDE) &#123;                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(l[j]) &lt; EPSILON) &#123;                                <span class="hljs-keyword">continue</span>;                            &#125;                            list2.emplace_back(l[i] / l[j]);                        &#125;                        <span class="hljs-keyword">if</span> (solve(list2)) &#123;                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                        &#125;                        list2.pop_back();                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。一共有 $9216$ 种可能性，对于每种可能性，各项操作的时间复杂度都是 $O(1)$，因此总时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(1)$。空间复杂度取决于递归调用层数与存储中间状态的列表，因为一共有 $4$ 个数，所以递归调用的层数最多为 $4$，存储中间状态的列表最多包含 $4$个元素，因此空间复杂度为常数。</li></ul><hr><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><p><code>数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</code></p><p>空白格用 ‘.’ 表示。</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>一个数独。</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p><p>答案被标成红色。</p><p>Note:</p><ol><li>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 9x9 形式的。</li></ol><hr><ol><li><strong>DFS+回溯</strong></li></ol><p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用$ \textit{line}[i]$，$\textit{column}[j]$，$\textit{block}[x][y]分别$表示第 $i$ 行，第 $j$ 列，第 $(x, y)$ 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p><blockquote><p>九宫格内坐标范围：$0\le x\le2,0 \le y \le 2$.具体的 第 $i$行第$j$列的数字，属于第$\lfloor \frac{i}{3},\frac{j}{3} \rfloor$个九宫格。$\lfloor$表示向下取整。</p></blockquote><p>我们首先对整个数独数组进行遍历，当我们遍历到第$i$行，第$j$个位置：</p><ul><li>如果该位置是一个空白格，那么我们将其加入一个用于存储空白格的列表中，方便后续进行递归。</li><li>如果该位置是一个数字，我们将$line$，$column$,$block$相应位置分别置为$True$。</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">private</span> boolean[][] line = <span class="hljs-keyword">new</span> boolean [<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//行号和具体数字</span>    <span class="hljs-keyword">private</span> boolean[][] column = <span class="hljs-keyword">new</span> boolean [<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//列号和具体数字</span>    <span class="hljs-keyword">private</span> boolean[][] block = <span class="hljs-keyword">new</span> boolean [<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//第几个方块（3*x/3+y/3），具体数字</span>    <span class="hljs-keyword">private</span> boolean succ = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否成功填完</span>    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<span class="hljs-comment">//用于表示空格</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;        <span class="hljs-keyword">if</span>(pos == spaces.size())        &#123;            succ = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> x = spaces.get(pos)[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = spaces.get(pos)[<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;n &lt; <span class="hljs-number">9</span> ;  n++ )            <span class="hljs-keyword">if</span>(!line[x][n]&amp;&amp;!column[y][n]&amp;&amp;!block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>][n]) &#123;                board[x][y] = (<span class="hljs-keyword">char</span>)(n + <span class="hljs-string">&#x27;1&#x27;</span>);                line[x][n] = column[y][n] = block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>][n] = <span class="hljs-literal">true</span>;                backtrack(board, pos+<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(succ) <span class="hljs-keyword">return</span>;                line[x][n] = column[y][n] = block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>][n] = <span class="hljs-literal">false</span>;            &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">//遍历棋盘，如果遇到&#x27;.&#x27;则按照1-9填充，直到下一个数字无法被填充为止，进行回溯</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">9</span>;j++)                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)                &#123;                    line[i][(<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>)] = column[j][(<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>)]                            = block[i/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j/<span class="hljs-number">3</span>][(<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>)] = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">else</span>                  spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<span class="hljs-comment">//遇到&#x27;.&#x27;则将其坐标加入空格数组</span>        backtrack(board,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// public static void main(String args[])</span>    <span class="hljs-comment">// &#123;</span>    <span class="hljs-comment">//     char[][] board =&#123;&#123;&#x27;5&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;4&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;8&#x27;,&#x27;5&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;2&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;3&#x27;,&#x27;.&#x27;,&#x27;8&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;7&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;9&#x27;,&#x27;.&#x27;,&#x27;1&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;9&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;4&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;7&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;9&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;6&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;3&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;4&#x27;,&#x27;8&#x27;,&#x27;6&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;&#125;;</span>    <span class="hljs-comment">//     Solution s = new Solution();</span>    <span class="hljs-comment">//     s.solveSudoku(board);</span>    <span class="hljs-comment">// &#125;</span>&#125;</code></pre><p><strong>2. 位运算</strong></p><p>我们使用长度为9的数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一个整数表示每个数字是否出现过。</p><p>具体地，数$b$ 的二进制表示的第$i$位（从低到高，最低位为第$0$位），当且仅当数字$i+1$已经出现过。例如当 b 的二进制表示为 $(011000100)_2$ 时，就表示数字 3，7，8 已经出现过。</p><p>位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：</p><ul><li><p>对于第$i$行第$j$列的位置，$line[i]|column[j]|block[i/3*3+j/3]$中第$k$位为1，表示该位置不能填入数字$k+1$.我们先与上$(11111111)_2=(1FF)_{16}$消除高位的影响，然后对其取反，然后枚举。因为是需要9个bit状态，所以是左移九位。</p></li><li><p>我们可以使用按位异或运算$ \wedge$, 与 $1&lt;&lt;i$异或即可。</p></li><li><p>我们可以用 $b \&amp; (−b) $得到 b 二进制表示中最低位的 1，这是因为 $(−b)$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 如果和 $∼b$ 进行按位与运算，那么会得到 0，但是当 $\sim b$ 增加 1 之后，最低位的连续的 1 都变为 0，而最低位的 0 变为 1，对应到 $b$ 中即为最低位的 1，因此当 $b$ 和 $∼b+1$ 进行按位与运算时，只有最低位的 1 会被保留；</p></li><li><p>我们可以用$b$与最低位的1按位异或，就可以将其从$b$中去除，这样就可以枚举下一个1。同样的，我们可以用$b\&amp;(b-1)$达到同样的效果，这被称为<strong>Brian kernighan算法</strong>。</p><p>​    </p></li></ul><p><strong>代码</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] line = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<span class="hljs-comment">//存放二进制</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] column = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<span class="hljs-comment">//列号和具体数字</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] block = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<span class="hljs-comment">//第几个方块（3*x/3+y/3），具体数字</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> succ = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否成功填完</span>    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<span class="hljs-comment">//用于表示空格</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;        <span class="hljs-keyword">if</span>(pos == spaces.size())        &#123;            succ = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> x = spaces.get(pos)[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = spaces.get(pos)[<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> mask = ~(line[x]|column[y]|block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>])&amp;<span class="hljs-number">0x1ff</span>;        <span class="hljs-keyword">for</span>(;mask != <span class="hljs-number">0</span>; mask&amp;=(mask-<span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">//遍历每个1</span>            <span class="hljs-keyword">int</span> digit = mask&amp;(-mask);<span class="hljs-comment">//表示最低位的1</span>            <span class="hljs-keyword">int</span> shift = Integer.bitCount(digit-<span class="hljs-number">1</span>);<span class="hljs-comment">//比如 digit = 4 是2的2次方 (4-1).bitcount =  3, 3-1 = 2</span>            board[x][y] = (<span class="hljs-keyword">char</span>) (shift + <span class="hljs-string">&#x27;1&#x27;</span>);            flip(x, y, shift);<span class="hljs-comment">//翻转</span>            backtrack(board, pos + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (succ) <span class="hljs-keyword">return</span>;            flip(x, y, shift);<span class="hljs-comment">//翻转恢复</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">//遍历棋盘，如果遇到&#x27;.&#x27;则按照1-9填充，直到下一个数字无法被填充为止，进行回溯</span><span class="hljs-comment">//    List&lt;List&lt;Integer&gt;&gt; a = new ArrayList&lt;&gt;();</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">9</span>;j++)                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)                &#123;                    <span class="hljs-keyword">int</span> shift = (<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>);                    flip(i,j,shift);                &#125;                <span class="hljs-keyword">else</span>                  spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<span class="hljs-comment">//遇到&#x27;.&#x27;则将其坐标加入空格数组</span>        backtrack(board,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> shift)</span></span><span class="hljs-function">    </span>&#123;        line[i] ^= (<span class="hljs-number">1</span>&lt;&lt;shift);        column[j] ^= (<span class="hljs-number">1</span>&lt;&lt;shift);        block[i/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j/<span class="hljs-number">3</span>] ^= (<span class="hljs-number">1</span>&lt;&lt;shift);    &#125;&#125;</code></pre><hr><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><pre><code class="hljs awk">输入：<span class="hljs-number">4</span>输出：[ [<span class="hljs-string">&quot;.Q..&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">1</span>  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;..Q.&quot;</span>], [<span class="hljs-string">&quot;..Q.&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">2</span>  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;.Q..&quot;</span>]]解释: <span class="hljs-number">4</span> 皇后问题存在两个不同的解法。</code></pre><p>提示：</p><p>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</p><hr><p>学会使用编码，使访问指定元素的时间复杂度为$O(1)$</p><p><strong>方法一：基于集合的回溯</strong><br>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合$ columns、diagonals_1 $ 和 $\textit{diagonals}_2$ 分别记录每一列以及两个方向的每条斜线上是否有皇后。</p><p>列的表示法很直观，一共有 N 列，每一列的下标范围从 0 到 N-1，使用列的下标即可明确表示每一列。</p><p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/1.png" alt="fig1"></p><p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足行下标与列下标之差相等，例如 (0,0)和 (3,3)在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/2.png" alt="fig2"></p><p>方向二的斜线为从右上到左下方向，同一条斜线上的每个位置满足行下标与列下标之和相等，例如 (3,0) 和 (1,2) 在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条方向二的斜线。</p><p>每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; col_group, diag1, diag2;<span class="hljs-comment">//列，以及两条斜线，diag1表示(y-x)，而diag2表示(x+y)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(i==n) res.emplace_back(board);        <span class="hljs-comment">//将斜线上元素加入不可访问列表</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; n;y++)        <span class="hljs-keyword">if</span> (!col_group.count(y)&amp;&amp;!diag1.count(y-row)&amp;&amp;!diag2.count(row+y))        &#123;            board[row][y] = <span class="hljs-string">&#x27;Q&#x27;</span>;            col_group.insert(y);            diag1.insert(y-row);            diag2.insert(y+row);            backtrack(board,row+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>);            board[row][y] = <span class="hljs-string">&#x27;.&#x27;</span>;            col_group.erase(y);            diag1.erase(y-row);            diag2.erase(y+row);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">solveNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;       <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> &#123;&#123;<span class="hljs-string">&quot;Q&quot;</span>&#125;&#125;;       <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> &#123;&#125;;       <span class="hljs-keyword">this</span>-&gt;n = n;       <span class="hljs-comment">//基本思路，回溯法</span>       <span class="hljs-comment">//我们依次安排N个皇后的位置</span>       <span class="hljs-comment">//如果不满足题意则回溯</span>       <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">board</span><span class="hljs-params">(n,<span class="hljs-built_in">string</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;       backtrack(board,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);       <span class="hljs-keyword">return</span> res;     &#125;&#125;;</code></pre><hr><p>Bibliography</p><blockquote><ol><li><p><a href="https://deepmind.com/research/case-studies/alphago-the-story-so-far">https://deepmind.com/research/case-studies/alphago-the-story-so-far</a></p></li><li><p><a href="https://baike.baidu.com/item/阿尔法围棋/19319610?fromtitle=AlphaGo&amp;fromid=19315265&amp;fr=aladdin">AlphaGo百度百科</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解空间极大问题通用策略</title>
    <link href="/2020/08/01/2020-8-1-common-way-solve-big-problem/"/>
    <url>/2020/08/01/2020-8-1-common-way-solve-big-problem/</url>
    
    <content type="html"><![CDATA[<h1 id="解空间极大问题通用策略"><a href="#解空间极大问题通用策略" class="headerlink" title="解空间极大问题通用策略"></a>解空间极大问题通用策略</h1><hr><ul><li><ol><li>子集</li></ol></li><li><ol><li>第k个排列</li></ol></li><li><ol><li>每个元音包含偶数次的最长子字符串</li></ol></li><li><ol><li>全排列</li></ol></li><li><ol><li>全排列2</li></ol></li><li><ol><li>子集2</li></ol></li><li><ol><li>递增子序列</li></ol></li><li><ol><li>删除无效括号</li></ol></li><li><ol><li>组合</li></ol></li><li><ol><li>组合总和II</li></ol></li><li>216.组合总和III</li></ul><blockquote><p>通常来说这类问题的解规模较大，很容易漏掉解，为此笔者提出一种解决问题的思路。</p></blockquote><p>比如全排列问题，组合问题等。让我们以78.<a href="https://leetcode-cn.com/problems/subsets/">子集</a>为例引入到情景中。</p><ul><li>全排列  $N!$</li><li>组合 $N!$</li><li>子集 $2^N$，每个元素可能存在或者不存在</li></ul><p>要确保结果<strong>完整</strong>且不<strong>重复</strong>，有多种策略：</p><ol><li><strong>递归</strong></li><li><strong>回溯</strong></li><li><strong>字典</strong></li><li><strong>数学</strong></li><li><strong>状态压缩</strong></li><li><strong>【补充】剪枝技巧</strong></li></ol><h2 id="I-递归"><a href="#I-递归" class="headerlink" title="I. 递归"></a>I. 递归</h2><p>递归不一定是递归函数，而是逐层次的把nums下一个数与前面的数融合起来。</p><p>比如：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvcmVjdXJzaW9uLnBuZw?x-oss-process=image/format,png" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;    res.push_back(&#123;&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)    &#123;        <span class="hljs-keyword">auto</span> _res = res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;k :_res)        &#123;            k.push_back(c);            res.push_back(k);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p><strong>剪枝及技巧</strong></p><p>很多时候dfs会经历不需要的中间状态，因此需要设计代码，避免不必要的递归。</p><p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p><p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p><p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p><h2 id="II-回溯"><a href="#II-回溯" class="headerlink" title="II. 回溯"></a>II. 回溯</h2><blockquote><p>注意：在大规模问题上，回溯法<strong>极容易</strong>超时。</p><p>正例：<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301.删除无效括号</a>(Hard)</p><p>反例：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>(Medium)(正确的解法是动态规划，而不是回溯)</p><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a href="https://baike.baidu.com/item/条件/1783021">条件</a>的某个<a href="https://baike.baidu.com/item/状态/33204">状态</a>的点称为“回溯点”。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvY29tYmluYXRpb25zLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>以该题为例，比如我们要在<code>[1,2,3]</code>中找到所有子集，思路是这样的：</p><p>定义一个回溯方法 backtrack(first, curr)，第一个参数为索引 first，第二个参数为当前子集 curr。</p><ul><li><p>如果当前子集构造完成，将它添加到输出集合中。</p></li><li><p>否则，从 first 到 n 遍历索引 i。</p><ul><li>将整数 nums[i] 添加到当前子集 curr。</li><li>继续向子集中添加整数：backtrack(i + 1, curr)。</li><li>从 curr 中删除 nums[i] 进行回溯。</li></ul></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvYmFja3RyYWNraW5nLnBuZw?x-oss-process=image/format,png" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;curr)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(first&gt;=n) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt; n; i++)        &#123;            curr.push_back(nums[i]);            res.push_back(curr);            backtrack(i+<span class="hljs-number">1</span>, curr);            curr.pop_back();        &#125;            &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//回溯法</span>                <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;        <span class="hljs-keyword">this</span>-&gt;n = nums.size();        <span class="hljs-keyword">this</span>-&gt;nums = nums;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; curr;                    backtrack(<span class="hljs-number">0</span>, curr);        res.push_back(&#123;&#125;);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><blockquote><p>注意，这里的第六行<code>for (int i = first; i &lt; n; i++)</code>非常关键，它保证各个子集是单调增的，避免了重复。</p></blockquote><p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p><p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p><p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p><h2 id="III-字典"><a href="#III-字典" class="headerlink" title="III. 字典"></a>III. 字典</h2><blockquote><p>该方法思路来自于Donald E. Knuth</p></blockquote><p>将每个子集映射到长度为n的掩码中，其中第i位掩码<code>nums[i]</code>为<code>1</code>，表示第i个元素在子集中， 如果第i位掩码<code>nums[i]</code>位<code>0</code>，表明第i位元素不在子集中。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvYml0bWFzazQucG5n?x-oss-process=image/format,png" alt="img"></p><p>乍看起来生成二进制数很简单，但如何处理左边填充 0 是一个问题。因为必须生成固定长度的位掩码：例如 <code>001</code>，而不是 <code>1</code>。因此可以使用一些位操作技巧：<br>$python$:<br><pre><code class="hljs python">nth_bit = <span class="hljs-number">1</span> &lt;&lt; n<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n):    <span class="hljs-comment"># generate bitmask, from 0..00 to 1..11</span>    bitmask = bin(i | nth_bit)[<span class="hljs-number">3</span>:]</code></pre><br>$C++$<br><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span>(<span class="hljs-params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span>        n = len(nums)        output = []                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n, <span class="hljs-number">2</span>**(n + <span class="hljs-number">1</span>)):            <span class="hljs-comment"># generate bitmask, from 0..00 to 1..11</span>            bitmask = bin(i)[<span class="hljs-number">3</span>:]                        <span class="hljs-comment"># append subset corresponding to that bitmask</span>            output.append([nums[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n) <span class="hljs-keyword">if</span> bitmask[j] == <span class="hljs-string">&#x27;1&#x27;</span>])                <span class="hljs-keyword">return</span> output</code></pre></p><p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p><p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p><p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p><hr><h2 id="IV-数学"><a href="#IV-数学" class="headerlink" title="IV. 数学"></a>IV. 数学</h2><blockquote><p>60.<a href="https://leetcode-cn.com/problems/permutation-sequence/">第k个排列</a></p></blockquote><p>这里我们将题目稍微变形一下。来讲解数学知识如何发挥巨大的作用的。</p><p>给你一个排列$s$，由数字<code>1-9</code>组成，在<strong>不求全排列</strong>的前提下，返回它是正序的第k个排列。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">213</span>输出: k = <span class="hljs-number">3</span>解释：<span class="hljs-number">123</span>全部的排列为 <span class="hljs-number">123</span>， <span class="hljs-number">132</span>， <span class="hljs-number">213</span>， <span class="hljs-number">231</span>， <span class="hljs-number">312</span>， <span class="hljs-number">321</span></code></pre><p>要想解决本题，首先需要了解一个简单的结论：</p><blockquote><p>对于 $n$ 个不同的元素（例如数 $1,2,⋯,n$），它们可以组成的排列总数目为 $n!$。</p></blockquote><p>对于给定的 $n$ 和 $k$，我们不妨从左往右确定第 $k$ 个排列中的每一个位置上的元素到底是什么。</p><p>我们首先确定排列中的首个元素 $a_1$ 。根据上述的结论，我们可以知道：</p><ul><li>以 1 为 $a_1$ 的排列一共有 $(n-1)!$ 个；<br>以 2 为 $a_1 $ 的排列一共有 $(n-1)!$ 个；<br>$\cdots⋯$<br>以 n 为 $a_1$ 的排列一共有 $(n-1)!$个。<br>由于我们需要求出从小到大的第 k 个排列，因此：</li></ul><p>如果 $k \leq (n-1)!$，我们就可以确定排列的首个元素为 1；<br>如果 $(n-1)! &lt; k \leq 2 \cdot (n-1)!$，我们就可以确定排列的首个元素为 2；<br>$\cdots⋯$<br>如果 $(n-1) \cdot (n-1)! &lt; k \leq n \cdot (n-1)!$，我们就可以确定排列的首个元素为 n。<br>因此，第 k 个排列的首个元素就是：</p><script type="math/tex; mode=display">a_1 = \lfloor \frac{k-1}{(n-1)!} \rfloor + 1</script><p>其中 $\lfloor x \rfloor$ 表示将 x 向下取整。</p><p>当我们确定了 $a_1$后，如何使用相似的思路，确定下一个元素 $a_2$呢？实际上，我们考虑以 $a_1$为首个元素的所有排列：</p><p>第 k 个排列实际上就对应着这其中的第</p><script type="math/tex; mode=display">k' = (k-1) \bmod (n-1)! + 1</script><p>个排列。这样一来，我们就把原问题转化成了一个完全相同但规模减少 1的子问题.</p><p><strong>代码</strong>：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">factorial</span><span class="hljs-params">(n)</span></span>;        factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;            factorial[i] = factorial[i - <span class="hljs-number">1</span>] * i;        &#125;        --k;        <span class="hljs-built_in">string</span> ans;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">valid</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;            <span class="hljs-keyword">int</span> order = k / factorial[n - i] + <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;                order -= valid[j];                <span class="hljs-keyword">if</span> (!order) &#123;                    ans += (j + <span class="hljs-string">&#x27;0&#x27;</span>);                    valid[j] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            k %= factorial[n - i];        &#125;           <span class="hljs-keyword">return</span> ans;         &#125;&#125;;</code></pre><hr><h2 id="V-状态压缩"><a href="#V-状态压缩" class="headerlink" title="V. 状态压缩"></a>V. 状态压缩</h2><p>可以使用二进制或者,$bitset$进行状态压缩.</p><p>状态压缩经典问题：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. 每个元音包含偶数次的最长子字符串</a></p><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p>示例 1：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;eleetminicoworoep&quot;</span>输出：<span class="hljs-number">13</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetminicowor&quot;</span> ，它包含 e，i，o 各 <span class="hljs-number">2</span> 个，以及 <span class="hljs-number">0</span> 个 a，u 。</code></pre><p>示例 2：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;leetcodeisgreat&quot;</span>输出：<span class="hljs-number">5</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetc&quot;</span> ，其中包含 <span class="hljs-number">2</span> 个 e 。</code></pre><p>示例 3：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;bcbcbc&quot;</span>输出：<span class="hljs-number">6</span>解释：这个示例中，字符串 <span class="hljs-string">&quot;bcbcbc&quot;</span> 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 <span class="hljs-number">0</span> 次。</code></pre><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li>s 只包含小写英文字母。</li></ul><p>定义$pre[i][k]$表示前$i$个字母，第$k$个元音字母总出现的次数。那么在$[i-1,j-1]$区间内，元音字母出现次数为$pre[j][k]-pre[i][k]$，在$O(1)$时间内得到第$k$个元音字母出现的次数。</p><p>同时我们要考虑避免枚举所有的$i$，计算以它结尾的满足条件的最长子字符串长度，我们要找到最小$i$使得$pre[j][k]-pre[i][k]$均为偶数。 我们需要利用【所有元音出现偶数次】这个条件，对于满足条件的子串而言，$pre[i][k]$和$pre[j][k]$的奇偶性一定相同，因为偶数一定是奇数+奇数，或者偶数+偶数组成。所以我们可以把$pre[i][k]$改为表示$[0,i-1]$的<strong>元音奇偶性</strong>。</p><p>此外我们还需要进行「状态压缩」：</p><pre><code class="hljs dts">&#123;<span class="hljs-symbol">  a:</span> cnta, <span class="hljs-comment">// a 出现次数的奇偶性</span><span class="hljs-symbol">  e:</span> cnte, <span class="hljs-comment">// e 出现次数的奇偶性</span><span class="hljs-symbol">  i:</span> cnti, <span class="hljs-comment">// i 出现次数的奇偶性</span><span class="hljs-symbol">  o:</span> cnto, <span class="hljs-comment">// o 出现次数的奇偶性</span><span class="hljs-symbol">  u:</span> cntu  <span class="hljs-comment">// u 出现次数的奇偶性</span>&#125;</code></pre><p>我们可以用二进制表示这些奇偶。</p><p>举一个例子，假如到第 $i $个位置，<code>u o i e a</code>出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 $(11001)_2=(25)_{10}$ 作为它的状态。</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = s.size(), res = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; vowel&#123;            &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>&#125;        &#125;;        <span class="hljs-comment">// 我们用pre[status]表示status状态对应的位置i，不断更新</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>,<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">//初始均为偶</span>        pre[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态，所有元音为偶数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)        &#123;            <span class="hljs-keyword">if</span>(vowel.count(s[i<span class="hljs-number">-1</span>]))            status ^= vowel[s[i<span class="hljs-number">-1</span>]];                        <span class="hljs-keyword">if</span>(~pre[status]) res = max(res,i - pre[status]); <span class="hljs-comment">//pre[status]!=-1</span>            <span class="hljs-keyword">else</span>             &#123;                pre[status] = i ;            &#125;                &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><blockquote><p>注意 18行的 ~pre[status]表示<strong>按位取反</strong>，包含了符号位，所以只有pre[status]不为-1，才为True。</p><p>$ \text{~} 0 = -1$， </p></blockquote><p>时间复杂度: $O(N)$. $N$为字符串长度。</p><p>空间复杂度: $O(1)$.</p><hr><blockquote><p> 一些子母问题（数字重复与不重复）</p></blockquote><ul><li>46 <a href="https://leetcode-cn.com/problems/permutations/">全排列</a></li></ul><p>数字不重复，求全排列，回溯法</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; output, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> len)</span></span>&#123;        <span class="hljs-comment">// 所有数都填完了</span>        <span class="hljs-keyword">if</span> (first == len) &#123;            res.emplace_back(output);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt; len; ++i) &#123;            <span class="hljs-comment">// 动态维护数组</span>            swap(output[i], output[first]);            <span class="hljs-comment">// 继续递归填下一个数</span>            backtrack(res, output, first + <span class="hljs-number">1</span>, len);            <span class="hljs-comment">// 撤销操作</span>            swap(output[i], output[first]);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;        backtrack(res, nums, <span class="hljs-number">0</span>, (<span class="hljs-keyword">int</span>)nums.size());        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><ul><li>47 <a href="https://leetcode-cn.com/problems/permutations-ii/">全排列2</a></li></ul><p>数字重复，求全排列【此时一定要用hash表】</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dict;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)        &#123;            res.push_back(arr);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:dict)        &#123;            <span class="hljs-keyword">if</span>(c.second&gt;<span class="hljs-number">0</span>)             &#123;                arr.push_back(c.first);                c.second--;                dfs(n<span class="hljs-number">-1</span>);                c.second++;                arr.pop_back();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permuteUnique</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;        <span class="hljs-keyword">this</span>-&gt;nums = nums;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)            dict[c]++;        dfs(nums.size());        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><ul><li><p>78 子集（上面作为例子讲了）</p></li><li><p>90 <a href="https://leetcode-cn.com/problems/subsets-ii/">子集2</a></p></li></ul><p>求包含重复元素的所有子集</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; data;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i == n) &#123;           res.push_back(tmp);           <span class="hljs-keyword">return</span> ;         &#125;        dfs(i + <span class="hljs-number">1</span>);        <span class="hljs-comment">//i是从n-1开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; data[i].second; j ++) &#123;            tmp.push_back(data[i].first);            dfs(i + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; data[i].second; j ++) tmp.pop_back();        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<span class="hljs-comment">//统计nums每个数字的个数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;            mp[x] ++;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : mp) &#123;            data.push_back(x);<span class="hljs-comment">//相当于把哈希表存到数组</span>        &#125;        n = data.size();        dfs(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;            &#125;&#125;;</code></pre><ul><li><ol><li><a href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列</a></li></ol></li></ul><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]输出: [[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">7</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]]</code></pre><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><hr><p><strong>方法1：二进制枚举+哈希</strong></p><p>我们用二进制0，1表示解选中或者不被选中。那么长度为$n$的序列，对应有$2^n$种可能，对于序列去重，我们可以采用串哈希算法，（Rabin-Karp算法），即对于一个序列${a_0,a_1,…,a_{n-1}}$，我们可以认为是一个$\max(a_i)+1$（记为b）进制的数。</p><script type="math/tex; mode=display">f(a)=\sum\limits_{i=0}^{n-1}b^i×a_i</script><p>在实际使用种，我们发现这个编码可能非常的大，我们可以把它模上一个大素数$P$，再映射到$int$范围。</p><script type="math/tex; mode=display">f(a)=\sum\limits_{i=0}^{n-1}b^i×a_i(mod \ P)</script><p>Rabin-karp编码</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MIN_VAL = <span class="hljs-number">-100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_VAL = <span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> mod)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//这里的base为数组的最大值, min_val 为数组可能最小值，题目给出,为了避免负数的情况</span><span class="hljs-comment">//这里的mod 是一个大素数</span><span class="hljs-comment">//时间复杂度 O(N) 慎用</span>    <span class="hljs-keyword">int</span> hashVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:temp)    &#123;        hashVal = <span class="hljs-number">1L</span>L*hashVal*base % mod + (c - MIN_VAL + <span class="hljs-number">1</span>);          hashVal %= mod;    &#125;    <span class="hljs-keyword">return</span> hashVal;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> hashValue = getHash(MAX_VAL, (<span class="hljs-keyword">int</span>)(<span class="hljs-number">1E9</span>)+<span class="hljs-number">7</span>);</code></pre><p>数组编码</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;    <span class="hljs-keyword">int</span> mask = i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)    &#123;        <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>)         &#123;            ...        &#125;    mask &gt;&gt;= <span class="hljs-number">1</span>;&#125;&#125;</code></pre><p><strong>字符串编码</strong></p><p>在该方法中，我们将字符串看成一个 $\textit{base}$ 进制的数，它对应的十进制值就是哈希值。显然，两个字符串的哈希值相等，当且仅当这两个字符串本身相同。然而如果字符串本身很长，其对应的十进制值在大多数语言中无法使用内置的整数类型进行存储。因此，我们会将十进制值对一个大质数 $\textit{mod}$ 进行取模。此时：</p><ul><li><p>如果两个字符串的哈希值在取模后不相等，那么这两个字符串本身一定不相同；</p></li><li><p>如果两个字符串的哈希值在取模后相等，并不能代表这两个字符串本身一定相同。例如两个字符串的哈希值分别为 2 和 15，模数为 13，虽然 $2 \equiv 15 ~~ (\bmod~13)$，但它们不相同。</p></li></ul><p>一般来说，我们选取一个大于字符集大小（即字符串中可能出现的字符种类的数目）的质数作为 $base$，再选取一个在字符串长度平方级别左右的质数作为 $mod$，产生哈希碰撞的概率就会很低。</p><p><strong>复杂度分析</strong></p><p>假设序列的长度是 $n$。</p><ul><li>时间复杂度：$O(2^n \cdot n)$。这里枚举所有子序列的时间代价是 $O(2^n)$，每次检测序列是否合法和获取哈希值的时间代价都是 $O(n)$.</li><li>空间复杂度：$O(2^n)$。最坏情况下整个序列都是递增的，每个长度大于等于 2 的子序列都要加入答案，这里哈希表中要加入 $2^n$<br>  个元素，空间代价为 $O(2^n)$,用一个临时的数组来存当前答案，空间代价为 $O(n)$。</li></ul><p><strong>方法2：递归+剪枝</strong></p><p>这是一个递归枚举子序列的通用模板，即用一个临时数组 $\rm temp$ 来保存当前选出的子序列，使用 $\rm cur$ 来表示当前位置的下标，在 dfs(cur, nums) 开始之前，$[0, {\rm cur} - 1]$这个区间内的所有元素都已经被考虑过，而$ [{\rm cur}, n]$ 这个区间内的元素还未被考虑。在执行 dfs(cur, nums) 时，我们考虑 ${\rm cur}$ 这个位置选或者不选，如果选择当前元素，那么把当前元素加入到 $\rm temp$ 中，然后递归下一个位置，在递归结束后，应当把 $\rm temp$的最后一个元素删除进行回溯；如果不选当前的元素，直接递归下一个位置。</p><p>当然，如果我们简单地这样枚举，对于每一个子序列，我们还需要做一次 $O(n)$ 的合法性检查和哈希判重复，在执行整个程序的过程中，我们还需要使用一个空间代价 $O(2^n) $的哈希表来维护已经出现的子序列的哈希值。我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的都是合法的并且不重复：</p><p>使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的</p><p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p><ul><li><p>前者被选择，后者被选择</p></li><li><p>前者被选择，后者不被选择</p></li><li><p>前者不被选择，后者被选择</p></li><li><p>前者不被选择，后者不被选择</p><p>其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</p></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> last, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur == nums.size()) &#123;<span class="hljs-comment">//当前序号达到末尾才进行答案归纳</span>            <span class="hljs-keyword">if</span> (temp.size() &gt;= <span class="hljs-number">2</span>) &#123;                ans.push_back(temp);            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (nums[cur] &gt;= last) &#123;            temp.push_back(nums[cur]);            dfs(cur + <span class="hljs-number">1</span>, nums[cur], nums);            temp.pop_back();        &#125;        <span class="hljs-keyword">if</span> (nums[cur] != last) &#123;<span class="hljs-comment">//只有前后元素不相同才考虑不选</span>            dfs(cur + <span class="hljs-number">1</span>, last, nums);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">findSubsequences</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        dfs(<span class="hljs-number">0</span>, INT32_MIN, nums);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><hr><h2 id="剪枝技巧"><a href="#剪枝技巧" class="headerlink" title="剪枝技巧"></a><strong>剪枝技巧</strong></h2><ul><li>一种常见的技巧是让生成子序列是单增顺序的，如 216. 组合总和III。</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> target,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sub)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>&amp;&amp;target==<span class="hljs-number">0</span>) &#123;res.push_back(sub);<span class="hljs-keyword">return</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= min(<span class="hljs-number">9</span>,target);i++)        <span class="hljs-keyword">if</span>(!sub.size()||i &gt; sub.back())        &#123;            sub.emplace_back(i);            dfs(k<span class="hljs-number">-1</span>,target-i,sub);            sub.pop_back();        &#125;    &#125;</code></pre><ul><li>当题目不能出现重复项时，有两种方法。如40.组合总和II</li><li><ol><li>使用哈希表天然去重功能，但是需要编码。</li><li>先对<code>candidates</code>进行排序，然后每次dfs取下一项，遇到<code>candidates</code>重复项就跳过。这里我们分<code>candidates</code>能否被选无限次进行讨论。</li></ol></li></ul><p>A. Candidates只能选取一次【40题】</p><pre><code class="hljs Cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; candidates;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;        res.push_back(path);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= <span class="hljs-number">0</span>; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])            <span class="hljs-keyword">continue</span>;        path.push_back(candidates[i]);        <span class="hljs-comment">// 元素不可重复利用，使用下一个即i+1</span>        DFS(i + <span class="hljs-number">1</span>, target - candidates[i]);        path.pop_back();    &#125;&#125;</code></pre><p>B. Candidates选取无限次【39题】</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;            res.push_back(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start;             i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= <span class="hljs-number">0</span>; i++) &#123;            path.push_back(candidates[i]);            DFS(i, target - candidates[i]);            path.pop_back();        &#125;    &#125;</code></pre><p>区别在于<code>dfs(i)</code>还是<code>dfs(i+1)</code>.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解空间极大问题</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 如何让Unordered_map支持pair作为键值</title>
    <link href="/2020/07/25/2020-07-25-how-Unordered_map-support-pair-as-key/"/>
    <url>/2020/07/25/2020-07-25-how-Unordered_map-support-pair-as-key/</url>
    
    <content type="html"><![CDATA[<blockquote><p>C++</p></blockquote><h1 id="如何让Unordered-map支持pair作为键值"><a href="#如何让Unordered-map支持pair作为键值" class="headerlink" title="如何让Unordered_map支持pair作为键值"></a>如何让Unordered_map支持pair作为键值</h1><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt; </span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair_hash</span>//没这个<span class="hljs-title">pair</span> 就不能在<span class="hljs-title">unorder</span>——<span class="hljs-title">map</span>快乐的玩耍了</span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;T1, T2&gt;&amp; p)</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> hash&lt;T1&gt;()(p.first) ^ hash&lt;T2&gt;()( p.second);<span class="hljs-comment">//异或思想</span>    &#125;    <span class="hljs-comment">//如果遇到了&lt;3,5&gt;和&lt;5,3&gt;怎么办，皮神有想法，再把两个hash判断一遍</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;T1,T2&gt; &amp;lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;T1,T2&gt; &amp;rhs)</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> equal_to&lt;T1&gt;()(lhs.first,rhs.first) &amp;&amp; equal_to&lt;T2&gt;()(lhs.second,rhs.second);    &#125;&#125;;<span class="hljs-comment">//使用</span><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">double</span>,pair_hash&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,pair_hash&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; minDis;   minDis.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<span class="hljs-number">1.5</span>));</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>像python那样将任何对象变为dict的键值，C++把原有的hash函数删去了（处于性能考虑 )，所以要自己写。</p><p>然后用的话就根据需要，正常操作了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>嗯 Python中defaultdict有一点好处，就是可以直接用tuple作为键值，这样的话间接解决了list不能作为键值的问题，mark一下</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做一只可爱的小🐖背包 Cover「背包九讲」</title>
    <link href="/2020/07/25/2020-07-27-backpack-problem/"/>
    <url>/2020/07/25/2020-07-27-backpack-problem/</url>
    
    <content type="html"><![CDATA[<h1 id="做一只可爱的小🐖背包"><a href="#做一只可爱的小🐖背包" class="headerlink" title="做一只可爱的小🐖背包"></a>做一只可爱的小🐖背包</h1><blockquote><p>  推荐观看dd大牛：<a href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲的传送门</a>, <a href="https://www.bilibili.com/video/av33930433">「背包九讲」视频教程</a></p><p>  0-1 背包    </p><blockquote><p> 完全背包</p><blockquote><p>多重背包 I II III</p></blockquote><p>混合背包问题</p><blockquote><p>二维费用的背包问题</p></blockquote><p>分组背包问题</p><blockquote><p>背包问题求解方案数</p></blockquote><p>求背包问题的方案</p><blockquote><p>有依赖的背包问题</p></blockquote></blockquote></blockquote><h2 id="I-0-1背包问题"><a href="#I-0-1背包问题" class="headerlink" title="I. 0-1背包问题"></a>I. 0-1背包问题</h2><blockquote><p><u><strong>注意</strong>解空间极大问题有时可以转化0-1背包,从而避免TLE!</u></p></blockquote><p>题目：有一个容量为 V 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。</p><p>例子</p><pre><code class="hljs angelscript">背包最大容量：<span class="hljs-number">50</span>物品重量为：&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>&#125;物品价值为：&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;输出：<span class="hljs-number">8</span>解释：当选择物品重量为<span class="hljs-number">20</span>，<span class="hljs-number">30</span>或者<span class="hljs-number">10</span>，<span class="hljs-number">40</span>对应的价值最大。</code></pre><p>我们适当作一些约定：$dp[i][j]或dp[j]$表示最大价值，$i$为具体问题下物品编号或组编号，$j$为体积。$W_i$为价值数组，$V_i$为体积数组。</p><p>$N$表示物品数量，$C$表示背包容积，$Q$表示背包最大重量。</p><p>0-1 背包问题中，物品只有两种状态，装载或者不装载，因此被称为<strong>0-1背包</strong>。除此之外还有<strong>完全背包</strong>和<strong>多重背包</strong>。</p><ol><li><strong>找子问题</strong>，第一，包的当前容量比物品小，装不下，这时的最大价值和前<script type="math/tex">i-1</script>个物品的最大价值是一样的。我们令<script type="math/tex">dp[i][j]</script>表示前<script type="math/tex">i</script>个物品在背包容量为<script type="math/tex">j</script>所能达到的最大价值。第二，包的当前可用容量比物品大，这个时候要决定是否添加下一个物品，因为在体积相同的情况下，总价值不一定更大。</li><li>找到<strong>状态转移方程</strong>，我们用辅助函数$sumWeight(i)$表示当前物品的总重量。</li></ol><script type="math/tex; mode=display">dp[i][j]=\begin{cases}dp[i-1][j],\ sumWeight(i-1)+w[i-1]>j\\\max(dp[i-1][j-w[i-1]]+v[i-1], dp[i-1][j])，otherwise\end{cases}</script><ol><li><p>确定<strong>边界条件</strong>：</p><p><script type="math/tex">dp[0][j]=0</script>，不装物品时最大价值为0.，同理<script type="math/tex">dp[i][0]=0</script>，即背包容量为0时，最大价值也为0. </p></li></ol><p>时间复杂度：<script type="math/tex">O(V*N)</script>，状态数量为V*N, V为背包容量，N为物品数目，状态转移复杂度为<script type="math/tex">O(1)</script>。</p><p>空间复杂度：<script type="math/tex">O(V*N)</script>, 为dp数组大小。</p><blockquote><p>变式：要求完全装满背包。</p></blockquote><p>我们令<script type="math/tex">dp[0][j]=0</script>，不装物品时最大价值为0.，<script type="math/tex">dp[0][j]=-\infin</script>，这样的话，在<script type="math/tex">dp[n][V]</script>刚好大于0.</p><blockquote><p>优化：用一维数组表示</p></blockquote><p>因为dp的物品数量维度i，仅与前一项有关，因此可以优化。<u>为保证每个物品只能使用一次，我们倒序遍历所有的值，类似于贪心的思路，而反过来就变成了<strong>完全背包</strong>问题。想想为什么？</u></p><script type="math/tex; mode=display">dp[j] = \max(dp[j-w[i-1]]+v[i-1],dp[j])</script><p>注意后面的dp[j]其实是上一次的结果，这相当于滚动数组。优化后空间复杂度为<script type="math/tex">O(V)</script>。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">backpack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;val, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span>    <span class="hljs-keyword">int</span> N = val.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//dp[j]表示容量为j的最大价值</span>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V;i++) dp[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = V; j &gt;= weight[i<span class="hljs-number">-1</span>];j--)        dp[j] = max(dp[j],dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> dp[V];&#125;</code></pre><hr><h2 id="II-完全背包问题"><a href="#II-完全背包问题" class="headerlink" title="II. 完全背包问题"></a>II. 完全背包问题</h2><p>我们让每种物品数量可以无限<script type="math/tex">0-\infty</script>。</p><p>例子</p><pre><code class="hljs angelscript">背包最大容量：<span class="hljs-number">60</span>物品重量为：&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>&#125;物品价值为：&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;输出：<span class="hljs-number">10</span>解释：当选择物品重量为两个<span class="hljs-number">30</span>对应的价值最大。</code></pre><p>我们将上述优化算法由<strong>倒序遍历</strong>J变为<strong>正序遍历</strong>J即可实现。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">backpack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;val, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span>    <span class="hljs-keyword">int</span> N = val.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//dp[j]表示容量为j的最大价值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = weight[i<span class="hljs-number">-1</span>]; j &lt;= V;j++)    <span class="hljs-keyword">if</span>(dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]&gt;dp[j])    dp[j] = dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">return</span> dp[V];&#125;</code></pre><hr><h2 id="III-多重背包问题"><a href="#III-多重背包问题" class="headerlink" title="III. 多重背包问题"></a>III. 多重背包问题</h2><p>多重背包问题介于0-1背包和完全背包之间。</p><p>我们除了给出背包的最大容量，物品的体积V和价值W，还给出物品的最大数量S。</p><p><u>我们可以将多重背包问题转化为0-1背包，即将每种物品视为k种不同的物品</u>，这样的时间复杂度为<script type="math/tex">O(s×\sum k_i)</script>，由此可见，降低每件物品的数量可以大大降低其时间复杂度。我们运用一些tricky技巧，将原来数量为k的物品拆分为若干组，每组物品看成一件物品，其价值和重量为该组所有物品之和。$\color{red}{每组物品包含原物品数目分别为: 1,2,4···k-2^c+1}，其中k为使得k-2^c+1大于0的最大整数$.得到新的时间复杂度为<script type="math/tex">O(s×\sum \log k_i)</script>。</p><p><strong>二进制优化</strong></p><pre><code class="hljs Cpp"><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//分别表示物品数量和背包容量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> w,v;<span class="hljs-comment">//用于分组</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">vector</span>&lt;object&gt; objects;    <span class="hljs-keyword">int</span> a,b,s,line = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;s)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s;k*=<span class="hljs-number">2</span>)        &#123;<span class="hljs-comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span>            s -= k;            objects.push_back(&#123;k*b,k*a&#125;);        &#125;        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) objects.push_back(&#123;s*b,s*a&#125;);        line ++;    &#125;    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;object:objects)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= object.v;k--)    &#123;        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span>    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>单调队列优化(Hard)</strong></p><p><code>0&lt;N≤10000&lt;N≤10000&lt;V≤200000&lt;V≤200000&lt;vi,wi,si≤20000</code></p><p>当数据范围变得极大，使用二进制将<code>TLE</code>，我们必须优化，这里有一种优化方式是单调队列优化。</p><p>因为我们需要的是${ dp[j], dp[v+j], dp[2<em>v+j], dp[3</em>v+j], … , dp[k*v+j] }$ 中的最大值，我们通过维护一个单调队列来维护这些数中最大值。</p><p>单调队列问题，最重要的两点<br>1）维护队列元素的个数，如果不能继续入队，弹出队头元素<br>2）维护队列的单调性，即：$尾值 &gt;= dp[j + k<em>v] - k</em>w$</p><p>本题中，队列中元素的个数应该为 $s+1$ 个，即 $0 - s $个物品 $i$. 为了方便大家理解，我举例进行说明。</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">20010</span>;<span class="hljs-keyword">int</span> dp[N_MAX],pre[N_MAX],Q[N_MAX];<span class="hljs-comment">//分别表示物品数量和背包容量</span><span class="hljs-comment">//单调队列存的是体积，末尾存储最大价值。</span><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和背包容量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> v,w,s,l=<span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)    &#123;        <span class="hljs-built_in">memcpy</span>(pre,dp,<span class="hljs-keyword">sizeof</span> dp);<span class="hljs-comment">//copy dp-&gt;pre</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; v;j++)        &#123;<span class="hljs-comment">//j是余数，即C%k</span>            <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队列头部和尾部</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = j;k &lt;= C;k += v)            &#123;<span class="hljs-comment">// j+n*k==C</span>                <span class="hljs-keyword">if</span>(head&lt;=tail)                &#123;<span class="hljs-comment">//如果容量超过了S,则单调队列应该缩小 head++</span>                <span class="hljs-keyword">if</span>((k-s*v) &gt; Q[head]) head++;                <span class="hljs-comment">//如果k对应价值大于头部价值，那么不断，相当于把体积插入到使得队列单增的位置，tail--</span>                <span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;(pre[k] - (k - j)/v*w) &gt;= (pre[Q[tail]] - (Q[tail] - j)/v*w)) tail--;                dp[k] = max(dp[k],pre[Q[head]] + (k-Q[head])/v*w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>                &#125;                Q[++tail] =  k;            &#125;        &#125;    &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>说实话，笔者单调队列这里也不是很明白，需要再仔细讲究一下。</p><hr><h2 id="IV-混合背包"><a href="#IV-混合背包" class="headerlink" title="IV. 混合背包"></a>IV. 混合背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）；</li><li>第二类物品可以用无限次（完全背包）；</li><li>第三类物品最多只能用 $s_i$ 次（多重背包）；</li></ul><p>每种体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。</p><ul><li>$si=−1$ 表示第 $i$ 种物品只能用1次；</li><li>$si=0$ 表示第 $i$ 种物品可以用无限次；</li><li>$si&gt;0$ 表示第 $i$ 种物品可以使用 $si$ 次；</li></ul><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000<br>−1≤si≤1000$</p><blockquote><hr></blockquote><p>我们直接分类讨论，状态转移直接分为<strong>无限个</strong>和<strong>非无限</strong>即可。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//分别表示物品数量和背包容量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> kind;    <span class="hljs-keyword">int</span> w,v;<span class="hljs-comment">//用于分组</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">vector</span>&lt;object&gt; objects;    <span class="hljs-keyword">int</span> v,w,s;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)    &#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-number">-1</span>) objects.push_back(&#123;<span class="hljs-number">-1</span>,w,v&#125;);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) objects.push_back(&#123;<span class="hljs-number">0</span>,w,v&#125;);        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s;k*=<span class="hljs-number">2</span>)        &#123;<span class="hljs-comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span>            s -= k;            objects.push_back(&#123;<span class="hljs-number">1</span>,k*w,k*v&#125;);        &#125;        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) objects.push_back(&#123;<span class="hljs-number">1</span>,s*w,s*v&#125;);    &#125;    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;object:objects)    <span class="hljs-keyword">if</span>(object.kind == <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = object.v;k &lt;= C;k++)    &#123;        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>    &#125;    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= object.v;k--)    &#123;        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="V-二维费用的背包问题"><a href="#V-二维费用的背包问题" class="headerlink" title="V. 二维费用的背包问题"></a>V. 二维费用的背包问题</h2><p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p><p>每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N≤1000\\<br>0&lt;V,M≤100\\0&lt;v_i,m_i≤100\\<br>0&lt;w_i≤1000$</p><p>其实非常容易进行扩展，将数组维度扩大，再加一层循环即可。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,Q;<span class="hljs-comment">//分别表示物品数量，背包体积容量，背包最大重量</span><span class="hljs-keyword">int</span> V[<span class="hljs-number">1001</span>],W[<span class="hljs-number">1001</span>],M[<span class="hljs-number">1001</span>];<span class="hljs-comment">//体积，价值和重量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> v,w,m,line = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C&gt;&gt;Q;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;m&gt;&gt;w)    &#123;        V[line] = v;        M[line] = m;        W[line] = w;                line ++;    &#125;    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>][Q+<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= V[i<span class="hljs-number">-1</span>];k--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = Q;j &gt;= M[i<span class="hljs-number">-1</span>];j--)    &#123;        dp[k][j] = max(dp[k][j],dp[k - V[i<span class="hljs-number">-1</span>]][j - M[i<span class="hljs-number">-1</span>]] + W[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k][j]);</span>    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C][Q];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="VI-分组背包问题"><a href="#VI-分组背包问题" class="headerlink" title="VI. 分组背包问题"></a>VI. 分组背包问题</h2><p>有 N 组物品和一个容量是 V 的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有 $N$ 组数据：</p><ul><li>每组数据第一行有一个整数 $S_i$，表示第 $i $个物品组的物品数量；</li><li>每组数据接下来有 $Si$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；</li></ul><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0&lt;N,V≤1000&lt;Si≤1000&lt;vij,wij≤100</code></p><blockquote><hr></blockquote><p>我们只需要对每组每一个物品进行讨论。求每组的dp是并列的关系，注意循环之间位置关系。枚举体积的循环在外面，而枚举组内物品循环在里面。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,v,w;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;        <span class="hljs-comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//每组物品的数量</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)    &#123;    <span class="hljs-built_in">cin</span>&gt;&gt; num;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; num; j++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;V[j]&gt;&gt;W[j];    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= <span class="hljs-number">0</span>;k--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;s &lt; num; s++)    <span class="hljs-keyword">if</span>(k &gt;= V[s])    &#123;        dp[k] = max(dp[k],dp[k - V[s]] + W[s]);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span>    &#125;            &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="VII-有依赖的背包问题（hard）-树形dp"><a href="#VII-有依赖的背包问题（hard）-树形dp" class="headerlink" title="VII. 有依赖的背包问题（hard）[树形dp]"></a>VII. 有依赖的背包问题（hard）[树形dp]</h2><p>有 $N$ 个物品和一个容量是 $V$ 的背包。</p><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><p>如下图所示：<br><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt="QQ图片20181018170337.png"></p><p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p><p>每件物品的编号是 $i$，体积是 $vi$，价值是 $wi$，依赖的父节点编号是 $pi$。物品的下标范围是 $1…N$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。</p><p>接下来有 $N$ 行数据，每行数据表示一个物品。<br>第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>如果 $p_i=−1$，表示根节点。 <strong>数据保证所有物品构成一棵树。</strong></p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N,V≤100\\1≤v_i,w_i≤100$</p><p>父节点编号范围：</p><ul><li>内部结点：$1≤p_i≤N$;</li><li>根节点 $pi=−1$;</li></ul><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">7</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="hljs angelscript"><span class="hljs-number">11</span></code></pre><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><pre><code class="hljs angelscript">我们选择根节点,价值为&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;，编号为<span class="hljs-number">1</span>的叶节点，我们选择&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;或&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;。编号为<span class="hljs-number">2</span>的叶节点，我们选择&#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>&#125;或&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;。 最大容积<span class="hljs-number">7</span>， 我们选择&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;和&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;,这样总体积就是<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span> = <span class="hljs-number">7.</span> 总价值为 <span class="hljs-number">2</span>+<span class="hljs-number">6</span>+<span class="hljs-number">3</span>=<span class="hljs-number">11.</span></code></pre><blockquote><hr></blockquote><p>这道题其实是分组背包和<u>树形dp</u>的结合。先考虑节点的数据表示我们用<code>vector&lt;int&gt; g[N_MAX]</code>表示二叉树。$dp[i][j]$表示，<strong>我们选择节点$i$为根节点，并且体积为$j$的最大价值。</strong></p><p>既然是树，我们就需要深度优先搜索（DFS）。由于子节点依赖于根节点，那么根节点必定占据一定空间，且初始价值应该等于根节点。</p><blockquote><p>初始条件：$ dp[root][j] = W_{root}, V_{root} \le j \le C$ , $C$表示背包容积。</p></blockquote><p>按照0-1背包思路，我们在$k \in[V_{root},C]$区间内逆向遍历，那么子节点的可用空间为$m \in [0,k-V_{root}]$. 可以类比分组背包的$k\in[0,C],s \in [0,num],where  k &gt; V_s$, $num$为组号。之后我们将每个子节点分别进行搜索，对$dp[root][k]$进行更新。</p><script type="math/tex; mode=display">dp[root][k] = \max(dp[root][k],dp[root][k-m]+dp[son][m])</script><blockquote><p>返回值：$dp[root][C]$</p></blockquote><p>弄清楚这一层写代码就不难了。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,p;<span class="hljs-comment">//物品数量，背包容积，父节点</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX][N_MAX];<span class="hljs-comment">//体积数组，价值数组，dp[i][j]选择第i个节点为根节点在体积为j对应最大价值</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[N_MAX];<span class="hljs-comment">//保存子节点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//cap表示容量，no表示节点编号</span>    <span class="hljs-comment">//root必选，所以我们初始化dp[root][V[root]~C] 为 W[root]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = V[root];j &lt;= C;i++) dp[root][j] = W[root];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;son:g[root])     &#123;        dfs(son);<span class="hljs-comment">//遍历子节点</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C; k &gt;= V[root]; k--)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt;= (k-V[root]);m++)<span class="hljs-comment">//分配给子树的空间不能大于C-V[son]</span>        &#123;            dp[root][k] = max(dp[root][k], dp[root][k-m] + dp[son][m]);<span class="hljs-comment">//根据不同的子节点更新父节点的值</span>            <span class="hljs-comment">// if(dp[root][k]) printf(&quot;rt:%d,sn:%d,dp[%d]:%d\n&quot;,root,son,k,dp[root][k]);</span>                    &#125;    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span>    <span class="hljs-keyword">int</span> root;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;p;        <span class="hljs-keyword">if</span>(~p) g[p].emplace_back(i);        <span class="hljs-keyword">else</span> root = i;    &#125;    dfs(root);    <span class="hljs-built_in">cout</span>&lt;&lt;dp[root][C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="VIII-背包求解方案数"><a href="#VIII-背包求解方案数" class="headerlink" title="VIII.背包求解方案数"></a>VIII.背包求解方案数</h2><p>有 $N$件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$, 用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <strong>方案数</strong> 模 $10^9+7$ 的结果。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\\<br>0&lt;v_i,w_i≤1000$</p><blockquote><p>我们除了需要对价值$dp[j]$进行状态转移（同0-1背包），还需要对方案数进行转移，设$M[j]$表示物品总体积为$j$对应的方案数。</p><p>那么有：</p><script type="math/tex; mode=display">M[j] = \begin{cases}        M[j], M[j]>M[j-v_i]\\        M[j-v_i], M[j]<M[j-v_i]\\        M[j]+M[j-v_i], M[j]=M[j-v_i]\\        \end{cases}.</script><p>初始条件： $M[0] = 1$， 背包为空只有一种方案。</p></blockquote><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">1010</span>, MOD = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和容积</span><span class="hljs-keyword">int</span> dp[N_MAX],M[N_MAX];<span class="hljs-comment">//方案数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> v,w,line = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-built_in">memset</span>(dp,INT_MIN,<span class="hljs-keyword">sizeof</span>(dp));<span class="hljs-comment">//为了使价值从0开始计数，我们把dp数组初始化为-inf</span>    M[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//价值为0的方案为1，即全不放</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= v;k--)        &#123;               <span class="hljs-keyword">int</span> t  = max(dp[k],dp[k - v] + w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品，注意它们价值可能相同</span>            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<span class="hljs-comment">// 不是M[k]，否则三种方案叠加</span>            <span class="hljs-keyword">if</span>(t == dp[k-v]+w) s += M[k-v];            <span class="hljs-keyword">if</span>(t == dp[k]) s += M[k];<span class="hljs-comment">//这里不能写成else if ，两种路径分开考虑，求的是总方案数</span>            dp[k] = t;            M[k] =s%MOD;            <span class="hljs-comment">// printf(&quot;i:%d,k:%d,dp:%d,M:%d\n&quot;,i,k,dp[k],M[k]);</span>                    &#125;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, maxw = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= C;j++)    &#123;        <span class="hljs-comment">// cout&lt;&lt;dp[j]&lt;&lt;&quot;,&quot;&lt;&lt;M[j]&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(dp[j] == dp[C])        &#123;            res += M[j];            res %= MOD;        &#125;    &#125;            <span class="hljs-built_in">cout</span>&lt;&lt;res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="IX-背包问题求具体方案"><a href="#IX-背包问题求具体方案" class="headerlink" title="IX. 背包问题求具体方案"></a>IX. 背包问题求具体方案</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。</p><h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p><p>物品编号范围是 $1…N$。</p><h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\\<br>0&lt;v_i,w_i≤1000$</p><blockquote><hr></blockquote><p>我们用一个二维dp数组$dp[i][j]$表示选取$i$个物品，体积为$j$对应的最大价值。这里的$i$是用来反推具体方案的。我们思考如何反推。</p><p>$dp[i][j] == dp[i-1][j]$说明不选第$i$个物品就能得到最大价值。</p><p>$dp[i][j]==dp[i-1][j-v[i-1]]+w[i-1]$表示选择第$i$个物品得到最大价值。</p><p>为了得到最小的字典序，我们可以采用贪心的策略。在进行状态转移的时候，我们按编号从大到小进行遍历。为了更直观的理解，我们举例：</p><p>设物品数4，背包容积5.  物品的体积$v_i$和价值$w_i$分别为: $[1,2],[2,4],[3,4],[4,6]$.  编号$i$的范围$[1,4]$</p><p>从$i=4$开始，我们从体积为0开始进行状态转移。最后的结果一定是最大价值。如下图所示：</p><pre><code class="hljs angelscript">i:<span class="hljs-number">4</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span> ←i:<span class="hljs-number">4</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span> ←i:<span class="hljs-number">3</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span> ←i:<span class="hljs-number">2</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">8</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">2</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">8</span>  ←</code></pre><p>用$sum$表示剩余体积，开始$sum=5. $然后我们考虑 $dp[i][sum]==dp[i-1][sum-v[i]]+w[i]$ ，如果为True则选择第i个。</p><script type="math/tex; mode=display">dp[1][5]=8→dp[2][4]=6→dp[3][4]=6→dp[4][0]=0.</script><p>最后$sum==0$，表示找到字典序最小的方案。</p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">1010</span>;<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和容积</span><span class="hljs-keyword">int</span> dp[N_MAX][N_MAX];<span class="hljs-comment">//方案数</span><span class="hljs-keyword">int</span> v[N_MAX], w[N_MAX];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N;i++) <span class="hljs-built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = N;i &gt;= <span class="hljs-number">1</span> ;i--)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt;= C;k++)        &#123;             dp[i][k] = dp[i+<span class="hljs-number">1</span>][k];    <span class="hljs-comment">//这句话作用是使得k&lt;v[i]仍可进行反推</span>            <span class="hljs-keyword">if</span>(k &gt;= v[i])             dp[i][k]  = max(dp[i][k],dp[i+<span class="hljs-number">1</span>][k - v[i]] + w[i]);<span class="hljs-comment">//如果选和不选价值相同，那么我们贪心的进行选择</span>            <span class="hljs-comment">// printf(&quot;i:%d,k:%d,dp:%d\n&quot;,i,k,dp[i][k]);</span>        &#125;    &#125;    <span class="hljs-comment">// 根据结果反推具体方案</span>    <span class="hljs-keyword">int</span> sum = C;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N; i++)    &#123;        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][sum]&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(sum &gt;= v[i]&amp;&amp;dp[i][sum]==(dp[i+<span class="hljs-number">1</span>][sum-v[i]]+w[i]))        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;            sum -= v[i];        &#125;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="经典题目分析、"><a href="#经典题目分析、" class="headerlink" title="经典题目分析、"></a>经典题目分析、</h2><p><strong>例题</strong></p><ul><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</li></ul><hr><p><strong><a href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</strong></p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><pre><code class="hljs angelscript">输入：nums: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], S: <span class="hljs-number">3</span>输出：<span class="hljs-number">5</span>解释：<span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span> = <span class="hljs-number">3</span>一共有<span class="hljs-number">5</span>种方法让最终目标和为<span class="hljs-number">3</span>。</code></pre><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><blockquote><p>这道题看起来简单,实际上非常<code>Disgusting</code>.因为它给了三个提示,每一条都杀人诛心. </p></blockquote><p>这一次,我们每一个”物品”都必须选. <strong>我们考虑$dp[i][j]$表示$0-i$区间内组成$j$的方案数</strong>. 那么相应的状态方程为:</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</script><p>很多时候我们会因为惯性思维写成<code>nums[i-1]</code>但这是不对的,因为我们定义区间<code>[0,i]</code>.</p><p>然后很糟糕的是, 或者更糟糕的是, 中间可能产生负数目标的情况,为了避免数组越界,我们需要将数组整体搬移, 这时候第二个提示发挥作用.我们设这个$offset=1000$. </p><p>关于边界条件. 一开始我们很容易写成:</p><script type="math/tex; mode=display">dp[0][nums[0]+sum] = 1;         \\            dp[0][-nums[0]+sum] = 1;</script><p>第一个数可能为负或者正嘛. 但是如果第一个数为$0$.那么上面的式子将失效, 0 的相反数是其自身. 所以边界条件应该为:</p><script type="math/tex; mode=display">\left\{\begin{array}{cr}\begin{cases}dp[0][nums[0]+sum] = 1;\\         dp[0][-nums[0]+sum] = 1;\\\end{cases},nums[0]!=0\\2,otherwise\end{array}\right.</script><p>然后,你这样就以为大功告成了就大错特错了.</p><p>在双重循环中,我们必须要考虑$j$的范围,即$dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]$的适用条件. 并不是所有情况都可以用这个式子表示.</p><p>经过很长时间的摸索, $-sum \le j \le sum$, $sum$表示数组和,为了节省空间,我们也可以把1000改为$sum$:</p><script type="math/tex; mode=display">dp[i][j] =\left\{ \begin{array}{lcc}dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]],sum-nums[i] >=j>=nums[i]-sum\\dp[i-1][j-nums[i]],j>nums[i]-sum\\dp[i-1][j+nums[i]],j<sum-nums[i]\end{array}\right.</script><p>做完此题,深感出题人的恐怖.</p><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1000</span>;<span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-comment">//子集问题，转换为0-1背包，动态规划解决。</span>        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-comment">//我们用dp[i][j]表示 0-i区间内组成j的方案数</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums) sum+= c;        S = S&gt;=<span class="hljs-number">0</span>?S:-S;        <span class="hljs-keyword">if</span>(S&gt;sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//为了使得负数也能被索引，我们必须加上它自身的绝对值</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>*sum+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">if</span>(!nums[<span class="hljs-number">0</span>]) dp[<span class="hljs-number">0</span>][sum] = <span class="hljs-number">2</span>;        <span class="hljs-keyword">else</span> &#123;            dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]+sum] = <span class="hljs-number">1</span>;                     dp[<span class="hljs-number">0</span>][-nums[<span class="hljs-number">0</span>]+sum] = <span class="hljs-number">1</span>;                &#125;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = -sum;j &lt;= sum;j++)        &#123;           <span class="hljs-keyword">if</span>(j+nums[i] &lt;= sum &amp;&amp; j-nums[i]&gt;=-sum)                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j-nums[i]+sum] + dp[i<span class="hljs-number">-1</span>][j+nums[i]+sum];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j-nums[i]&gt;=-sum)                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j-nums[i]+sum];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j+nums[i]&lt;=sum)                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j+nums[i]+sum];            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j+sum]&lt;&lt;endl;</span>        &#125;        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][S+sum];    &#125;&#125;;</code></pre><p>时间复杂度:$O(1)$, 因为题目已经告诉了具体范围不超过$O(20*2000)=O(40000)$,所以时间复杂度是常数.</p><p>空间复杂度:$O(N(2sum+1))$, 这里的$N$表示数组大小, $sum$表示数组之和. </p><p>同类题目还有416. 分割等和子数组.</p><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爸爸再也不想做图类题目了</title>
    <link href="/2020/07/21/2020-08-1-representation_of_graph/"/>
    <url>/2020/07/21/2020-08-1-representation_of_graph/</url>
    
    <content type="html"><![CDATA[<h1 id="图的表示和图算法"><a href="#图的表示和图算法" class="headerlink" title="图的表示和图算法"></a>图的表示和图算法</h1><ul><li><del>DFS&amp;BFS</del>(在相应专题讲)</li><li>Dijkstra</li><li>Floyd算法</li><li>Bellman-Ford算法</li><li>SPFA算法</li></ul><h2 id="1-邻接矩阵表示法"><a href="#1-邻接矩阵表示法" class="headerlink" title="1.邻接矩阵表示法"></a>1.邻接矩阵表示法</h2><p>如图：</p><p> <img src="\img\graph_1.png" alt="img"><img src="\img\graph_2.png" alt="img"></p><p>　　也就是说，如果两节点之间有一条弧，则邻接矩阵中对应的元素为1；否则为0。可以看出，这种表示法非常简单、直接。但是，在邻接矩阵的所有元素中，只有少量为非零元。如果网络比较稀疏，这种表示法浪费大量的存储空间，从而增加了在网络中查找弧的时间。</p><p>　　同样，对于网络中的权，也可以用类似邻接矩阵的 矩阵表示。只是此时一条弧所对应的元素不再是1，而是相应的权而已。如果网络中每条弧赋有多种权，则可以用多个矩阵表示这些权。</p><h2 id="2-关联矩阵表示法"><a href="#2-关联矩阵表示法" class="headerlink" title="2. 关联矩阵表示法"></a>2. 关联矩阵表示法</h2><p><img src="\img\graph_3.png" alt="img"><img src="\img\graph_4.png" alt="img"></p><p>　　也就是说，在关联矩阵中，<u>每行对应于图的一个节点，每列对应于图的一条弧</u>。如果一个节点是一条弧的起点，则关联矩阵中对应的元素为1；如果一个节点是一条弧的终点，则关联矩阵中对应的元素为 -1；如果一个节点与一条弧不关联，则关联矩阵中对应的元素为0。对于简单图，关联矩阵每列只含有两个非零元（一个 1，一个-1）可以看出，这种表示法也非常简单、直接。但是，在关联矩阵的所有$mn$ 个元素中，只有 $2m$个为非零元。如果网络比较稀疏，这种表示法也会浪费大量的存储空间。但由于关联矩阵有许多特别重要的理论性质，因此它在网络优化中是非常重要的概念。</p><p>　　同样，对于网络中的权，也可以通过对关联矩阵的扩展来表示。例如，如果网络中每条弧有一个权，我们可以把关联矩阵增加一行，把每一条弧所对应的权存储在增加的行中。如果网络中每条弧赋有多个权，我们可以把关联矩阵增加相应的行数，把每一条弧所对应的权存储在增加的行中。</p><h2 id="3-弧表示法"><a href="#3-弧表示法" class="headerlink" title="3.弧表示法"></a>3.弧表示法</h2><p><img src="\img\graph_5.png" alt="img"><img src="\img\graph_6.png" alt="img"></p><p>例如，例7所示的图，假设弧$(1,2)，(1,3)，(2,4)，(3,2)，(4,3)，(4,5)，(5,3)和(5,4)$上的权分别为$8，9，6，4，0，3，6和7$，则弧表表示如上：</p><p>为了便于检索，一般按照起点、终点的字典序顺序存储弧表，如上面的弧表就是按照这样的顺序存储的。</p><h2 id="4-邻接表表示法"><a href="#4-邻接表表示法" class="headerlink" title="4. 邻接表表示法"></a>4. 邻接表表示法</h2><p>　　邻接表表示法将图以邻接表（adjacency lists）的形式存储在计算机中。所谓图的邻接表，也就是图的所有节点的邻接表的集合；而对每个节点，它的邻接表就是它的所有出弧。邻接表表示法就是对图的每个节点，用一个单向链表列出从该节点出发的所有弧，链表中每个单元对应于一条出弧。为了记录弧上的权，链表中每个单元除列出弧的另一个端点外，还可以包含弧上的权等作为数据域。图的整个邻接表可以用一个指针数组表示。例如，例7所示的图，邻接表表示为</p><p><img src="\img\weighed_graph.png" alt="img"></p><h2 id="5-星形表示法"><a href="#5-星形表示法" class="headerlink" title="5.星形表示法"></a>5.星形表示法</h2><p>星形（star）表示法的思想与邻接表表示法的思想有一定的相似之处。对每个节点，它也是记录从该节点出发的所有弧，但它不是采用单向链表而是采用一个单一的数组表示。也就是说，在该数组中首先存放从节点1出发的所有弧，然后接着存放从节点2出发的所有孤，依此类推，最后存放从节点 出发的所有孤。对每条弧，要依次存放其起点、终点、权的数值等有关信息。这实际上相当于对所有弧给出了一个顺序和编号，只是从同一节点出发的弧的顺序可以任意排列。此外，为了能够快速检索从每个节点出发的所有弧，我们一般还用一个数组记录每个节点出发的弧的起始地址（即弧的编号）。在这种表示法中，可以快速检索从每个节点出发的所有弧，这种星形表示法称为前向星形（forward star）表示法。</p><p>例如，在例7所示的图中，仍然假设弧（1,2），（l,3），（2,4），（3,2），（4,3），（4,5），（5,3）和（5,4）上的权分别为8，9，6，4，0，3，6和7。此时该网络图可以用前向星形表示法表示如下：</p><p><img src="\img\graph_7.png" alt="img"><img src="\img\graph_8.png" alt="img"></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">邻接矩阵（暴力）</th><th style="text-align:center">邻接表（类似链表）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>使用范围</strong></td><td style="text-align:center">稠密图</td><td style="text-align:center">主要是稀疏图</td></tr><tr><td style="text-align:center"><strong>空间耗费</strong></td><td style="text-align:center">$n^2$（ n<em>n</em>为点个数）</td><td style="text-align:center">理论上是 $e$（ $e$为边条数）</td></tr><tr><td style="text-align:center"><strong>实现方式</strong></td><td style="text-align:center">二维数组</td><td style="text-align:center">数组模拟链表、 $vector$</td></tr></tbody></table></div><hr><h1 id="Dijsktra算法"><a href="#Dijsktra算法" class="headerlink" title="Dijsktra算法"></a>Dijsktra算法</h1><blockquote><p><a href="https://www.luogu.com.cn/blog/FrozaFerrari/xue-tu-lun-ni-zhen-di-liao-xie-zui-duan-lu-ma-post">米奇妙妙屋</a></p></blockquote><p>先用邻接矩阵存储数据，考虑采用一个二重循环，每次寻找出距离集合最近的一个点，然后数组标记它已经加入集合，然后在用当前点对不在集合中的点进行松弛，进行 <em>n</em> 次，整个操作就完成了,注意起点对应的最小距离是0.</p><p><strong>cpp代码</strong></p><p>数据预处理</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;weight_type, <span class="hljs-keyword">int</span>&gt;&gt; e[<span class="hljs-number">10005</span>];<span class="hljs-comment">//这个vector的元素类型为&lt;weight_type,int&gt;,第一个存储到当前点的权重，第二个存储顶点，长度为10005</span><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">10005</span>];<span class="hljs-comment">//表示当前点是否被访问,为什么是10005因为题目要求2 &lt;= n &lt;= 10^4</span><span class="hljs-keyword">int</span> edge_len;<span class="hljs-comment">//边的个数</span><span class="hljs-keyword">int</span> vetice_num;<span class="hljs-comment">//顶点个数</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vetice;<span class="hljs-comment">//包含所有顶点的vector  </span><span class="hljs-keyword">int</span> n;<span class="hljs-comment">// 顶点个数</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<span class="hljs-comment">//边数组</span><span class="hljs-built_in">vector</span>&lt;weight_type&gt; weight;<span class="hljs-comment">//权重数组，和边数组对应</span><span class="hljs-comment">//**重要，初始化图，根据题目修改相应入口参数</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * @description: 初始化图</span><span class="hljs-comment"> * @param &#123;type&#125; //n为顶点的个数，edges为边个数，s为对应权重，start为起点，end为终点,direct是true为双向,false为单向</span><span class="hljs-comment"> * @return &#123;type&#125; Null</span><span class="hljs-comment"> * @author: Durant Thorvals</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, <span class="hljs-built_in">vector</span>&lt;weight_type&gt;&amp; s, <span class="hljs-keyword">bool</span> direct)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">this</span>-&gt;n = n;    <span class="hljs-keyword">this</span>-&gt;edges = edges;    <span class="hljs-keyword">this</span>-&gt;weight = s;    edge_len = edges.size();<span class="hljs-comment">//边的个数</span>    vetice_num = n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;edge_len;i++)    &#123;        e[edges[i][<span class="hljs-number">0</span>]].push_back(&#123;s[i],edges[i][<span class="hljs-number">1</span>]&#125;);        <span class="hljs-keyword">if</span>(direct) e[edges[i][<span class="hljs-number">1</span>]].push_back(&#123;s[i],edges[i][<span class="hljs-number">0</span>]&#125;);<span class="hljs-comment">//因为是双向的，所以要再加一条相反的边     </span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edge_len;i++)    &#123;            <span class="hljs-keyword">if</span>(!count(vetice.begin(),vetice.end(),edges[i][<span class="hljs-number">0</span>])) vetice.push_back(edges[i][<span class="hljs-number">0</span>]);            <span class="hljs-keyword">if</span>(!count(vetice.begin(),vetice.end(),edges[i][<span class="hljs-number">1</span>])) vetice.push_back(edges[i][<span class="hljs-number">1</span>]);    &#125;&#125;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;left, T <span class="hljs-keyword">const</span> &amp;right)</span></span><span class="hljs-function">    </span>&#123;    <span class="hljs-comment">// 以y比较。输出结果为y较大的在前y相同时，先进入队列的元素在前。</span>        <span class="hljs-keyword">return</span> (left.first &gt; right.first); <span class="hljs-comment">// left.first在后面，顶部元素first最大</span>    &#125;&#125;;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;weight_type,<span class="hljs-keyword">int</span>&gt; data;<span class="hljs-function">weight_type <span class="hljs-title">dijkstra</span><span class="hljs-params">( <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<span class="hljs-comment">//不能处理带负权的边</span>    <span class="hljs-keyword">if</span>(start == end ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//优先队列是按照pair的第一个元素进行排序</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;weight_type&gt; <span class="hljs-title">minDis</span><span class="hljs-params">(vetice_num,INT32_MAX)</span></span>;<span class="hljs-comment">//与e不同的是，存储的是最大的权重</span>    <span class="hljs-built_in">priority_queue</span>&lt;data,<span class="hljs-built_in">vector</span>&lt;data&gt;,cmp&lt;data&gt;&gt; pq;<span class="hljs-comment">//用一个优先队列，顶部是权重最小的，这样可以把时间复杂度降低至O((e+n)logn)</span>        pq.push(&#123;<span class="hljs-number">0</span>,start&#125;);<span class="hljs-comment">//相乘值从1.0开始, 如果是cost从0开始</span>    minDis[start] = <span class="hljs-number">0</span>;<span class="hljs-comment">//同上</span>    <span class="hljs-keyword">while</span>(!pq.empty()&amp;&amp;pq.top().second!=end)<span class="hljs-comment">//队列不为空</span>    &#123;        <span class="hljs-keyword">auto</span> cur  = pq.top().second;<span class="hljs-comment">//w表示权重，v表示节点</span>        pq.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:e[cur])<span class="hljs-comment">//搜寻与当前节点k相邻的所有节点</span>        &#123;            <span class="hljs-keyword">int</span> dis = t.first;            <span class="hljs-keyword">int</span> nextnode = t.second;            <span class="hljs-keyword">if</span>((minDis[cur] + dis) &lt; minDis[nextnode])           &#123;                 minDis[nextnode] = minDis[cur] + dis;                  pq.push(&#123;minDis[nextnode],nextnode&#125;);<span class="hljs-comment">//则加入到优先队列之中</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> minDis[end]==INT32_MIN?<span class="hljs-number">-1</span>:minDis[end];    &#125;</code></pre><p>当然也可以采用匿名函数, 这样的话将减少优先队列空间占用。</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> cmp = [&amp;minDis](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; right)&#123;      <span class="hljs-keyword">return</span> minDis[left] &gt; minDis[right];&#125;;<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt;pq(cmp);</code></pre><p>Java</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> INTL = <span class="hljs-number">0x3f3f3f3f_3f3f3f3fl</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNABLE2REACH = -<span class="hljs-number">1</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * A simple implementation of Dijkstra algorithm.</span><span class="hljs-comment"> * Time complexity: O(VlogV+E), where E is the number of edges, and V denotes the number of vertices.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> verticesCnt the number of vertices in the graph</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> graph every 1D array should be &#123;from, to, weight&#125; with no duplicated or negative-weighted edge</span><span class="hljs-comment"> *              the from and to values should be in the range [0, verticesCnt)</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> src the source node of Dijkstra algorithm</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> des the destination node of Dijkstra algorithm</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the minimal cost from src to des</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> verticesCnt, <span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> des)</span> </span>&#123;<span class="hljs-keyword">if</span>(src == des) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//preprocessing the graph</span>List&lt;<span class="hljs-keyword">int</span>[]&gt;[] edges = <span class="hljs-keyword">new</span> List[verticesCnt];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; verticesCnt;i++)&#123;    edges[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge:graph)&#123;    <span class="hljs-keyword">int</span> from = edge[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> to = edge[<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> cost = edge[<span class="hljs-number">2</span>];    edges[from].add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;to,cost&#125;);<span class="hljs-comment">//&#123;from:&#123;to,cost&#125;&#125;</span>    edges[to].add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;from,cost&#125;);&#125;<span class="hljs-keyword">int</span>[] minDis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[verticesCnt];Arrays.fill(minDis,INF);minDis[src] = <span class="hljs-number">0</span>;PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(        <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;                <span class="hljs-keyword">return</span> Integer.compare(minDis[o1],minDis[o2]);            &#125;        &#125;);pq.offer(src);<span class="hljs-comment">//压入队列</span><span class="hljs-keyword">while</span>(!pq.isEmpty()&amp;&amp;pq.peek()!=des)&#123;    <span class="hljs-keyword">int</span> cur = pq.poll();<span class="hljs-comment">//取顶元素并弹队列</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] next:edges[cur])    &#123;        <span class="hljs-keyword">int</span> nextnode = next[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> dis = next[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>( (dis + minDis[cur]) &lt; minDis[nextnode])        &#123;            minDis[nextnode] = dis + minDis[cur];            pq.offer(nextnode);        &#125;    &#125;&#125;<span class="hljs-keyword">return</span> (minDis[des] == INF)? UNABLE2REACH:minDis[des];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东方不败-&gt;回文问题</title>
    <link href="/2020/07/21/2020-08-19-manacher/"/>
    <url>/2020/07/21/2020-08-19-manacher/</url>
    
    <content type="html"><![CDATA[<h1 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h1><blockquote><p>直觉上：回文≈难题，LC上的回文难题, 但是总不能指望面试/周赛出中等题吧?</p></blockquote><ul><li><ol><li>回文对</li></ol></li><li><p>214.最短回文串</p></li><li><ol><li>分割回文串</li></ol></li><li><ol><li>统计不同的回文子序列</li></ol></li><li><ol><li>超级回文数</li></ol></li><li><ol><li>段式回文</li></ol></li><li>…</li></ul><h2 id="1-线性时间内解决回文串问题——Manacher算法-竞赛难度"><a href="#1-线性时间内解决回文串问题——Manacher算法-竞赛难度" class="headerlink" title="1. 线性时间内解决回文串问题——Manacher算法 {竞赛难度}"></a>1. 线性时间内解决回文串问题——Manacher算法 {竞赛难度}</h2><p>Manacher 算法是在<strong>线性时间</strong>!内求解最长回文子串的算法。在本题中，我们要求解回文串的个数，为什么也能使用 Manacher 算法呢？这里我们就需要理解一下 Manacher 的基本原理。</p><p>Manacher 算法的处理方式是在所有的相邻字符中间插入 $#$，比如 $abaaabaa$ 会被处理成 $#a#b#a#a#a#b#a#a#$，这样可以保证所有找到的回文串都是奇数长度的(因为$n+n+1=2n+1$)，以任意一个字符为回文中心，既可以包含原来的奇数长度的情况，也可以包含原来偶数长度的情况。假设原字符串为 $S$，经过这个处理之后的字符串为 $s$。</p><p>我们用 $f(i)$ 来表示以 $s$ 的第 $i$ 位为回文中心，可以拓展出的最大回文半径，那么 $f(i) - 1$ 就是以 $i$为中心的最大回文串长度 （想一想为什么）。</p><p>Manacher 算法依旧需要枚举 $s$ 的每一个位置并先假设它是回文中心，但是它会利用已经计算出来的状态来更新 $f(i)$，而不是向「中心拓展」一样盲目地拓展。具体地说，假设我们已经计算好了 $[1, i - 1] $区间内所有点的 $f$（即我们知道 $[1, i - 1] $这些点作为回文中心时候的最大半径）， 那么我们也就知道了 $[1, i - 1]$ 拓展出的回文达到最大半径时的回文右端点。例如 $i = 4$的时候 $f(i) = 5$，说明以第 4 个元素为回文中心，最大能拓展到的回文半径是 5，此时右端点为 $4 + 5 - 1 = 8$。所以当我们知道一个 $i$ 对应的 $f(i)$ 的时候，我们就可以很容易得到它的右端点为 $i + f(i) - 1$。</p><p>Manacher 算法如何通过已经计算出的状态来更新 $f(i)$ 呢？Manacher 算法要求我们维护「当前最大的回文的右端点 $r_m$」以及这个回文右端点对应的回文中心 $i_m$ 。我们需要顺序遍历 $s$，假设当前遍历的下标为 $i$。我们知道在求解 $f(i)$ 之前我们应当已经得到了从 $[1, i - 1]$ 所有的 $f$，并且当前已经有了一个最大回文右端点 $r_m$ 以及它对应的回文中心 $i_m$。</p><p><strong>初始化 $f(i)$</strong></p><ul><li>如果 $i \leq r_m$，说明 $i$ 被包含在当前最大回文子串内，假设 $j$ 是 $i $关于这个最大回文的回文中心 $i_m$的对称位置（即 $j + i = 2 \times i_m$），我们可以得到 $f(i)$ 至少等于 $\min\{f(j), r_m - i + 1\}$。这里将 $f(j)$ 和 $r_m - i + 1$取小，是先要保证这个回文串在当前最大回文串内。（思考：为什么 $f(j)$ 有可能大于 $r_m - i + 1$？）如果 $i &gt; r_m$，那就先初始化 $f(i) = 1$。</li></ul><p><strong>中心拓展</strong></p><ul><li>做完初始化之后，我们可以保证此时的$s[i + f(i) - 1] = s[i - f(i) + 1]$，要继续拓展这个区间，我们就要继续判断 $s[i + f(i)]$和 $s[i - f(i)]$是否相等，如果相等将 $f(i)$自增；这样循环直到 $s[i + f(i)] \neq s[i - f(i)]$，以此类推。我们可以看出循环每次结束时都能保证$ s[i + f(i) - 1] = s[i - f(i) + 1]$，而循环继续（即可拓展的条件）一定是 $s[i + f(i)] = s[i - f(i)]$。 这个时候我们需要注意的是不能让下标越界，有一个很简单的办法，就是在开头加一个 $\$$，并在结尾加一个 $!$，这样开头和结尾的两个字符一定不相等，循环就可以在这里终止。<br>这样我们可以得到 $s$ 所有点为中心的最大回文半径，也就能够得到 $S$ 中所有可能的回文中心的的最大回文半径，把它们累加就可以得到答案。</li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.size();        <span class="hljs-built_in">string</span> t = <span class="hljs-string">&quot;$#&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c: s) &#123;            t += c;            t += <span class="hljs-string">&#x27;#&#x27;</span>;        &#125;        n = t.size();        t += <span class="hljs-string">&#x27;!&#x27;</span>;        <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; (n);        <span class="hljs-keyword">int</span> iMax = <span class="hljs-number">0</span>, rMax = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;            <span class="hljs-comment">// 初始化 f[i]</span>            f[i] = (i &lt;= rMax) ? min(rMax - i + <span class="hljs-number">1</span>, f[<span class="hljs-number">2</span> * iMax - i]) : <span class="hljs-number">1</span>;            <span class="hljs-comment">// 中心拓展</span>            <span class="hljs-keyword">while</span> (t[i + f[i]] == t[i - f[i]]) ++f[i];            <span class="hljs-comment">// 动态维护 iMax 和 rMax</span>            <span class="hljs-keyword">if</span> (i + f[i] - <span class="hljs-number">1</span> &gt; rMax) &#123;                iMax = i;                rMax = i + f[i] - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span>            ans += (f[i] / <span class="hljs-number">2</span>);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h2 id="2-Rabin-Karp编码"><a href="#2-Rabin-Karp编码" class="headerlink" title="2. Rabin-Karp编码"></a>2. Rabin-Karp编码</h2><hr><h4 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214. 最短回文串"></a><a href="https://leetcode-cn.com/problems/shortest-palindrome/">214. 最短回文串</a></h4><p>给定一个字符串 <strong><em>s</em></strong>，你可以通过在字符串<strong>前面</strong>添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><p><strong>示例 1:</strong></p><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;aacecaaa&quot;</span>输出: <span class="hljs-string">&quot;aaacecaaa&quot;</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;abcd&quot;</span>输出: <span class="hljs-string">&quot;dcbabcd&quot;</span></code></pre><hr><p>我们可以用Rabin-Karp编码判断一个子集是否为回文串, 设$ASCII(i)$表示字符的ascii码.</p><p>$base$可以取比整个字符集大的素数, $mod$可以取一个很大的幂加上一个素数,比如$10^5+7$. $f(i)和\hat{f(i)}$分别表示字符串编码和对应的回文串编码.</p><script type="math/tex; mode=display">f(i) = f(i-1)*base\% mod + s[i]\\\hat{f(i)} = (\hat{f(i-1)} +s[i]*base^i)\%mod</script><p>由于题目只要求在字符串前加字符,因此可以判断$s$中最长回文前缀,</p><p>代码如下:</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">shortestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-comment">//思路，回文数判断：Manacher算法</span>        <span class="hljs-comment">//反过来思考：去掉最少几个字符它将称为回文数</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, mul = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> base = <span class="hljs-number">157</span>, mod = <span class="hljs-number">1E5</span>+<span class="hljs-number">7</span>;        <span class="hljs-keyword">int</span>  loc = <span class="hljs-number">1</span>;         <span class="hljs-keyword">int</span> n = s.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            left = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)left*base%mod + (<span class="hljs-keyword">int</span>)s[i];            right = (right+ (<span class="hljs-keyword">int</span>)s[i]*mul)%mod;            <span class="hljs-keyword">if</span>(left == right)             &#123;                loc = i;            &#125;            mul = (mul*base)%mod;         &#125;        <span class="hljs-built_in">string</span> add = (loc==n<span class="hljs-number">-1</span>)?<span class="hljs-string">&quot;&quot;</span>:s.substr(loc,n-loc);        reverse(add.begin(),add.end());        <span class="hljs-keyword">return</span> (add+s);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(|s|)$。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a>336. 回文对</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>回文</tag>
      
      <tag>manacher算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解华容道</title>
    <link href="/2020/07/21/2020-7-28-HuaRongDao/"/>
    <url>/2020/07/21/2020-7-28-HuaRongDao/</url>
    
    <content type="html"><![CDATA[<h1 id="解华容道问题"><a href="#解华容道问题" class="headerlink" title="解华容道问题"></a>解华容道问题</h1><h2 id="状态空间表示法及搜索策略"><a href="#状态空间表示法及搜索策略" class="headerlink" title="状态空间表示法及搜索策略"></a>状态空间表示法及搜索策略</h2><p>华容道问题，如下所示，在一个8x9的棋盘内，曹操要躲过五虎上将的围剿，成功从下方撤离华容道。卒子大小1x1，赵云，马超，黄忠，张飞均为1x2，关羽为2x1.</p><p><img src="https://img-blog.csdn.net/20161002102820064" alt="同质"></p><hr><p>我们不妨从简单问题出发，考虑一个3x3的华容道问题。</p><p><img src="https://exp-picture.cdn.bcebos.com/025d87c0affce18685f722c61f1fbee435daeb6c.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt="数字华容道游戏3X3模式怎么过？"></p><p>在搜索时需要解决的基本问题：</p><ul><li>搜索过程能否一定能找到一个解</li><li>找到一个解，是否为最优解</li><li>时间与空间复杂度如何</li><li>搜索过程是否终止运行或者陷入一个死循环</li></ul><p><strong>基本定义</strong></p><ol><li>状态（State）：描述问题在任一时刻所处状态的数据结构。</li><li>初始状态集S0，和目标状态集G</li><li>操作Operator：状态之间的转换函数</li><li>状态空间：四元组$（S，O，S_0，G）$</li></ol><p><strong>搜索分类</strong></p><p><code>盲目搜索</code>：在特定问题不具有任何相关信息，包括DFS和BFS。</p><p><code>启发式搜索</code>:考虑特定问题领域可应用的知识，动态地确定调用操作算子的步骤。优先选择较合适的操作算子，尽量减少不必要的搜索，以尽快到达目标状态。</p><blockquote><p>A*启发式搜索</p></blockquote><p>A*核心的思想是 <script type="math/tex">f(n)=g(n)+h(n)</script></p><p><script type="math/tex">f(n)</script>是节点n的综合优先级，<script type="math/tex">g(n)</script>是节点n距离起点的代价，<script type="math/tex">h(n)</script>是节点n距离终点的预计代价，也即启发函数,显然<script type="math/tex">h(n)</script>的好坏直接关乎到算法的好坏，一般而言<script type="math/tex">h(n)</script>比最优解大，一定是错误的，没有任何意义，<script type="math/tex">h(n)</script>与最优解相同，是理想状态；如果<script type="math/tex">h(n)</script>比最优解小，那么相差越大性能越差。一般用<code>open_set</code>来表示待遍历的节点，<code>close_set</code>表示已经遍历过的节点。</p><p>为了避免重复搜索或者陷入死循环，我们需要记录已经经历的状态，以及为了回溯，我们需要另外一个表记录相邻的状态。</p><p>设网格大小4x4, 给定任意初始状态S,请返回达到目标状态G所需要的最小步骤数.</p><blockquote><p>我们可以把华容道问题转换为并查集，每次只能交换空白方块和邻近方块，</p><p>在最好的情况下，所有块都排好了，那么这样交换次数为 $N-N$</p><p>在最坏情况下，</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【面试向】排序算法</title>
    <link href="/2020/07/21/2020-7-30-sorting-magic/"/>
    <url>/2020/07/21/2020-7-30-sorting-magic/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>排序算法及例题</p>          </div><h1 id="面试基础之排序算法"><a href="#面试基础之排序算法" class="headerlink" title="面试基础之排序算法"></a>面试基础之排序算法</h1><p><img src="\img\Sorting comparation.png" alt="Sorting comparation"></p><p>题目</p><ul><li><ol><li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前k个高频元素</a></li></ol></li></ul><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1. 快速排序"></a>1. 快速排序</h2><blockquote><p>面试要点：平均时间复杂度$O(N\log N)$，最好情况$O(N\log N)$，最坏情况$O(N^2)$,空间复杂度O($\log N$)</p></blockquote><p>快速排序非常神奇但是很容易忘记，因此需要经常记忆。</p><p>快速排序$a[l…r]$是一个典型的分治算法，参考《算法导论》第七章P95。</p><ul><li><strong>分解</strong>，将数组$a[l…r]$以$q$为分阶段划分为两个数组。使得一个数组元素完全小于另一个，即$a[l…q-1]\le a[q]\le a[q+1…r]$</li><li><strong>解决，</strong>通过递归调用快速排序，对子数组进行排序</li><li><strong>合并</strong>，因为子数组是按原址排序的，所以不需要合并操作。</li></ul><p>由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 $x$最终位置为 $q$，并且保证 $a[l⋯q−1] $中的每个元素小于等于 $a[q]$，且 $a[q]$ 小于等于 $a[q+1⋯r]$ 中的每个元素。所以只要某次划分的 $q$为倒数第 $k$ 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 $a[l⋯q−1] $和 $a[q+1⋯r]$ 是否是有序的，我们不关心。</p><p>因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 $q$ 正好就是我们需要的下标，就直接返回 $a[q]$；否则，如果 $q$ 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;public:    <span class="hljs-built_in">int</span> quick<span class="hljs-constructor">Select(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">index</span>)</span> &#123;        <span class="hljs-built_in">int</span> q = random<span class="hljs-constructor">Partition(<span class="hljs-params">a</span>, <span class="hljs-params">l</span>, <span class="hljs-params">r</span>)</span>;        <span class="hljs-keyword">if</span> (q<span class="hljs-operator"> == </span>index) &#123;            return a<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            return q &lt; index ? quick<span class="hljs-constructor">Select(<span class="hljs-params">a</span>, <span class="hljs-params">q</span> + 1, <span class="hljs-params">r</span>, <span class="hljs-params">index</span>)</span> : quick<span class="hljs-constructor">Select(<span class="hljs-params">a</span>, <span class="hljs-params">l</span>, <span class="hljs-params">q</span> - 1, <span class="hljs-params">index</span>)</span>;        &#125;    &#125;    inline <span class="hljs-built_in">int</span> random<span class="hljs-constructor">Partition(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;        <span class="hljs-built_in">int</span> i = rand<span class="hljs-literal">()</span> % (r - l + <span class="hljs-number">1</span>) + l;        swap(a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, a<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>);        return partition(a, l, r);    &#125;    inline <span class="hljs-built_in">int</span> partition(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) &#123;        <span class="hljs-built_in">int</span> x = a<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>, i = l - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = l; j &lt; r; ++j) &#123;            <span class="hljs-keyword">if</span> (a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> &lt;= x) &#123;                swap(a<span class="hljs-literal">[<span class="hljs-operator">++</span><span class="hljs-identifier">i</span>]</span>, a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>);            &#125;        &#125;        swap(a<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>, a<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>);        return i + <span class="hljs-number">1</span>;    &#125;    void find<span class="hljs-constructor">KthLargest(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;        srand(time(<span class="hljs-number">0</span>));        return quick<span class="hljs-constructor">Select(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">nums</span>.<span class="hljs-params">size</span>()</span> - <span class="hljs-number">1</span>, nums.size<span class="hljs-literal">()</span> - k);    &#125;&#125;;</code></pre><p>​        </p><h2 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2. 堆排序"></a>2. 堆排序</h2><h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3. 归并排序"></a>3. 归并排序</h2><h2 id="x-拓扑排序"><a href="#x-拓扑排序" class="headerlink" title="x.拓扑排序"></a>x.拓扑排序</h2><p>LC 课程表问题系列：207 210</p><blockquote><p>核心特性，对于图G中任何一条有向边$(u,v)$，$u$在排列中都出现在$v$的前面，这样的排列称为「拓扑排序」。</p></blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）：</p><ul><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li><li>若图中存在环，则不存在拓扑排序</li></ul><p><strong><em>重点</em></strong>：如何判断有无环：如果某个节点的相邻节点处于探索状态（在visited中），但还未加入拓扑序列，则说明有环。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">graph</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,num</span>):</span>        self.graph = defaultdict(list)        self.visited = &#123;&#125;         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params">self,u,v</span>):</span>        self.graph[u].append(v)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canFinish</span>(<span class="hljs-params">self, numCourses: int, prerequisites: [[int]]</span>) -&gt; bool:</span>        g = graph(numCourses+<span class="hljs-number">1</span>)           topo_sort = []        <span class="hljs-keyword">for</span> lists <span class="hljs-keyword">in</span> prerequisites:            g.visited[lists[<span class="hljs-number">0</span>]] = <span class="hljs-literal">False</span>            <span class="hljs-keyword">for</span> i,it <span class="hljs-keyword">in</span> zip(range(<span class="hljs-number">1</span>,len(lists)), lists):                g.graph[lists[i]].append(lists[<span class="hljs-number">0</span>])                g.visited[lists[i]] = <span class="hljs-literal">False</span>                        isLoop = <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prerequisites <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> prerequisites[<span class="hljs-number">0</span>]: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-comment">#只要存在一种拓扑排序，返回true</span>        <span class="hljs-comment">#定义三种状态，未探索，探索中以及已经探索</span>        <span class="hljs-comment">#A-&gt;B: 表示A是B的先修课</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">vertex</span>):</span>            <span class="hljs-keyword">nonlocal</span> isLoop            <span class="hljs-keyword">if</span> isLoop: <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vertex <span class="hljs-keyword">in</span> g.graph.keys():                g.visited[vertex] = <span class="hljs-literal">True</span> <span class="hljs-comment">#标记为已经访问</span>                topo_sort.append(vertex)                <span class="hljs-keyword">return</span> <span class="hljs-comment">#如果已经访问则跳过</span>            g.visited[vertex] = <span class="hljs-literal">True</span> <span class="hljs-comment">#标记为已经访问</span>            <span class="hljs-keyword">for</span> neigbor <span class="hljs-keyword">in</span> g.graph[vertex]:<span class="hljs-comment">#遍历邻接顶点</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> g.visited[neigbor] :                    dfs(neigbor)                <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> neigbor <span class="hljs-keyword">in</span> topo_sort:<span class="hljs-comment">#如果某个节点的相邻节点处于探索状态（在visited中），但还未加入拓扑序列，则说明有环</span>                    isLoop = <span class="hljs-literal">True</span>                    <span class="hljs-keyword">return</span>             topo_sort.append(vertex)                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> g.graph.keys():            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isLoop <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> g.visited[v]:                dfs(v)                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> isLoop</code></pre><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度: $O(n+m)$，其中 $n$ 为课程数，$m$ 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p><p>空间复杂度: $O(n+m)$。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 $O(n+m)$。在深度优先搜索的过程中，我们需要最多 $O(n)$ 的栈空间（递归）进行深度优先搜索，并且还需要若干个 $O(n)$ 的空间存储节点状态、最终答案等。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神奇的多指针</title>
    <link href="/2020/07/21/2020-7-30-pointers/"/>
    <url>/2020/07/21/2020-7-30-pointers/</url>
    
    <content type="html"><![CDATA[<h1 id="多指针问题"><a href="#多指针问题" class="headerlink" title="多指针问题"></a>多指针问题</h1><hr><blockquote><p>75.<a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p><p>1574.<a href="https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">删除最短的子数组使剩余数组有序</a></p><ol><li><p><a href="https://leetcode-cn.com/problems/string-compression/">压缩字符串</a></p></li><li><p>环形链表II（快慢指针）</p></li></ol></blockquote><p>很多时候多指针（双指针，三指针，快慢指针）能极大的帮助我们降低时间复杂度。</p><p>比如求链表到数第N个节点，以及判断链表中是否有环。</p><p>首先我们介绍Floyd判圈法</p><h2 id="Floyd判圈法"><a href="#Floyd判圈法" class="headerlink" title="Floyd判圈法"></a>Floyd判圈法</h2><p><strong>想法</strong></p><p>当然一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。</p><p><strong>算法</strong></p><p>Floyd 的算法被划分成两个不同的 阶段 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 null 并退出。否则，用 相遇节点 来找到环的入口。</p><p>阶段 1</p><p>这里我们初始化两个指针 - 快指针和慢指针。我们每次移动慢指针一步、快指针两步，直到快指针无法继续往前移动。如果在某次移动后，快慢指针指向了同一个节点，我们就返回它。否则，我们继续，直到 while 循环终止且没有返回任何节点，这种情况说明没有成环，我们返回 null 。</p><p>下图说明了这个算法的工作方式：</p><p><img src="\img\floyd.jpg" alt="image.png" style="zoom:50%;" /></p><p>环中的节点从 0 到 $C-1$ 编号，其中 $C$ 是环的长度。非环节点从 $-F$ 到 $−1 $编号，其中 $F$ 是环以外节点的数目。 $F$ 次迭代以后，慢指针指向了 0 且快指针指向某个节点 $h$ ，其中 $F≡h(modC)$ 。这是因为快指针在 $F$ 次迭代中遍历了 $2F$ 个节点，且恰好有 $F$ 个在环中。继续迭代 $C-h$ 次，慢指针显然指向第 $C-h$ 号节点，而快指针也会指向相同的节点。原因在于，快指针从 $h$ 号节点出发遍历了 $2(C-h)$ 个节点。</p><script type="math/tex; mode=display">h+2(C−h)=2C−h≡C−h(modC)</script><p>因此，如果列表是有环的，快指针和慢指针最后会同时指向同一个节点，因此被称为 <strong>相遇</strong> 。</p><p>阶段 2</p><p>给定阶段 1 找到的相遇点，阶段 2 将找到环的入口。首先我们初始化额外的两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p><p>下面的图将更好的帮助理解和证明这个方法的正确性。</p><p><img src="\img\floyd2.jpg" alt="image.png" style="zoom:50%;" /></p><p>我们利用已知的条件：慢指针移动 1 步，快指针移动 2 步，来说明它们相遇在环的入口处。（下面证明中的 tortoise 表示慢指针，hare 表示快指针）</p><script type="math/tex; mode=display">\begin{aligned} 2 \cdot distance(tortoise) &= distance(hare) \\ 2(F+a) &= F+a+b+a \\ 2F+2a &= F+2a+b \\ F &= b \\ \end{aligned}</script><p>因为 $F=b$ ，指针从 $h$ 点出发和从链表的头出发，最后会遍历相同数目的节点后在环的入口处相遇。</p><p>444题可作为练习。</p><hr><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]输出: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]</code></pre><hr><p>我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。</p><p><img src="\img\pointer1.jpg" alt="image.png"></p><p>此题思路很直观，本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p><p>但是细节很需要注意，细节往往能致人于死地。</p><ol><li>中间指针curr起始位置为0，不是1，为什么？</li><li>若nums[curr]==0，则与nums[p0]互换时curr++，而nums[curr]==1，curr不需要—，为什么？</li></ol><p>这两个问题实质是相同的，我们需要让curr在p0前面，去接近p1，相当于给你一个方向，你去前进。这样理解会不会好些。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>, mid =<span class="hljs-number">0</span>, end = nums.size()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(begin&lt;=mid &amp;&amp; mid&lt;=end)        &#123;            <span class="hljs-comment">// mid = begin;</span>            <span class="hljs-keyword">if</span>(nums[mid]==<span class="hljs-number">0</span>)            &#123;                swap(nums[mid],nums[begin]);                begin++;                mid ++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==<span class="hljs-number">2</span>)            &#123;                swap(nums[mid],nums[end]);                end--;            &#125;            <span class="hljs-keyword">else</span> mid ++;                    &#125;    &#125;&#125;;</code></pre><hr><h2 id="1574-删除最短的子数组使剩余数组有序"><a href="#1574-删除最短的子数组使剩余数组有序" class="headerlink" title="1574.删除最短的子数组使剩余数组有序"></a>1574.<a href="https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">删除最短的子数组使剩余数组有序</a></h2><p>给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。</p><p>一个子数组指的是原数组中连续的一个子序列。</p><p>请你返回满足题目要求的最短子数组的长度。</p><p>示例 1：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]输出：<span class="hljs-number">3</span>解释：我们需要删除的最短子数组是 [<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] ，长度为 <span class="hljs-number">3</span> 。剩余元素形成非递减数组 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 。</code></pre><p>另一个正确的解为删除子数组 [3,10,4] 。<br>示例 2：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">4</span>解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 <span class="hljs-number">4</span> 的子数组，要么删除 [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]，要么删除 [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]。</code></pre><p>示例 3：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">0</span>解释：数组已经是非递减的了，我们不需要删除任何元素。</code></pre><p>示例 4：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">1</span>]输出：<span class="hljs-number">0</span></code></pre><p>提示：</p><p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>0 &lt;= arr[i] &lt;= 10^9</code></p><hr><p>双指针，先找出最大有序前缀pre和最大有序后缀suf, 若pre==n则表示全部有序，若pre == suf &amp;&amp; suf == 0则表示全部逆序</p><p>  前缀指针i和后缀指针j，i从0开始，j从后缀起点开始, </p><ul><li><p>如果arr[i] &lt;= arr[j]，则表示[0:i]和[j:-1]可以形成升序，计算值并和min比较</p><p>然后前缀指针右移，选择更大的值进行比较</p></li><li><p>如果arr[i] &gt; arr[j]，则表示后缀值过小，后缀向后移直到能形成升序</p></li></ul><p>「左指针是用来缩小距离，右指针是用来组成非降序」！</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfShortestSubarray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;    <span class="hljs-keyword">if</span>(arr.size()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//双指针，先找出最大有序前缀pre和最大有序后缀suf</span>    <span class="hljs-comment">//若pre==n则表示全部有序，若pre == suf &amp;&amp; suf == 0则表示全部逆序</span>    <span class="hljs-comment">// 前缀指针i和后缀指针j，i从0开始，j从后缀起点开始</span>    <span class="hljs-comment">// 如果arr[i] &lt;= arr[j]，则表示[0:i]和[j:-1]可以形成升序，计算值并和min比较</span>    <span class="hljs-comment">//然后前缀指针右移，选择更大的值进行比较</span>    <span class="hljs-comment">// 如果arr[i] &gt; arr[j]，则表示后缀值过小，后缀向后移直到能形成升序</span>    <span class="hljs-comment">//前缀指针的作用是缩小距离，后缀指针作用是形成升序</span>    <span class="hljs-keyword">int</span> n = arr.size();    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, suf = n<span class="hljs-number">-1</span>;<span class="hljs-comment">//分别记录最长前缀的下标和最长后缀的下标</span>    <span class="hljs-keyword">while</span>(pre+<span class="hljs-number">1</span>&lt;n &amp;&amp; arr[pre] &lt;= arr[pre+<span class="hljs-number">1</span>]) pre++;    <span class="hljs-keyword">while</span>(suf&gt;<span class="hljs-number">0</span> &amp;&amp; arr[suf<span class="hljs-number">-1</span>] &lt;= arr[suf]) suf--;    <span class="hljs-keyword">if</span>(pre+<span class="hljs-number">1</span> == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//全部升序</span>    <span class="hljs-keyword">if</span>(suf == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//全部逆序</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = suf;        <span class="hljs-comment">//只选择前缀或后缀需要删除的最小数量</span>    <span class="hljs-keyword">int</span> res = min(n-pre<span class="hljs-number">-1</span>, suf);    <span class="hljs-keyword">while</span>(i&lt;=pre &amp;&amp; j&lt;n  &amp;&amp; i &lt;= j)    <span class="hljs-keyword">if</span>(arr[i] &lt;= arr[j])             res = min(res,j-(++i));    <span class="hljs-keyword">else</span> j++;    <span class="hljs-keyword">return</span> res;        &#125;&#125;;</code></pre><p>时间复杂度: $O(N)$, </p><p>空间复杂度：$O(1)$</p><hr><h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></h2><p>给定一组字符，使用<a href="https://baike.baidu.com/item/原地算法">原地算法</a>将其压缩。</p><p>压缩后的长度必须始终小于或等于原数组长度。</p><p>数组的每个元素应该是长度为1 的<strong>字符</strong>（不是 int 整数类型）。</p><p>在完成<a href="https://baike.baidu.com/item/原地算法">原地</a><strong>修改输入数组</strong>后，返回数组的新长度。</p><p><strong>进阶：</strong><br>你能否仅使用O(1) 空间解决问题？</p><p><strong>示例 1：</strong></p><pre><code class="hljs smalltalk">输入：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>]输出：返回 <span class="hljs-number">6</span> ，输入数组的前 <span class="hljs-number">6</span> 个字符应该是：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;2&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;2&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>,<span class="hljs-comment">&quot;3&quot;</span>]说明：<span class="hljs-comment">&quot;aa&quot;</span> 被 <span class="hljs-comment">&quot;a2&quot;</span> 替代。<span class="hljs-comment">&quot;bb&quot;</span> 被 <span class="hljs-comment">&quot;b2&quot;</span> 替代。<span class="hljs-comment">&quot;ccc&quot;</span> 被 <span class="hljs-comment">&quot;c3&quot;</span> 替代。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>]</span>输出：返回 1 ，输入数组的前 1 个字符应该是：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>]</span>解释：没有任何字符串被替代。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs smalltalk">输入：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>]输出：返回 <span class="hljs-number">4</span> ，输入数组的前<span class="hljs-number">4</span>个字符应该是：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;1&quot;</span>,<span class="hljs-comment">&quot;2&quot;</span>]。解释：由于字符 <span class="hljs-comment">&quot;a&quot;</span> 不重复，所以不会被压缩。<span class="hljs-comment">&quot;bbbbbbbbbbbb&quot;</span> 被 “b12” 替代。注意每个数字在数组中都有它自己的位置。</code></pre><p><strong>提示：</strong></p><ul><li>所有字符都有一个ASCII值在<code>[35, 126]</code>区间内。</li><li><code>1 &lt;= len(chars) &lt;= 1000</code>。</li></ul><hr><p>使用双指针，将产生立竿见影的效果。</p><p>用一个指针p1作为锚点，指示一个特定字符，而p2则在p1基础上进行滑动，计算后面有多少个与锚点相同的字符。p4用于指示下一个锚点，是所有指针中最快的，res用于记录原地替换的长度。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars)</span> </span>&#123;        <span class="hljs-comment">//使用双指针,注意原地替换只考虑被替换部分的值</span>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>,p4 = <span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = chars.length;        <span class="hljs-keyword">while</span>(p1 &lt; n)        &#123;            <span class="hljs-keyword">char</span> c = chars[p1];            p2 = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(p4 &lt; n &amp;&amp; chars[p4] == c) &#123;p2++;p4++;&#125;            chars[res++] = c;            <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;            <span class="hljs-comment">//将p2按位分解进行替换</span>            p1 = p4;            <span class="hljs-keyword">if</span>(p2&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果只有一个字符则不进行替换</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> it: (<span class="hljs-string">&quot;&quot;</span> + p2).toCharArray())            &#123;                chars[res++] = it;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p>这里使用了技巧</p><p><code>(&quot;&quot; + p2).toCharArray()</code>将整型数直接转换为字符数组进行操作。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，其中 $N$ 是 <code>chars</code> 的长度。</li><li>空间复杂度：$O(1)$，三个指针的占用空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口，滑动的艺术</title>
    <link href="/2020/07/21/2020-8-1-sliding-windows/"/>
    <url>/2020/07/21/2020-8-1-sliding-windows/</url>
    
    <content type="html"><![CDATA[<blockquote><p>滑动窗口是面试中一大难点，幸运的是我们有模板</p></blockquote><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>Sliding Windows，是一类很看重细节的问题，题目通常为<code>Medium</code>或者<code>hard</code></p></blockquote><ol><li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">最小区间</a>(hard)</p></li><li><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></p></li><li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p></li><li><p><a href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列</a></p></li></ol><hr><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><pre><code class="hljs nix">输入: <span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-attr">T</span> = <span class="hljs-string">&quot;ABC&quot;</span>输出: <span class="hljs-string">&quot;BANC&quot;</span></code></pre><p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><hr><p>在滑动窗口中有两个指针，一个指针静止，而另一个指针保持移动。我们在s上滑动窗口，如果能够包含整个T（<strong>注意</strong>，T可能有重复字符），如果能收缩，我们就收缩窗口直到得到最小窗口。</p><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="fig1"></p><p>下面介绍一下滑动窗口法思路：</p><ol><li><p>我们在字符串S中使用左右指针技巧，初始化<code>left=right=0</code>，把索引<strong>左闭右开区间</strong><code>[left,right)</code>称为一个<code>窗口</code>。</p></li><li><p>我们先不断增加<code>right</code>指针扩大窗口，直到窗口中的字符串满足要求。</p></li><li><p>此时我们停止增加 <code>right</code>，转而不断增加<code>left</code>指针缩小窗口，直到窗口中的字符串不再满足要求。同时，每增加<code>left</code>，我们都要更新一轮结果。</p></li><li><p>重复2,3直到<code>right</code>到达字符串S的尽头。</p></li></ol><p>滑动窗口的基本框架</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(right&lt;s.size())&#123;window.add(s[right])right++<span class="hljs-keyword">while</span>(the window needs shrink)&#123;window.pop(s[left])left++&#125;&#125;</code></pre><hr><p>比较难的问题</p><h2 id="LC-632最小区间"><a href="#LC-632最小区间" class="headerlink" title="LC.632最小区间"></a>LC.632<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists">最小区间</a></h2><p>你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。</p><pre><code class="hljs angelscript">输入:[[<span class="hljs-number">4</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">24</span>,<span class="hljs-number">26</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">20</span>], [<span class="hljs-number">5</span>,<span class="hljs-number">18</span>,<span class="hljs-number">22</span>,<span class="hljs-number">30</span>]]输出: [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>]解释: 列表 <span class="hljs-number">1</span>：[<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">24</span>, <span class="hljs-number">26</span>]，<span class="hljs-number">24</span> 在区间 [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>] 中。列表 <span class="hljs-number">2</span>：[<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>]，<span class="hljs-number">20</span> 在区间 [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>] 中。列表 <span class="hljs-number">3</span>：[<span class="hljs-number">5</span>, <span class="hljs-number">18</span>, <span class="hljs-number">22</span>, <span class="hljs-number">30</span>]，<span class="hljs-number">22</span> 在区间 [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>] 中。</code></pre><p>注意:</p><ol><li>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。</li><li>1 &lt;= k &lt;= 3500</li><li>-105 &lt;= 元素的值 &lt;= 105</li><li>对于使用Java的用户，请注意传入类型已修改为List<List<Integer>&gt;。重置代码模板后可以看到这项改动。</li></ol><hr><p>在讲这个方法之前我们先思考这样一个问题：有一个序列 <script type="math/tex">A = \{ a_1, a_2, \cdots, a_n \}</script> 和一个序列 <script type="math/tex">B = \{b_1, b_2, \cdots, b_m\}</script>，请找出一个 B 中的一个最小的区间，使得在这个区间中 A 序列的每个数字至少出现一次，请注意 A 中的元素可能重复，也就是说如果 A 中有 p 个 u，那么你选择的这个区间中 u 的个数一定不少于 p。</p><p>回到这道题，我们发现这两道题的相似之处在于都要求我们找到某个符合条件的最小区间，我们可以借鉴「76. 最小覆盖子串」的做法：这里序列 <script type="math/tex">\{ 0, 1, \cdots , k - 1 \}</script> 就是上面描述的 A 序列，即 k 个列表，我们需要在一个 B 序列当中找到一个区间，可以覆盖 A序列。这里的 B 序列是什么？我们可以用一个哈希映射来表示 B 序列—— B[i]表示 ii 在哪些列表当中出现过，这里哈希映射的键是一个整数，表示列表中的某个数值，哈希映射的值是一个数组，这个数组里的元素代表当前的键出现在哪些列表里。也许文字表述比较抽象，大家可以结合下面这个例子来理解。</p><p>如果列表集合为：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>: [<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>]<span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<span class="hljs-number">3</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]</code></pre><p>那么可以得到这样一个哈希映射</p><pre><code class="hljs angelscript"><span class="hljs-number">-1</span>: [<span class="hljs-number">0</span>] <span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>] <span class="hljs-number">2</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>] <span class="hljs-number">3</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>]</code></pre><p>我们得到的这个哈希映射就是这里的 BB 序列。我们要做的就是在 B 序列上使用双指针维护一个滑动窗口，并用一个哈希表维护当前窗口中已经包含了哪些列表中的元素，记录它们的索引。遍历 B 序列的每一个元素：</p><p>指向窗口右边界的指针右移当且仅当每次遍历到新的元素，并将这个新的元素对应的值数组中的每一个数加入到哈希表中<br>指向窗口左边界的指针右移当且仅当当前窗口内的元素包含 A中所有的元素，同时将原来左边界对应的值数组的元素们从哈希表中移除<br>答案更新当且仅当当前窗口内的元素包含 A 中所有的元素。</p><blockquote><p> 个人理解是，这题也一样可以套用模板，need（即B）哈希表的键为nums中出现的所有数字，值为该数字所在的所有数组在nums中的序号。window为一个长度为n的数组，只有当前的区间覆盖了所有nums中子数组，才能进行窗口缩小操作。注意,这里的left和right分别是nums中所有数的最大值和最小值。</p></blockquote><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#125;;<span class="hljs-keyword">int</span> n = nums.size();<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; B;<span class="hljs-comment">//B数组</span><span class="hljs-keyword">int</span> xMin = INT32_MAX, xMax = INT32_MIN;<span class="hljs-comment">//区间最大值和最小值</span><span class="hljs-comment">//这里的need包含了nums中所有数及其所在列表序号的映射对</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size();i++) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;c:nums[i])&#123;    B[c].push_back(i);    xMin = min(c,xMin);    xMax = max(c,xMax);&#125;<span class="hljs-comment">// sort(need.begin(),need.end());</span><span class="hljs-keyword">int</span> inside = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示包含最小区间的数组的个数,等于n表示窗口可以开始缩小</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">freq</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//A中每个子数组，被最小区间包含的次数</span><span class="hljs-keyword">int</span> left = xMin, right = xMin<span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> ansL = INT32_MAX, ansR = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> min_inter = INT32_MAX;<span class="hljs-keyword">while</span> (right &lt; xMax) &#123;    <span class="hljs-comment">// 右移窗口</span>    right++;    <span class="hljs-comment">// 进行窗口内数据的一系列更新</span>        <span class="hljs-keyword">if</span>(B.count(right))    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:B[right])    &#123;        freq[c]++;        <span class="hljs-keyword">if</span>(freq[c]==<span class="hljs-number">1</span>) inside++;    &#125;    <span class="hljs-comment">/*** debug 输出的位置 ***/</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);    <span class="hljs-comment">/********************/</span>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span>    <span class="hljs-keyword">while</span> (inside==n) &#123;        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span> &lt; min_inter||(right-left+<span class="hljs-number">1</span> == min_inter&amp;&amp;left&lt;ansL))        &#123;            min_inter = right-left+<span class="hljs-number">1</span>;            ansL = left;            ansR = right;        &#125;        <span class="hljs-keyword">if</span>(B.count(left))        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:B[left])        &#123;            freq[c]--;            <span class="hljs-keyword">if</span>(freq[c]==<span class="hljs-number">0</span>) inside--;        &#125;        <span class="hljs-comment">// 左移窗口，注意要放在后面，否则无法更新freq中左区间</span>        left++;            &#125;&#125;<span class="hljs-keyword">return</span> &#123;ansL,ansR&#125;;&#125;</code></pre><p>未完待续。。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红尘客栈之单调栈</title>
    <link href="/2020/07/21/2020-8-17-recognition-monostack/"/>
    <url>/2020/07/21/2020-8-17-recognition-monostack/</url>
    
    <content type="html"><![CDATA[<h1 id="炫酷skr的单调栈"><a href="#炫酷skr的单调栈" class="headerlink" title="炫酷skr的单调栈"></a>炫酷skr的单调栈</h1><ul><li><ol><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大矩形（Hard）</a></li></ol></li><li>85.<a href="https://leetcode-cn.com/problems/maximal-rectangle/">求最大矩形(Hard)</a></li><li>739.<a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度(Medium)</a></li><li>多重背包问题III【详见背包九讲】</li></ul><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <img src="\img\histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">10</span></code></pre><hr><p>这道题无论是暴力还是枚举均会超时（时间复杂度$O(N^2)$），最初的想法是用一个哈希表存<code>heights</code>中每一个高度「最长的横向距离」，最大面积等于<code>max(maxArea,heights[i]×len)</code>后来发现过于麻烦。但是直觉告诉我这是可行的，题解采用单调栈也验证了我的想法。</p><p>有一个<em>事实</em>需要注意：</p><ul><li>若后一个高度小于前一个高度，那么前一个高度将不会对后续的求最大面积操作产生影响。</li></ul><p>我们需要对$i$左右进行扩展，我们需要找到<strong>左右两侧最近且高度小于$h$的柱子，这和接雨水那一题非常相似</strong>。以</p><p>$[6,7,5,2,4,5,9,3]$为例，</p><ol><li>将6入栈，6左侧为哨兵，位置-1；</li><li>将7入栈，由于7&gt;6，故7不会被移除；</li><li>将5入栈，由于7&gt;5且6&gt;5，故6，7会被移除。此时栈为空，5左侧为哨兵，位置-1.</li><li>将2入栈，由于2&lt;5，5会被移除，2左侧为哨兵-1.</li><li>将4入栈</li><li>将5入栈</li><li>将9入栈</li><li>不断出栈直到遇到2&lt;3</li></ol><script type="math/tex; mode=display">\begin{array}\\1.[6(0)]\\2.[6(0),7(1)]\\3.[5(2)]\\4.[2(3)]\\5.[2(3),4(4)]\\6.[2(3),4(4),5(5)]\\7.[2(3),4(4),5(5),9(6)]\\8.[2(3),3(7)]\end{array}</script><p>这样以来我们得到左侧柱子的编号为$[-1,0,-1,-1,3,4,5,3]$，同样地，我们可以得到右侧柱子的编号$[2,2,3,8,7,7,7,8]$。  因而根据$(l_height-r_height-1)*height[i]$得到最大面积。</p><p>代码如下：</p><p>​     </p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;     <span class="hljs-keyword">if</span>(!heights.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-keyword">int</span> n = heights.size();     <span class="hljs-keyword">int</span> maxArea = INT32_MIN;    <span class="hljs-comment">//采用单调栈的思想，分别找到i左右两侧最近且高度小于h的柱子</span>    vector&lt;int&gt; lbound(n,0),rbound(n,0);    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; lstack,rstack;<span class="hljs-comment">//存放高度位置和下标</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    &#123;        <span class="hljs-keyword">if</span>(lstack.empty()) lbound[i] = <span class="hljs-number">-1</span>;<span class="hljs-comment">//哨兵 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heights[i] &gt; lstack.back().first)         &#123;            lbound[i] = lstack.back().second;        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">while</span>(!lstack.empty()&amp;&amp;heights[i]&lt;=lstack.back().first)lstack.pop_back();            <span class="hljs-keyword">if</span>(lstack.empty()) lbound[i] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">else</span> lbound[i] = lstack.back().second;        &#125;        lstack.push_back(&#123;heights[i],i&#125;);            &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>;j--)    &#123;        <span class="hljs-keyword">if</span>(rstack.empty()) rbound[j] = n;<span class="hljs-comment">//哨兵 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heights[j] &gt; rstack.back().first)         &#123;            rbound[j] = rstack.back().second;        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">while</span>(!rstack.empty()&amp;&amp;heights[j]&lt;=rstack.back().first) rstack.pop_back();            <span class="hljs-keyword">if</span>(rstack.empty()) rbound[j] = n;            <span class="hljs-keyword">else</span> rbound[j] = rstack.back().second;        &#125;        rstack.push_back(&#123;heights[j],j&#125;);            &#125;    <span class="hljs-comment">// for(auto &amp;c:lbound)</span>    <span class="hljs-comment">// printf(&quot;%d,&quot;,c);</span>    <span class="hljs-comment">// printf(&quot;\n&quot;);</span>    <span class="hljs-comment">// for(auto &amp;c:rbound)</span>    <span class="hljs-comment">// printf(&quot;%d,&quot;,c);</span>    <span class="hljs-comment">// printf(&quot;\n&quot;);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n;c++)    &#123;        <span class="hljs-keyword">if</span>(lbound[c]==<span class="hljs-number">-1</span>) maxArea = max(maxArea,rbound[c]*heights[c]);        <span class="hljs-keyword">else</span> maxArea = max(maxArea,(rbound[c]-lbound[c]<span class="hljs-number">-1</span>)*heights[c]);    &#125;    <span class="hljs-keyword">return</span> maxArea&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:maxArea;    &#125;&#125;;</code></pre><p>时间复杂度：$O(2N)$</p><p>空间复杂度: $O(4N)$，左右边界以及栈</p><p>但是此代码可以简化，把寻找左边界和寻找右边界放在一次迭代中完成。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;           <span class="hljs-comment">//84求柱状图的最大矩形，O(N)</span>           <span class="hljs-keyword">int</span> n = heights.size();           vector&lt;int&gt; left(n), right(n, n);           <span class="hljs-comment">//左右边界数组，维护每个矩形的最大左右宽度</span>           <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; mono_stack;<span class="hljs-comment">//单调栈</span>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;               <span class="hljs-keyword">while</span> (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;                   right[mono_stack.top()] = i;                   mono_stack.pop();               &#125;               left[i] = (mono_stack.empty() ? <span class="hljs-number">-1</span> : mono_stack.top());               mono_stack.push(i);           &#125;                      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;               ans = max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<span class="hljs-comment">//计算最大面积</span>           &#125;           <span class="hljs-keyword">return</span> ans;       &#125;</code></pre><p>可能看代码有些复杂，我们制作一个动画方便理解：</p><p>[动画正在制作之中。。。]</p><hr><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><hr><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 T[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 T[prevIndex] 和当前温度 T[i]，如果 T[i] &gt; T[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p><p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 T[i] 一定是 T[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><ul><li><p><strong>时间复杂度</strong>：$O(n)$，其中 n是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p></li><li><p><strong>空间复杂度</strong>：$O(n)$，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>臭名昭著的KMP算法</title>
    <link href="/2020/07/21/2020-8-29-KMP/"/>
    <url>/2020/07/21/2020-8-29-KMP/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法精讲"><a href="#KMP算法精讲" class="headerlink" title="KMP算法精讲"></a>KMP算法精讲</h2><blockquote><p>为什么说它臭名昭著呢？因为KMP 是最短小精悍,最强大,最不易理解,最容易健忘的算法之一.</p></blockquote><p><strong>术语约定</strong>：s为目标串，t为模式匹配串，KMP作用和<code>strStr()</code>相同</p><ul><li>KMP算法的核心在于获取PMT数组(Partly Matched Track)部分匹配数组，它是从$0$到$j$字串的前缀集合和后缀集合的最长公共字串长度</li></ul><p>​    为了编程方便，我们将第0位令为0，将PMT依次后移一位得到next数组，它其实是t数组与自身匹配运算，返回匹配的最长长度，所以</p><p>​    利用next数组信息，对目标串的匹配可以避免回溯过程。相当于用空间换时间，$T(N) = O(S+T)$, $S$，$T$表示目标串和模式串长度，一般的暴力解法为$O(S+T)$.</p><p>​    一个例子：</p><pre><code class="hljs yaml"><span class="hljs-attr">t  :</span> <span class="hljs-string">a</span> <span class="hljs-string">b</span> <span class="hljs-string">a</span> <span class="hljs-string">b</span> <span class="hljs-string">a</span> <span class="hljs-string">b</span> <span class="hljs-string">c</span> <span class="hljs-string">a</span><span class="hljs-attr">index:</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-attr">PMT :</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-string">next</span> <span class="hljs-string">:-1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span></code></pre><hr><p>C++代码</p><p>读者可以结合注释理解</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;next, <span class="hljs-built_in">string</span> t)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, k = <span class="hljs-number">-1</span>;        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(j &lt; t.size()<span class="hljs-number">-1</span>)        &#123;            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span> || t[j] == t[k])            &#123;                j++;k++;                next[j] = k;            &#125;            <span class="hljs-keyword">else</span> k = next[k];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//术语约定：s为目标串，t为模式匹配串，KMP作用和strStr()相同</span>        <span class="hljs-comment">//KMP算法的核心在于获取PMT数组(Partly Matched Track)部分匹配数组，它是从0到j字串的前缀集合和后缀集合的最长公共字串长度</span>        <span class="hljs-comment">//为了编程方便，我们将第0位令为0，将PMT依次后移一位得到next数组，它其实是t数组与自身匹配运算，返回匹配的最长长度，所以</span>        <span class="hljs-comment">//利用next数组信息，对目标串的匹配可以避免回溯过程。相当于用空间换时间，T(N) = O(S+T), S，T表示目标串和模式串长度，一般</span>        <span class="hljs-comment">//的暴力解法为O(S+T)</span>        <span class="hljs-comment">//一个例子：</span>        <span class="hljs-comment">//t    : a b a b a b c a</span>        <span class="hljs-comment">//index: 0 1 2 3 4 5 6 7 </span>        <span class="hljs-comment">//PMT  : 0 0 1 2 3 4 0 1</span>        <span class="hljs-comment">//next :-1 0 0 1 2 3 4 0</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(t.size(),<span class="hljs-number">0</span>)</span></span>;        get_next(next, t);        <span class="hljs-keyword">while</span>(i&lt;s.size() &amp;&amp; j&lt;(<span class="hljs-keyword">int</span>)t.size())        &#123;            <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==t[j])            &#123;                i++;j++;            &#125;            <span class="hljs-keyword">else</span> j = next[j];        &#125;         <span class="hljs-keyword">if</span>(j &gt;= t.size())            <span class="hljs-keyword">return</span>(i-j);        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>权力的游戏 之 零和博弈</title>
    <link href="/2020/07/21/2020-9-1-what-is-zero-sum/"/>
    <url>/2020/07/21/2020-9-1-what-is-zero-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是零和博弈-Zero-sum-？"><a href="#什么是零和博弈-Zero-sum-？" class="headerlink" title="什么是零和博弈(Zero sum )？"></a>什么是零和博弈(Zero sum )？</h1><blockquote><p>在零和博弈中，<strong>让自己最优</strong>和<strong>让对手最差</strong>其实是相同的目标！原因还是那句话，<strong>两人的总得分不会变化，自己多了，对手必然减少</strong>。</p></blockquote><p>在零和博弈问题中，一般会存在先手优势和后手劣势：</p><p><strong>先手优势</strong>：因为先手可以先走，所以可决定后手将要面对的局面。因此，后手虽然也会做出最优解，但是先手可以根据先发的优势，让后手进入最优解最差的局面。<br><strong>后手劣势</strong>：当先手走完后，虽然后手也会成为下一回合的先手，也可以做出最优解，但后手无法选择下一回合的局面。<br>所以一般零和博弈问题的关键都是要找出如何让后手陷入更差的局面的方法。</p><hr><p>例题</p><ul><li><ol><li><a href="https://leetcode-cn.com/problems/stone-game-iii/">石子游戏III</a>(Hard)</li></ol></li><li><p>877.<a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a>(Medium)</p></li><li><ol><li><a href="">预测赢家</a>(Medium)</li></ol></li><li><ol><li><a href="Medium">我能赢吗</a>(Medium)</li></ol></li></ul><p>下面以486为例讲解</p><hr><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p> <pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]输出：False解释：一开始，玩家<span class="hljs-number">1</span>可以从<span class="hljs-number">1</span>和<span class="hljs-number">2</span>中进行选择。如果他选择 <span class="hljs-number">2</span>（或者 <span class="hljs-number">1</span> ），那么玩家 <span class="hljs-number">2</span> 可以从 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）和 <span class="hljs-number">5</span> 中进行选择。如果玩家 <span class="hljs-number">2</span> 选择了 <span class="hljs-number">5</span> ，那么玩家 <span class="hljs-number">1</span> 则只剩下 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）可选。所以，玩家 <span class="hljs-number">1</span> 的最终分数为 <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>，而玩家 <span class="hljs-number">2</span> 为 <span class="hljs-number">5</span> 。因此，玩家 <span class="hljs-number">1</span> 永远不会成为赢家，返回 False 。</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">233</span>, <span class="hljs-number">7</span>]输出：True解释：玩家 <span class="hljs-number">1</span> 一开始选择 <span class="hljs-number">1</span> 。然后玩家 <span class="hljs-number">2</span> 必须从 <span class="hljs-number">5</span> 和 <span class="hljs-number">7</span> 中进行选择。无论玩家 <span class="hljs-number">2</span> 选择了哪个，玩家 <span class="hljs-number">1</span> 都可以选择 <span class="hljs-number">233</span> 。     最终，玩家 <span class="hljs-number">1</span>（<span class="hljs-number">234</span> 分）比玩家 <span class="hljs-number">2</span>（<span class="hljs-number">12</span> 分）获得更多的分数，所以返回 True，表示玩家 <span class="hljs-number">1</span> 可以成为赢家。</code></pre><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><hr><p>我们用$dp[l][r]$表示闭区间$[l,r]$内，自己「先手」能获得的分数最大值。那么函数<code>dfs(l,r)</code>返回<code>dp[l][r]</code>。并进行记录。</p><p><strong>记忆化搜索</strong> </p><p>$dp[l][r] = sum(l,r) - min(dp[l+1][r],dp[l][r-1])$</p><blockquote><p> 边界条件 $dp[l][l] = nums[l]$; 返回值：$dfs(nums,0,n-1)*2 &gt;= sum(nums,0,n-1)$</p></blockquote><p>时间复杂度：$O(2^n)$</p><p>空间复杂度: $O(n)$，递归的空间复杂度取决于使用了多少栈空间。</p><p><strong>动态规划</strong>    </p><p>$dp[l][r] = max(-dp[l+1][r] + nums[l],-dp[l][r-1]+nums[r])$</p><p>我们先在$nums[l],nums[r]$中进行选择，同时保证对手的$dp[l+1][r]或者dp[l][r-1]$最小。 </p><blockquote><p>边界条件 $dp[l][l] = nums[l]$, 返回值：$dp[0][n-1]&gt;=0$</p></blockquote><p>使用递归存在大量重复计算，时间复杂度很高，因而采用动态规划是更好的选择。<strong>注意</strong>：$i$的遍历要从$n$开始，即反过来。</p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度: $O(n)$，使用滚动数组优化。</p><h2 id="代码（DFS-记忆化搜索）"><a href="#代码（DFS-记忆化搜索）" class="headerlink" title="代码（DFS+记忆化搜索）"></a><strong>代码（DFS+记忆化搜索）</strong></h2><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allsum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//对下标l-r进行求和</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r;i++) sum += nums[i];        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//记忆化搜索，返回l,r使得先手优势最大的值</span>        <span class="hljs-keyword">if</span>(dp[l][r]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[l][r];        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l==r) &#123;dp[l][r]=nums[l];<span class="hljs-keyword">return</span> nums[l];&#125;        dp[l][r] = allsum(nums,l,r) - min(dfs(nums,l+<span class="hljs-number">1</span>,r),dfs(nums,l,r<span class="hljs-number">-1</span>));        <span class="hljs-comment">// printf(&quot;dp[%d][%d]=%d\n&quot;,lr,dp[l][r]);</span>        <span class="hljs-keyword">return</span> dp[l][r];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>&gt;=allsum(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p><strong>代码（DFS+记忆化搜索）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-comment">//表示[i,j]区间的最大值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) dp[i][i] = nums[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n;i &gt;= <span class="hljs-number">0</span>;i--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++)    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n &amp;&amp; j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)    &#123;        dp[i][j] = max(-dp[i+<span class="hljs-number">1</span>][j]+nums[i], -dp[i][j<span class="hljs-number">-1</span>]+nums[j]);        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;    </span>            &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><hr><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>游戏类问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown那些不为人知的酷炫特效</title>
    <link href="/2020/07/21/2020-9-3-Markdown%20-fantastic/"/>
    <url>/2020/07/21/2020-9-3-Markdown%20-fantastic/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-那些不为人知的炫🆒特性"><a href="#Markdown-那些不为人知的炫🆒特性" class="headerlink" title="Markdown 那些不为人知的炫🆒特性"></a>Markdown 那些不为人知的炫🆒特性</h1><hr><h2 id="新的甘特图功能，丰富你的文章（Mermaid语言）"><a href="#新的甘特图功能，丰富你的文章（Mermaid语言）" class="headerlink" title="新的甘特图功能，丰富你的文章（Mermaid语言）"></a>新的甘特图功能，丰富你的文章（Mermaid语言）</h2><pre><code class="hljs mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d</code></pre><ul><li>关于 <strong>甘特图</strong> 语法，参考 [这儿][2],</li></ul><h2 id="UML-图表（Mermaid语言）"><a href="#UML-图表（Mermaid语言）" class="headerlink" title="UML 图表（Mermaid语言）"></a>UML 图表（Mermaid语言）</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><pre><code class="hljs mermaid">sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</code></pre><p>这将产生一个流程图:</p><pre><code class="hljs mermaid">graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D</code></pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 [这儿][3],</li></ul><h2 id="FLowchart流程图（flow语言）"><a href="#FLowchart流程图（flow语言）" class="headerlink" title="FLowchart流程图（flow语言）"></a>FLowchart流程图（flow语言）</h2><p>我们依旧会支持flowchart的流程图：<br><pre><code class="hljs flow">start&#x3D;&gt;start: 开始loginInfo&#x3D;&gt;inputoutput: 登录数据verifyLogin&#x3D;&gt;subroutine: 登录验证isSuccess&#x3D;&gt;condition: 验证成功？respondSuccess&#x3D;&gt;operation: 响应成功responseFailure&#x3D;&gt;operation: 响应失败end&#x3D;&gt;end: 结束start-&gt;loginInfo-&gt;verifyLogin-&gt;isSuccessisSuccess(yes)-&gt;respondSuccess-&gt;endisSuccess(no)-&gt;responseFailure-&gt;end</code></pre></p><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://flowchart.js.org/">这儿</a>.</li></ul><p><a href="https://blog.csdn.net/Iccyco/article/details/106202945">https://blog.csdn.net/Iccyco/article/details/106202945</a></p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google划词搜索的秘密</title>
    <link href="/2020/07/21/2020-8-20-what-is-Trie/"/>
    <url>/2020/07/21/2020-8-20-what-is-Trie/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是前缀树Trie和前缀和？如何实现？"><a href="#什么是前缀树Trie和前缀和？如何实现？" class="headerlink" title="什么是前缀树Trie和前缀和？如何实现？"></a>什么是前缀树Trie和前缀和？如何实现？</h1><blockquote><p>前缀树又名<strong>Tries树</strong>、<strong>字典</strong>树、单词查找树等，常用于快速检索，大量字符串的排序和统计等。</p><p>LC208.<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现前缀树</a> - 制作板子</p><p>LC336.<a href="https://leetcode-cn.com/problems/palindrome-pairs/">回文对</a> - 结合回文</p><p>LC212.<a href="https://leetcode-cn.com/problems/word-search-ii/">单词搜索 II </a>- 类似 Boggle 的游戏。</p></blockquote><p><strong>三个基本性质</strong></p><ol><li>根节点不包含字符，除根节点外每个节点只包含一个字符</li><li>从根节点到某个节点，路径上所有的字符连在一起，就是这个节点所对应的字符串</li><li>每个节点的子节点所包含的字符都不同</li></ol><p><img src="\img\trie1.jpg" alt="Trie"></p><p><strong>应用场景</strong>：</p><p>1.自动补全</p><p><img src="\img\trie2.jpg" alt="自动补全"></p><p align="center" style="font:italic;color:gray"><i>图1. 谷歌的搜索建议</i></p><ol><li>拼写检查</li></ol><p><img src="\img\trie3.jpg" alt="image.png"></p><p align="center" style="font:italic;color:gray"><i>图2. 拼写检查</i></p><p>3.IP路由（最长前缀匹配）</p><p><img src="\img\trie4.jpg" alt="无效的图片地址"></p><p align="center"><i>图 3. 使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</i></p><ol><li>T9打字预测</li><li>Boggle单词游戏</li></ol><p>还有现成的高效结构如哈希表和平衡树，但为什么我们还要用前缀树呢，因为它有如下优势：</p><ul><li>找到具有同一前缀的全部键值</li><li>按词典枚举字符串的数据集</li></ul><p>Trie相比于哈希表的另一个优势是，随着哈希表长度增加，会出现大量冲突，时间复杂度可能会增加到$O(N)$. trie树子存储多个具有相同前缀的键时所用空间较少。因此前缀树只需要$O(m)$的空间，m为键长度。而在平衡树中需要$O(m\log n)$。</p><h2 id="设计Trie树"><a href="#设计Trie树" class="headerlink" title="设计Trie树"></a><strong>设计Trie树</strong></h2><p><strong>初始化</strong></p><p>我们设计一个Trie节点<code>node</code>具有如下属性：</p><ul><li>子树数组：因为字母表长度为26，所以数组长度为26；</li><li>结束标记，bool型表示，比如”apple”和”app”,后者是前者一个前缀，所以需要结束标记。</li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-keyword">bool</span> isEnd;    Trie* next[<span class="hljs-number">26</span>];<span class="hljs-keyword">public</span>:    Trie()    &#123;isEnd = <span class="hljs-literal">false</span>;        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(next));    &#125;&#125;;</code></pre><p><strong>插入键值</strong></p><p>我们从字符串头开始，如果字符<code>s[i]</code>存在于当前节点的子树数组中，那么我们直接递归进入该节点，否则我们创造新节点，再进入。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span></span><span class="hljs-function"></span>&#123;    Trie *node = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> &amp;c:word)    &#123;        <span class="hljs-keyword">if</span>(node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)        node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie(c);        node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];    &#125;&#125;</code></pre><p>注意这里我们把this作为根节点。所以每次new一个node都会产生一个根节点。  </p><ul><li>时间复杂度：$O(m)$，其中 $m$ 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 $m$ 次操作。</li></ul><ul><li>空间复杂度：$O(m)$。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 $m$ 个结点，使用 $O(m)$ 空间。</li></ul><p><strong>查找键值</strong></p><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始。检查当前节点中与键字符对应的链接。有两种情况：</p><p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。<br>不存在链接。若已无键字符，且当前结点标记为 End，则返回 true。否则有两种可能，均返回 false :<br>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。<br>没有键字符剩余，但当前结点没有标记为 End。也就是说，待查找键只是Trie树中另一个键的前缀。</p><pre><code class="hljs C++">  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;Trie* node = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> &amp;c:word)    &#123;        node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> node-&gt;isEnd;&#125;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(m)$。算法的每一步均搜索下一个键字符。最坏的情况下需要 $m$ 次操作。</li><li>空间复杂度 : $O(1)$。</li></ul><p><strong>查找 Trie 树中的键前缀</strong><br>该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “End” 标记，因为我们搜索的是键的前缀，而不是整个键。</p><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> startWith&#123;   <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   Trie* node = <span class="hljs-keyword">this</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> &amp;c:word)   &#123;   node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];   <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(m)$。算法的每一步均搜索下一个键字符。最坏的情况下需要 $m$ 次操作。</li><li>空间复杂度 : $O(1)$。</li></ul><hr><h2 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a>336. 回文对</h2><p>给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。</p><p>示例 1：</p><pre><code class="hljs lsl">输入：[<span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;dcba&quot;</span>,<span class="hljs-string">&quot;lls&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;sssll&quot;</span>]输出：[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]] 解释：可拼接成的回文串为 [<span class="hljs-string">&quot;dcbaabcd&quot;</span>,<span class="hljs-string">&quot;abcddcba&quot;</span>,<span class="hljs-string">&quot;slls&quot;</span>,<span class="hljs-string">&quot;llssssll&quot;</span>]</code></pre><p>示例 2：</p><pre><code class="hljs lua">输入：[<span class="hljs-string">&quot;bat&quot;</span>,<span class="hljs-string">&quot;tab&quot;</span>,<span class="hljs-string">&quot;cat&quot;</span>]输出：<span class="hljs-string">[[0,1],[1,0]]</span> 解释：可拼接成的回文串为 [<span class="hljs-string">&quot;battab&quot;</span>,<span class="hljs-string">&quot;tabbat&quot;</span>]</code></pre><hr><p>假设存在两个字符串$s1和s2$, $s1+s2$是一个回文串，记它们的长度分别为$len1和len2$.分情况进行讨论：</p><ol><li>$len1==len2$，此时$s1$是$s2$的翻转。</li><li>$len1&gt;len2$，此时仍然可以在$s1$找到一个前缀$s1’==s2$.</li><li>$len2&lt;len1$，同上。</li></ol><p><strong>注意</strong>：空串也是回文串。比如$s1=”aa”,s2=””$.</p><p>要实现这些操作，我们只需要设计一种能够在一系列字符串中查询「某个字符串的子串的翻转」是否存在的数据结构，有两种实现方法：</p><ol><li>我们可以使用字典树存储所有的字符串。在进行查询时，我们将待查询的子串<strong>逆序</strong>地在字典树上进行遍历，即可判断其是否存在。</li><li>我们可以使用哈希表存储所有字符串的翻转。在进行查询时，我们判断查询串是否在哈希表中出现，就可以判断其翻转子串是否存在。</li></ol><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-built_in">vector</span>&lt;Trie*&gt; child;    <span class="hljs-keyword">bool</span> end;<span class="hljs-comment">//结束的标志，表示在该节点结束</span>    <span class="hljs-keyword">int</span> index;<span class="hljs-comment">//该字符的下标，与end对应，默认-1，表示不存在</span>    <span class="hljs-keyword">char</span> val;     Trie() &#123;        val = <span class="hljs-string">&#x27; &#x27;</span>;        end = <span class="hljs-literal">false</span>;        index = <span class="hljs-number">-1</span>;        child.resize(<span class="hljs-number">26</span>);    &#125;    Trie(<span class="hljs-keyword">char</span> c) &#123;        val = c;        end = <span class="hljs-literal">false</span>;        index = <span class="hljs-number">-1</span>;        child.resize(<span class="hljs-number">26</span>);    &#125;        <span class="hljs-keyword">void</span> _insert(Trie* node, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> index)    &#123;        <span class="hljs-keyword">if</span>(i&gt;=word.size())         &#123;            node-&gt;end = <span class="hljs-literal">true</span>;            node-&gt;index = index;            <span class="hljs-keyword">return</span>;        &#125;           <span class="hljs-keyword">auto</span> &amp;n = node-&gt;child[(<span class="hljs-keyword">int</span>)(word[i]-<span class="hljs-string">&#x27;a&#x27;</span>)];         n = (n == <span class="hljs-literal">nullptr</span>)?<span class="hljs-keyword">new</span> Trie(word[i]):n;        _insert(n,word,i+<span class="hljs-number">1</span>,index);    &#125;    <span class="hljs-comment">/** Inserts a word into the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//root does not save char</span>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span>;        _insert(<span class="hljs-keyword">this</span>,word,<span class="hljs-number">0</span>,index);    &#125;    <span class="hljs-comment">/** Returns if the word is in the trie. */</span>    <span class="hljs-keyword">void</span> _search(<span class="hljs-built_in">string</span> mode, Trie *node, <span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">bool</span> &amp;isExist,<span class="hljs-keyword">int</span> &amp;index)    &#123;<span class="hljs-comment">//递归搜索，s为字符串，i为编号</span>      <span class="hljs-comment">// 上一个字符搜索到了才进行下一次搜索</span>       <span class="hljs-keyword">if</span>(i&lt;s.size()&amp;&amp;node-&gt;child[(<span class="hljs-keyword">int</span>)(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>)] &amp;&amp;node-&gt;child[(<span class="hljs-keyword">int</span>)(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>)]-&gt;val==s[i]&amp;&amp;!isExist)         _search(mode,node-&gt;child[(<span class="hljs-keyword">int</span>)(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>)],s,i+<span class="hljs-number">1</span>,isExist,index);        <span class="hljs-keyword">if</span>(!isExist)        <span class="hljs-keyword">if</span>(mode == <span class="hljs-string">&quot;search&quot;</span>) isExist = (i==s.size()&amp;&amp;node-&gt;end);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mode == <span class="hljs-string">&quot;prefix&quot;</span>) isExist = (i==s.size());        <span class="hljs-keyword">if</span>(isExist&amp;&amp;index==<span class="hljs-number">-1</span>)         index = node-&gt;index;            &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> isExist = <span class="hljs-literal">false</span>; <span class="hljs-keyword">int</span> i = <span class="hljs-number">-1</span>;        _search(<span class="hljs-string">&quot;search&quot;</span>,<span class="hljs-keyword">this</span>,word,<span class="hljs-number">0</span>,isExist,i);        <span class="hljs-keyword">return</span> i;    &#125;        <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> isExist = <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        _search(<span class="hljs-string">&quot;prefix&quot;</span>,<span class="hljs-keyword">this</span>,prefix,<span class="hljs-number">0</span>,isExist,i);        <span class="hljs-keyword">return</span> isExist;    &#125; &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-comment">//字典树版本</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;a,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = right - left + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; n/<span class="hljs-number">2</span>;i++)        <span class="hljs-keyword">if</span>(a[i+left]!=a[right-i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">palindromePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!words.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        Trie  tr;        <span class="hljs-comment">//将所有单词加入前缀树中</span>        <span class="hljs-keyword">int</span> n = words.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)         tr.insert(words[i],i);        <span class="hljs-comment">//遍历任意两个字符串</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            <span class="hljs-keyword">int</span> m = words[i].size();            <span class="hljs-built_in">string</span> sub = words[i];            reverse(sub.begin(),sub.end());            <span class="hljs-keyword">int</span> index = tr.search(sub);            <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;i,index&#125;);            <span class="hljs-keyword">if</span>(isPalindrome(words[i],<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>))             &#123;                <span class="hljs-keyword">int</span> index = tr.search(<span class="hljs-string">&quot;&quot;</span>);                <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;index,i&#125;);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)            &#123;                                <span class="hljs-keyword">if</span>(j&amp;&amp;isPalindrome(words[i],<span class="hljs-number">0</span>,j<span class="hljs-number">-1</span>))                &#123;                    <span class="hljs-built_in">string</span> sub = words[i].substr(j,m-j);                    reverse(sub.begin(),sub.end());                    <span class="hljs-keyword">int</span> index = tr.search(sub);                    <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;index,i&#125;);                &#125;                <span class="hljs-keyword">if</span>(isPalindrome(words[i],j,m<span class="hljs-number">-1</span>))                &#123;                    <span class="hljs-built_in">string</span> sub = words[i].substr(<span class="hljs-number">0</span>,j);                    reverse(sub.begin(),sub.end());                    <span class="hljs-keyword">int</span> index = tr.search(sub);                    <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;i,index&#125;);                &#125;                            &#125;        &#125;        <span class="hljs-keyword">return</span> res;            &#125;&#125;;</code></pre><p>时间复杂度: $O(N*M^2)$, $N$为字符数组总长度，$M$为字符串平均长度。</p><p>空间复杂度: $O(N*M)$。实际上由于字符前缀重合，用不到这么多空间。</p><hr><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><ul><li><ol><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为k的子数组</a>(Medium)</li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含最长的子字符串</a>(Medium)</li></ol></li><li><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></li></ul><hr><h2 id="560-和为k的子数组-Medium"><a href="#560-和为k的子数组-Medium" class="headerlink" title="560.和为k的子数组(Medium)"></a><strong><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560.和为k的子数组</a>(Medium)</strong></h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p><p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p><hr><p>定义$pre[i]$表示$[0…i]$所有数之和,那么范围$[j-i]$可以表示为: $pre[i]-pre[j-1]$,  且$pre[i] = pre[i-1] + nums[i]$ , 问题转化为,</p><p>找到有多少个区间,满足$pre[i]-pre[j-1]==k$. 所以我们考虑以 $i$ 结尾的和为 $k$ 的连续子数组个数时只要统计有多少个前缀和为 $\textit{pre}[i]-k$的 $\textit{pre}[j]$ 即可。我们建立哈希表 $\textit{mp}$，以和为键，出现次数为对应的值，记录 $\textit{pre}[i]$ 出现的次数，从左往右边更新 $\textit{mp}$边计算答案，那么以 $i$ 结尾的答案 $\textit{mp}[\textit{pre}[i]-k]$ 即可在 $O(1)$ 时间内得到。最后的答案即为所有下标结尾的和为 $k$ 的子数组个数之和。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> res;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//数组长度和k都非常大，因此要尽量在线性时间复杂度解决</span>        <span class="hljs-comment">//我们尝试动态规划解决,</span>        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]==k;        res = <span class="hljs-number">0</span>;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; memo;<span class="hljs-comment">//记录和的个数</span>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;        memo[<span class="hljs-number">0</span>]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)        &#123;            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;pre&lt;&lt;endl;</span>            pre = pre + nums[i];                        <span class="hljs-keyword">if</span>(memo.count(pre-k))            res += memo[pre-k];            memo[pre]++;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><hr><h2 id="1371-每个元音包含最长的子字符串-Medium"><a href="#1371-每个元音包含最长的子字符串-Medium" class="headerlink" title="1371,每个元音包含最长的子字符串(Medium)"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371,每个元音包含最长的子字符串</a>(Medium)</h2><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p>示例 1：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;eleetminicoworoep&quot;</span>输出：<span class="hljs-number">13</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetminicowor&quot;</span> ，它包含 e，i，o 各 <span class="hljs-number">2</span> 个，以及 <span class="hljs-number">0</span> 个 a，u 。</code></pre><p>示例 2：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;leetcodeisgreat&quot;</span>输出：<span class="hljs-number">5</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetc&quot;</span> ，其中包含 <span class="hljs-number">2</span> 个 e 。</code></pre><p>示例 3：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;bcbcbc&quot;</span>输出：<span class="hljs-number">6</span>解释：这个示例中，字符串 <span class="hljs-string">&quot;bcbcbc&quot;</span> 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 <span class="hljs-number">0</span> 次。</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 5 x 10^5s 只包含小写英文字母。</code></p><p>定义$pre[i][k]$表示前$i$个字母，第$k$个元音字母总出现的次数。那么在$[i-1,j-1]$区间内，元音字母出现次数为$pre[j][k]-pre[i][k]$，在$O(1)$时间内得到第$k$个元音字母出现的次数。</p><p>同时我们要考虑避免枚举所有的$i$，计算以它结尾的满足条件的最长子字符串长度，我们要找到最小$i$使得$pre[j][k]-pre[i][k]$均为偶数。 我们需要利用【所有元音出现偶数次】这个条件，对于满足条件的子串而言，$pre[i][k]$和$pre[j][k]$的奇偶性一定相同，因为偶数一定是奇数+奇数，或者偶数+偶数组成。所以我们可以把$pre[i][k]$改为表示$[0,i-1]$的<strong>元音奇偶性</strong>。</p><p>此外我们还需要进行「状态压缩」：</p><pre><code class="hljs dts">&#123;<span class="hljs-symbol">  a:</span> cnta, <span class="hljs-comment">// a 出现次数的奇偶性</span><span class="hljs-symbol">  e:</span> cnte, <span class="hljs-comment">// e 出现次数的奇偶性</span><span class="hljs-symbol">  i:</span> cnti, <span class="hljs-comment">// i 出现次数的奇偶性</span><span class="hljs-symbol">  o:</span> cnto, <span class="hljs-comment">// o 出现次数的奇偶性</span><span class="hljs-symbol">  u:</span> cntu  <span class="hljs-comment">// u 出现次数的奇偶性</span>&#125;</code></pre><p>我们可以用二进制表示这些奇偶。</p><p>举一个例子，假如到第 $i $个位置，<code>u o i e a</code>出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 $(11001)_2=(25)_{10}$ 作为它的状态。</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = s.size(), res = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; vowel&#123;            &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>&#125;        &#125;;        <span class="hljs-comment">// 我们用pre[status]表示status状态对应的位置i，不断更新</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>,<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">//初始均为偶</span>        pre[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态，所有元音为偶数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)        &#123;            <span class="hljs-keyword">if</span>(vowel.count(s[i<span class="hljs-number">-1</span>]))            status ^= vowel[s[i<span class="hljs-number">-1</span>]];                        <span class="hljs-keyword">if</span>(~pre[status]) res = max(res,i - pre[status]); <span class="hljs-comment">//pre[status]!=-1</span>            <span class="hljs-keyword">else</span>             &#123;                pre[status] = i ;            &#125;                &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><blockquote><p>注意 18行的 ~pre[status]表示<strong>按位取反</strong>，包含了符号位，所以只有pre[status]不为-1，才为True。</p><p>$ \text{~} 0 = -1$， </p></blockquote><p>时间复杂度: $O(N)$. $N$为字符串长度。</p><p>空间复杂度: $O(1)$.</p><h2 id="扩展：删除元素"><a href="#扩展：删除元素" class="headerlink" title="扩展：删除元素"></a>扩展：删除元素</h2><p><a href="https://mp.weixin.qq.com/s/uDar0F7x9w5F3sHOB5tIDA">https://mp.weixin.qq.com/s/uDar0F7x9w5F3sHOB5tIDA</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>类树结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2020/07/21/2020-07-21-dynamic-planning/"/>
    <url>/2020/07/21/2020-07-21-dynamic-planning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划(DP)的重要性我就不用说了，<code>LeetCode</code> 上DP问题多达228道，仅次于数组301题。</p><p>个人感觉，DP问题就像斐波那契数列一样，你需要找到能够递归的通式子，我们把这个式子称作<strong>状态转移方程</strong>（$transfer  eqution$）。本文采取题目加讲解的方式，中等题目强调找出状态转移方程，难题则附加代码研究细节，此篇可作为你刷DP类问题的指南。</p></blockquote><p>然后，现在我们干一件事情，把DP题目罗列出来，找到共同点，未来我们要做到看一眼题目就知道用什么方法。</p><ol><li><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a> (Easy)</li><li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a> (Easy)</li><li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a>(Easy)</li><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径2</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的搜索二叉树</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a>(medium)</li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">最大字序和</a>(Easy)</li><li><a href="https://leetcode-cn.com/problems/word-break/solution/">单词拆分</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/perfect-squares">完全平方数</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大和</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/remove-boxes">移除盒子</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/count-all-possible-routes/">统计所有可能路径</a>(Hard)</li></ol><p>配合<a href="http://zxi.mytechroad.com/blog/leetcode-problem-categories/?from=singlemessage">Huahua’s problem set</a>. 食用更佳！</p><hr><p>下面结合实例分析</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. <a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h2><p>非常经典！</p><p>用$dp[i]$表示爬上第i个梯子的方法数。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i] = dp[i-1] + dp[i-2];</script><p>边界条件: $dp[0] = 1, dp[1]=1$</p><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>用$dp[i]$表示爬上第i个梯子的<code>最小</code>消耗。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i] = min{dp[i-1] + cost[i-1], dp[i-2] + cost[i-1]};</script><p>边界条件: $dp[0] = 0, dp[1]=0$</p><p><strong>总结，这两题能这么做是因为，它们相邻两项的间距是恒定的要么为1，要么为2.</strong></p><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. <a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h2><blockquote><p>老dp了，还贪讷</p></blockquote><p>一眼看上去以为是跳跃游戏类似的贪心算法，没想到是老dp换了层皮。</p><p>以$dp[i]$表示前ii个元素中最大金额。<br>我们这样想，第$i-1$个元素$nums[i-1]$是否取到取决于前面一个元素是否取，如果前一个元素不取就是$dp[i-2]+nums[i-1]$，如果前一个元素取到就是$dp[i-1]$。</p><p>边值条件$dp[0]=0,dp[1]=nums[0]$，注意下标对应关系。</p><hr><p>再看跟路径有关的问题</p><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. <a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h2><p>用$dp[i][j]$表示从原点到达(m,n)的<code>最小</code>路径和。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i][j] = min(dp[i][j-1], dp[i-1][j])+grid[i][j];</script><p>边界条件: </p><script type="math/tex; mode=display">dp[0][i] = dp[0][i-1] + grid[0][i](0 \le{i}\le{m}), \\dp[j][0] = dp[j-1][0] + grid[j][0](0 \le{j}\le{n})</script><p>这题很特殊的地方是，先求完边界条件才能进行DP操作。</p><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. <a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h2><p>这题和上一题的区别是，不用管路径开销，这样的话我们可以把路径都设为1。</p><p>用$dp[i][j]$表示从原点到达(m,n)的<code>不同</code>路径数目。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i][j] = dp[i][j-1]+ dp[i-1][j];</script><p>边界条件: </p><script type="math/tex; mode=display">dp[0][i] = 1(0 \le{i}\le{m}), \\dp[j][0] = 1(0 \le{j}\le{n})</script><h2 id="63-不同路径2"><a href="#63-不同路径2" class="headerlink" title="63. 不同路径2"></a>63. <a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径2</a></h2><p>用$dp[i][j]$表示从<code>原点</code>到$(i,j)$的路径总数，只不过这题玩了一点花样，加入障碍物，和<code>62</code>异曲同工。上一题我们把边界，包括上边界和左边界，都设为1。这一题，我们想如果遇到障碍物在$(i,j)$，那么肯定$dp[i][j]=0$对吧？然后对于边界，一旦$dp[0][j]==0或dp[i][0]==0$表明，之后的全到不了，因为上左边界分别只有一条路径。</p><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{array}{lcl}dp[i-1][j]+dp[i][j-1],       & {obstacleGrid[i][j]!=1}\\0,     & {obstacleGrid[i][j]==1}\\\end{array} \right.</script><blockquote><p>边界</p><script type="math/tex; mode=display">dp[0][j] =\left\{ \begin{array}{lcr} 0, dp[0][j-1]!=0||obstacleGrid[0][j]==0\\1, {dp[0][j-1]!=0}\\\end{array} \right.\\,\\dp[i][0] =\left\{ \begin{array}{lcr} 0, {dp[i-1][0]==0||obstacleGrid[i][0]==0}\\1, {dp[i-1][0]!=0}\\\end{array} \right.</script></blockquote><p><strong>总结，因为路径问题只能向下或向右走和爬楼梯的只能走一步或者两步都是异曲同工的，把状态转移方程和边界条件想出来有助于快速解决问题</strong></p><hr><blockquote><p>此外，涉及到求规律的问题，一般先列出几项再使用dp</p></blockquote><h2 id="96-不同的搜索二叉树"><a href="#96-不同的搜索二叉树" class="headerlink" title="96. 不同的搜索二叉树"></a>96. 不同的搜索二叉树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">3</span>输出: <span class="hljs-number">5</span>解释:给定 n = <span class="hljs-number">3</span>, 一共有 <span class="hljs-number">5</span> 种不同结构的二叉搜索树:   <span class="hljs-number">1</span>         <span class="hljs-number">3</span>     <span class="hljs-number">3</span>      <span class="hljs-number">2</span>      <span class="hljs-number">1</span>    \       /     /      / \      \     <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     <span class="hljs-number">1</span>      <span class="hljs-number">1</span>   <span class="hljs-number">3</span>      <span class="hljs-number">2</span>    /     /       \                 \   <span class="hljs-number">2</span>     <span class="hljs-number">1</span>         <span class="hljs-number">2</span>                 <span class="hljs-number">3</span></code></pre><script type="math/tex; mode=display">f[i] = \begin{cases}2×(f[i-1]+···+f[(i-1)/2])+f[i/2]^2,i\%2!=0\\2×(f[i-1]+···+f[(i-1)/2])，otherwise\\\end{cases}</script><hr><p>事实上我们在方法一中推导出的 $G(n)$函数的值在数学上被称为卡塔兰数 $C_n $</p><p> 。卡塔兰数更便于计算的定义如下:$C_0 = 1, \qquad C_{n+1} = {2(2n+1)}/{n+2}C_n$,证明过程可以参考上述文献，此处不再赘述。</p><blockquote><p>下面我们看一些富有技巧而实际很简单 的dp问题</p></blockquote><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>输出: <span class="hljs-number">4</span></code></pre><hr><p>可以使用动态规划降低时间复杂度。我们用 $dp(i, j)$ 表示以 $(i, j)$ 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 $dp(i, j)$的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置$(i, j)$,检查在矩阵中该位置的值：</p><p>如果该位置的值是 0，则 $dp(i,j)=0$，因为当前位置不可能在由 1 组成的正方形中；</p><p>如果该位置的值是 1，则 $dp(i, j)$ 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><script type="math/tex; mode=display">dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</script><p>形子矩阵的官方题解，其中给出了详细的证明。</p><p>此外，还需要考虑边界条件。如果 $i$ 和 $j$ 中至少有一个为 $0$，则以位置 $(i,j)$ 为右下角的最大正方形的边长只能是 1，因此 $dp(i, j) = 1$。</p><blockquote><p>扩展85.最大矩形(Hard)<br>1277.统计全为1的正方形子矩阵</p></blockquote><hr><h2 id="53-最大字序和"><a href="#53-最大字序和" class="headerlink" title="53. 最大字序和"></a>53. <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">最大字序和</a></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><pre><code class="hljs angelscript">示例:输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。</code></pre><p>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><hr><p>一般人思路是暴力法，我承认，这的确很舒服，但是告诉你有$O(n)$的方法，你会怎么想呢。</p><p>用$dp[i]$，如何表示才具有可行性。刚开始想的是序号从$0-n-1$的最大字序和。后来发现存在$dp[i-1]与nums[i-1]$断开的情况，而且中间的和一定不大于0. 官解给的是 <em>以第i个数结尾的连续数组最大和。</em>也就是不存在断开的情况。妙，实在是妙！</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1]+nums[i-1],num[i-1])</script><p>max里面前者表示存在新的后续元素使之更大，后者是新元素比原来的和更大。</p><blockquote><p> 边界条件：</p></blockquote><p>$dp[0] = 0$</p><p>此外还可以用滚动数组降低空间复杂度。</p><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]输出: <span class="hljs-literal">true</span>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。</code></pre><hr><p>这一题可以正好填补一些我们思路上的空白。即，动态规划的迭代并不一定是连续的，很有可能存在跳跃。</p><p>用$dp[i]$表示s前i个字符能否由字典中单词组成。那么$dp[i]=dp[j] \text{and}  dict.check(s.substr(j,i-j));$，check在这里检查$s[j:i-1]$与字典中某一个单词匹配。初始条件为$dp[0]=true$空字符一定匹配，实际上，dp中大部分元素都是$false$。</p><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">6</span>解释: 子数组 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 有最大乘积 <span class="hljs-number">6</span>。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>]输出: <span class="hljs-number">0</span>解释: 结果不能为 <span class="hljs-number">2</span>, 因为 [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>] 不是子数组。</code></pre><hr><p>这道题我们很容易陷入惯性思维，与最大子序和相似，我们可以设定$dp[i]$为以$nums[i-1]$为末尾的最大乘积，很容易知道 </p><script type="math/tex; mode=display">dp[i]=max\{dp[i-1]*nums[i-1],nums[i-1]\}</script><p>但是这一题与53不同的是，负负得正，比如$[-9,1,-8]$得到最大和是72而不是1. 所以我们需要分类讨论，$num[i-1]$正负性，还要设计一个求最小积的$mdp[i]$，与求最大积$Mdp[i]$相对，具体如下：</p><script type="math/tex; mode=display">Mdp=\begin{cases}    \max\{Mdp[i-1]*nums[i-1],nums[i-1]\},nums[i-1]>0\\    \max\{mdp[i-1]*nums[i-1],nums[i-1]\},otherwise\\    \end{cases}\\    \\    \\    \\mdp=\begin{cases}    \min\{mdp[i-1]*nums[i-1],nums[i-1]\},nums[i-1]>0\\    \min\{Mdp[i-1]*nums[i-1],nums[i-1]\},otherwise\\    \end{cases}</script><p>初始条件$mdp[1]=nums[0],Mdp[1]=nums[0].$</p><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">12</span>输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4.</span></code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">13</span>输出: <span class="hljs-number">2</span>解释: <span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9.</span></code></pre><hr><p>这个例子表明dp算法可以和其它算法结合在一起，比如贪心算法。</p><p>我们设$minSquare(i)$表示数字$i$对应的最小完全平方数数目，那么：</p><script type="math/tex; mode=display">minSquare(i) = \min\limits_{1\le k < i}(minSqaure(i-k)+1)</script><p>但其实我们并不需要全部计算出$minSquare(i-k)$的值，因为中间结果可能出现$minSquare(i-k)$，因此我们可以采用哈希表加速。</p><blockquote><p>边界条件：minSquare(0)=0; // 注意这个条件是虚构的</p></blockquote><p>我们先找到小于n的所有完全平方数然后从1开始到n，找到最小数。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(n\cdot\sqrt{n})$，在主步骤中，我们有一个嵌套循环，其中外部循环是 $n$ 次迭代，而内部循环最多需要 $\sqrt{n}$ 迭代。</li><li>空间复杂度：$\mathcal{O}(n)$，使用了一个一维数组 dp。</li></ul><hr><blockquote><p>下面我们看一些复杂的DP问题。</p></blockquote><h2 id="410-分割数组的最大和"><a href="#410-分割数组的最大和" class="headerlink" title="410. 分割数组的最大和"></a>410. <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大和</a></h2><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>注意:<br>数组长度 n 满足以下条件:</p><ul><li>1 ≤ n ≤ 1000</li><li>1 ≤ m ≤ min(50, n)</li></ul><p>示例:<br><pre><code class="hljs angelscript">输入:nums = [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]m = <span class="hljs-number">2</span>输出:<span class="hljs-number">18</span>解释:一共有四种方法将nums分割为<span class="hljs-number">2</span>个子数组。其中最好的方式是将其分为[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] 和 [<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]，因为此时这两个子数组各自的和的最大值为<span class="hljs-number">18</span>，在所有情况中最小。</code></pre></p><hr><p><code>将数组分割为m段，求...</code>是动态规划的常见问法。</p><p>我们可以令$dp[i][j]$表示数组前$i$个数分割为$j$段，所能得到最大连续子数组和的最小值，我们可以考虑第$j$段的具体范围，即我们可以枚举$k$，将前$k$个数分割为$j-1$段，而第$k+1$到第$i$个数为第$j$段，此时，这$j$段数组中和的最大值等于$dp[k][j-1]$与$sum(k+1,i)$中和的较大值，其中$sum(a,b)$表示$nums[i]在[a,b]$的范围和。</p><p>状态转移方程：</p><script type="math/tex; mode=display">dp[i][j]=\min\limits_{k=0}^{i-1}(\max(dp[k][j-1],\sum\limits_{k+1}^i{nums[i]})</script><p>边界条件:</p><script type="math/tex; mode=display">dp[0][0] = 0;</script><p>时间复杂度: $O(n^2m)$,其中$n$是数组长度，$m$是分成非空的连续子数组个数，总状态数$O(n×m)$,状态转移时间$O(n)$。<br>空间复杂度：$O(n×m)$为动态规划数组开销。</p><blockquote><p>“我🤮饱了，后面还有吗” </p><p>“当然”</p></blockquote><p>下面介绍一下字符串中的dp解法，比如10. 正则表达式匹配 和 44. 通配符匹配。 都是很经典的dp。 寥寥几句足以把超复杂的可能性涵盖其中，真让人不尽感叹造物主的鬼斧神工。</p><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.<a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><pre><code class="hljs 1c">&#x27;.&#x27; 匹配任意单个字符&#x27;*&#x27; 匹配零个或多个前面的那一个元素</code></pre><p>所谓匹配，是要涵盖 整个字符串 s的，而不是部分字符串。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;aa&quot;</span>p = <span class="hljs-string">&quot;a&quot;</span><span class="hljs-section">输出: false</span><span class="hljs-section">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span></code></pre><p>示例 2:</p><pre><code class="hljs smalltalk">输入:s = <span class="hljs-comment">&quot;aa&quot;</span>p = <span class="hljs-comment">&quot;a*&quot;</span>输出: <span class="hljs-keyword">true</span>解释: 因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-comment">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。</code></pre><p>示例 3:</p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;ab&quot;</span>p = <span class="hljs-string">&quot;.*&quot;</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span></code></pre><p>示例 4:</p><pre><code class="hljs smalltalk">输入:s = <span class="hljs-comment">&quot;aab&quot;</span>p = <span class="hljs-comment">&quot;c*a*b&quot;</span>输出: <span class="hljs-keyword">true</span>解释: 因为 <span class="hljs-string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="hljs-string">&#x27;c&#x27;</span> 为 <span class="hljs-number">0</span> 个, <span class="hljs-string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="hljs-comment">&quot;aab&quot;</span>。</code></pre><p>示例5<br><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;mississippi&quot;</span>p = <span class="hljs-string">&quot;mis*is*p*.&quot;</span><span class="hljs-section">输出: false</span></code></pre></p><hr><p>我们用 $dp[i][j]$ 表示 s 的前 i 个字符与 pp 中的前 j 个字符是否能够匹配。在进行状态转移时，我们考虑 pp 的第 jj 个字符的匹配情况：</p><ul><li>如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母，即<script type="math/tex; mode=display">dp[i][j] =  (s[i-1]==p[j-1] \&\& dp[i-1][j-1]</script></li></ul><p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 ss 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p><ul><li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</p></li><li><p>不匹配字符，将该组合扔掉，不再进行匹配。</p></li></ul><p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{array}{lcr}dp[i-1][j]||dp[i][j-2],\ s[i]==p[j-1]\\dp[i][j-2],\ s[i]\ne p[j-1]\end{array}\right.</script><ul><li>在任意情况下，只要 $p[j]$ 是<code>.</code>，那么 $p[j]$ 一定成功匹配 ss 中的任意一个小写字母。</li></ul><p>最终的状态转移方程如下：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}\text{if}\ (p[j]\ne '*')=\begin{cases}dp[i-1][j-1], matches(s[i],p[j]) \\false, \ otherwise\end{cases}\\\\otherwise = \begin{cases}dp[i-1][j]\ || \ dp[i][j-2], matches(s[i],p[j-1])\\dp[i][j-2], otherwise\end{cases}\end{cases}</script><p>其中$\textit{matches}(x, y)$ 判断两个字符是否匹配的辅助函数。只有当 y 是 <code>.</code> 或者 x 和 y 本身相同时，这两个字符才会匹配。</p><blockquote><p> 细节</p></blockquote><p>动态规划的边界条件为 $ dp[0][0] = true $，即两个空字符串是可以匹配的。最终的答案即为 $dp[m][n]$，其中 m和 n 分别是字符串 s 和 p 的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。</p><p>在上面的状态转移方程中，如果字符串 p 中包含一个字符+星号的组合（例如 $a<em>$），那么在进行状态转移时，会先将 a 进行匹配（当 $p[j]$ 为 a 时），再将 a</em> 作为整体进行匹配（当 $p[j]$ 为 <em> 时）。然而，在题目描述中，我们必须将 a</em> 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。</p><p>C++代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = s.size();        <span class="hljs-keyword">int</span> n = p.size();        <span class="hljs-keyword">auto</span> matches = [&amp;](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>];        &#125;;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;                    f[i][j] |= f[i][j - <span class="hljs-number">2</span>];                    <span class="hljs-keyword">if</span> (matches(i, j - <span class="hljs-number">1</span>)) &#123;                        f[i][j] |= f[i - <span class="hljs-number">1</span>][j];                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (matches(i, j)) &#123;                        f[i][j] |= f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[m][n];    &#125;&#125;;</code></pre><hr><h1 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a>44. <a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h1><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><pre><code class="hljs C++"><span class="hljs-string">&#x27;?&#x27;</span> 可以匹配任何单个字符。<span class="hljs-string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。两个字符串完全匹配才算匹配成功。</code></pre><p>说明:</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li></ul><hr><p>我们用$dp[i][j]$表示s的第$i$个字符与p的第$j$个字符是否匹配。</p><ul><li><p>第一种情况是字母与字母匹配，即</p><script type="math/tex; mode=display">dp[i][j] =  (s[i-1]==p[j-1] \&\& dp[i-1][j-1])</script></li><li><p>第二种情况是$p[j]$是问好，则对$s[i]$没有任何要求</p><script type="math/tex; mode=display">dp[i][j] = (p[j-1]=='?'\&\&dp[i-1][j-1])</script></li><li><p>第三种情况，是遇到$’’*’’$，这种情况最为复杂，因为不知道星号要匹配多少个字符，这里很容易想到<code>回溯</code>方法，但是回溯一般会超时，著名的KMP算法是因为了避免回溯才会那么快。</p><p>所以我们想这个星号可以使用多次，也可以一次都不使用。</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j]||dp[i][j-1]</script><p>后面一项表示不使用星号，前面一项表示使用星号。</p><p>总结一下：</p><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{array}{lcr}s[i-1]==p[j-1] \&\& dp[i-1][j-1]，'a-z'\\p[j-1]=='?'\&\&dp[i-1][j-1],'?'\\dp[i-1][j]||dp[i][j-1], '*'\end{array}\right.</script></li></ul><blockquote><p>边界条件：</p><p>也就是$dp[0][0]$，我们不能单纯认为开始两个字符相等就是$dp[0][0]==True$。因为$p$有星号和问号开头的情况。<br>$dp[0][0]=(s[0]==p[0])||(p[0]==’?’)||(p[0]==’*’)$</p></blockquote><ol><li><p>若两个字符串为空，$dp[0][0]$也为True.</p><script type="math/tex; mode=display">dp[i][0]=!s.size()</script><p>即空字符串无法匹配非空字符串。</p></li><li><p>若s为空，p全为”*”，才能完成匹配。</p><script type="math/tex; mode=display">dp[0][j] = (p[j]=='*')\&\&dp[0][j-1]</script></li></ol><p>我们可以发现，$dp[i][0]$的值恒为假，$dp[0][j]$ 在 $j$ 大于模式 $p$ 的开头出现的星号字符个数之后，值也恒为假，而 $dp[i][j]$ 的默认值（其它情况）也为假，因此在对动态规划的数组初始化时，我们就可以将所有的状态初始化为 False，减少状态转移的代码编写难度。</p><p>此外还要考虑字符串的硬边界。此外，<strong>注意</strong>下标对$dp[i][j]$表示$s[i-1]$与$p[j-1]$匹配，因为下标是从0开始的。</p><p>Python 实现：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">self, s: str, p: str</span>) -&gt; bool:</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> s: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> p: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>             m = len(s); n = len(p)    dp = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>) ]    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>) <span class="hljs-keyword">or</span> (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">or</span> (s <span class="hljs-keyword">and</span> s[<span class="hljs-number">0</span>]==p[<span class="hljs-number">0</span>])     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">not</span> len(s)    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):        dp[<span class="hljs-number">0</span>][j] = (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">and</span> dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):            dp[i][j] = (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> \                        (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">and</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> \                        (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-keyword">and</span> (dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-keyword">or</span> dp[i][j<span class="hljs-number">-1</span>]))            print(<span class="hljs-string">&quot;(%d,%d):&quot;</span>%(i,j),dp[i][j])    <span class="hljs-keyword">return</span> dp[m][n]</code></pre><p>C++实现：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (!p.size() &amp;&amp; s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (!s.size() &amp;&amp; !p.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">int</span> m = s.size(), n = p.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)||(p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>)||(s.size()&amp;&amp;s[<span class="hljs-number">0</span>]==p[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++) dp[i][<span class="hljs-number">0</span>] = !s.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++) dp[<span class="hljs-number">0</span>][j] = (p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;*&#x27;</span>) &amp;&amp; dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++)        dp[i][j] = (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) || \                            (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) || \                            (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; (dp[i<span class="hljs-number">-1</span>][j] || dp[i][j<span class="hljs-number">-1</span>]));        <span class="hljs-keyword">return</span> dp[m][n];                &#125;&#125;;</code></pre><p>明显是C++要快些()，嘻嘻😂，而且内存占用要小些</p><p>老规矩，下面分析时间复杂度和空间复杂度.</p><p>时间复杂度：$O(MN)$</p><p>空间复杂度:$O(NM)$ $N和M$分别表示目标串和模式串的长度。我们可以使用<code>滚动数组</code>对空间进行优化，即用两个长度为 $n+1$ 的一维数组代替整个二维数组进行状态转移，空间复杂度为$ O(n)$。</p><p>当然这题也有贪心解法，有兴趣的小伙伴可以研究一下。</p><hr><h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h1><p>这一题在LC上属于难题分类，但实际上通过率高达59.6%，是一道名副其实的<code>Easy</code>题。</p><p>但是我们想说的dp千变万化，不离其宗。题目做多了自然就有想法了。</p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><hr><p>我们用$dp[i][j]$表示word1前i个字符转换为word2前j个字符所需的<code>最小</code>操作数。 </p><p>然后在word1插入一个字符相当于$dp[i][j]=dp[i-1][j]+1$，一定会多出来一个步骤。</p><p>然后在word1删除一个字符相当于$dp[i][j]=dp[i][j-1]+1$，也一定会多出来一个步骤。</p><p>如果word1最后一个字符通过替换得到word2，那么要分情况，如果最后一个字符相同，那么$dp[i][j]=dp[i-1][j-1]$，否则$dp[i][j]=dp[i-1][j-1]+1$.</p><blockquote><p>边界条件 $dp[0][j] = j,dp[i][0]=i$</p></blockquote><p>就是完全的删除或者完全插入。</p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">string</span> word2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!word1.size()) <span class="hljs-keyword">return</span> word2.size();        <span class="hljs-keyword">if</span>(!word2.size()) <span class="hljs-keyword">return</span> word1.size();        <span class="hljs-comment">//dp[i][j]表示word1的前i位替换为word2前i位所需的最小步数</span>        <span class="hljs-keyword">int</span> m = word1.size(), n = word2.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (word1[<span class="hljs-number">0</span>]==word2[<span class="hljs-number">0</span>])? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=m ;i++) dp[i][<span class="hljs-number">0</span>] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ;j++) dp[<span class="hljs-number">0</span>][j] = j;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=m; i++ )        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++ )        &#123;            <span class="hljs-keyword">int</span> exchange = (word1[i<span class="hljs-number">-1</span>]==word2[j<span class="hljs-number">-1</span>])?dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]:dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;            dp[i][j] = min(exchange, min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>));        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;;</code></pre><blockquote><p>小伙伴如果有收获，请点赞留言哦Σ(っ °Д °;)っ</p></blockquote><hr><h4 id="5494-统计所有可行路径"><a href="#5494-统计所有可行路径" class="headerlink" title="5494. 统计所有可行路径"></a><a href="https://leetcode-cn.com/problems/count-all-possible-routes/">5494. 统计所有可行路径</a></h4><p>给你一个 互不相同 的整数数组，其中 locations[i] 表示第 i 个城市的位置。同时给你 start，finish 和 fuel 分别表示出发城市、目的地城市和你初始拥有的汽油总量</p><p>每一步中，如果你在城市 i ，你可以选择任意一个城市 j ，满足  j != i 且 0 &lt;= j &lt; locations.length ，并移动到城市 j 。从城市 i 移动到 j 消耗的汽油量为 |locations[i] - locations[j]|，|x| 表示 x 的绝对值。</p><p>请注意， fuel 任何时刻都 不能 为负，且你 可以 经过任意城市超过一次（包括 start 和 finish ）。</p><p>请你返回从 start 到 finish 所有可能路径的数目。</p><p>由于答案可能很大， 请将它对 10^9 + 7 取余后返回。</p><p>示例 1：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>], start = <span class="hljs-number">1</span>, finish = <span class="hljs-number">3</span>, fuel = <span class="hljs-number">5</span>输出：<span class="hljs-number">4</span>解释：以下为所有可能路径，每一条都用了 <span class="hljs-number">5</span> 单位的汽油：<span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span></code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], start = <span class="hljs-number">1</span>, finish = <span class="hljs-number">0</span>, fuel = <span class="hljs-number">6</span>输出：<span class="hljs-number">5</span>解释：以下为所有可能的路径：<span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">1</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span></code></pre><p>示例 3：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">2</span>, fuel = <span class="hljs-number">3</span>输出：<span class="hljs-number">0</span>解释：没有办法只用 <span class="hljs-number">3</span> 单位的汽油从 <span class="hljs-number">0</span> 到达 <span class="hljs-number">2</span> 。因为最短路径需要 <span class="hljs-number">4</span> 单位的汽油。</code></pre><p>示例 4 ：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">0</span>, fuel = <span class="hljs-number">3</span>输出：<span class="hljs-number">2</span>解释：总共有两条可行路径，<span class="hljs-number">0</span> 和 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> 。</code></pre><p>示例 5：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">2</span>, fuel = <span class="hljs-number">40</span>输出：<span class="hljs-number">615088286</span>解释：路径总数为 <span class="hljs-number">2615088300</span> 。将结果对 <span class="hljs-number">10</span>^<span class="hljs-number">9</span> + <span class="hljs-number">7</span> 取余，得到 <span class="hljs-number">615088286</span> 。</code></pre><p>提示：</p><ul><li><code>2 &lt;= locations.length &lt;= 1001 &lt;= locations[i] &lt;= 10^9所有 locations 中的整数 互不相同 。0 &lt;= start, finish &lt; locations.length1 &lt;= fuel &lt;= 200</code></li></ul><hr><p>此题乃背包问题的变形。背包内有一些物品，拿相邻两个物品需要时间，这个时间取决于它们的重量差，一共给你<code>fuel</code>时间，问开始拿<code>start</code>物品，最后拿<code>finsih</code>物品有多少种可行方案。</p><p>老规矩，<strong>动态规划</strong>和<strong>记忆化搜索</strong>都能做。</p><p><strong>动态规划</strong></p><p>设$dp[i][f]$表示从起点到达第$i$个城市<strong>刚好消耗f个汽油</strong>的可行路径数。这里强调刚好是把问题变成离散化。刚开始容易想成最多消耗f汽油。这样做的问题是，会产生大量重复解。而刚好消耗则把总的汽油数进行恰当分解，得到结果唯一。</p><ul><li>状态转移方程：$dp[i][f] = dp[i][f] + dp[j][f-cost[i,j]]$</li></ul><p>这里的$cost[i,j]$表示从第$i$个城市到第$j$个城市消耗的汽油，即$abs(locations[i]-locations[j])$。</p><blockquote><p>这里不是max而是+=的形式，想一想为什么。因为我们从起点到$j$城市的路径数知道了，接下来是求$j-&gt;i$的路径数。且保证汽油消耗刚好为$f$。此时$j-&gt;i$路径数是$1$,因为是直达。严格意义上讲，(start-&gt;j-&gt;i)路径数为$1*dp[j][cost[i,j]]$，是相乘的关系。然后可能有别的路径所以把这些相加，即得到总的路径数。</p></blockquote><ul><li><p>初始化条件：$dp[start][0]=1$ ，需要注意的是很容易把从初始到每个城市的路径数初始化为1. 这样做会造成重复。我们在进行状态转移时，就会考虑这些情况。</p></li><li><p>循环条件：</p></li></ul><p>$i,j$两个城市是并列关系，只要两个城市互不相同就可以访问，且可以重复访问，不管是否到达终点，所以我们<strong>考虑消耗汽油为$f$前提下</strong>，从起点到$i$可行路径数。把汽油数作为最外层循环，否则城市将不能循环访问！</p><ul><li>求解目标：</li></ul><p>我们最终求解，$\sum\limits_{i} dp[finish][f_i]$</p><ul><li><p>细节，由于dp中间结果可能非常大，每做一次状态转移都要取模。</p></li><li><p>代码实现：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    ll mod = <span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRoutes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span> </span>&#123;                <span class="hljs-comment">//老思路dp, 不过这里的节点可以反复遍历，直到汽油耗光为止,可以转化为完全背包</span>        <span class="hljs-keyword">int</span> n = locations.size();        res = <span class="hljs-number">0</span>;        <span class="hljs-comment">//dp[i][f]表示从起点到第i城市刚好消耗f燃料的可行路径数。</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &gt;(fuel+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-comment">//初始条件</span>        dp[start][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;       <span class="hljs-comment">//状态转移</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt;= fuel; f++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(j!=i)        &#123;        <span class="hljs-keyword">int</span> cost = <span class="hljs-built_in">abs</span>(locations[i]-locations[j]);        <span class="hljs-keyword">if</span>(f &gt;= cost)         &#123;             dp[i][f] +=  dp[j][f-cost] ;             dp[i][f] %= mod;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d-&gt;%d,cost:%d,dp:%d\n&quot;</span>,start,j,i,cost,dp[i][f]);        &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt;= fuel ;f++)         <span class="hljs-keyword">if</span>(dp[finish][f])        &#123;            res += dp[finish][f];            res %= mod;        &#125;        <span class="hljs-keyword">return</span> res%mod;    &#125;&#125;;</code></pre><ul><li>时间复杂度：$O(N^2*f)$. $N$为城市数，$f$为总汽油量</li><li>空间复杂度:   $O(N*f)$.</li></ul></li></ul><p><strong>记忆化搜索</strong></p><p>根据题目给的数据范围，数组长度不太大,<code>fuel</code>不太大，判断记忆化搜索可行。</p><p><code>2 &lt;= locations.length &lt;= 1001 &lt;= locations[i] &lt;= 10^9所有 locations 中的整数 互不相同 。0 &lt;= start, finish &lt; locations.length1 &lt;= fuel &lt;= 200</code></p><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">205</span>];<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span></span>&#123;        <span class="hljs-comment">//返回从start到finish的可行路径数</span>        <span class="hljs-keyword">if</span>(dp[start][fuel] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[start][fuel];        ll ans = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> len = locations.size();        <span class="hljs-keyword">if</span>(start == finish) ans++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-keyword">int</span> diff = <span class="hljs-built_in">abs</span>(locations[i] - locations[start]);            <span class="hljs-keyword">if</span>(start == i) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(fuel - diff &gt;= <span class="hljs-number">0</span>)&#123;                ans = (ans + dfs(locations, i, finish, fuel - diff)) % MOD;            &#125;        &#125;        dp[start][fuel] = (ans % MOD);        <span class="hljs-keyword">return</span> dp[start][fuel];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRoutes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span> </span>&#123;        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));        <span class="hljs-keyword">return</span> dfs(locations, start, finish, fuel);    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Durant终于有个家写写东西了</title>
    <link href="/2020/07/19/2020-07-19-damn_blog/"/>
    <url>/2020/07/19/2020-07-19-damn_blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上周，非常有幸接触到<code>Hux</code>大佬的博客，深感震撼，而且他也在Github上分享了Jekyll源码,star&gt;5000。我决定DIY一番，不然对不起程序员的身份。</p></blockquote><h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>好不容易搭建好了，结果写好的markdown样子和Hux完全不同。</p><ol><li>标签前面有<code>#</code>，而且是有标签的那种</li><li>图片不显示</li><li>公式不显示</li><li>语法没高亮，没行号 </li><li>目录没显示</li><li>评论区没显示</li></ol><p>这叫我如何能忍。是可忍，孰不可忍。</p><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><ol><li>将 <code>_config.yml</code>文件的<code>anchorjs</code>改为<code>false</code>。这主要是跳转用的，不需要。</li><li><p>采用网络图片，刷新几次就好了<del><strong>玄学</strong></del></p></li><li><p>Kramdown主要是<code>$$ ... $$</code>表示公式区域，它会自动渲染为mathjax标签。之前用VS code自带的markdown math 是以<code>$ ... $</code>。疏忽了。<br>在<code>_include</code>的<code>head.html</code>加入一句话，在post文件前加<code>latex:true</code>即可。</p></li></ol><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> page.latex == true %&#125;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span></code></pre><ol><li>之前以为是C++，改成cpp就能高亮了，呃</li></ol><h1 id="I-want-more"><a href="#I-want-more" class="headerlink" title="I want more"></a>I want more</h1><p>作为一个前端，后端小白，还是很想扩展一下博客的功能的····，满足自己的装bei心里。</p><ol><li>加入评论功能</li><li>统计访问量</li><li>为博客加入点赞功能</li><li>花里胡哨的功能</li></ol><ol><li>博客搜索</li><li>博客置顶</li><li>访问加速</li><li>访客限制</li><li>（高级）在网站上直接post&amp;push</li></ol><hr><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>hexo简单强大，完爆Github page。</p><p>配置Hexo<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">传送门</a></p><p>配置<a href="https://blog.csdn.net/frone/article/details/81170627">Mathjax</a></p><p><a href="https://www.cnblogs.com/codehome/p/8428738.html">上传本地图片</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>朝花夕拾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>妈妈终于不用担心我分不清楚红黑树和树状数组了！</title>
    <link href="/2020/07/17/2020-07-17-fenwicktree-segmentTree/"/>
    <url>/2020/07/17/2020-07-17-fenwicktree-segmentTree/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树和树状数组"><a href="#线段树和树状数组" class="headerlink" title="线段树和树状数组"></a>线段树和树状数组</h1><blockquote><p>“树状数组和线段树都是用于维护数列信息的数据结构，支持单点/区间修改，单点/区间询问信息。以增加权值与询问区间权值和为例，其余的信息需要维护也都类似。时间复杂度均为$O(logn)$。 ”</p><p><a href="https://zhuanlan.zhihu.com/p/191524460">详细的数学证明</a></p></blockquote><ul><li>练习题目<ul><li><ol><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">计算右侧小于当前元素的个数</a></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">最大子序和</a></li></ol></li></ul></li></ul><h1 id="I-树状数组"><a href="#I-树状数组" class="headerlink" title="I. 树状数组"></a>I. 树状数组</h1><h2 id="Fenwick-Tree"><a href="#Fenwick-Tree" class="headerlink" title="Fenwick Tree"></a>Fenwick Tree</h2><p>地中海的程序猿们研究数组，时候遇到这样一个问题: 有一个数组$S$从$0 - n-1$，现在要在$O(logn)$ 的时间复杂度内，搜索一个确定的值（或修改）$w$并且对区间 $[a,b]$ 求和。空间复杂度必须严格限制在$O(n)$.</p><p>他们想到了二叉搜索树(BST)，对于平衡二叉树其插入和删除的时间复杂度都是$O(logn)$，因为树是类似于嵌套列表的思想，进而可以想到二叉堆，这是一种非嵌套列表，也可以实现$O(logn)$。于是有了下面这张图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vQUtNZXIvMTIyODU5OS9vX1RyZWVBcnJheS5qcGc?x-oss-process=image/format,png" alt="FenwickTree"></p><blockquote><p>解释一下，编号为$x$的节点上统计着$[x-lowbit(x)+1,x]$这一段区间的信息，$x$的父亲就是$x+lowbit(x)$,我们要维护数组$C$上的信息，存储在数组$A$中。</p></blockquote><p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的$f[i]$的个数也是2的幂。</p><h2 id="1-Lowbit函数"><a href="#1-Lowbit函数" class="headerlink" title="1. Lowbit函数"></a>1. Lowbit函数</h2><blockquote><p>返回参数转换为二进制后，最后一个1的位置所代表的数值。</p></blockquote><p>比如34转换为二进制就是0010 0010, Lowbit(34)返回2. 程序上 我们可以用<code>((Not I)+1) AND I</code>, 比如NOT(0010 0010) = 1101 1101, 加1之后为 1101 1110，再与上I,为0000 0010(2)。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;</code></pre><h2 id="2-新建数组"><a href="#2-新建数组" class="headerlink" title="2. 新建数组"></a>2. 新建数组</h2><p>我们定义一个数组BIT，用以维护A的前缀和，</p><script type="math/tex; mode=display">BIT_i = \sum\limits_{j=i-lowbit(i)+1}^{i} A_{j}</script><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_N; i++)    &#123;        BIT[i] = A[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">2</span>; j &gt;= i - lowbit(i); j--)            BIT[i] += A[j];    &#125;&#125;</code></pre><h2 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h2><p>假设现在要在$A[i]$的值增加$\delta$, 那么需要将$BIT$在所有含$A[i]$的区间都加上一个数，<br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> w)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">// 在下标k、加上w</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&lt; tr.size();j+=low_bit(j)) tr[j]+=w;    &#125;</code></pre></p><h2 id="4-区间求和"><a href="#4-区间求和" class="headerlink" title="4. 区间求和"></a>4. 区间求和</h2><p>假设我们需要计算$\sum\limits_{i=1}^kA_i$的值。</p><ol><li>首先，将$ans$初始化为$k$</li><li>将$ans$的值加上$BIT[i]$</li><li>将$i$的值减去$Lowbit(i)$</li><li>重复2 . 3 步骤直到$i$的值变为0.</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i))        ans += BIT[i];    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>应用：求<a href="https://blog.csdn.net/cattycat/article/details/5640838">逆序数</a></p><blockquote><p>练习 <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">LC315. 计算右侧小于当前元素的个数</a></p></blockquote><h1 id="II-线段树"><a href="#II-线段树" class="headerlink" title="II. 线段树"></a>II. 线段树</h1><h2 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h2><blockquote><p>使用线段树可以快速查找某一个节点在若干线段中出现的次数，时间复杂度为$O(logN)$，而未优化的空间复杂度为$2N$，一般要开$4N$的数组防止越界。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvYmQzZWIxMzUzM2ZhODI4YmNiNWZlODVmZmUxZjQxMzQ5NzBhNWEwOQ?x-oss-process=image/format,png" alt="线段树"></p><p>除了叶子节点外，对于$[a,b]$线段节点，其有两个子节点, 左子节点$[a,(a+b)/2]$和右子节点$[(a+b)/2+1,b]$。由于线段树在程序竞赛中被广泛应用，这种结构被$ACMer$和$OIer$戏谑为必须掌握的数据结构。一般地，我们先定义一个线段树节点结构体:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> start;<span class="hljs-comment">//线段左节点</span>    <span class="hljs-keyword">int</span> end;<span class="hljs-comment">//线段右节点</span>    <span class="hljs-keyword">int</span> sum;<span class="hljs-comment">//线段对应的和</span>    <span class="hljs-keyword">int</span> lazytag;<span class="hljs-comment">//懒标记</span>    SegmentNode *left;    SegmentNode *right;    SegmentNode():start(<span class="hljs-number">0</span>),end(<span class="hljs-number">0</span>),sum(<span class="hljs-number">0</span>)&#123;&#125;&#125;;</code></pre><p>请务必熟悉理解<code>上述</code>结构！</p><h2 id="1-建立树"><a href="#1-建立树" class="headerlink" title="1. 建立树"></a>1. 建立树</h2><p>我们对区间$[l,r]$建立线段树，是一个自上而下过程。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;        self-&gt;start = l;self-&gt;end = r;        <span class="hljs-keyword">if</span>(l==r)        &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        self-&gt;left = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;left,l,mid);        self-&gt;right = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;right,mid+<span class="hljs-number">1</span>,r);    &#125;</code></pre><h2 id="2-单点修改"><a href="#2-单点修改" class="headerlink" title="2. 单点修改"></a>2. 单点修改</h2><p>从根节点开始,以递归的方式不断更新sum值，直到叶子节点即<code>区间长度为1</code>，每个区间的sum值等于左子区间的sum值，加上右子区间的sum值。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos&lt;self-&gt;start||pos&gt;self-&gt;end) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(self-&gt;start == self-&gt;end)    &#123;        self-&gt;sum += k;        <span class="hljs-keyword">return</span>;     &#125;    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&gt;pos) add(self-&gt;left,pos,k);    <span class="hljs-keyword">else</span> add(self-&gt;right,pos,k);    self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;&#125;</code></pre><h2 id="3-区间查询"><a href="#3-区间查询" class="headerlink" title="3. 区间查询"></a>3. 区间查询</h2><ul><li>第一种情况是当前的区间范围完全在$[l,r]$内，这个时候把当前区间的$sum$值返回即可，</li><li>第二张情况是当前节点的<code>左子节点</code>的<code>右端点</code>和$[l,r]$有交集。这个时候就搜索左子节点。</li><li>第三张情况是当前节点的<code>右子节点</code>的<code>左端点</code>和$[l,r]$有交集。这个时候就搜索右子节点。<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//这里的i,j分别代表要搜索的区间</span>    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(i&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=j)    &#123;        <span class="hljs-keyword">return</span> self-&gt;sum;     &#125;    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j);    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j);    <span class="hljs-keyword">return</span> s;&#125;</code></pre><h2 id="4-延迟标记"><a href="#4-延迟标记" class="headerlink" title="4. 延迟标记"></a>4. 延迟标记</h2></li></ul><p>对于区间修改，这里会遇到一个问题：为了使所有sum值都保持正确，每一次插入操作可能要更新$O(N)$个sum值，从而使时间复杂度退化为$O(N)$。所以就有了Lazytag，如果一个节点有延迟标记，那么表明这个节点已经被修改过了。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_tag</span><span class="hljs-params">(SegmentNode *self,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span> </span>&#123;    self-&gt;sum += (r-l+<span class="hljs-number">1</span>)*v;self-&gt;lazytag+=v;<span class="hljs-comment">//标记只对儿子有影响，自己在打标记的同时一起把统计信息更改了。</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(SegmentNode *self,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    add_tag(self-&gt;left,l,mid,self-&gt;lazytag);    add_tag(self-&gt;right,mid+<span class="hljs-number">1</span>,r,self-&gt;lazytag);    self-&gt;lazytag = <span class="hljs-number">0</span>;<span class="hljs-comment">//把当前标记分别传给两个儿子然后清空</span>&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-comment">//[l,r]为当前区间,[L,R]为要修改的区间</span>    <span class="hljs-keyword">if</span>(l&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=r) &#123;        add_tag(self,l,r,v);<span class="hljs-comment">//打标记</span>        <span class="hljs-keyword">return</span>;&#125;    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;    push_down(self,l,r);<span class="hljs-comment">//下传标记</span>    <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j,v);    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j,v);    <span class="hljs-keyword">return</span> s;&#125;</code></pre><h1 id="III-树状数组和线段树比较"><a href="#III-树状数组和线段树比较" class="headerlink" title="III. 树状数组和线段树比较"></a>III. 树状数组和线段树比较</h1><div class="table-container"><table><thead><tr><th style="text-align:center">数据结构</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">适用特点</th></tr></thead><tbody><tr><td style="text-align:center">线段树</td><td style="text-align:center">$O(logN)$</td><td style="text-align:center">O(N)</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">树状数组</td><td style="text-align:center">$O(logN)$</td><td style="text-align:center">O(N)</td><td style="text-align:center">空间复杂度略低，容易扩展到多维，适用范围较线段树小</td></tr></tbody></table></div><p>下面看一些经典题目吧</p><h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">最大子序和</a></h1><p>其实这题除了用动态规划，还可以用线段树做。</p><p><strong>这个分治方法类似于「线段树求解 LCIS 问题」的 pushUp 操作</strong>。 当然，如果读者有兴趣的话，推荐看一看线段树区间合并法解决 <code>多次询问</code> 的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p><p>我们定义一个操作<code>get(a,l,r)</code>表示查询a序列$[l,r]区$间内的最大字段和。对于一个区间，我们取$m = [\frac{l+r}{2}]$,然后<code>逐层递归</code>。最关键的问题是：</p><ul><li><p>我们要维护区间什么信息？</p></li><li><p>我们如何合并这些信息？</p></li></ul><p>  对于一个区间$[l,r]$，<code>lSum</code>表示$[l,r]$以$l$为左端点的最大子段和；<code>rSum</code>表示$[l,r]$以$r$为右端点的最大子段和，<code>mSum</code>表示$[l,r]$</p><p>  内的最大子段和。<code>iSum</code>表示$[l,r]$的区间和。</p><ul><li><code>iSum</code>是左右区间的子段和的和。</li><li>对于 $[l, r]$ 的 <code>lSum</code>，存在两种可能，它要么等于「左子区间」的 <code>lSum</code>，要么等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>lSum</code>，二者取大。</li><li>对于 $[l, r]$ 的 <code>rSum</code>，存在两种可能，它要么等于「右子区间」的 <code>rSum</code>，要么等于「右子区间」的 <code>iSum</code> 加上「左子区间」的 <code>rSum</code>，二者取大。</li><li>对于<code>mSum</code>，存在三种可能，要么完全在左区间，要么完全在中间，要么两边都有，我想你已经猜到了，就是左区间的<code>rSum</code>加上右区间的<code>lSum</code>。</li></ul><p>好的已经可以开始写代码了</p><hr><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Status</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">int</span> lSum, rSum, mSum, iSum;        <span class="hljs-comment">// 分别表示，以l为左端点的最大子序和，以r为右端点的最大子序和，</span>        <span class="hljs-comment">// mSum表示区间[l,r]最大子序和</span>        <span class="hljs-comment">//iSum表示区间和</span>    &#125;;    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums,<span class="hljs-keyword">int</span>  l,<span class="hljs-keyword">int</span>  r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> (Status)&#123;nums[l],nums[l],nums[l],nums[l]&#125;;        <span class="hljs-keyword">int</span> m = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        Status lpus = get(nums,l,m);        Status rpus = get(nums,m+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">int</span> lSum = max(lpus.lSum, lpus.iSum + rpus.lSum);        <span class="hljs-keyword">int</span> rSum = max(rpus.rSum, rpus.iSum + lpus.rSum);        <span class="hljs-keyword">int</span> iSum = lpus.iSum + rpus.iSum;        <span class="hljs-keyword">int</span> mSum = max(lpus.rSum+ rpus.lSum,max(lpus.mSum, rpus.mSum));        <span class="hljs-keyword">return</span> (Status)&#123;lSum,rSum,mSum,iSum&#125;;     &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> get(nums, <span class="hljs-number">0</span> , nums.size()<span class="hljs-number">-1</span>).mSum;    &#125;</code></pre><p>然后我们分析一下时间和空间复杂度。</p><p>时间复杂度：$O(n)$，我们把递归过程看成二叉树的先序遍历，那么这颗二叉树时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 $O(\log n)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为 $O(n)$。<br>空间复杂度：递归会使用 O(\log n)O(logn) 的栈空间，故渐进空间复杂度为 $O(logn)$。 </p><hr><h1 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a>315. <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a></h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>示例：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 解释：<span class="hljs-number">5</span> 的右侧有 <span class="hljs-number">2</span> 个更小的元素 (<span class="hljs-number">2</span> 和 <span class="hljs-number">1</span>)<span class="hljs-number">2</span> 的右侧仅有 <span class="hljs-number">1</span> 个更小的元素 (<span class="hljs-number">1</span>)<span class="hljs-number">6</span> 的右侧有 <span class="hljs-number">1</span> 个更小的元素 (<span class="hljs-number">1</span>)<span class="hljs-number">1</span> 的右侧有 <span class="hljs-number">0</span> 个更小的元素</code></pre><hr><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> start;    <span class="hljs-keyword">int</span> end;    <span class="hljs-keyword">int</span> sum;    SegmentNode *left;    SegmentNode *right;    SegmentNode():start(<span class="hljs-number">0</span>),end(<span class="hljs-number">0</span>),sum(<span class="hljs-number">0</span>)&#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">//---------------------------Segment tree solution----------------------------</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;        self-&gt;start = l;self-&gt;end = r;        <span class="hljs-keyword">if</span>(l==r)        &#123;            <span class="hljs-comment">// self-&gt;sum = l;</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        self-&gt;left = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;left,l,mid);        self-&gt;right = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;right,mid+<span class="hljs-number">1</span>,r);        <span class="hljs-comment">// self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(pos&lt;self-&gt;start||pos&gt;self-&gt;end) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(self-&gt;start == self-&gt;end)        &#123;            self-&gt;sum += k;            <span class="hljs-keyword">return</span>;         &#125;        <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&gt;pos) add(self-&gt;left,pos,k);        <span class="hljs-keyword">else</span> add(self-&gt;right,pos,k);        self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(i&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=j)        &#123;            <span class="hljs-keyword">return</span> self-&gt;sum;         &#125;        <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j);        <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j);        <span class="hljs-keyword">return</span> s;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller_SegmentTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> nums;        SegmentNode *root = <span class="hljs-keyword">new</span> SegmentNode();        <span class="hljs-comment">//find the min and max val in nums</span>        <span class="hljs-keyword">int</span> min_val = INT_MAX, max_val = INT_MIN;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)&#123;min_val=min(min_val,c);max_val = max(max_val,c);&#125;        build(root,min_val,max_val);        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;        <span class="hljs-comment">// for(auto &amp;c:nums) </span>        <span class="hljs-comment">//     add(root,c,1);//All sub interval adds 1</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.size()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>;i--)        &#123;            add(root,nums[i],<span class="hljs-number">1</span>);            res[i] = search(root,min_val,nums[i]<span class="hljs-number">-1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;<span class="hljs-comment">//------------------------------Fenwick Tree Solution----------------------------------</span><span class="hljs-comment">//Due to the uncertainty of scale of data, we discretize the array</span>    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tr;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//pow(2,x)</span>        <span class="hljs-keyword">return</span> (x&amp;(-x));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&gt;<span class="hljs-number">0</span>; j-=low_bit(j)) res+=tr[j];        <span class="hljs-keyword">return</span> res;    &#125;       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> w)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">// add k to node w</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&lt; tr.size();j+=low_bit(j)) tr[j]+=w;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller_Fenwick</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-comment">//First, we discretize the vector and delete the repeated nums</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp = nums;        sort(tmp.begin(),tmp.end());        <span class="hljs-keyword">auto</span> c = unique(tmp.begin(),tmp.end());        tmp.erase(c,tmp.end());        <span class="hljs-keyword">int</span> new_len = c - tmp.begin();        <span class="hljs-comment">// we define a unordered-map to count the number of tmp</span>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; ump;        tr = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(new_len + <span class="hljs-number">1</span>);<span class="hljs-comment">//redefine the tr to (new_len+1) default value</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;new_len;i++)            ump[tmp[i]] = count++;<span class="hljs-comment">//redefine the discretized values into serialized values using hashmap</span>        <span class="hljs-comment">//we build the Fenwick tree and do summation and addition</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = nums.size()<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--)        &#123;            count = ump[nums[k]];<span class="hljs-comment">// count of number</span>            res[k] = sum(count<span class="hljs-number">-1</span>);            add(count,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><blockquote><p>感谢！有任何问题请在评论区提出，笔者看到会及时回答！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 内存手动管理</title>
    <link href="/2020/06/25/2020-06-25-C++memory_management/"/>
    <url>/2020/06/25/2020-06-25-C++memory_management/</url>
    
    <content type="html"><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><blockquote><p>内存管理是非常让人头疼的事情，因为一不小心就可能导致内存泄漏，为此很多C++程序员跑路到java或python，？？？但是反过来说，优秀的程序员知道如何管理内存，并显式获得速度的飞跃。</p></blockquote><p>内存分类：</p><ol><li><p><strong>静态内存</strong>：用来保存局部<code>static</code>对象，类的<code>static</code>数据成员以及定义在任何函数之外的变量。</p></li><li><p><strong>栈内存</strong>：用来保存定义在函数内的非<code>static</code>对象。</p><p>分配在静态或栈内存中的对象由编译器自动创建和销毁。</p></li><li><p><strong>动态内存</strong>，又被称为<strong>堆</strong>(heap)，由程序的生命周期所控制，我们的代码必须<em>显式</em>的销毁它们。</p></li></ol><p>通常我们用<code>new</code>创建一个对象，然后用<code>delete</code>销毁它。</p><blockquote><p>未完待续</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全手写实现AVL树</title>
    <link href="/2020/05/10/2020-04-30-avl-tree/"/>
    <url>/2020/05/10/2020-04-30-avl-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="全手写实现AVL树"><a href="#全手写实现AVL树" class="headerlink" title="全手写实现AVL树"></a>全手写实现AVL树</h1><blockquote><p>本文阅读大概需要45分钟，<strong>独立</strong>编程需要两天，建议预留充足的时间和咖啡。</p></blockquote><p>（友情提示，笔者基本未参考网络资料，边思考边写代码，100%干货，学AVL看这一篇就够了）</p><p>学树的顺序，一般来说是：二叉树-&gt;二叉查找树-&gt;AVL树-&gt;2-3-4树-&gt;红黑树。它们的难度依次递增。不得不说的是，树是计算机科学最重要研究课题之一。在算法类面试当中，树的考察也是不可或缺的。</p><p><img src="https://img-blog.csdnimg.cn/20200425225354848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>先简单回顾一下二叉查找树：</p><p>一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/二叉树">二叉树</a>：</p><p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3）左、右子树也分别为二叉排序树；</p><p>（4）没有键值相等的结点。</p><p>让我们介绍一种全新的<strong><em>自平衡二叉树（斜体加粗表示这玩意很酷炫）\</em></strong>。相信在你学完并且理解之后。会觉得之前学的树都太low了。</p><p>你可能觉得AVL是某些niubilious（自造词，牛批的意思）的英文缩写。事实是，AVL树的名字来源于它的发明作者G.M. <strong>A</strong>delson-<strong>V</strong>elsky 和 E.M. <strong>L</strong>andis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。</p><p>它的特点是：<strong>左右子树高度差（平衡因子）的绝对值小于等于1.</strong> （红色加粗的字体表明你应该记住这句话）</p><p>下面邀请插画师turtle配合演示，事实上，整个AVL树的插入和删除操作我们都会作图演示，保证你能看懂：</p><p><img src="https://img-blog.csdnimg.cn/20200425231356816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>感谢turtle先生，你今天的粉色画笔非常好看！</p></blockquote><p> 数字代表val，字母代表payload。你可以借助字典中的key和value来理解。最下面的数字，我们称为<strong>平衡因子（balance factor,bf）</strong>。只有一棵树所有节点平衡因子在1,0,-1之间，这棵树才是平衡的。 所谓的树的高度，就是垂直方向，从当前节点到根节点的最大深度。<strong>平衡因子等于左右子树高度差，叶子节点平衡因子一定为0。</strong></p><p><em>为什么要满足这个条件呢？（斜体表示你问了一个问题）</em>因为我们希望一棵树尽量对称均匀，看起来漂亮（删除线表示这是错误的理解）我们先区分两个概念</p><ol><li><strong>满二叉树：</strong>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树为<em>满二叉树（国内定义）</em>。</li><li><strong>完全二叉树：</strong>若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都<strong>连续集中在最左边</strong>，这就是完全二叉树。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200425233454747.png" alt="img"></p><p>​                                                                                                        <strong>满二叉树</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvZjlkY2QxMDBiYWExY2QxMTcxZmFmMWJkYjUxMmM4ZmNjMmNlMmRkYQ?x-oss-process=image/format,png" alt="img" style="zoom:50%;" /></p><p>​                                                                                                <strong>完全二叉树</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>AVL树是一种完全二叉树，因为这个特性，我们发现它的插入，删除操作最好最坏的情况都是log(n)。</p><p><em>这是怎么得来的？</em> 你如果只是死记而不理解的话，这会很糟糕，你可能会记混淆。一棵完全二叉树的深度设为k ， 那么前k-1层一共有2^(k-1)-1个节点，最后一层节点数最少为0，最多为2^(k-1)。设节点总数为N。那么2^(k-1)-1&lt;=N&lt;=2^(k-1)-1+2^(k-1)=2^k-1。解得： k-1&lt;Log2(N+1)&lt;k，按照层数递归的思想，我们的时间复杂度就是O(logN)量级的。</p><p>由于之前的博客已经讲解了<a href="https://blog.csdn.net/qq_32439305/article/details/105741842">二叉查找树</a>。下面让我们思考，在插入过程如何保持二叉树动态平衡。</p><p>希望你能保持足够的耐心，关闭音乐，集中注意力，只要不是咖啡撒到键盘上就行。</p><p>下面是插入操作的实现.</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span> (<span class="hljs-params">self, val, payload</span>):</span>    <span class="hljs-keyword">if</span> self.root:        self._put(val, payload,self.root)    <span class="hljs-keyword">else</span>:        self.root = BSTNode(val,payload)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_put</span>(<span class="hljs-params">self,val,payload,currentNode</span>):</span>    <span class="hljs-keyword">if</span> val &lt;= currentNode.val:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currentNode.left_child:            left_new = BSTNode(val,payload,parent=currentNode)            currentNode.left_child = left_new        <span class="hljs-keyword">else</span>:            self._put(val,payload,currentNode.left_child)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currentNode.right_child:            right_new = BSTNode(val,payload,parent=currentNode)            currentNode.right_child = right_new        <span class="hljs-keyword">else</span>:            self._put(val,payload,currentNode.right_child)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这是BST插入的相关代码。下面介绍添加节点时的平衡操作：</p><h1 id="Put方法实现"><a href="#Put方法实现" class="headerlink" title="Put方法实现"></a>Put方法实现</h1><ul><li>我们先考虑当前节点bf的变化，如果当前节点的bf大于1或小于-1，说明我们需要进行<strong>旋转</strong>操作，下面我会详细介绍；否则在当前节点为左子节点时，我们将其父节点的bf加 1，当前节点为右子节点，其父节点减1. <strong>这里其实是一个递归操作，</strong>每当子节点改变，其上层的所有父节点需要改变，除非某个父节点的平衡因子为0.</li><li>我们先介绍几种平衡方法：<strong><em>左旋(L_Rot)，右旋(R_Rot)，LR双旋(LR_doubRot)，RL双旋(RL_doubRot)</em></strong>。它们是你前所未见的炫操作。</li></ul><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p><strong>1.左旋（感谢<a href="https://blog.csdn.net/sun_tttt">Sun_TTTT博客</a>精彩配图）</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTMzNTQ4MC8yMDE4MDIvMTMzNTQ4MC0yMDE4MDIyMjIzNTQzMDIwNi0xOTk0NjkwMzQwLmdpZg" alt="左旋"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>简而言之就是某个节点的父节点变成了其左子节点，对于原来的左子节点，变成原来父节点的右节点。</p><p><strong>2.右旋</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTMzNTQ4MC8yMDE4MDIvMTMzNTQ4MC0yMDE4MDIyMjIzNTUwMzEyNC0xNDE1MDk5MzcuZ2lm" alt="右旋"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>简而言之就是某个节点的父节点变成了其右子节点，对于原来的右子节点，变成原来父节点的左节点。</p><p><strong>3.LR双旋</strong></p><p><img src="https://img-blog.csdnimg.cn/20200426232346142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>它是左旋和右旋的结合版。</p><p><strong>4.RL双旋</strong></p><p>LR双旋的相反版本。</p><p>至于AVL是如何设计出这样的结构，这不是人类考虑的问题了。但是笔者理解是，为了保持节点平衡，尽可能降低树的高度，在红黑树中也有类似的操作。</p><p>好了，介绍了这几种旋转方法，我猜你已经晕头转向了。但是好戏刚刚开始。</p><ul><li>关于旋转：什么时候进行什么样的旋转？<em>我们需要一点想象力(Ignite your Imagination)。</em></li><li><p>对于直线型结构和回旋镖型结构，如下图所示。在当前节点的平衡因子小于-1且左子节点不存在并且当前节点的右子节点的左子节点存在，那么表示我们需要进行RL双旋，否则进行左旋；在当前节点的平衡因子大于1且右子节点不存在并且当前节点的左子节点的右子节点存在，那么表示我们需要进行LR双旋，否则进行右旋。</p><p> <img src="https://img-blog.csdnimg.cn/20200429130542284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 80%;" /></p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429130844114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码如下，供参考：</p><pre><code class="hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">renew_balance_factor</span>(<span class="hljs-params">self,currNode:AVLNode</span>):</span>     <span class="hljs-keyword">if</span> currNode.balance_factor&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> currNode.balance_factor&lt;<span class="hljs-number">-1</span>:         <span class="hljs-keyword">if</span> self.isrebalance: self.rebalance(currNode)         <span class="hljs-keyword">return</span>      <span class="hljs-keyword">if</span> currNode.isLeftChild():          currNode.parent.balance_factor+=<span class="hljs-number">1</span>     <span class="hljs-keyword">elif</span> currNode.isRightChild():         currNode.parent.balance_factor-=<span class="hljs-number">1</span>     <span class="hljs-keyword">if</span> currNode.parent!=<span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> currNode.parent.balance_factor != <span class="hljs-number">0</span> :                  self.renew_balance_factor(currNode.parent)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rebalance</span>(<span class="hljs-params">self,currNode:AVLNode</span>):</span>     <span class="hljs-keyword">if</span> currNode.balance_factor&gt;<span class="hljs-number">1</span>:<span class="hljs-comment"># left-heavy sub tree</span>         <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currNode.right_child <span class="hljs-keyword">and</span> currNode.left_child.right_child:             self.LR_doubRot(currNode)             <span class="hljs-keyword">return</span>          <span class="hljs-keyword">else</span>:             self.R_Rot(currNode)     <span class="hljs-keyword">elif</span> currNode.balance_factor&lt;<span class="hljs-number">-1</span>:<span class="hljs-comment"># right-heavy sub tree</span>         <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currNode.left_child <span class="hljs-keyword">and</span> currNode.right_child.left_child:             self.RL_doubRot(currNode)         <span class="hljs-keyword">else</span>:             self.L_Rot(currNode)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>旋转后平衡因子如何更新</li></ul><p>我们在BST中插入节点，如果发现某个节点的平很因子大于1或小于-1。就表示我们该进行自平衡操作了。进行R单旋的情况是直线型结构：</p><p><img src="https://img-blog.csdnimg.cn/20200426233308794.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我们只需要将当前节点16绕7旋转至其右节点即可。其他节点不作改变。我们旋转的同时也<em>必须考虑平衡因子的变化</em>，这里会涉及</p><p>到比较复杂的数学推导，不过没必要紧张，你完全可以画图理解。</p><p><img src="https://img-blog.csdnimg.cn/20200426234231887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我们只需要更新A和B的平衡因子即可。</p><p><img src="https://img-blog.csdnimg.cn/20200428192052711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上面的new old 分别表示新老节点，h(·)表示节点高度。你看到这可能已经跃跃欲试了，数学可是我的强项呀！ L单旋同理。</p><p>很不幸的是，对于大部分人，包括笔者，数学都不是我们的强项！<strong>所以我们需要调动程序员思维。</strong>正所谓“车到山前必有路”。</p><p>思考替代方案中。。。</p><hr><p>很棒，你已经有了思路，我可以直接获取节点的高度啊！只需要编写一个get_node_bf（）函数就行了。需要注意的是，我们需要得到的是该节点左右子树中高度的<em>最大值。</em>所以我们必须进行递归左右子树，左右子树的“路径”，个数我们不知道：按照h(Node) = 1 + max(h(left_child),h(right_child)). 因此我们需要用两个列表path_level_l 和 path_level_r 来分别存储左右子树各个路径的高度。最后套用公式就是该节点的高度。</p><p>我们稍微整理一下思路写出代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_level</span>(<span class="hljs-params">node,depth,path_level</span>):</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            <span class="hljs-keyword">if</span> node.isLeaf(): path_level.append(depth);<span class="hljs-keyword">return</span>              depth+=<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> node.left_child:                get_level(node.left_child,depth,path_level)            <span class="hljs-keyword">if</span> node.right_child:                get_level(node.right_child,depth,path_level)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果是叶子节点其高度为1，bf为0，我们再写一个求节点bf的函数：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_bf</span>(<span class="hljs-params">self,currNode:AVLNode</span>)-&gt;int:</span>        <span class="hljs-comment"># obtain current node&#x27;s bf</span>        max_l = max_r =<span class="hljs-number">0</span>        path_level_l = []        path_level_r = []        <span class="hljs-keyword">if</span> currNode.isLeaf():            <span class="hljs-keyword">return</span> (max_l-max_r)        <span class="hljs-keyword">else</span>:            get_level(currNode.left_child,<span class="hljs-number">1</span>,path_level_l)            get_level(currNode.right_child,<span class="hljs-number">1</span>,path_level_r)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path_level_l: max_l = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:max_l = max(path_level_l)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path_level_r: max_r = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>: max_r = max(path_level_r)            <span class="hljs-keyword">return</span> (max_l - max_r)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>进行LR单旋的是“回旋镖型结构”：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200426233513572.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我们同样进行平衡因子的动态更新，不过这次只用调用get_node_bf函数即可。注意C先变为B的父节点，B为C左子节点，A再变为C的右子节点，C的父节点改为A的父节点。A的父节点改为C是不是非常简单呢？</p><ul><li>下面我们将上述过程可视化：</li></ul><p>以下面数据为例：</p><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> = &#123;16:&#x27;<span class="hljs-type">A</span>&#x27;,3:&#x27;<span class="hljs-type">B</span>&#x27;,7:&#x27;<span class="hljs-type">C</span>&#x27;,11:&#x27;<span class="hljs-type">D</span>&#x27;,9:&#x27;<span class="hljs-type">E</span>&#x27;,26:&#x27;<span class="hljs-type">F</span>&#x27;,18:&#x27;<span class="hljs-type">G</span>&#x27;,14:&#x27;<span class="hljs-type">H</span>&#x27;,15:&#x27;<span class="hljs-type">I</span>&#x27;&#125;</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200429131256439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200429131329106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> 大家可以自行验证另一个完全相反的过程，检查自己的代码有无纰漏。</p><p>好了，非常高兴你能坚持看到这，如果你觉得困的话，可以明天再看删除操作：</p><h1 id="Del-方法实现"><a href="#Del-方法实现" class="headerlink" title="Del 方法实现"></a>Del 方法实现</h1><p>你已经喝完了咖啡，是否还感觉困呢？咖啡不要放太多糖。</p><p>Del 方法比put方法稍微复杂一点，但是我们有了put的相关方法，因而不会太麻烦。我们构建了上述二叉树，现在尝试依次删除150，130，160，140，155，120，157。</p><p>删除有三种情况：</p><ol><li>删除叶子节点；</li><li>删除节点只有一个子节点；</li><li>删除节点有两个子节点。</li></ol><p>如果你认真看了我关于二叉查找树的博客的话，会发现万变不离其宗。我们只需要在每次删除节点后更新bf即可。为此我们设计函数update_del_bf（）。如果我们发现当前节点不平衡，就将其通过旋转的方式平衡，继续更新它的父节点；如果节点平衡，我们依次更新父节点，直到父节点为None止。</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_del_bf</span>(<span class="hljs-params">self,currNode:AVLNode</span>):</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currNode:<span class="hljs-keyword">return</span>    currNode.balance_factor = self.get_node_bf(currNode)    <span class="hljs-keyword">if</span> currNode.balance_factor&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> currNode.balance_factor&lt;<span class="hljs-number">-1</span>:        <span class="hljs-keyword">if</span> self.isrebalance: self.rebalance(currNode)        self.update_del_bf(currNode.parent)        <span class="hljs-keyword">return</span>         <span class="hljs-keyword">if</span> currNode.parent:<span class="hljs-comment">#update all parent bf         </span>        self.update_del_bf(currNode.parent)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>好了删除操作我们也完成了，下面以图片的形式展示整个删除过程。</p><p><img src="https://img-blog.csdnimg.cn/20200429142633426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429142942653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429143050100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429143153960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">上面就是，整个插入和删除的过程，相信你一定会有许多收获或者疑问，欢迎留言或者email .</p><p><a href="https://gitee.com/durantSaaS/data_structure_source_plan/blob/master/Advanced/AVL_tree.py">源代码在这里！</a></p><p>下一期介绍红黑树*</p>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>平衡树 - python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花拳绣腿学红黑</title>
    <link href="/2020/05/10/2020-05-10-red-black-tree/"/>
    <url>/2020/05/10/2020-05-10-red-black-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="花拳绣腿学红黑"><a href="#花拳绣腿学红黑" class="headerlink" title="花拳绣腿学红黑"></a>花拳绣腿学红黑</h1><p>一提到红黑树，你应该是这样想的。。。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTM5MzcwMTEwODUsMzIyNzA1Mjk5NSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上一期我们详细分析了<a href="https://blog.csdn.net/qq_32439305/article/details/105758962">AVL树</a>，相信你已经对二叉平衡树有了非常棒的理解。这一期我们开始介绍红黑树，红黑树在网上有很多资源，但是讲的不严谨，也不全面。笔者初学时也浪费了许多时间，因此我将非常细致的讲解，将自己踩过的坑晒出来，保证你能看懂。</p><p>红黑树和AVL树的区别是：<strong>AVL树是严格平衡的二叉树，红黑树是弱平衡的二叉树。和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此相同节点数的前提下，AVL树的高度往往低于红黑树。</strong>AVL树根据节点的平衡因子进行调整，而红黑树是根据颜色进行调整。大致地说，红黑树理解上较容易，而实现起来，需要注意的细节要更多（比如说考虑叔叔节点）。推荐大佬<a href="https://blog.csdn.net/Gosick_Geass_Gate/article/details/88556840">博客</a>：比较两者不同。</p><p><em>为什么要学二叉树呢？（斜体表示你问了一个很棒的问题）：</em></p><ul><li><strong>红黑树的结点增删改查效率非常优良，都为log(n) ,</strong> 应用方面：1. Linux内核进程调度由红黑树管理进程控制块。 2. Epoll用红黑树管理事件块。 3. nginx服务器用红黑树管理定时器。 4. C++ STL中的map和set的底层实现为红黑树。 5. Java中的TreeMap和TreeSet由红黑树实现。 6. Java8开始，HashMap中，当一个桶的链表长度超过8，则会改用红黑树。</li></ul><p>下面我们看一下红黑树的性质：</p><p><strong>1. 每个节点要么是黑色，要么是红色</strong> </p><p><strong>2. 根节点一定为黑色</strong> </p><p><strong>3. 每一个空节点(null / NIL)都是黑色（注意空节点不等于根节点）</strong></p><p><strong>4.一旦一个节点为黑色，它的孩子一定为黑色，也就是说，不可能有父子节点同时为红色。</strong></p><p><strong>5. 对每个节点而言，从每个黑色节点到叶子节点的节点数量相同。</strong></p><p>因此我们需要对树可视化函数稍作修改，对每个节点上色。对turtle，使用 t.fillcolor来设置填充颜色，t.begin_fill和t.end_fill来实现开始填充和结束填充，非常方便。</p><p><img src="https://img-blog.csdnimg.cn/20200505232447788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>笔者得到的树如上图所示，是不是很美观呢？但是光美观是不够的，我们还得实现背后的逻辑，而这也是最酷炫的部分。我保证，如果你能亲手成就一个红黑树，能让你“快乐”很长时间。</p><p>和AVL树类似，红黑树只需要在节点类加入颜色属性即可。为了后期代码方便，我们实现两个函数，一个是获取当前节点的叔叔节点get_uncle，另一个是获取兄弟节点get_brother</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uncle</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.parent <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.parent.parent: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-keyword">if</span> self.parent.parent.hasBothChildren():        <span class="hljs-keyword">if</span> self.parent.isLeftChild():            <span class="hljs-keyword">return</span> self.parent.parent.right_child        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.parent.parent.left_child<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_brother</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.parent : <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-keyword">if</span> self.parent.hasBothChildren():        <span class="hljs-keyword">if</span> self.isLeftChild():            <span class="hljs-keyword">return</span> self.parent.right_child        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.parent.left_child</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 好了，我们依旧从插入和删除来讨论算法</p><h2 id="1-Put方法实现"><a href="#1-Put方法实现" class="headerlink" title="1. Put方法实现"></a>1. Put方法实现</h2><p>我们和AVL树类比，其实就是将平衡因子改变的过程变为更新颜色的过程而已，为此我们需要实现一个函数renew_color。需要注意的是每当创建一个新的叶子节点时候，它都应该是红色的。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>旋转过程在我上篇的AVL树博客中已经介绍（需要的读者自行食用），红黑树中的旋转也完全相同。</p><p>我们来作一些简单的设定。</p><p><img src="https://img-blog.csdnimg.cn/20200505232447788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在这幅图中，当前节点为B，那么其兄弟节点为E，其父节点为D，它的叔节点为A，祖父节点为C。</p><p>我们由浅入深 循序渐进来化解这个问题：</p><p>（1）若树为空树，那么直接添加一个节点作为根节点，且为黑色（事实上，根节点一定为黑色）。</p><p>（2）插入节点的key已经存在，那么我们只需要将节点的val更新成新的val即可。</p><p>（3）插入节点的父节点为黑节点，那么插入新节点不会影响树的平衡，直接插入即可。</p><p>（4）插入节点 的父节点为红色节点，插入节点也为红色，明显不平衡。且父节点肯定不是根节点，我们需要详细的讨论这种情况：</p><p><strong>1. 叔叔节点存在，并且叔叔节点为红色：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200514132939126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当前节点为B，此时父节点的左子树和右子树肯定是不平衡的。给你10s请你想一想，如何满足性质5？</p><p>一种直观的想法是将父节点D\C全部变为黑色，然后将当前节点B和其兄弟节点I</p><p>变为红色。</p><p><img src="https://img-blog.csdnimg.cn/20200514133333470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后我们需要考虑当前节点的祖父节点的颜色F。如果它不是根节点，我们需要将其颜色变为红色，然后将祖父节点变为当前节点继续向上平衡。注意，只有所有子树都平衡的情况下，整个树才是平衡的。简言之，红黑树平衡是至下而上的，而AVL树是自上而下的。</p><p><strong>2. 插入节点的父节点是左子节点</strong></p><p>这时候我们看当前节点是左子节点还是右子节点：</p><p><strong>右子节点：我们对祖父节点A进行LR双旋，祖父节点变为红色，父节点变为黑色 。</strong></p><p><img src="https://img-blog.csdnimg.cn/2020051413435664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>左子节点：对祖父节点A进行R单旋，同时将父节点颜色设为黑色，叔叔节点设为红色</strong></p><p><img src="https://img-blog.csdnimg.cn/20200514135453274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>3. 插入节点的父节点是右子节点</strong></p><p>与左子节点情况刚好相反，故不再演示，但是调试时候注意考虑这种情况。</p><p><em>OK，上面便是插入操作，我们来测试一下，数据为data = {12:’A’,1:’B’,9:’C’,2:’D’,3:’E’,2.5:’F’,11:’G’,10:’H’,2.4:’I’,6:’J’}</em><img src="https://img-blog.csdnimg.cn/20200514135937654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200514140103721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><h2 id="2-Del方法实现"><a href="#2-Del方法实现" class="headerlink" title="2. Del方法实现"></a>2. Del方法实现</h2><p>现在我们考虑更复杂的删除情况。你需要一杯咖啡，因为接下来内容会比较多和干燥。但是我保证你看完之后会很有启发。</p><p>现在我们写一个def <strong>delitem</strong>函数，这样我们就能使用del 关键字删除特定key了。我们先简单回顾一下，</p><p>（1）如果待删除的结点是叶子结点，则直接删除即可。</p><p>（2）如果待删除的结点只有一个孩子，则设定currNode.parent.left_child = currNode.left_child或者currNode.parent.right_child = currNode.right_child，替换节点为其独子。　　</p><p>（3）如果待删除的结点有两个孩子，则可以找它的<strong>后继</strong>，将值覆盖过来，之后情况转变成删除前驱或者后继结点，回到（1）和     （2）。</p><p>删除的<strong>含义</strong>在于，删的不是节点本身，而是它的“替身”。（你可以想象成JOJO里的替身使者:-&gt;）</p><p>下面是 <strong>正片</strong> 即在<strong>删除之前</strong>，我们必须更新颜色和进行旋转，这些在函数update_del_color()中体现：</p><p>先考虑几个边值条件：</p><p><strong>1. 树为空，直接返回None即可；</strong></p><p><strong>2. 利用get_node函数找到需要删除的节点，如果没找到，直接返回None。</strong></p><p><strong>3. 如果替换节点是红色的，将其改为黑色，因为删除红色节点不会影响平衡</strong></p><p>所谓的再平衡无异乎是找兄弟或者父母去“借”，是不是很形象呢{坏笑}：<br>我们可以将<strong>当前节点分为左子节点和右子节点</strong>两种情况，它们是完全对称的，</p><ul><li>先考虑左子节点情况：</li></ul><p>​    假设实际被删除节点为C，</p><p><strong>（a）父节点为红色，且兄弟节点没有子节点</strong></p><p>我们将父节点变为黑色，同时将兄弟节点变为红色（兄弟节点一定没有子节点）。下面这个图可以直观展现这点：</p><p><img src="https://img-blog.csdnimg.cn/20200514201702553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>（b）父节点为黑色，且兄弟节点没有子节点</strong></p><p>我们将兄弟节点颜色改为红色，之后再对父节点执行update_del_color进行递归。</p><p><img src="https://img-blog.csdnimg.cn/20200514191528935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>（c）兄弟节点左子节点存在，且为红色节点，右节点随意</strong></p><p> 那么这个时候我们需要考虑父节点B的颜色，因为兄弟左子节点D为红色，我们可以把它借出去，涂成父节点的颜色，再将父节点颜色设为黑色。之后对父节点B进行RL双旋，但是不要改变节点颜色，只有在插入时才改变节点颜色。</p><p><img src="https://img-blog.csdnimg.cn/20200514193714675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里白色表示颜色不确定。</p><p><strong>（d）兄弟节点右子节点存在，且为红色节点，左子节点为黑色</strong></p><p>兄弟变为父节点颜色，同时父节点变为黑色，而且右侄子变为黑色。再对父节点进行左旋。</p><p><img src="https://img-blog.csdnimg.cn/20200514194840326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>（e）兄弟节点有两个儿子，且兄弟为红色节点</strong></p><p>我们直接对父节点左旋，这就变成上面兄弟为黑色情况，再调用update_del_color对父节点进行递归：</p><p><img src="https://img-blog.csdnimg.cn/20200514201513136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>当前节点为右子节点，刚好相反，故不再赘述</li></ul><p>下面我们将完整的过程展现出来，根据July的博客<a href="https://blog.csdn.net/v_july_v/article/details/6284050。">https://blog.csdn.net/v_july_v/article/details/6284050。</a></p><p>依次删除12 1 9 2 0 11 7 19 4 15 18 5 14 13 10 16 6 3 8 17。 大家可以作一个对比，如果你有任何问题，请立刻在下方留言！笔者不胜感激。</p><ul><li>完整的红黑树</li></ul><p><img src="https://img-blog.csdnimg.cn/20200514202205266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514202813225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514202921413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203019653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203205400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> <img src="https://img-blog.csdnimg.cn/20200514203706923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/2020051420352144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203800625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203823648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203914829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203951941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204138852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204152841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204239757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204302184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204326749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204346475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204356989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204427970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204443441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>希望本文对你有帮助，</p><p><a href="https://gitee.com/durantSaaS/data_structure_source_plan/blob/master/Advanced/RedBlackTree.py">源代码</a>在这里！</p><p>码字不易，希望大家多多转发，多点赞！邮箱durant2019@sina.com</p>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>平衡树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
