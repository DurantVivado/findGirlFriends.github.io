<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「置顶」本博客导航！</title>
    <link href="/2025/12/31/2020-10-8-article_navigator/"/>
    <url>/2025/12/31/2020-10-8-article_navigator/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>若您的网页显示mathjax公式出现问题，导致无法阅读，请在任意Mathjax公式上点击右键，<code>Math settings</code>-&gt;<code>Math renderer</code>-&gt;更改为<code>HTML-CSS</code>即可解决。</p>          </div><div class="note note-primary">            <p>因博主水平有限，不足之处请直接在评论区指出，博主将感激不尽！</p>          </div><p>欢迎您光顾本博客！</p><p>本博客 包括<strong>LeetCode</strong>刷题记录和经验，机器学习，以及硕士专业研究课题方面。</p><p>本人硕士研究课题是 <u><strong>纠删码</strong>及<strong>去重</strong>在Ceph分布式存储集群上的应用</u>。对此研究方向感兴趣的道友欢迎一起交流。</p><hr><h2 id="👌LeetCode刷题记录"><a href="#👌LeetCode刷题记录" class="headerlink" title="👌LeetCode刷题记录"></a>👌LeetCode刷题记录</h2><h3 id="A-动态规划"><a href="#A-动态规划" class="headerlink" title="A. 动态规划"></a>A. 动态规划</h3><ul><li><p>动态规划 <a href="https://durantthorvalds.top/2020/07/21/2020-07-21-dynamic-planning/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>动态规划是将问题分解为更易解决的子问题的一类方法，本blog由浅入深介绍动态规划的常见题型，dp是笔试最常考的问题之一。</p></blockquote></li></ul><ul><li><p>做一只可爱的小🐖背包 Cover「背包九讲」 <a href="https://durantthorvalds.top/2020/07/25/2020-07-27-backpack-problem/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>背包问题是很经典的一类dp问题。本blog介绍9种类型的背包问题。面试者若能举一反三，必将事半功倍。</p></blockquote></li></ul><h3 id="B-树类问题"><a href="#B-树类问题" class="headerlink" title="B. 树类问题"></a>B. 树类问题</h3><ul><li><p>必须掌握的数据结构-树 <a href="https://durantthorvalds.top/2020/09/23/2020-9-23-binary_tree/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>如果你还不知道什么是树，没有关系！我们将从零开始介绍，1. 二叉树的表示 2.二叉树的遍历 3. 二叉树序列化以及反序列化 4. 树形dp  5.线索二叉树 等。使得你对树类问题有基本认识。</p></blockquote></li></ul><ul><li><p>树状数组和线段树 <a href="https://durantthorvalds.top/2020/07/17/2020-07-17-fenwicktree-segmentTree/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>树状数组和线段树都是用于维护数列信息的数据结构，支持单点/区间修改，单点/区间询问信息。以增加权值与询问区间权值和为例，其余的信息需要维护也都类似。时间复杂度均为$O(logn)$。</p></blockquote></li></ul><ul><li><p>Google划词搜索的秘密——前缀树 <a href="https://durantthorvalds.top/2020/07/21/2020-8-20-what-is-Trie/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>前缀树又名<strong>Tries树</strong>、<strong>字典</strong>树、单词查找树等，常用于快速检索，大量字符串的排序和统计等。Trie相比于哈希表存储多个具有相同前缀的键时所用空间较少。因此前缀树只需要$O(m)$的空间，m为键长度。在字符串问题中很常见。</p></blockquote></li></ul><ul><li><p>花拳绣腿学红黑树 <a href="https://durantthorvalds.top/2020/05/10/2020-05-10-red-black-tree/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>红黑树的结点增删改查效率非常优良，都为$log(n) $, 应用方面：1. Linux内核进程调度由红黑树管理进程控制块。 2. Epoll用红黑树管理事件块。 3. nginx服务器用红黑树管理定时器。 4. C++ STL中的map和set的底层实现为红黑树。 5. Java中的TreeMap和TreeSet由红黑树实现。 6. Java8开始，HashMap中，当一个桶的链表长度超过8，则会改用红黑树。红黑树在面试中会出现，笔试中可不会出现哦。</p></blockquote></li></ul><ul><li><p>全手写实现AVL树 <a href="https://durantthorvalds.top/2020/05/10/2020-04-30-avl-tree/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>AVL树是严格平衡的二叉树，红黑树是弱平衡的二叉树。和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此相同节点数的前提下，AVL树的高度往往低于红黑树。同样，在笔试中不会出现，面试时可能会问概念。有兴趣的读者可以自己实现。</p></blockquote></li></ul><h3 id="C-模拟问题"><a href="#C-模拟问题" class="headerlink" title="C. 模拟问题"></a>C. 模拟问题</h3><ul><li><p>神奇的多指针 <a href="https://durantthorvalds.top/2020/07/21/2020-7-30-pointers/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>很多时候多指针（双指针，三指针，快慢指针）能极大的帮助我们降低时间复杂度和空间复杂度，比如从$O(n^2)$降低到$O(n)$。例如求链表到数第N个节点，以及判断链表中是否有环，神奇的Floyd判圈法。</p></blockquote></li></ul><ul><li><p>「面试向」排序算法 <a href="https://durantthorvalds.top/2020/07/21/2020-7-30-sorting-magic/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>包括冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序，计数排序，桶排序，基数排序。研究它们算法，以及最好最坏平均时间复杂度和空间复杂度，是否为就地替换以及稳定性。</p></blockquote></li></ul><ul><li><p>解空间极大问题通用策略 <a href="https://durantthorvalds.top/2020/08/01/2020-8-1-common-way-solve-big-problem/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>如果输出有非常的项（比如求子集，全排列），要确保结果<strong>完整</strong>且不<strong>重复</strong>，有多种策略：1. 递归，2. 回溯，3. 字典， 4. 数学， 5. 状态压缩， 6. 剪枝技巧</p></blockquote></li></ul><ul><li><p>滑动窗口，滑动的艺术 <a href="https://durantthorvalds.top/2020/07/21/2020-8-1-sliding-windows/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>在滑动窗口中有两个指针，一个指针静止，而另一个指针保持移动。我们在s上滑动窗口，如果能够包含整个T（<strong>注意</strong>，T可能有重复字符），如果能收缩，我们就收缩窗口直到得到最小窗口。</p></blockquote></li></ul><ul><li><p>红尘客栈之单调栈 <a href="https://durantthorvalds.top/2020/07/21/2020-8-17-recognition-monostack/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>单调栈内元素保持<strong>非递减顺序</strong>，在特定的应用背景下，比如一维参量在一个<strong>连续</strong>范围变化，温度在一段时间变化，股价的增减，柱状图。请考虑单调栈。</p></blockquote></li></ul><ul><li><p>数组和字符串的🆒skr操作——前缀和 <a href="https://durantthorvalds.top/2020/10/16/2020-10-16-prefix_sum/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>前缀和的本质是一维或二维差分数组，对区间的查询和修改，比树状数组和线段树相比，不需要特定的数据结构，更加容易使用。</p></blockquote></li></ul><ul><li><p>一句话能打败 99.99999%的程序员的位操作代码 <a href="https://durantthorvalds.top/2020/08/23/2020-8-23-bitoperation/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>位操作是计算机最基本的操作之一，它可以与很多问题进行结合，从而优化解法空间复杂度，比如在状态压缩中利用左移，数组low_bit以及<strong>Brian kernighan算法</strong>.</p></blockquote></li></ul><h3 id="D-贪心算法"><a href="#D-贪心算法" class="headerlink" title="D. 贪心算法"></a>D. 贪心算法</h3><ul><li><p>贪婪而巧妙的贪心算法 <a href="https://durantthorvalds.top/2020/09/02/2020-8-25-greedy/">&gt;&gt;传送门&lt;&lt;</a></p><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p></blockquote></li></ul><h3 id="E-数学"><a href="#E-数学" class="headerlink" title="E. 数学"></a>E. 数学</h3><ul><li>数学和线性代数用于解题 <a href="https://durantthorvalds.top/2020/09/02/2020-8-25-math/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>数论，求质因数,最大公因数（GCD）,最小公倍数（LCM）, 快速幂算法, Gauss消元法, 几何，排列组会问题等</p></blockquote><h3 id="F-字符串"><a href="#F-字符串" class="headerlink" title="F. 字符串"></a>F. 字符串</h3><ul><li>臭名昭著的KMP算法<a href="https://durantthorvalds.top/2020/07/21/2020-8-29-KMP/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p><strong>KMP</strong>算法是用于字符串匹配，十分巧妙，也极难理解。</p></blockquote><ul><li>东方不败——回文问题<a href="https://durantthorvalds.top/2020/07/21/2020-08-19-manacher/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>回文指正反读都一样的字符串，<strong>Manacher</strong>算法专门用于解决回文问题。当然，<strong>Rabin-Karp</strong>编码在一定条件下也是不错的解决问题的方法。</p></blockquote><h3 id="G-图论"><a href="#G-图论" class="headerlink" title="G. 图论"></a>G. 图论</h3><ul><li>再也不想做图类题目了 <a href="https://durantthorvalds.top/2020/07/21/2020-08-1-representation_of_graph/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>本博客介绍了四种图的表示方法，包括 邻接矩阵表示法，关联矩阵表示法，邻接表表示法，弧表示法，星形表示法。以及图的典型算法，包括Dijkstra, Floyd, Bellman-Ford以及SPFA算法。</p></blockquote><ul><li>双胞胎DFS与BFS <a href="https://durantthorvalds.top/2020/09/27/2020-8-12-dfs-bfs/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>二叉树里面的三种遍历既可以用DFS（递归写法），也可以用BFS（迭代+栈），而层序遍历对应的就是BFS。</p><p>在图和树类型题目，以及部分数组题目，都可以时不时看到两种算法同时出现。递归注意1. 触发条件 2. 终止条件 3. 剪枝问题。</p></blockquote><ul><li>浅析最小生成树  <a href="https://durantthorvalds.top/2020/09/18/2020-9-12-minimal-Spanning-tree/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>最小生成树（$Minimal  Spanning  Tree,MST$）：有 n 个结点的<a href="https://baike.baidu.com/item/连通图/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。比较常用的有两种算法：$Kruskal$算法和$Prim$算法。</p></blockquote><ul><li>优雅而巧妙的并查集 <a href="https://durantthorvalds.top/2020/08/14/2020-8-14-what-is-UnionSet/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。即<strong>查询</strong>和<strong>合并</strong>。在求联通/合并问题能大显身手。</p></blockquote><ul><li>求解欧拉通路<a href="https://durantthorvalds.top/2020/08/27/2020-8-27-some_tricks/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>给定一个 <em>n</em> 个点 <em>m</em> 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。常见算法有$Hierholzer$算法。</p></blockquote><ul><li>抛砖引玉析回溯 <a href="https://durantthorvalds.top/2020/08/02/2020-8-2-trackback-demo/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>回溯法，通常以dfs或bfs为载体，在特定的问题下，通过试错，得到所有可能状态，当然有些状态是多余的，因此<strong>剪枝</strong>显得极为重要。</p></blockquote><ul><li>距离向量路由选择算法——DV <a href="https://durantthorvalds.top/2020/12/15/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95DV/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>目前的路由器都在运行的算法，你一定不想不知道！</p></blockquote><h3 id="H-综合应用"><a href="#H-综合应用" class="headerlink" title="H. 综合应用"></a>H. 综合应用</h3><ul><li>买股票问题 <a href="https://durantthorvalds.top/2020/08/26/2020-8-26-lotus/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>这类问题涉及很多知识，可能包括dp，单调栈，有限状态自动机等。</p></blockquote><ul><li>权力的游戏之零和博弈  <a href="https://durantthorvalds.top/2020/07/21/2020-9-1-what-is-zero-sum/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>在零和博弈中，让自己最优和让对手最差其实是相同的目标！原因还是那句话，两人的总得分不会变化，自己多了，对手必然减少。没有人是傻子，但是赢者通常会利用游戏规则!</p></blockquote><h3 id="G-其它"><a href="#G-其它" class="headerlink" title="G. 其它"></a>G. 其它</h3><ul><li>有限状态自动机（DSA）<a href="https://durantthorvalds.top/2020/09/02/2020-9-2-fsm/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：有一个特殊的状态，被称作「初始状态」。还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</p></blockquote><ul><li>代码优化系列<a href="https://durantthorvalds.top/2020/09/18/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>包括C++,Java, Python代码中很容易遇见的坑，类似于错别字和陷阱，一定要注意。</p></blockquote><ul><li>设计类问题 <a href="">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>Leetcode 上典型设计问题的赏析。举一反三，触类旁通。</p></blockquote><ul><li>「研究向」Redis中跳表实现原理<a href="https://durantthorvalds.top/2020/12/01/%E3%80%90%E7%A0%94%E7%A9%B6%E5%90%91%E3%80%91Redis%E4%B8%AD%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>在分布式存储系统Redis中一个非常优秀的算法，跳表，LC上也有对应的题目。</p></blockquote><h2 id="🤖机器学习系列"><a href="#🤖机器学习系列" class="headerlink" title="🤖机器学习系列"></a>🤖机器学习系列</h2><blockquote><p>以周志华老师《机器学习》为基准，力争从算法角度解释机器学习的所有问题。</p></blockquote><ul><li>机器学习I 基本概念 <a href="https://durantthorvalds.top/2020/08/04/2020-05-10-ML1/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习II 模型评估与选择<a href="https://durantthorvalds.top/2020/08/04/2020-08-4-ML2/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习III 线性模型 <a href="https://durantthorvalds.top/2020/08/23/2020-08-23-ML3/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习算法I 决策树 <a href="https://durantthorvalds.top/2020/09/27/ML4_DecisionTree/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习算法II 神经网络 <a href="[https://durantthorvalds.top/2020/10/02/20201002-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95II-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/](https://durantthorvalds.top/2020/10/02/20201002-机器学习算法II-神经网络/">&gt;&gt;传送门&lt;&lt;</a>)</li></ul><h2 id="🚀大数据与分布式存储系列"><a href="#🚀大数据与分布式存储系列" class="headerlink" title="🚀大数据与分布式存储系列"></a>🚀大数据与分布式存储系列</h2><blockquote><p>以云存储和大数据为研究背景。辐射包括Ceph，Hadoop，纠删码研究等方方面面。</p><p>其中「入门部署」表示初始部署集群，「高级部署」表示有一定挑战性的部署，比如手动部署，「参考」表示一些非核心的帮助理解的内容，「核心」表示深入理解原理，并且熟练操作。「综述」表示一些学术性总结内容。「研究向」表示需要很多时间和兴趣来研究的内容，面试一般不会考到，但很经典。</p></blockquote><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>「高级部署」ceph手动部署集群<a href="https://durantthorvalds.top/2020/10/21/Ceph%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>包括手动部署，存储集群配置以及<strong>源码编译</strong>等。</p></blockquote><ul><li>「入门理论」ceph基础理论——<a href="https://durantthorvalds.top/2020/10/28/CEPH%E8%B8%A9%E5%9D%91%E5%AD%A6%E4%B9%A0/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph的基本原理，供读者有一个大致了解。</p></blockquote><ul><li>「入门部署」ceph-ansible部署踩坑日记——<a href="https://durantthorvalds.top/2020/11/25/Ceph-ansible%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph-ansible是目前用的最广的ceph部署工具，功能远超ceph-deploy。建议采用此方式。</p></blockquote><ul><li>「入门部署」Ceph-deploy流程 <a href="https://durantthorvalds.top/2020/11/19/Ceph-deploy%E6%B5%81%E7%A8%8B/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>完整的ceph-deploy部署流程。</p></blockquote><ul><li>「综述」纠删码在存储系统的应用——<a href="https://durantthorvalds.top/2020/11/15/%E7%BA%A0%E5%88%A0%E7%A0%81%E5%9C%A8%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E7%94%A8/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>最最最最最最新的纠删码综述，包括RS码，包括RS码，MSR，LRC等。不断更新，引领前沿。</p></blockquote><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li>「核心」Ceph三部曲之一：浅析CRUSH算法———<a href="https://durantthorvalds.top/2020/11/27/A%20first%20glance%20at%20CRUSH/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>介绍Ceph核心算法，CRUSH算法。以及相关实践。</p></blockquote><ul><li>「核心」Ceph三部曲之二：ceph纠删码部署——<a href="https://durantthorvalds.top/2020/11/26/ceph%E7%BA%A0%E5%88%A0%E7%A0%81%E9%83%A8%E7%BD%B2/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph中纠删码部署。从原理到五种库源码，笔者研究重点，因为目前Ceph纠删码还有很多待完善的地方。</p></blockquote><ul><li>「核心」Ceph三部曲之三：迁移之美——PG读写流程与状态迁移详解 ———<a href="https://durantthorvalds.top/2020/12/15/%E8%BF%81%E7%A7%BB%E4%B9%8B%E7%BE%8EPG%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E8%AF%A6%E8%A7%A3/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph最难理解也最有趣的概念，PG。深入学习必看!</p></blockquote><ul><li>「核心」Ceph三部曲之四:下一代对象存储引擎BlueStore ———<a href="https://durantthorvalds.top/2020/12/27/%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EBlueStore/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>目前的存储介质已经由传统的机械硬盘hdd升级到SSD和NVME，这为下一代对象存储BlueStore提供了基础，相比于目前FileStore，BlueStore拥有无与伦比的优势。</p></blockquote><ul><li>「核心」Ceph学习三部曲之五:控制先行——Ceph的QoS策略</li></ul><blockquote><p>详细介绍Ceph QoS策略，讲解dmClock等算法实现和操作。</p></blockquote><ul><li>「核心」Ceph学习三部曲之六：分布式块存储RBD</li></ul><blockquote><p>介绍Ceph分布式块存储，包括快照克隆等功能的理解。</p></blockquote><ul><li>「核心」Ceph学习三部曲之七：对象存储网关RGW</li></ul><blockquote><p>Ceph对象存储使用Ceph对象网关守护进程（<code>radosgw</code>），它是一个用于与Ceph存储群集进行交互的HTTP服务器。由于它提供与OpenStack Swift和Amazon S3兼容的接口，因此Ceph对象网关具有自己的用户管理。</p></blockquote><ul><li>「参考」Ceph pool  ———<a href="https://durantthorvalds.top/2020/12/14/ceph%20pool/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>Ceph的池是理解PG，OSD的桥梁，可以直接操作的对象！</p></blockquote><ul><li>「参考」Ceph配置文件conf ———<a href="https://durantthorvalds.top/2020/12/15/Ceph%20%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph文件配置参考。</p></blockquote><ul><li>「参考」Ceph-Mon详解 ———<a href="https://durantthorvalds.top/2020/11/03/2020113-Ceph-Mon-%E8%AF%A6%E8%A7%A3/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>对Ceph的管理者Monitor进行理解。监视器们维护着集群运行图的“主副本”，就是说客户端连到一个监视器并获取当前运行图就能确定所有监视器、 OSD 和元数据服务器的位置。</p></blockquote><h2 id="大师"><a href="#大师" class="headerlink" title="大师"></a>大师</h2><h2 id="🍜文化"><a href="#🍜文化" class="headerlink" title="🍜文化"></a>🍜文化</h2><blockquote><p>看看就好，笔者的一些随笔和感想。涵盖方面及其广泛。</p></blockquote><ul><li>小白投资入门（煎炸卤炖）———<a href="https://durantthorvalds.top/2020/12/14/%E5%B0%8F%E7%99%BD%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>看知乎，学炒股。</p></blockquote><ul><li>日语名谚语系列 ———<a href="https://durantthorvalds.top/2020/11/19/%E6%AF%8E%E6%97%A5%E6%94%BE%E9%80%81%EF%BC%8D%E6%97%A5%E6%9C%AC%E3%81%AE%E8%AB%BA/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>笔者对日语文化有浓厚兴趣，立志考过N1，いしょうに頑張ってなあ！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>导航</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「核心」Ceph学习三部曲之七：对象存储网关RGW</title>
    <link href="/2021/01/03/%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3RGW/"/>
    <url>/2021/01/03/%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3RGW/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第六章。以及<a href="https://docs.ceph.com/en/latest/man/8/rados/">官方RADOS指南</a>，以及<a href="https://docs.ceph.com/en/latest/radosgw/">官方RGW教程</a></p>          </div><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>前面我们讲过，Ceph集成了BlueStore分布式对象存储，针对非结构化的数据，比如静态数据，备份存储以及流媒体等场景。上一节，我们介绍了RADOS 中的RBD模块，并且rados提供了API接口librados供用户使用。这一节我们将介绍RADOS Gateway , 即RADOS网关，它主要支持两种类型的接口：</p><ul><li><strong>与S3兼容</strong>：为对象存储功能提供与Amazon S3 RESTful API的大部分子集兼容的接口。</li><li><strong>兼容Swift</strong>：为对象存储功能提供与OpenStack Swift API的大部分子集兼容的接口。</li></ul><p>因为Ceph核心模块RADOS提供的访问接口是私有接口，不支持通用的HTTP协议访问，因而为了支持HTTP协议访问，涉及了支持RESTful接口访问而设计的RADOS gateway.</p><blockquote><p><strong>官方定义</strong>：Ceph对象存储使用Ceph对象网关守护进程（<code>radosgw</code>），它是一个用于与Ceph存储群集进行交互的HTTP服务器。由于它提供与OpenStack Swift和Amazon S3兼容的接口，因此Ceph对象网关具有自己的用户管理。Ceph对象网关可以将数据存储在用于存储来自Ceph文件系统客户端或Ceph块设备客户端的数据的同一Ceph存储群集中。S3和Swift API共享一个公共的名称空间，因此可以使用一个API编写数据，而使用另一个API检索数据。</p></blockquote><p><img src="https://docs.ceph.com/en/latest/_images/1ae399f8fa9af1042d3e1cbf31828f14eb3fe01a6eb3352f88c3d2a04ac4dc50.png" alt="../_images/1ae399f8fa9af1042d3e1cbf31828f14eb3fe01a6eb3352f88c3d2a04ac4dc50.png"></p><p>RGW作为对象存储网关系统，一方面扮演RADOS集群客户端角色，为对象存储应用提供RESTful接口；另一方面，扮演HTTP角色，接收并解析互联网传输数据。RGW目前支持主流的WEB服务器：Civetweb，Apache，Nginx等，其中Civetweb是一个C++库，可以内嵌到RGW框架中，是RGW默认的WEB服务器；Apache与Nginx需要以独立进程存在，收到应用请求后，通过RGW注册的监听端口号将请求转发到RGW上进行处理。</p><h2 id="1-1-数据组织"><a href="#1-1-数据组织" class="headerlink" title="1.1 数据组织"></a>1.1 数据组织</h2><p>一个对象存储系统包括三个部分：用户、存储桶和对象。</p><ul><li><strong>用户</strong>：指对象存储应用的使用者。一个用户拥有一个或多个存储桶。</li><li><p><strong>存储桶</strong>：是对象的容器，设置这一层级的目的是方便关联和操作具有同一属性的一类对象而引入的一层关联单元。</p></li><li><p><strong>对象</strong>：对象是存储的基本单位，包括数据和元数据两个部分。其中元数据在类型和数目上不受限制。与文件系统不同，对象存储系统中所有对象以扁平的方式存储，对象之间没有之间的关联。并且，对象存储不提供部分编辑功能，这意味着，即使更新一个字符，也必须将整个对象从云端下载下来，更新后上传。</p></li></ul><p>以Amazon S3为例，它数据实体包括user、bucket、object，如下图所示；而OpenStack将用户的概念细分为account和user，其中account对应一个项目或者租户，每个account可以被多个user共享，其他的集成实体比如container和object与以上的存储桶、对象概念相符。</p><p>RGW为了兼容Amazon S3和OpenStack接口，所以将用户分为user和subuser，分别对应S3用户和Swift用户。</p>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构</tag>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/31/%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7Csim/"/>
    <url>/2020/12/31/%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7Csim/</url>
    
    <content type="html"><![CDATA[<h1 id="Csim-通用型仿真工具"><a href="#Csim-通用型仿真工具" class="headerlink" title="Csim 通用型仿真工具"></a>Csim 通用型仿真工具</h1><blockquote><p>导师不久前给笔者安排了一个很不同寻常的任务，在一个拥有大量磁盘的主机中，仿真其I/O使用情况。</p><p>因此笔者开始学习Csim。将学习历程记录在此。</p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>什么是CSIM？</p><p>CSIM是通用目的的系统仿真环境：</p><ul><li>离散事件仿真——包括时间和序列</li><li>层次化框图仿真</li><li>模型函数均用C语言表示。</li><li>模型集成，包括并发（concurrency）和时间协调。</li></ul><p>它拥有大量模型库，可以快速建模以及测试。支持多种抽象层次结构。</p><h2 id="1-1-模型的描述"><a href="#1-1-模型的描述" class="headerlink" title="1.1 模型的描述"></a>1.1 模型的描述</h2><p>有三个维度的信息可以描述功能，结构和时间。</p><p><strong>结构</strong>：实例化模型，展示细节。</p><p><strong>功能</strong>：展示模型的功能，通过公式或者代码表述。</p><p><strong>时间</strong>：时延，速率，关系，序列…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/20201220-%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E5%85%AD%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%9D%97%E5%AD%98%E5%82%A8RBD/"/>
    <url>/2020/12/29/20201220-%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E5%85%AD%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%9D%97%E5%AD%98%E5%82%A8RBD/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第六章。以及<a href="https://docs.ceph.com/en/latest/man/8/rados/">官方RADOS指南</a>，以及<a href="https://docs.ceph.com/en/latest/man/8/rbd/">官方RBD教程</a></p>          </div><h1 id="无心插柳——分布式块存储RBD"><a href="#无心插柳——分布式块存储RBD" class="headerlink" title="无心插柳——分布式块存储RBD"></a>无心插柳——分布式块存储RBD</h1><blockquote><p>RADOS(Reliable, Autonomic Distributed Object Store) </p><p><strong>rbd</strong>是用于处理rados块设备（RBD）映像的实用程序，由Linux rbd驱动程序和QEMU / KVM的rbd存储驱动程序使用。RBD映像是简单的块设备，在对象上划分条带并存储在RADOS对象存储中。分割image的对象的大小必须是2的幂。——来自官方</p></blockquote><p>RBD($RADOS Block  Device$)指分布式块存储服务组件，是Ceph对外的三大存储服务组件之一。另外两个分别是CephFS以及Radosgw                                                                                          。我们将在后面介绍。上层应用访问RBD有两种途径：librbd以及krbd。其中librbd是基于librados的用户态接口库，而krbd是继承在GNU/Linux内核中的一个内核模块。通过librbd命令行工具，将RBD块设备映射为本地的一个块设备文件。</p><p><img src="/img/rados.png" alt=""></p><p>一个块通常是512字节，块设备接口无处不在，非常适合与包括Ceph在内的海量数据存储进行交互。Ceph块设备是精简配置的，可调整大小的，并且可以在多个OSD上条带化存储数据。Ceph块设备利用了 RADOS功能，包括快照，复制和强大的一致性。Ceph块存储客户端通过内核模块或<code>librbd</code>库与Ceph集群通信。</p><p>Ceph的的块设备提供与广阔的可扩展性，高性能的 <a href="https://docs.ceph.com/en/latest/rbd/rbd-ko/">内核模块</a>，或者KVM系列如<a href="https://docs.ceph.com/en/latest/rbd/qemu-rbd/">QEMU</a>和基于云计算系统，如<a href="https://docs.ceph.com/en/latest/rbd/rbd-openstack">OpenStack的</a>和<a href="https://docs.ceph.com/en/latest/rbd/rbd-cloudstack">的CloudStack</a>依赖的libvirt和QEMU与Ceph的块设备集成。可以同一群集同时运行<a href="https://docs.ceph.com/en/latest/radosgw/#object-gateway">Ceph RADOS网关</a>， <a href="https://docs.ceph.com/en/latest/cephfs/#ceph-file-system">Ceph文件系统</a>和Ceph块设备。</p><p><img src="/img/rbd1.png" alt="image-20201220224241218" style="zoom:67%;" /></p><p>RBD架构如上图所示，由于元数据信息非常少，且访问不频繁，因此RBD在Ceph集群中不需要daemon守护进程直接将元数据加载到内存进行元数据访问加速，所有数据操作直接与MON和OSD进行交互。</p><h2 id="S1-元数据"><a href="#S1-元数据" class="headerlink" title="$\S1$ 元数据"></a>$\S1$ 元数据</h2><p>RBD块设备在Ceph中被称为image，由元数据和数据组成。其中元数据有三种存储方式，第一种将元数据编码后以二进制文件的形式存储在RADOS对象的数据部分，后面将该类型标识为data。第二种将元数据以键值对的形式存储在RADOS对象的扩展属性中，称为xattr；第三种将元数据以键值对形式存储在RADOS对象omap中，称为omap。更多关于元数据的讨论见<a href="https://durantthorvalds.top/2020/12/27/%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EBlueStore/#6-ObjectStore-OS">BlueStore</a></p><h3 id="1-1-image元数据对象"><a href="#1-1-image元数据对象" class="headerlink" title="1.1 image元数据对象"></a>1.1 image元数据对象</h3><ul><li><code>rbd_id.&lt;name&gt;</code>，data类型，记录image名称到image id 的单向映射关系。</li><li><code>rbd_header.&lt;id&gt;</code>，omap\xattr类型，记录image所支持的功能特性、容量大小等基本信息以及配置参数、自定义元数据，锁信息等。</li><li><code>rbd_object_map.&lt;id&gt;</code>，data类型，记录组成image的所有数据对象的存在状态。</li></ul><p><img src="/img/rbd3.png" alt="image-20201221173651999" style="zoom:67%;" /></p><p>通常情况下，image的数据和元数据存储在同一个存储池下。但是当前纠删码池不支持omap，必须将数据对象和元数据分开存储，需要一个独立的元数据<code>data_pool_id</code>用于记录数据对象所在的存储池。</p><p>$\S 1$ rbd_id</p><p>image内部的元数据和数据的名称以id为基础，这样即使image重命名，内部结构也基本不发生改变。</p><p>$\S 2$ rbd_header</p><p>这是image最主要的元数据对象，其对象名由rbd_header.<id>,<id>表示rbd_id所记录的内部id。</p><p>$\S3$ rbd_object_map</p><p>为了解决克隆image数据I/O对象执行时间过长的问题，Ceph引入object-map，它将所有数据对象的存在记录在一个独立的元数据对象，总共有四种状态，b00对象不存在、b01对象存在、b10对象待删除、b11对象存在且从第一次快照创建后没有进行写。</p><h3 id="1-2-RBD管理元数据对象"><a href="#1-2-RBD管理元数据对象" class="headerlink" title="1.2 RBD管理元数据对象"></a>1.2 RBD管理元数据对象</h3><ul><li><p>rbd_directory</p><p>omap类型。记录存储池中所有image列表。其中 <code>name_&lt;name&gt;</code> 记录image名称所对应的image id；<code>id_&lt;id&gt;</code>记录image名称。</p></li><li><p>rbd_children</p><p>omap类型。记录父image快照到克隆image之间的单向映射关系（parent-&gt;children）。其中<code>&lt;parent&gt;</code>记录当前存储池下基于父image快照创建的一个或多个克隆image id列表。由<pool_id,image_id,snap_id>三个字段组成，用于表示克隆image所关联的父image快照，而元数据内容为克隆image的id集合。</p></li></ul><h2 id="S2-数据"><a href="#S2-数据" class="headerlink" title="$\S2$  数据"></a>$\S2$  数据</h2><p>如rbd_header的定义，在创建image时可以通过<code>object-size</code>控制数据对象的容量大小，默认为4MB，image数据以该大小为单元进行等量划分。每个数据对象的名称由rbd_header元数据中对象前缀和对象序号组成。</p><p><strong>数据条带化</strong></p><p>RBD image在许多对象上分条，然后由Ceph分布式对象存储（RADOS）存储。结果，对图像的读取和写入请求分布在群集中的许多节点上，通常可以防止在单个image变大或繁忙时任何单个节点成为瓶颈。默认为类似于RAID-0的方式进行条带化（Stripping V2）.</p><p>条带化由三个参数控制：</p><ul><li><p><code>object-size</code></p><p>我们分割的对象的大小是2的幂。将四舍五入到最接近的2的幂。默认对象大小为4 MB，最小为4K，最大为32M。</p></li><li><p><code>stripe_unit</code></p><p>在继续下一个对象之前，每个[ <em>stripe_unit</em> ]连续字节都存储在同一对象中。</p></li><li><p><code>stripe_count</code></p><p>之后，我们写[ <em>stripe_unit</em> ]字节为[ <em>stripe_count</em> ]对象，我们循环回到初始对象和写入另一个条纹，直到对象达到其最大尺寸。在这一点上，我们继续下一个[ <em>stripe_count</em> ]对象。</p></li></ul><p>默认情况下，[ <em>stripe_unit</em> ]与对象大小相同，[ <em>stripe_count</em> ]为1。指定不同的[ <em>stripe_unit</em> ]和/或[ <em>stripe_count</em> ]通常被称为使用“花式”条带，并且需要v2。</p><h2 id="S3-功能特性"><a href="#S3-功能特性" class="headerlink" title="$\S3 $ 功能特性"></a>$\S3 $ 功能特性</h2><h3 id="RADOS快照"><a href="#RADOS快照" class="headerlink" title="RADOS快照"></a>RADOS快照</h3><p>由于快照的存在，一个RADOS对象可能由一个head对象和多个克隆组成。在OSD端使用SnapSet结构体来保存对象的快照信息，其中clone_overlap字段记录clone对象与head对象的数据内容重叠的区间，在数据恢复时，可以减少OSD直接的信息传输。</p><p>RADOS对象创建快照后数据读取流程非常简单，RADOS客户端在读操作中携带需要读取的RADOS对象的snapid，通过snapid定位到clone对象或head对象即可读到相应的数据。</p><p>假设初始时的head对象是一个完整的使用默认4MB大小的对象，且之前未有过COW操作。对该对象制作快照snap1，然后写数据至[512K~1M]区间，此时会触发COW，通过底层的克隆操作生成一个clone对象clone1，然后将新数据写入head对象。写操作会同步更新这个head对象上记录的clone_overlap[snap1]，对于一个新的快照对象一开始这个重叠区间是整个对象的[0 ~ 4M]， 然后每个新的写入操作会在这个区间减去新写的区间。 </p><h3 id="RBD快照"><a href="#RBD快照" class="headerlink" title="RBD快照"></a>RBD快照</h3><p>RBD快照只需要保存少量的快照元数据信息，其底层数据I/O的实现完全依赖于RADOS快照实现，</p><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>RBD克隆是在RBD快照基础上实现的可写快照，与RBD快照功能相似，RBD克隆的实现也依赖COW。与RBD快照不同的是 快照功能依赖于RADOS层的对象快照实现，但是功能完全在RBD客户端实现。</p><p>创建克隆image的过程基本上就是创建一个新的image，但是在image的元数据中会记录一个parent键值对，也就是记录克隆image与快照相连的父子关系。所以才会有parent和rbd_children等属性。由于克隆关系可能存在多层，因此RBD客户端会尝试访问最顶层的parent。</p><p><strong>如果访问克隆对象遇到不一致如何处理</strong>？</p><p>克隆image读流程</p><ul><li>RBD客户端读取指定区间的数据，假设该区间最终落到第一个数据对象；</li><li>由于第一个对象不存在，故会返回对象不存在错误；</li><li>RBD会访问parent并得到关联的快照信息，需要注意的是，创建克隆image时可以指定与快照image不同的条带化参数，因此从快照image读取数据的区间可能落到与第一步不同的数据对象；</li><li>读操作返回</li></ul><p>克隆image写流程</p><ul><li>RBD客户端读取指定区间的数据，假设该区间最终落到第一个数据对象；</li><li>由于第一个对象不存在，故会返回对象不存在错误；</li><li>与读操作不同，写入操作需要从快照image读取克隆image第一个数据对象整个对象区间的数据；</li><li>对快照image的读操作返回；</li><li>将从快照读取的数据写入克隆image的第一个数据对象，然后重新执行原始的针对克隆image的第一个数据对象的写操作，最终写操作完成。</li></ul><hr><h1 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h1><h2 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h2><ol><li><p>我们可以创建一个rbd_image并且指定它的大小：</p><pre><code class="hljs livecodeserver">rbd <span class="hljs-built_in">create</span> mypool/myimage <span class="hljs-comment">--size 102400</span></code></pre><p>或者指定对象大小（8M）</p><pre><code class="hljs angelscript">rbd create mypool/myimage --size <span class="hljs-number">102400</span> --object-size <span class="hljs-number">8</span>M</code></pre></li><li><p>删除（小心！）</p></li></ol><pre><code class="hljs nginx"><span class="hljs-attribute">rbd</span> rm mypool/myimage</code></pre><ol><li>创建快照</li></ol><pre><code class="hljs nginx"><span class="hljs-attribute">rbd</span> snap create mypool/myimage<span class="hljs-variable">@mysnap</span></code></pre><h2 id="获取rbd-id"><a href="#获取rbd-id" class="headerlink" title="获取rbd_id"></a>获取rbd_id</h2><pre><code class="hljs vim">rados <span class="hljs-built_in">get</span> -<span class="hljs-keyword">p</span> rbd rbd_id.<span class="hljs-symbol">&lt;image_name&gt;</span> file_rbd_id<span class="hljs-keyword">cat</span> file_rbd_id</code></pre><p>可以获得类似<code>ac62a15cbf99</code>这样的id标识。</p><ul><li>features 已启用的功能特性</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th>bit位</th><th>注解</th></tr></thead><tbody><tr><td>layering</td><td>0(LSB)</td><td>是否支持image克隆操作，克隆image与关联的父image快照之间通过COW实现数据共享</td></tr><tr><td>striping</td><td>1</td><td>是否进行数据对象间数据条带化，类似于RAID 0，在创建image时如果指定了条带化参数，数据会在多个image数据对象之间进行条带化</td></tr><tr><td>exclusive-lock</td><td>2</td><td>是否支持分布式锁，即image自带互斥访问锁机制以限制以限制同时只能有一个客户端访问image，主要应用于虚拟机热迁移</td></tr><tr><td>object-map</td><td>3</td><td>是否记录组成image的数据对象存在的状态位图，通过查表加速类似于导入、导出、克隆分离、已使用容量计算等操作，同时有助于减少COW机制带来的克隆image的I/O时延，依赖于exclusive-lock特性</td></tr><tr><td>fast-diff</td><td>4</td><td>用于计算快照间增量数据等操作加速，依赖于object-map特性</td></tr><tr><td>deep-flatten</td><td>5</td><td>克隆分离时十分同时解除克隆image创建的快照与父image之间的关联关系。该特性只是为了阻止老的RBD客户端访问image而设置</td></tr><tr><td>journaing</td><td>6</td><td>是否记录image修改操作到日志对象，用于远程异步镜像功能，依赖于exclusive-lock特性</td></tr><tr><td>data-pool</td><td>7(MSB)</td><td>是否将数据对象存储于与元数据不同的存储池，用于支持将image的数据对象存储于EC纠删码存储池</td></tr></tbody></table></div><hr>  <pre><code class="hljs angelscript">value (<span class="hljs-number">8</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                           |=.......|<span class="hljs-number">00000008</span></code></pre><p>  0x3d对应二进制<code>0&#39;b00111101</code> 表示启用了layering、exclusive-lock、object-map，fast-diff，deep-flatten等特性。</p><ul><li><p>object_prefix 数据对象名称前缀</p><pre><code class="hljs angelscript">value (<span class="hljs-number">25</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">15</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">72</span> <span class="hljs-number">62</span> <span class="hljs-number">64</span> <span class="hljs-number">5f</span>  <span class="hljs-number">64</span> <span class="hljs-number">61</span> <span class="hljs-number">74</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>e <span class="hljs-number">61</span> <span class="hljs-number">63</span> <span class="hljs-number">36</span>  |....rbd_data.ac6|<span class="hljs-number">00000010</span>  <span class="hljs-number">32</span> <span class="hljs-number">61</span> <span class="hljs-number">31</span> <span class="hljs-number">35</span> <span class="hljs-number">63</span> <span class="hljs-number">62</span> <span class="hljs-number">66</span> <span class="hljs-number">39</span>  <span class="hljs-number">39</span>                       |<span class="hljs-number">2</span>a15cbf99|<span class="hljs-number">00000019</span></code></pre></li><li><p>order 组成image的数据对象容量大小，以2为底的指数</p><pre><code class="hljs angelscript">value (<span class="hljs-number">1</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">16</span>                                                |.|<span class="hljs-number">00000001</span></code></pre></li><li><p>parent 当存在克隆关系时，克隆image记录的关联的父image快照信息</p></li><li><p>size 容量大小</p><pre><code class="hljs angelscript">value (<span class="hljs-number">8</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                           |...@....|<span class="hljs-number">00000008</span></code></pre><p>64位整型，上述表示1GB</p></li><li><p>snap_seq 用于记录image最后一次创建的快照的id</p><pre><code class="hljs angelscript">value (<span class="hljs-number">8</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>                           |........|<span class="hljs-number">00000008</span></code></pre><p>上图表示最后一次创建快照id为0x04</p></li><li><p>snap_<snap_id>所记录的是一个cls_rbd_snap结构体实例，记录快照名称、id等基本信息。</p><pre><code class="hljs routeros">rados getomapval -p cephfs_data rbd_header.ac62a15cbf99 snapshot_0000000000000004 f_snapceph-decoder<span class="hljs-built_in"> type </span>cls_rbd_snap import \&gt; f_snap decode dump_jsonceph-dencoder<span class="hljs-built_in"> type </span>cls_rbd_snap import f_snap decode dump_json</code></pre><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">4</span>,    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;snap1&quot;</span>,    <span class="hljs-attr">&quot;image_size&quot;</span>: <span class="hljs-number">1073741824</span>,    <span class="hljs-attr">&quot;protection_status&quot;</span>: <span class="hljs-string">&quot;unprotected&quot;</span>,    <span class="hljs-attr">&quot;child_count&quot;</span>: <span class="hljs-number">0</span>&#125;</code></pre><p>与普通的image不同，克隆image在创建时不能指定容量大小，而是由image_size决定克隆image的初始容量大小。features是父image在创建快照时的features元数据记录，创建克隆image时如果不显示指定需要启用的功能特性<code>--image-feature &lt;feature_name&gt;</code>，则默认会使用features所有记录的值。protection_status 用于标示快照被保护状态，处于被保护的快照不能被删除，克隆image必须基于被保护的快照进行创建，主要是为了防止克隆image所引用的父image被误删除。</p></li><li><p>stripe_count\stripe_unit所记录的元素据是64位整数，用于记录image条带化信息。详细见理论部分。</p></li></ul><h2 id="RBD管理元数据对象"><a href="#RBD管理元数据对象" class="headerlink" title="RBD管理元数据对象"></a>RBD管理元数据对象</h2><ul><li><h3 id="rbd-directory"><a href="#rbd-directory" class="headerlink" title="rbd_directory"></a>rbd_directory</h3></li></ul><p>用于记录当前存储池中image列表。</p><pre><code class="hljs apache"><span class="hljs-attribute">rados</span> listomapvals -P cephfs_data rbd_directory id_ac<span class="hljs-number">62</span>a<span class="hljs-number">15</span>cbf<span class="hljs-number">99</span></code></pre><pre><code class="hljs angelscript">value (<span class="hljs-number">12</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">72</span> <span class="hljs-number">62</span> <span class="hljs-number">64</span> <span class="hljs-number">69</span>  <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span>              |....rbdimage|<span class="hljs-number">0000000</span>cid_aca0d915627fvalue (<span class="hljs-number">13</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">72</span> <span class="hljs-number">62</span> <span class="hljs-number">64</span> <span class="hljs-number">69</span>  <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">65</span> <span class="hljs-number">32</span>           |....rbdimage2|<span class="hljs-number">0000000</span>dname_rbdimagevalue (<span class="hljs-number">16</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">61</span> <span class="hljs-number">63</span> <span class="hljs-number">36</span> <span class="hljs-number">32</span>  <span class="hljs-number">61</span> <span class="hljs-number">31</span> <span class="hljs-number">35</span> <span class="hljs-number">63</span> <span class="hljs-number">62</span> <span class="hljs-number">66</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span>  |....ac62a15cbf99|<span class="hljs-number">00000010</span>name_rbdimage2value (<span class="hljs-number">16</span> bytes) :<span class="hljs-number">00000000</span>  <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">61</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">30</span>  <span class="hljs-number">64</span> <span class="hljs-number">39</span> <span class="hljs-number">31</span> <span class="hljs-number">35</span> <span class="hljs-number">36</span> <span class="hljs-number">32</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span>  |....aca0d915627f|<span class="hljs-number">00000010</span></code></pre><h3 id="rbd-children"><a href="#rbd-children" class="headerlink" title="rbd_children"></a>rbd_children</h3><p>当image之间具有克隆关系时，rbd_children 元数据对象用于记录父image快照到克隆image之间的单向映射关系。</p>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构</tag>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「核心」Ceph学习三部曲之五:控制先行——Ceph的QoS策略</title>
    <link href="/2020/12/28/%E6%8E%A7%E5%88%B6%E5%85%88%E8%A1%8C-Ceph%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0QoS/"/>
    <url>/2020/12/28/%E6%8E%A7%E5%88%B6%E5%85%88%E8%A1%8C-Ceph%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0QoS/</url>
    
    <content type="html"><![CDATA[<h1 id="控制先行——Ceph的QoS策略"><a href="#控制先行——Ceph的QoS策略" class="headerlink" title="控制先行——Ceph的QoS策略"></a>控制先行——Ceph的QoS策略</h1><div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第五章。9/7/2017 韩国SK团队进展 .PPT见<a href="https://www.slideshare.net/ssusercee823/implementing-distributed-mclock-in-ceph">链接</a>,Code见<a href="https://github.com/ceph/ceph/pull/16369">链接</a>.</p>          </div><blockquote></blockquote><p>Ceph作为开源社区的明星，因为其高可扩展性、高可靠性，受到各大厂商的热烈追捧，并成为OpenStack事实上的默认存储后端。但是人非圣贤，孰能无过?它也同样面临I/O资源分配的问题。为了保证客户能够体验更好的服务，Ceph引入了QoS($Quality of Service$).</p><p>$dmClock$是一种分布式系统的I/O调度算法，它起源于mClock（<a href="https://www.usenix.org/legacy/events/osdi10/tech/full_papers/Gulati.pdf">论文地址</a>）,目前被应用于Ceph中。</p><p>Ceph作为分布式存储系统集大成者，不能像传统QoS实现位置首选的中心节点，必须在每个OSD中实现QoS。下图展示了社区目前（2017版本）的Ceph QoS pool单元：</p><p><img src="/img/image-20201219164136113.png" alt="image-20201219164136113" style="zoom:80%;" /></p><h2 id="1-dmClock算法原理"><a href="#1-dmClock算法原理" class="headerlink" title="1 dmClock算法原理"></a>1 dmClock算法原理</h2><p>首先我们先了解mClock，这是一种基于时间标签的I/O调度算法，最先被VMware提出了的用于集中式管理的存储系统。它使用了reservation（预留，表示客户端获得的最低I/O资源）、weight（权重，表示客户端占用共享I/O资源的权重，共享I/O指满足预留之后剩余的I/O资源）以及limit（上限，表示用户所能使用的最大I/O）作为一套模板（QoS spec），作用于不同的客户端。下图是其典型应用模型：</p><p><img src="/img/dmClock.png" alt="image-20201216151614635"></p><p>mClock是典型的C/S架构，Client可以驻留在实际的客户端或者服务器端，主要负责下发QoS模板的参数值、收集请求的完成信息等；server为mClock的服务端，实现I/O调度的核心功能。</p><p>其算法流程如下：</p><ol><li>Server为每个客户端设置一套QoS模板参数，包括预留（r），权重（w）和上限（l）三个部分，并依次计算出I/O请求的时间标签，其中预留和上限为绝对时间，权重标签为相对时间。</li><li>服务器分为两个阶段来处理I/O请求：一是Constarint-based，只处理满足预留时间标签的请求；二是Weight-based阶段，处理满足上限的时间标签的权重标签请求。</li><li>服务器先工作也Constraint-based，再转入Weight-based阶段。</li></ol><p>如果用$q_i$表示QoS的模板参数$q_i\in\{r_i,w_i,l_i\}$，$Q^r_i$表示来自第i个客户的第r个请求的时间标签。有如下公式：</p><script type="math/tex; mode=display">Q_i^r=max\{Q^{r-1}_i+1/q_i,current\_time\}</script><p>以第一个请求到达时间作为初始基准标签，后续标签依据预设的模板参数值，对单位时间进行均匀切分计算而来。在Constraint-based阶段 ，各客户端请求被均匀的处理，而在weight-based阶段，则将出现竞争，由于权重标签是相对值，它和真实的时间之差通常会很大，从而出现饥饿现象。因此需要调整旧client的权重标签，以新client的权重时间标签为基准，添加一个补偿值。</p><p>dmClock是mClock 的分布式版本，两者的基本原理相同。每个请求的时间标签计算公式如下：</p><script type="math/tex; mode=display">R_i^r=max\{R_i^{r-1}+\rho_i/r_i,current\_time\}\\W_i^r=max\{W_i^{r-1}+\delta_i/w_i,current\_time\}\\L_i^r=max\{L_i^{r-1}+\delta_i/l_i,current\_time\}\\</script><p>dmClock和mClock的主要区别在于：</p><ul><li>分布式系统具有多个服务器，服务器回应每个I/O请求时，返回其在哪个阶段被处理完成。</li><li>客户端记录每个服务器完成的请求个数，在向服务器下发请求时，携带距上次下发请求以来，收到完成的请求个数的增量，并且是除目标服务器之外，其它服务器完成的请求数之和，分别用$\rho$和$\delta$表示两个阶段的增量处理个数。</li><li>服务器计算请求的时间标签，使用$\rho$和$\delta$作为调整因子，不再以$1/q$均匀递增。从而减小了每个服务器处理的请求的个数。</li></ul><p>通过对$\rho$和$\delta$的调整，使得集群整体对外提供预期的I/O处理效果。</p><h2 id="2-QoS的设计与实现"><a href="#2-QoS的设计与实现" class="headerlink" title="2 QoS的设计与实现"></a>2 QoS的设计与实现</h2><p>在OSD中，存在<code>op_shardedwq</code>队列处理各种来自上级的I/O，并且这是一个复合队列，通常包含若干子队列。I/O请求从队列出列后，通过ObjectStore接口与磁盘交互。</p><p>OSD支持多种不同的子队列，目前主要包括优先级队列（prio）和基于权重的优先级队列（wpq）两种，</p><p>I/O操作类型主要包括以下几种：</p><ol><li>ClientOp：来自客户端的读写I/O请求；</li><li>SubOp：OSD之间的I/O请求。主要包括客户端I/O产生的副本间数据读写请求，以及由数据同步、数据扫描、负载均衡等引起的I/O请求。</li><li>SnapTrim：快照数据删除。</li><li>Scrub：用于发现对象的静默数据错误。其中Scrub只扫描元数据，而Deep Scrub对对象整体进行扫描。</li><li>Recovery：数据恢复和迁移。集群扩容、OSD添加与移除、手动进行数据重平衡都有可能触发recovery过程。</li></ol><p><img src="/img/dmClock2.png" alt="image-20201218175910498" style="zoom:67%;" /></p><p>上图表示OSD内部结构，我们对原有的prior队列，wpq队列以及新增的dmClock队列加以分析。</p><h2 id="2-1-优先级队列prior"><a href="#2-1-优先级队列prior" class="headerlink" title="2.1 优先级队列prior"></a>2.1 优先级队列prior</h2><p>prior是一个基于令牌桶的优先队列，由三个级别组成：1.I/O类型的优先级prior； 2. 客户端级别的client队列；3.真实的list请求；每个元素包括请求r以及数据大小cost。可以把prior看成一个三维的队列。</p><p>每个prior队列，在其第一个请求入队时，被创建，并分配一个大小为<code>max_tokens</code>的令牌桶。</p><p>关于出队的规则，有以下几点：</p><ol><li>选择合理的prior：从小到大轮询所有prior，只要满足条件则被选中。即，该prior队列的令牌桶中剩余 的令牌数量足够多，可以容纳将被选中的请求（每个请求出队时，必须拿到与其大小cost相当的令牌的个数）。</li><li>选择合理的client：对同优先级下的client进行轮询，即第一个client出队一个请求后，将请求的出队权交给第二个client，该优先级再次被选中时，从第二个client出队请求。</li><li>选择合理的请求：从被选中的client的请求list表中出队一个请求（FIFO策略）。</li></ol><p>当出队一个请求时，从令牌桶中拿掉与请求大小cost相当的令牌个数，随后将拿到的令牌数分发、交还至所有prior队列，使得令牌总数维持不变。令牌分发的规则是，按照各自prior的占用比重，每个prior队列可回收的令牌总数token：</p><script type="math/tex; mode=display">token = \frac{prior}{total\_prior}\times cost</script><p>对于prio较大的队列将优先被考虑，I/O类型到达优先级可以用过配置参数修改，如下表所示：</p><div class="table-container"><table><thead><tr><th>优先级配置参数</th><th>默认值</th></tr></thead><tbody><tr><td><code>osd_client_op_priority</code></td><td>63</td></tr><tr><td><code>osd_snap_trim_priority</code></td><td>5</td></tr><tr><td><code>osd_scrub_prority</code></td><td>5</td></tr><tr><td><code>osd_recovery_op_priority</code></td><td>3</td></tr></tbody></table></div><p>优先队列同样存在一些局限性，如果集群中某个OSD分布了比其它OSD更多的PG或者Object对象时，该OSD由于需要处理更多的副本请求，导致客户端长时间得不到处理出现饥饿现象。</p><p>为此社区引入了基于权重的优先级队列wpq.</p><h2 id="2-2-权重优先级队列wpq"><a href="#2-2-权重优先级队列wpq" class="headerlink" title="2.2 权重优先级队列wpq"></a>2.2 权重优先级队列wpq</h2><p>基于权重的wpq不需要创建令牌桶，与prior仅在出队方式上有区别：</p><ul><li><p>采用权重概率的方式确定prior级别，每个队列的优先级prior作为其权重，该prior队列被选中的概率即为其权重占总权重的比例。通过随机数对total_prior取余的方式得到在$[0,total_prior-1]$的范围内完全随机分布。(rand()%total_prior)</p></li><li><p>被选中的prior队列并不一定能出队请求，还需要根据将要出队的请求大小来确定，即是否满足$rand()\%max_cost\le (max_cost - (request_size*9/10))$</p></li></ul><p>max_cost指该prior队列最大的请求的大小。较小请求对应右边值更大，因而出队概率更高。</p><ul><li>client级别和真实请求的选择和prior相同。</li></ul><h2 id="2-3-dmClock队列"><a href="#2-3-dmClock队列" class="headerlink" title="2.3 dmClock队列"></a>2.3 dmClock队列</h2><p>dmClock是一个两级映射的队列，第一级为客户端的client队列，第二级是真实的请求队列，每个请求包含三个时间标签$<R_i,W_i,L_i>$, 其中i表示所属的client编号，没有使用优先级prior。</p><p>dmClock采用<strong>完全二叉树</strong>这种数据结构来处理大量的请求。分别构建预留时间标签、权重时间标签、上限时间标签二叉树，树节点为每个client对应的请求队列，节点在二叉树的位置，则根据其队首元素的三个标签决定，总体原则是父节点时间标签小于子节点。</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>对于已存在的client，将请求直接挂入请求队列的尾部；对于新增client，除了新创建一个对应的请求队列，还要将队列作为一个新节点加入标签二叉树。根据完全二叉树的特点，采用顺序的变长数组结构存储，新节点先加入二叉树的尾部，再调整至合适的位置，二叉树的调整规则如下：</p><ul><li>R预留标签二叉树：以节点的队首元素的预留标签为基础，值小的节点调整至树的上层，反之调整至下层，最终根节点的预留标签值最小；</li><li>W权重标签二叉树：该树的节点中有两种状态，一种满足出队条件，其上限小于或等于当前时间，ready标记被置为true；另一种不满足出队条件，ready被置为false。对节点位置调整时，根据请求队列队首元素的ready状态，满足出队条件的节点调至上层，不满足出队条件的调至下层。相同状态的节点再由权重标签的大小决定，标签值较小的往上调整，反之往下调整。</li><li>L上限标签二叉树：用于判决权重二叉树的节点中的请求是否满足出队条件，也使用ready进行标记区分。但与权重二叉树不同，ready为true的节点向下调整。ready相同的节点根据上限标签值的大小决定。</li></ul><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>首先进入constraint-based阶段取预留标签二叉树的根节点的请求队列，判断其队首元素的预留标签是否小于当前时间，作为是否满足出队条件的依据。如果条件满足，则选取该节点对应的client，从其请求队列的队首出队一个元素；否则进入weight-based阶段，从上限标签二叉树的根节点开始，逐个判断队首元素的上限标签是否小于等于当前时间，并，设置满足条件的请求的ready为true，以决定其是否可以参加随后的<strong>权重竞争</strong>。所谓的权重竞争，指对所有满足上限条件的clients，依据其队首元素的权重标签值，调整自身在权重二叉树的位置的过程，最终位于根节点的client胜出。</p><h2 id="2-4-Client的设计"><a href="#2-4-Client的设计" class="headerlink" title="2.4  Client的设计"></a>2.4  Client的设计</h2><p>目前Client 的设计有三种初步方案：</p><p>1）使用mClock作为一种分配调度策略，控制客户端的I/O请求和Ceph内部产生的I/O调度。这将所有不同真实客户端作为同一个抽象的client考虑；</p><p>2）使用dmClock以存储池或者卷为粒度，为其设置QoS模板参数，客户端请求以消息的形式发送至OSD。这是将每个存储池或存储池中的卷作为一个client；</p><p>3）使用dmClock为每个真实客户端设置一套QoS模板，这是将每个真实client作为一个client；</p><p>对于每一个 QoS 对象来说，首先需要在 OSD 中实现以下前置条件:</p><ol><li>对于每个客户端来说，每个请求具有唯一的标识符，客户端和请求形成全局唯一</li><li>必须将每个请求对应的 QoS 控制信息持久化</li><li>OSD 能够通过标识符从来访的请求中找到 QoS 控制信息</li></ol><h2 id="2-5-总结与展望"><a href="#2-5-总结与展望" class="headerlink" title="2.5 总结与展望"></a>2.5 总结与展望</h2><p>目前对QoS的优化有以下几种方向：</p><ol><li><p>合理模板参数的设置</p><p>只有集群运行于超负荷时（入队速率大于出队速率），权重的效果才能体现出来。</p></li><li><p>I/O带宽的限制</p><p>QoS限速体系的设计，比如通过OIO throttling来进行限速【参考SK团队PPT】。</p></li><li><p>突发I/O的处理</p><p>dmClock的做法是为每个client预先设置一个可调整参数$\sigma$，当出现突发I/O状况，减小该client的权重标签至$t-\sigma_i/w_i$，从而使其在权重竞争中更有优势。这里有一个问题，就是服务端如何判断客户端产生突发I/O访问？通过记录客户端的状态是一种可行的方式。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Ceph</category>
      
      <category>理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QoS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「核心」Ceph学习三部曲之四:下一代对象存储引擎BlueStore</title>
    <link href="/2020/12/27/%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EBlueStore/"/>
    <url>/2020/12/27/%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EBlueStore/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第二章。以及<a href="https://docs.ceph.com/en/latest/rados/operations/bluestore-migration/">官方BlueStore教程</a>。</p><p>推荐博客<a href="http://www.itworld123.com/2019/06/04/storage/ceph/Ceph%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EBlueStore%E7%AE%80%E6%9E%90/">Ceph存储引擎BlueStore简析</a></p>          </div><h1 id="下一代对象存储引擎BlueStore"><a href="#下一代对象存储引擎BlueStore" class="headerlink" title="下一代对象存储引擎BlueStore"></a>下一代对象存储引擎BlueStore</h1><p>相比于目前FileStore，BlueStore拥有无与伦比的优势：</p><ul><li>充分考虑下一代全SSD以及NVMe SSD闪存阵列的适配。例如将高效索引元数据的引擎由LevelDB替换为RocksDB。</li><li>传统的基于POSIX接口的FileStore需要通过操作系统自带的文件系统间接管理磁盘。BlueStore选择绕开文件系统，从而使得I/O路径大大减小。</li><li>在设计中将元素据和用户数据严格分离，因此元素据可以单独采用高速固态存储设备，诸如NVMe SSD，以实现性能加速。</li><li>与传统机械硬盘相比，SSD普遍采用4k 或者更大的块大小，因此采用位图进行管理可以获得更高的空间收益。</li></ul><h2 id="1-设计理念"><a href="#1-设计理念" class="headerlink" title="1 设计理念"></a>1 设计理念</h2><p>在存储系统中，所有读操作都是同步的，即除非在缓存命中，否则必须从磁盘中读到指定内容才向客户端返回。而写操作则不一样，一般处于效率考虑，所有写操作都会在内存中进行缓存，由文件系统进行组织后再批量写入磁盘。</p><p>数据可靠性：我们考虑写的期间发生断电的情况，因为内存是易失性的，所有数据会丢失。针对这个问题，有人提出用一个掉电不丢失的中间设备作为过渡设备，等数据写入普通磁盘后再释放中间设备上的空间，这个写中间设备的过程被称为<strong>写日志</strong>。中间设备被称为日志设备。但这样会消耗额外硬件资源。</p><p> 数据一致性：数据修改要么全部完成，要么没有变化（All or nothing）. 具体而言，我们用ACID（A: Atomicity, C: Consistency, I:Isolation, D:Durability）来描述这种系统，即<strong>事务型系统</strong>。</p><p><strong>术语</strong></p><p>块大小： 指对磁盘进行操作的最小粒度。 对普通机械硬盘为512字节，而SSD为4KB。</p><p>RMW：覆盖写。 如果本次改写的内容不足一个块，那么需要将对应的块读进来，将待修改的内容与原先内容进行合并。它的问题在于：额外的读惩罚，以及潜在的数据丢失风险。</p><p>COW：写时重定向。在磁盘分配新的空间，再写入，写完成后再释放旧数据。</p><h2 id="2-BlueStore写策略"><a href="#2-BlueStore写策略" class="headerlink" title="2 BlueStore写策略"></a>2 BlueStore写策略</h2><p>BlueStore综合运用了RMW和COW，任何一个写请求，根据磁盘块大小，分为三个部分，即首尾非块大小对齐部分和中间块大小对齐部分，针对两边RMW，针对中间采用COW。</p><p>BlueStore提供的读写访问接口都是基于PG粒度的。</p><h2 id="3-缓存替换机制"><a href="#3-缓存替换机制" class="headerlink" title="3 缓存替换机制"></a>3 缓存替换机制</h2><p>LRU算法：最近最少使用，时间局部性原理。</p><p>LFU算法：最近不经常使用，SDD访问模型。</p><p>ARC算法，同时考虑了LRU和LFU的长处，同时使用两个队列对缓存中页面进行管理：</p><ul><li>MRU (Most Recently Used) 队列保存最近访问过的页面</li><li><p>MFU（Most Frequently Used）队列保存最近一段时间<strong>至少被访问过两次</strong>的界面。</p></li><li><p>两个队列的长度是可变的，会根据请求队列的特征自动进行调整，取LRU和LFU共同之所长。</p><ul><li>当系统中请求序列呈现明显的时间局部性，MFU队列长度变为0，从而退化为LRU。</li><li>当系统中请求序列呈现明显的空间局部性，MRU队列长度变为0，从而退化为LFU。</li></ul></li></ul><p>2Q算法：双队列热点算法，一种针对数据库特别是关系数据库系统优化的缓存淘汰算法：</p><p>数据库系统由于需要保证每个操作的原子性，所以经常存在多个事务操作同一块热点数据的场景，因此针对数据库系统的缓存淘汰算法主要关注如何识别多个并发事务之间的数据相关性。</p><p>与ARC类似，2Q也使用了多个队列来管理整个缓存空间，分布称为$A1in,A1out,Am$。这些队列都是LRU队列，其中$A1in$与$Am$是真正的缓存队列，$A1out$是影子队列，i.e.只保存相关页面的管理结构。</p><ul><li>新的页面一开始总是被加入A1in，当某个页面被频繁访问，2Q认为这些访问是相关的，不会针对该页面执行任何热度提升的操作，直到其被正常淘汰至Aout。这个时间间隔被称为“相关时间间隔”。</li><li>当A1out中某个页面被再次访问时，2Q认为这些访问不再相关，此时执行页面热度提升，将其加入Am头部。Am队列中的页面再次被命中时，同样将其加入Am队列头部进行页面热度提升。从Am中淘汰的页面也进入A1out。这个时间间隔被称为“热度保留间隔”。</li></ul><h2 id="4-缓存管理"><a href="#4-缓存管理" class="headerlink" title="4 缓存管理"></a>4 缓存管理</h2><p>BlueStore 目前采用了LRU和2Q两种算法。</p><p>参考Theodore和Dennis的测试结论，推荐A1in和Am队列的容量配比1:1.</p><p>BlueStore的cache既可以用于缓存用户数据，也可以用于缓存元数据。bluestore中默认元数据的比重位90%。</p><p>BlueStore中元素据分为两类：Collection和Onode. Collection是PG在BlueStore中内存管理结构。每个OSD最多承载100个PG而且Collection管理结构本身比较小，故被设计成常驻内存。而Onode的数量和其管理的磁盘空间成正比，因而不可能常驻内存，需要引入淘汰机制。Onode采用LRU。</p><h2 id="5-BlueFS"><a href="#5-BlueFS" class="headerlink" title="5 BlueFS"></a>5 BlueFS</h2><p>诞生于2011年的LevelDB是基于Google的BigTable数据库系统发展而来。然而随着SSD普及，LevelDB无法发挥SSD全部性能，因而诞生了RocksDB。</p><ul><li><p>RocksDB适合存储小型或者中型键值对；性能随着键值对长度上升下降很快。</p></li><li><p>性能随CPU核数以及后端存储设备的I/O能力呈线性扩展。</p></li></ul><p>传统的本地文件系统（XFS，ext4，ZFS）等不能与RocksDB完全兼容，因而专门为其量身打造一款本地文件系统——BlueFS。在逻辑空间上分为三个层次 </p><p>（1）慢速空间 </p><p> 主要用于存储对象数据，可由大容量机械硬盘担任存储。</p><p>（2）高速空间（DB）</p><p>主要存储BlueStore内部的元素据，比如Onode。 可以由SSD提供。</p><p>（3）超高速（WAL）</p><p>WAL(Write Ahead Log)指日志。 可以由NVMe SSD或NVRAM等高速设备充当。</p><p>BlueFS上的磁盘数据包括文件、目录、日志三种类型。其定位文件分为两步：1. 通过<code>dir_map</code>找到文件的最底层文件夹 2.通过<code>file_map</code>找到对应的文件。其磁盘数据结构如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">成员</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ino</td><td style="text-align:center">唯一标识一个fnode</td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">文件大小</td></tr><tr><td style="text-align:center">mtime</td><td style="text-align:center">文件上一次被修改时间</td></tr><tr><td style="text-align:center">prefer_bdev</td><td style="text-align:center">存储该文件优先使用的设备</td></tr><tr><td style="text-align:center">extents</td><td style="text-align:center">磁盘上物理段集合包括{bdev，offset，length}</td></tr></tbody></table></div><p><img src="/img/image-20201202001057524.png" alt="image-20201202001057524"></p><h2 id="6-ObjectStore-OS"><a href="#6-ObjectStore-OS" class="headerlink" title="6 ObjectStore(OS)"></a>6 ObjectStore(OS)</h2><p>Ceph是一个指导原则是所有存储的不管是块设备、对象存储、文件存储最后都转化成了底层的对象object，这个object包含3个元素data，xattr，omap。data是保存对象的数据；xattr是保存对象的扩展属性，每个对象文件都可以设置文件的属性，这个属性是一个key/value值对，这类操作的特征是kv对并且与某一个Object关联，但是受到文件系统的限制，key/value对的个数和每个value的大小都进行了限制。如果要设置的对象的key/value不能存储在文件的扩展属性中；还存在另外一种方式保存omap(在Ceph中称为omap)，omap实际上是保存到了key/vaule  值对的RocksDB中，在这里value的值限制要比xattr中好的多。</p><p>对于FileStore实现，每个Object在FileStore层会被看成是一个文件，Object的属性(xattr)会利用文件的xattr属性存取，因为有些文件系统(如Ext4)对xattr的长度有限制，因此超出长度的Metadata会被存储在DBObjectMap里。而Object的omap则直接利用DBObjectMap实现。因此，可以看出xattr和omap操作是互通的，在用户角度来说，前者可以看作是受限的长度，后者更宽泛(API没有对这些做出硬性要求)。目前纠删码还不支持omap。</p><p>而在BlueStore则没有这种限制。</p><hr><h1 id="部署和操作BlueStore"><a href="#部署和操作BlueStore" class="headerlink" title="部署和操作BlueStore"></a>部署和操作BlueStore</h1><h1 id="BLUESTORE迁移"><a href="#BLUESTORE迁移" class="headerlink" title="BLUESTORE迁移"></a>BLUESTORE迁移</h1><p>每个OSD都可以运行BlueStore或FileStore，并且单个Ceph集群可以包含两者的混合。先前已部署FileStore的用户可能希望过渡到BlueStore，以利用改进的性能和健壮性。有几种策略可以实现这种过渡。</p><p>单个OSD不能单独进行原地转换，但是：BlueStore和FileStore根本不同，以致于无法实用。“转换”将依靠群集的正常复制和修复支持，或者依靠将OSD内容从旧的（FileStore）设备复制到新的（BlueStore）设备的工具和策略。</p><h2 id="部署新的OSD与BLUESTORE"><a href="#部署新的OSD与BLUESTORE" class="headerlink" title="部署新的OSD与BLUESTORE"></a>部署新的OSD与BLUESTORE</h2><p>可以使用BlueStore部署任何新的OSD（例如，在扩展群集时）。这是默认行为，因此不需要进行特定更改。</p><p>同样，更换故障驱动器后重新配置的任何OSD都可以使用BlueStore。</p><h2 id="将现有的OSD"><a href="#将现有的OSD" class="headerlink" title="将现有的OSD"></a>将现有的OSD</h2><h3 id="标记并替换"><a href="#标记并替换" class="headerlink" title="标记并替换"></a>标记并替换</h3><p>最简单的方法是依次标记每个设备，等待数据在群集中复制，重新配置OSD，然后再次将其标记回。它很容易实现自动化。但是，它需要的数据迁移量超出了必要，因此不是最佳选择。</p><ol><li><p>确定要替换的FileStore OSD：</p><pre><code class="hljs ini"><span class="hljs-attr">ID</span>=&lt;osd-id-number&gt;<span class="hljs-attr">DEVICE</span>=&lt;disk-device&gt;</code></pre><p>您可以使用以下命令判断给定的OSD是FileStore还是BlueStore：</p><pre><code class="hljs perl">ceph osd metadata $ID | <span class="hljs-keyword">grep</span> osd_objectstore</code></pre><p>您可以使用以下命令获取文件存储与bluestore的当前计数：</p><pre><code class="hljs applescript">ceph osd <span class="hljs-built_in">count</span>-metadata osd_objectstore</code></pre></li><li><p>将文件存储OSD标记为：</p><pre><code class="hljs nginx"><span class="hljs-attribute">ceph</span> osd out <span class="hljs-variable">$ID</span></code></pre></li><li><p>等待数据从有问题的OSD迁移：</p><pre><code class="hljs bash"><span class="hljs-keyword">while</span> ! ceph osd safe-to-destroy <span class="hljs-variable">$ID</span> ; <span class="hljs-keyword">do</span> sleep 60 ; <span class="hljs-keyword">done</span></code></pre></li><li><p>停止OSD：</p><pre><code class="hljs bash">systemctl <span class="hljs-built_in">kill</span> ceph-osd@<span class="hljs-variable">$ID</span></code></pre></li><li><p>记下此OSD使用的设备：</p><pre><code class="hljs crystal">mount | grep /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-$<span class="hljs-title">ID</span></span></code></pre></li><li><p>卸载OSD：</p><pre><code class="hljs crystal">umount /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-$<span class="hljs-title">ID</span></span></code></pre></li><li><p>销毁OSD数据。请<em>格外小心，</em>因为这会破坏设备的内容；在继续操作之前，请确保不需要设备上的数据（即，群集运行状况良好）。</p><pre><code class="hljs dockerfile">ceph-<span class="hljs-keyword">volume</span><span class="bash"> lvm zap <span class="hljs-variable">$DEVICE</span></span></code></pre></li><li><p>告诉集群OSD已被破坏（并且可以使用相同的ID重新配置新的OSD）：</p><pre><code class="hljs nginx"><span class="hljs-attribute">ceph</span> osd destroy <span class="hljs-variable">$ID</span> --<span class="hljs-literal">yes</span>-i-really-mean-it</code></pre></li><li><p>使用相同的OSD ID在其位置重新配置BlueStore OSD。这要求您确实根据上面看到的内容确定要擦除的设备。小心！</p><pre><code class="hljs dockerfile">ceph-<span class="hljs-keyword">volume</span><span class="bash"> lvm create --bluestore --data <span class="hljs-variable">$DEVICE</span> --osd-id <span class="hljs-variable">$ID</span></span></code></pre></li><li><p>重复。</p></li></ol><p>您可以允许替换OSD的重新填充与下一个OSD的排空同时进行，或者对多个OSD并行执行相同的步骤，只要确保在销毁群集之前群集是完全干净的（所有数据具有所有副本）即可。任何OSD。否则，将减少数据的冗余，并增加（甚至可能导致）数据丢失的风险。</p><p>优点：</p><ul><li>简单。</li><li>可以逐个设备完成。</li><li>不需要备用设备或主机。</li></ul><p>缺点：</p><ul><li>数据通过网络复制了两次：一次复制到集群中的其他OSD（以保持所需的副本数），然后再次返回到重新配置的BlueStore OSD。</li></ul><h3 id="整个主机更换"><a href="#整个主机更换" class="headerlink" title="整个主机更换"></a>整个主机更换</h3><p>如果集群中有一个备用主机，或者有足够的可用空间来疏散整个主机以用作备用主机，则可以在每个主机的基础上使用存储的每个数据副本进行转换仅迁移一次。</p><p>首先，您需要有一个没有数据的空主机。有两种方法可以执行此操作：从尚未包含在群集中的新的空主机开始，或者从群集中现有主机上卸载数据。</p><h4 id="使用新的，空的主机"><a href="#使用新的，空的主机" class="headerlink" title="使用新的，空的主机"></a>使用新的，空的主机</h4><p>理想情况下，主机应具有与将要转换的其他主机大致相同的容量（尽管并不严格）。</p><pre><code class="hljs ini"><span class="hljs-attr">NEWHOST</span>=&lt;empty-host-name&gt;</code></pre><p>将主机添加到CRUSH层次结构，但不要将其附加到根目录：</p><pre><code class="hljs smali">ceph osd crush<span class="hljs-built_in"> add-bucket </span>$NEWHOST host</code></pre><p>确保已安装ceph软件包。</p><h4 id="使用现有的主机"><a href="#使用现有的主机" class="headerlink" title="使用现有的主机"></a>使用现有的主机</h4><p>如果要使用已经是群集一部分的现有主机，并且该主机上有足够的可用空间，以便可以迁移其所有数据，则可以执行以下操作：</p><pre><code class="hljs autoit">OLDHOST=&lt;existing-cluster-host-<span class="hljs-keyword">to</span>-offload&gt;ceph osd crush unlink $OLDHOST <span class="hljs-keyword">default</span></code></pre><p>其中“默认”是CRUSH地图中的直接祖先。（对于具有未修改配置的较小群集，通常将是“默认”，但也可能是机架名称。）现在，您应该在OSD树输出的顶部看到没有父节点的主机：</p><pre><code class="hljs lsl">$ bin/ceph osd treeID CLASS WEIGHT  TYPE NAME     STATUS REWEIGHT PRI-AFF<span class="hljs-number">-5</span>             <span class="hljs-number">0</span> host oldhost<span class="hljs-number">10</span>   ssd <span class="hljs-number">1.00000</span>     osd<span class="hljs-number">.10</span>        up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span><span class="hljs-number">11</span>   ssd <span class="hljs-number">1.00000</span>     osd<span class="hljs-number">.11</span>        up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span><span class="hljs-number">12</span>   ssd <span class="hljs-number">1.00000</span>     osd<span class="hljs-number">.12</span>        up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span><span class="hljs-number">-1</span>       <span class="hljs-number">3.00000</span> root <span class="hljs-section">default</span><span class="hljs-number">-2</span>       <span class="hljs-number">3.00000</span>     host foo <span class="hljs-number">0</span>   ssd <span class="hljs-number">1.00000</span>         osd<span class="hljs-number">.0</span>     up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span> <span class="hljs-number">1</span>   ssd <span class="hljs-number">1.00000</span>         osd<span class="hljs-number">.1</span>     up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span> <span class="hljs-number">2</span>   ssd <span class="hljs-number">1.00000</span>         osd<span class="hljs-number">.2</span>     up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span>...</code></pre><p>如果一切正常，请直接跳到下面的“等待数据迁移完成”步骤，然后从那里继续进行操作以清理旧的OSD。</p><h4 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h4><p>如果您使用的是新主机，请从步骤1开始。对于现有主机，请跳至下面的步骤5。</p><ol><li><p>为所有设备配置新的BlueStore OSD：</p><pre><code class="hljs awk">ceph-volume lvm create --bluestore --data <span class="hljs-regexp">/dev/</span><span class="hljs-variable">$DEVICE</span></code></pre></li><li><p>验证OSD通过以下方式加入集群：</p><pre><code class="hljs dos">ceph osd <span class="hljs-built_in">tree</span></code></pre><p>您应该看到新主机<code>$NEWHOST</code>与它下面的所有的OSD的，但主机应该<em>不</em>被嵌套任何其他节点下的层次结构（像）。例如，如果是空主机，则可能会看到以下内容：<code>root default``newhost</code></p><pre><code class="hljs lsl">$ bin/ceph osd treeID CLASS WEIGHT  TYPE NAME     STATUS REWEIGHT PRI-AFF<span class="hljs-number">-5</span>             <span class="hljs-number">0</span> host newhost<span class="hljs-number">10</span>   ssd <span class="hljs-number">1.00000</span>     osd<span class="hljs-number">.10</span>        up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span><span class="hljs-number">11</span>   ssd <span class="hljs-number">1.00000</span>     osd<span class="hljs-number">.11</span>        up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span><span class="hljs-number">12</span>   ssd <span class="hljs-number">1.00000</span>     osd<span class="hljs-number">.12</span>        up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span><span class="hljs-number">-1</span>       <span class="hljs-number">3.00000</span> root <span class="hljs-section">default</span><span class="hljs-number">-2</span>       <span class="hljs-number">3.00000</span>     host oldhost1 <span class="hljs-number">0</span>   ssd <span class="hljs-number">1.00000</span>         osd<span class="hljs-number">.0</span>     up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span> <span class="hljs-number">1</span>   ssd <span class="hljs-number">1.00000</span>         osd<span class="hljs-number">.1</span>     up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span> <span class="hljs-number">2</span>   ssd <span class="hljs-number">1.00000</span>         osd<span class="hljs-number">.2</span>     up  <span class="hljs-number">1.00000</span> <span class="hljs-number">1.00000</span>...</code></pre></li><li><p>确定要转换的第一个目标主机</p><pre><code class="hljs ini"><span class="hljs-attr">OLDHOST</span>=&lt;existing-cluster-host-to-convert&gt;</code></pre></li><li><p>将新主机交换到群集中旧主机的位置：</p><pre><code class="hljs nginx"><span class="hljs-attribute">ceph</span> osd crush swap-bucket <span class="hljs-variable">$NEWHOST</span> <span class="hljs-variable">$OLDHOST</span></code></pre><p>此时，所有数据<code>$OLDHOST</code>将开始迁移到上的OSD <code>$NEWHOST</code>。如果新旧主机的总容量不同，您可能还会看到一些数据迁移到集群中的其他节点或从集群的其他节点迁移，但是只要这些主机的大小相同，这将是相对少量的数据。</p></li><li><p>等待数据迁移完成：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span> ! ceph osd safe-<span class="hljs-keyword">to</span>-destroy <span class="hljs-constructor">$(<span class="hljs-params">ceph</span> <span class="hljs-params">osd</span> <span class="hljs-params">ls</span>-<span class="hljs-params">tree</span> $OLDHOST)</span>; <span class="hljs-keyword">do</span> sleep <span class="hljs-number">60</span> ; <span class="hljs-keyword">done</span></code></pre></li><li><p>停止所有空的旧OSD <code>$OLDHOST</code>：</p><pre><code class="hljs crystal">ssh $OLDHOSTsystemctl kill ceph-osd.targetumount /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-*</span></code></pre></li><li><p>销毁并清除旧的OSD：</p><pre><code class="hljs nginx">for osd in `ceph osd ls-tree $OLDHOST`; do    <span class="hljs-attribute">ceph</span> osd purge <span class="hljs-variable">$osd</span> --<span class="hljs-literal">yes</span>-i-really-mean-itdone</code></pre></li><li><p>擦拭旧的OSD设备。这要求您确定要手动擦除哪些设备（请小心！）。对于每个设备：</p><pre><code class="hljs dockerfile">ceph-<span class="hljs-keyword">volume</span><span class="bash"> lvm zap <span class="hljs-variable">$DEVICE</span></span></code></pre></li><li><p>将现在为空的主机用作新主机，然后重复：</p><pre><code class="hljs ini"><span class="hljs-attr">NEWHOST</span>=<span class="hljs-variable">$OLDHOST</span></code></pre></li></ol><p>优点：</p><ul><li>数据只能通过网络复制一次。</li><li>一次转换整个主机的OSD。</li><li>可以并行转换为一次转换多个主机。</li><li>每个主机上都不需要备用设备。</li></ul><p>缺点：</p><ul><li>需要备用主机。</li><li>整个主机的OSD值将同时迁移数据。这很可能会影响整个群集的性能。</li><li>所有迁移的数据仍然在网络上进行了一整跳。</li></ul><h3 id="每OSD设备副本"><a href="#每OSD设备副本" class="headerlink" title="每OSD设备副本"></a>每OSD设备副本</h3><p>可以使用的<code>copy</code>功能转换单个逻辑OSD <code>ceph-objectstore-tool</code>。这要求主机具有一个或多个空闲设备来供应新的空BlueStore OSD。例如，如果群集中的每个主机都有12个OSD，则需要第13个可用设备，以便可以依次转换每个OSD，然后再收回旧设备以转换下一个OSD。</p><p>注意事项：</p><ul><li>此策略要求准备一个空白的BlueStore OSD，而无需分配该<code>ceph-volume</code> 工具不支持的新OSD ID 。更重要的是，<em>dmcrypt</em>的设置与OSD身份紧密相关，这意味着该方法不适用于加密的OSD。</li><li>设备必须手动分区。</li><li>工具未实现！</li><li>没有记录！</li></ul><p>优点：</p><ul><li>在转换期间，很少或没有数据在网络上迁移。</li></ul><p>缺点：</p><ul><li>工具尚未完全实现。</li><li>流程未记录。</li><li>每个主机必须具有备用或空设备。</li><li>OSD在转换过程中处于脱机状态，这意味着新的写入操作将仅写入OSD的一部分。这会增加由于后续故障而导致数据丢失的风险。（但是，如果在转换完成之前出现故障，则可以启动原始FileStore OSD来提供对其原始数据的访问。）</li></ul>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>bluestore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ceph</tag>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「ML vol.1」kNN算法</title>
    <link href="/2020/12/23/%E3%80%8CML%20vol.3%E3%80%8D%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2020/12/23/%E3%80%8CML%20vol.3%E3%80%8D%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="「ML-vol-3」感知机"><a href="#「ML-vol-3」感知机" class="headerlink" title="「ML vol.3」感知机"></a>「ML vol.3」感知机</h1><p>感知机（Perceptron）假设数据是二分类的线性可分的数据，数据标签是 +1 和-1，寻找一个超平面将数据分离开来。</p><p>我们设这个超球面为$h(x_i)=(\vec{w}.\vec{x_i}+b)$，其中$b$是一个偏置，如果去掉则超平面经过原点。为了方便处理，我们可以把b放入权重向量$\vec{w}$中。因此$h(x_i)=sign(\vec{w} . \vec{x_i})$</p><p><img src="「ML vol.3」感知机/image-20201223161331800.png" alt="image-20201223161331800"></p><p>我们可以看到，当$y_i(\vec{w}^T\cdot\vec{x_i})\le 0$时对应错误分类的情况。</p><h2 id="感知机收敛性"><a href="#感知机收敛性" class="headerlink" title="感知机收敛性"></a>感知机收敛性</h2><p>假设对于数据集D，$\exist \vec{w_i} ,y_i(\vec{w}^T\cdot\vec{x_i})&gt; 0,\forall (\vec{x_i},y_i)\in D$.现在我们对每个数据点进行缩放，使得$||\vec{w}^*||=1$且  $||x_i||\le1,\forall \vec{x_i}\in D$.</p><p>我们记超平面为$\gamma$,那么$y = \mathop{\min}_{(x_i,y_i)\in D}|\vec{w}^*\cdot\vec{x_i}|$</p><p><img src="「ML vol.3」感知机/image-20201223162744770.png" alt="image-20201223162744770" style="zoom:67%;" /></p><p>如果我们把所有数据点放在单位圆内。我们可以断言：$\gamma$是超平面（蓝色线）距离最近的数据点的距离并且$\vec{w}^*$在单位圆内。并且有如下定理：满足上述条件的感知机算法最多需要$1/\gamma^2$步骤就可以结束。</p><p>证明：对于一次更新：$\vec{w}$更新为$\vec{w}+y\vec{x}$，我们考虑$\vec{w}\cdot\vec{w}^*$和$\vec{w}\cdot\vec{w}$。对于一次更新：</p><script type="math/tex; mode=display">(\vec{w}+y\vec{x})\vec{w}^* = \vec{w}\vec{w}^*+y\vec{x}\vec{w}^*\ge\vec{w}\vec{w}^*+\gamma</script><p>注意上述不等式满足是因为超平面距离$\vec{x}$距离至少是$\gamma$，即$y(\vec{x}\vec{w}^*)=|\vec{x}\cdot\vec{w}|\ge \gamma$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视频压缩算法设计</title>
    <link href="/2020/12/23/%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/12/23/%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="视频压缩算法设计"><a href="#视频压缩算法设计" class="headerlink" title="视频压缩算法设计"></a>视频压缩算法设计</h1><h2 id="一-课题背景："><a href="#一-课题背景：" class="headerlink" title="一. 课题背景："></a>一. 课题背景：</h2><p>本实验是设计并实现一种视频的压缩算法，包括颜色特征提取，图像分块，预测编码，统计编码等</p><h2 id="二-实验要求"><a href="#二-实验要求" class="headerlink" title="二. 实验要求"></a>二. 实验要求</h2><p>视频数据采用 “test.mp4” 视频，设计压缩和解压两个模块。</p><h2 id="三-实验评估"><a href="#三-实验评估" class="headerlink" title="三. 实验评估"></a>三. 实验评估</h2><p>本实验采用（编码后的视频和原始视频的）压缩比和（解码后的视频和原始视频的）信噪比来评价压缩效果</p><h2 id="四-视频压缩代码示例："><a href="#四-视频压缩代码示例：" class="headerlink" title="四. 视频压缩代码示例："></a>四. 视频压缩代码示例：</h2><pre><code class="hljs plain"></code></pre><hr><h2 id="S1-理论基础"><a href="#S1-理论基础" class="headerlink" title="$\S1$ 理论基础"></a>$\S1$ 理论基础</h2><p>研究发现，多媒体数据中存在大量的冗余数据，比如空间冗余，时间冗余以及结构冗余和知识冗余等等。</p><p>例如高清视频 1.5Gbps，4K视频 12Gbps，压缩为MPEG-2 后采样率分别为20Mbps和160Mbps，相当于压缩75倍，压缩到HEVC/265或者AVS2、VP9为5Mbps和40Mbps，相当于压缩300倍。如下面图表所示：</p><p><img src="视频压缩算法设计/image-20201221151830695.png" alt="image-20201221151830695" style="zoom: 67%;" /></p><p>按照信息是否有损可以分为无损压缩和有损压缩。而编码方法有三种：</p><ul><li>熵编码：不考虑数据源的无损压缩技术；</li><li>源编码：考虑数据源的无损压缩技术。</li><li>混合编码：组合熵编码与源编码。</li></ul><p>根据是否自适应又分为自适应编码和非自适应编码。</p><p><img src="视频压缩算法设计/image-20201221152527369.png" alt="image-20201221152527369" style="zoom:80%;" /></p><p>PCM：脉冲编码调制。</p><p>统计编码的理论基础是信息论，理论依据是<strong>变字长编码理论</strong>。</p><p>编码器的编码输出码字是字长不等的码字：</p><ul><li>按照编码输入信息符号出现的概率，给输出码字以不同的字长：<ul><li>大概率赋予小字长</li><li>小概率赋予大字长</li></ul></li></ul><p>信息熵$I_i=-\log p_i $，$p_i$表示第i个事件的概率。根据香农信息论，信源的熵定义为：$H(S)=\eta=\sum_i p_i\log(1/p_i) = \sum_i p_i I_i$</p><p>其中$H(S)$表示编码的最小长度，$p_i$是符号$s_i$在S中出现的概率，$I_i$表示包含在$s_i$中的信息量也就是编码所需的位数。</p><h3 id="香农-范诺-Shannon-Fano-编码"><a href="#香农-范诺-Shannon-Fano-编码" class="headerlink" title="香农-范诺(Shannon-Fano)编码"></a>香农-范诺(Shannon-Fano)编码</h3><ul><li><p>采用从上到下的方法进行编码</p></li><li><p>使用递归的方法分为两个部分，每个部分具有近似相等的概率</p></li></ul><p>下面举例子来分析，假设某灰度图像有40个像素，灰度等级为5，分别用A，B，C，D，E来表示：</p><p><img src="视频压缩算法设计/image-20201221162704365.png" alt="image-20201221162704365" style="zoom:80%;" /></p><p>构建范诺树</p><p><img src="视频压缩算法设计/image-20201221162822702.png" alt="image-20201221162822702" style="zoom:67%;" /></p><p><img src="视频压缩算法设计/image-20201221162836224.png" alt="image-20201221162836224" style="zoom:67%;" /></p><p><img src="视频压缩算法设计/image-20201221162847644.png" alt="image-20201221162847644" style="zoom:67%;" /></p><p><img src="视频压缩算法设计/image-20201221162857345.png" alt="image-20201221162857345" style="zoom:67%;" /></p><h3 id="哈夫曼Huffman编码"><a href="#哈夫曼Huffman编码" class="headerlink" title="哈夫曼Huffman编码"></a>哈夫曼Huffman编码</h3><p>迄今为止，这是最著名也是最高效的熵编码方法。</p><p>算法思想是按照概率的大小进行排序，对输出码分配不同码字长度的变字长编码方法；输出码字的平均长度最短，与信息熵值接近，编码方法最佳。</p><p>但是哈夫曼编码没有错误保护功能，同时想进行查询某个数据也很困难。</p><h3 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h3><p>这是JPEG图像用到的经典算法。消息用0到1之间的实数进行编码，依据两个基本参数：<strong>符号概率</strong>和<strong>编码间隔</strong>。</p><p><img src="视频压缩算法设计/image-20201221164145724.png" alt="image-20201221164145724" style="zoom:67%;" /></p><p>算术译码对错误敏感！</p><h3 id="行程编码（RLE）"><a href="#行程编码（RLE）" class="headerlink" title="行程编码（RLE）"></a>行程编码（RLE）</h3><p><img src="视频压缩算法设计/image-20201221164618685.png" alt="image-20201221164618685" style="zoom:50%;" /></p><h3 id="词典编码"><a href="#词典编码" class="headerlink" title="词典编码"></a>词典编码</h3><p>第一类词典编码：查找正在压缩的字符序列是否在以前输入的数据中出现过。</p><p>第二类词典法：用一个词典记录出现过的字符，编码数据过程中当遇到以前出现的“短语时”，编码器就输出这个词典    中短语的索引号。</p><h3 id="变换编码"><a href="#变换编码" class="headerlink" title="变换编码"></a>变换编码</h3><p>其理论核心是信号理论中的离散信号傅里叶变换。</p><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="- 傅里叶变换"></a>- 傅里叶变换</h3><p>具体可以参见 奥本海默《信号与系统》这里不细讲。</p><p>比较有用的是<strong>离散余弦-DCT变换</strong>，离散余弦变换具有很强的“能量集中特性”，i.e.：</p><ul><li>大部分自然信号的能量集中在离散余弦变换的低频部分；</li><li>高频部分描述信号的细节。</li></ul><p>离散余弦变换在数字图像压缩中可与最佳变换K-L变换媲美。因而应用广泛：JPEG、MPEG、H.26x。</p><p>二维的DCT公式是对每个单独的彩色图像分量，把整个分量图像空间分成一个8x8的图像块，并作为二维离散余弦变换DCT的输入；</p><p>变换公式为：</p><script type="math/tex; mode=display">F(u,v)=\frac{1}{4}C(u)C(v)(\sum\limits_{i=0}^{7}\sum\limits_{i=0}^{7}f(i,j)cos\frac{(2i+1)u\pi}{16}cos\frac{(2j+1)v\pi}{16})\\f(i,j)=\frac{1}{4}C(u)C(v)(\sum\limits_{u=0}^{7}\sum\limits_{v=0}^{7}F(u,v)cos\frac{(2i+1)u\pi}{16}cos\frac{(2j+1)v\pi}{16})\\where, C(u)=C(v)=\begin{cases}1/\sqrt{2},&if \ u,v = 0\\1, &otherwise\end{cases}</script><p><img src="视频压缩算法设计/image-20201222142033770.png" alt="image-20201222142033770" style="zoom:67%;" /></p><p>理论上最理想的变换应该使得信号在变换域中的样本相互统计独立。</p><h2 id="S2-图像编码标准JPEG"><a href="#S2-图像编码标准JPEG" class="headerlink" title="$\S2$ 图像编码标准JPEG"></a>$\S2$ 图像编码标准JPEG</h2><p>全称是Joint Photographic Experts Group, 是连续色调、多级灰度、静止图像的数字图像压缩编码标准。也是目前应用极为广泛的通用标准，其压缩方法主要有两种：</p><ul><li>以DCT为基础的有损压缩算法</li><li>以预测技术为基础的无损压缩算法</li></ul><p>它利用人的视觉特性使用量化和无损压缩来去掉视觉的冗余信息以及数据本身的冗余信息。</p><h3 id="编码步骤"><a href="#编码步骤" class="headerlink" title="编码步骤"></a>编码步骤</h3><p><img src="视频压缩算法设计/image-20201222142813006.png" alt="image-20201222142813006" style="zoom:67%;" /></p><ol><li>使用正向离散余弦函数（FDCT）把图像（8x8大小）从空间域变到频域；</li><li><p>使用加权函数对DCT系数$F(u,v)$进行量化（这个加权函数对于人的视觉特性是最佳的）；</p></li><li><p>Z字形编码，量化后的DCT系数需要重新编排，目的是为了增加连续“0”的个数，把8x8矩阵变成一个1x64矢量，频率低的系数放在矢量顶部；</p></li></ol><p><img src="视频压缩算法设计/image-20201222144019683.png" alt="image-20201222144019683" style="zoom:67%;" /></p><ol><li><p>使用差分脉冲编码调制（DPCM）对直流系数（DC）进行编码，DC系数有两个特点：一是系数的数值比较大，二是相邻图像块的数值变化不大，因而使用DPCM对相邻图像块DC系数的差值进行编码；</p></li><li><p>使用行程编码（RLE）对交流系数（AC）进行编码，因为量化后AC系数特点是1*63矢量中含有许多数字“0”，并且许多“0”是连续的；</p></li></ol><p>JPEG使用了一个字节的高四位来表示连续“0”的个数，而使用它的第四位来表示下个非“0”系数所需要的位数，跟在它后面的是量化AC系数的数值；</p><p><img src="视频压缩算法设计/image-20201222144557187.png" alt="image-20201222144557187" style="zoom: 50%;" /></p><ol><li>熵编码：使用哈夫曼编码器对量化系数进行编码；</li><li>组成位数据流（JPEG bitstream），把各种标记代码和编码后的图像数据组成一帧帧数据。</li></ol><p>译码和解压缩过程则刚好相反。其中量化处理是导致信息损失的根源。</p><hr><h2 id="图像相似度衡量"><a href="#图像相似度衡量" class="headerlink" title="图像相似度衡量"></a>图像相似度衡量</h2><blockquote><p>图像PSNR和SSIM</p><h2 id="PSNR-Peak-Signal-to-Noise-Ratio"><a href="#PSNR-Peak-Signal-to-Noise-Ratio" class="headerlink" title="PSNR (Peak Signal to Noise Ratio)"></a><strong>PSNR (Peak Signal to Noise Ratio)</strong></h2><p>峰值信噪比PSNR衡量图像失真或是噪声水平的客观标准。2个图像之间PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。定义为，</p><script type="math/tex; mode=display">PSNR=10log_{10}（\frac{MAX^{2}}{MSE}）</script><p>代码实现</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_psnr</span>(<span class="hljs-params">self, target, ref</span>):</span>    <span class="hljs-keyword">import</span>  math    <span class="hljs-comment"># 将图像格式转为float64</span>    target_data = np.array(target, dtype=np.float64)    ref_data = np.array(ref, dtype=np.float64)    <span class="hljs-comment"># 直接相减，求差值</span>    diff = ref_data - target_data    <span class="hljs-comment"># 按第三个通道顺序把三维矩阵拉平</span>    diff = diff.flatten(<span class="hljs-string">&#x27;C&#x27;</span>)    <span class="hljs-comment"># 计算MSE值</span>    rmse = math.sqrt(np.mean(diff ** <span class="hljs-number">2.</span>))    <span class="hljs-comment"># 精度</span>    eps = np.finfo(np.float64).eps    <span class="hljs-keyword">if</span> (rmse == <span class="hljs-number">0</span>):        rmse = eps    <span class="hljs-keyword">return</span> <span class="hljs-number">20</span> * math.log10(<span class="hljs-number">255.0</span> / rmse)</code></pre><h2 id="SSIM-Structural-SIMilarity-结构相似性"><a href="#SSIM-Structural-SIMilarity-结构相似性" class="headerlink" title="SSIM (Structural SIMilarity) 结构相似性"></a>SSIM (Structural SIMilarity) 结构相似性</h2><p>SSIM公式基于样本x和y之间的三个比较衡量：亮度 (luminance)、对比度 (contrast) 和结构 (structure)。</p><p><img src="https://www.zhihu.com/equation?tex=l%28x%2Cy%29+%3D+%5Cfrac%7B2%5Cmu_x+%5Cmu_y+%2B+c_1%7D%7B%5Cmu_x%5E2%2B+%5Cmu_y%5E2+%2B+c_1%7D" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=c%28x%2Cy%29+%3D+%5Cfrac%7B2%5Csigma_x+%5Csigma_y+%2B+c_2%7D%7B%5Csigma_x%5E2%2B+%5Csigma_y%5E2+%2B+c_2%7D" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=s%28x%2Cy%29+%3D+%5Cfrac%7B%5Csigma_%7Bxy%7D+%2B+c_3%7D%7B%5Csigma_x+%5Csigma_y+%2B+c_3%7D" alt="[公式]"></p><p>一般取<img src="https://www.zhihu.com/equation?tex=c_3+%3D+c_2+%2F+2" alt="[公式]">。</p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cmu_x" alt="[公式]">为<img src="https://www.zhihu.com/equation?tex=x" alt="[公式]">的均值</li><li><img src="https://www.zhihu.com/equation?tex=%5Cmu_y" alt="[公式]">为<img src="https://www.zhihu.com/equation?tex=y" alt="[公式]">的均值</li><li><img src="https://www.zhihu.com/equation?tex=%5Csigma_x%5E2" alt="[公式]">为<img src="https://www.zhihu.com/equation?tex=x" alt="[公式]">的方差</li><li><img src="https://www.zhihu.com/equation?tex=%5Csigma_y%5E2" alt="[公式]">为<img src="https://www.zhihu.com/equation?tex=y" alt="[公式]">的方差</li><li><img src="https://www.zhihu.com/equation?tex=%5Csigma_%7Bxy%7D" alt="[公式]">为<img src="https://www.zhihu.com/equation?tex=x" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=y" alt="[公式]">的协方差</li><li><img src="https://www.zhihu.com/equation?tex=c_1+%3D+%28k_1L%29%5E2%2C+c_2+%3D+%28k_2L%29%5E2" alt="[公式]">为两个常数，避免除零</li><li><img src="https://www.zhihu.com/equation?tex=L" alt="[公式]">为像素值的范围，<img src="https://www.zhihu.com/equation?tex=2%5EB-1" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=k_1%3D0.01%2C+k_2%3D0.03" alt="[公式]">为默认值</li></ul><p>那么</p><p><img src="https://www.zhihu.com/equation?tex=SSIM%28x%2C+y%29+%3D+%5Bl%28x%2Cy%29%5E%7B%5Calpha%7D+%5Ccdot+c%28x%2Cy%29%5E%7B%5Cbeta%7D+%5Ccdot+s%28x%2Cy%29%5E%7B%5Cgamma%7D%5D" alt="[公式]"></p><p>将<img src="https://www.zhihu.com/equation?tex=%5Calpha%2C%5Cbeta%2C%5Cgamma" alt="[公式]">设为 1，可以得到</p><p><img src="https://www.zhihu.com/equation?tex=SSIM%28x%2C+y%29+%3D+%5Cfrac%7B%282%5Cmu_x+%5Cmu_y+%2B+c_1%29%282%5Csigma_%7Bxy%7D%2Bc_2%29%7D%7B%28%5Cmu_x%5E2%2B+%5Cmu_y%5E2+%2B+c_1%29%28%5Csigma_x%5E2%2B%5Csigma_y%5E2%2Bc_2%29%7D" alt="[公式]"></p><p>每次计算的时候都从图片上取一个<img src="https://www.zhihu.com/equation?tex=N%C3%97N" alt="[公式]">的窗口，然后不断滑动窗口进行计算，最后取平均值作为全局的 SSIM。</p><pre><code class="hljs python"><span class="hljs-comment"># im1 和 im2 都为灰度图像，uint8 类型</span>ssim = skimage.measure.compare_ssim(im1, im2, data_range=<span class="hljs-number">255</span>)</code></pre></blockquote><h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p><a href="https://www.impulseadventure.com/photo/jpeg-quantization.html">https://www.impulseadventure.com/photo/jpeg-quantization.html</a></p><p><img src="https://www.impulseadventure.com/photo/images/quant_matrix.gif" alt="img"></p><p>所谓量化就是将DCT变换的临时结果，除以各自量化步长并四舍五入后得到结果，得到量化系数。</p><p>因为经过DCT后，数据就不同了，左上方都是大数值，右下方都是小数值。比如左上方都是几十几百的，右下方附近，都是个位数，那么，大数值和小数值就可以分别量化。</p><p>在术语里，左上方称为<strong>低频数据</strong>，右下方称为<strong>高频数据</strong>。 </p><p>JPEG系统分别规定了亮度分量和色度分量的量化表，色度分量相应的量化步长比亮度分量大。</p><p><strong>对量化系数的处理和组织</strong><br>思想：JPEG采用定长和变长相结合的编码方法。<br><strong>直流系数：</strong>通常相邻8*8图象块的DC分量很接近，因此JPEG对量化后的直流分量采用无失真DPCM编码。通常JPEG要保存所需比特数和实际差值。</p><p><strong>交流系数：</strong>经过量化后，AC分量出现较多的0。JPEG采用对0系数的行程长度编码。而对非0值，则要保存所需数和实际值。<br>ZIG-ZAG排序：为使连续的0个数增多，采用Z形编码。 </p><h2 id="交流直流编码"><a href="#交流直流编码" class="headerlink" title="交流直流编码"></a>交流直流编码</h2><p>JPEG 压缩的最后一步是对量化后的系数进行熵编码。这一步采用通用的无损数据压缩技术，对图像质量没有影响。在熵编码前，对63个交流系数先采用ZigZag排序，转变为一维向量。这样做的目的是为了将低频系数放在前面，高频系数放在后面，因为高频系数中有很多 0，为了 节约空间，所以交流系数的“中间符号”用零行程码 (Zero Run Length) 表示。</p><p>然后再对直流系数和行程编码之后的交流系数进行huffman编码。Huffman编码是一种变长编码，符号出现的频率越高，码字越短。其实现的细节不是本文的重点，可以参考这里<a href="https://blog.csdn.net/FX677588/article/details/70767446">Huffman编码详细解释</a></p><hr><h2 id="S3-视频编码标准-H-26X和MPEG"><a href="#S3-视频编码标准-H-26X和MPEG" class="headerlink" title="$\S3$ 视频编码标准 H.26X和MPEG"></a>$\S3$ 视频编码标准 H.26X和MPEG</h2><h3 id="标准介绍"><a href="#标准介绍" class="headerlink" title="标准介绍"></a>标准介绍</h3><p>H.26X主要应用于实时视频通信系统；MPEG主要应用于数字监控、视频存储、广播电视等领域；</p><p><img src="视频压缩算法设计/image-20201222145146342.png" alt="image-20201222145146342" style="zoom: 50%;" /></p><p><img src="视频压缩算法设计/image-20201222145238108.png" alt="image-20201222145238108"></p><p><img src="视频压缩算法设计/image-20201222145340229.png" alt="image-20201222145340229"></p><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><h2 id="S3-1-MPEG"><a href="#S3-1-MPEG" class="headerlink" title="$\S3.1$ MPEG"></a>$\S3.1$ MPEG</h2><p>在空间上采用MPEG压缩算法来去掉冗余的信息；</p><p>在时间的方向上采用运动补偿（Motion Compensation）算法来去掉冗余信息；</p><p>为了在保证图像质量基本不降低而又能获得高的压缩比，MPEG专家组定义了三种图像：</p><ul><li>帧内图（Intra pictures，I）</li><li>预测图（Predicted pictures，P）</li><li>插补图，即双向预测图（Bidirectional Prediction，B）</li></ul><p>帧间预测编码时要用到先前的图，当前的预测图作为后面预测图的参考值。双向预测图压缩效果显著，需要先前和后续的信息，双向预测图不能作为其它图的预测参考图。</p><p>三种参考图在时间上排序为：</p><pre><code class="hljs armasm">I <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> I <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> B</code></pre><p>三者之间存在明显的因果关系：如第四帧的P图是由第一帧的I图的预测，第一帧I图和第四帧P图共同预测出它们之间的双向预测B图。</p><p>因此接收端解码器输入不能按照时间的顺序，而应按照</p><pre><code class="hljs armasm">I P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> P <span class="hljs-keyword">B</span> <span class="hljs-keyword">B</span> I <span class="hljs-keyword">B</span> B...</code></pre><h3 id="I图编码"><a href="#I图编码" class="headerlink" title="I图编码"></a>I图编码</h3><p><img src="视频压缩算法设计/image-20201222150632046.png" alt="image-20201222150632046" style="zoom:67%;" /></p><blockquote><p>补充：</p><p>YCbCr或Y’CbCr有的时候会被写作：YCBCR或是Y’CBCR，是<a href="https://baike.baidu.com/item/色彩空间/4615427">色彩空间</a>的一种，通常会用于影片中的影像连续处理，或是数字摄影系统中。Y’为颜色的亮度(luma)成分、而CB和CR则为蓝色和红色的浓度偏移量成份。Y’和Y是不同的，而Y就是所谓的亮度(<a href="https://baike.baidu.com/item/luminance/8678317">luminance</a>)，表示光的浓度且为非线性，使用伽马修正(gamma correction)编码处理。</p><p>YUV：“Y”表示明亮度（Luminance或Luma），也就是灰阶值，“U”和“V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。Y’UV, YUV, <a href="https://baike.baidu.com/item/YCbCr">YCbCr</a>，<a href="https://baike.baidu.com/item/YPbPr">YPbPr</a>等专有名词都可以称为YUV。</p></blockquote><h3 id="P图编码"><a href="#P图编码" class="headerlink" title="P图编码"></a>P图编码</h3><p>预测图像的编码也是以图像宏块（macro block）为基本单元。一般取16x16. 预测图像编码宏块称为MPI，而参考图像中参考宏块称为MRJ。</p><p>预测图像P用两种类型的参数来表示：</p><ul><li>一种是当前要编码的图像宏块和参考图像宏块的差值；</li><li>宏块的运动矢量；</li></ul><p>对运动图像的编码其实就是寻找最佳的匹配图像宏块，找到最佳宏块之后就找到了最佳运动矢量d(dx,dy).</p><p><img src="视频压缩算法设计/image-20201222151154068.png" alt="image-20201222151154068"></p><p><img src="视频压缩算法设计/image-20201222151547886.png" alt="image-20201222151547886" style="zoom:67%;" /></p><p>那么我们如何求解运动矢量呢？</p><p>要使预测图像更精确，就要找到与MRJ最佳匹配的MPI。这通常以绝对值AE（Absolute difference）最小作为匹配依据：</p><script type="math/tex; mode=display">AE=\sum\limits_{i=0}^{15}\sum\limits_{j=0}^{15}|f(i,j)-g(i-d_x,j-d_y)|</script><p>其中$d_x,d_y$分别是MRJ上的移动矢量d(dx,dy)在x，y方向的矢量。</p><p><img src="视频压缩算法设计/image-20201222152643104.png" alt="image-20201222152643104"></p><p>MPEG允许选择I图像的频率和位置</p><ul><li>I图像频率指每秒出现I图像的次数（一般为2）；</li><li>位置指时间方向上I帧所在的位置；</li></ul><p>MPEG编码允许在一对I图像或者P图像之间选择B图像的数目。对于快速运动图像，B帧数目少一些，对于快速运动的图像，B帧数目多一些。</p><h2 id="预测编码"><a href="#预测编码" class="headerlink" title="预测编码"></a>预测编码</h2><p>In video compression “<strong>prediction</strong>“ of a block means finding the most“<strong>similar</strong>” block to the current one among the surrounding blocks.</p><p>在视频压缩技术中，“预测”一词指的是在当前像素块周围的一些像素块中找出（或者用一定的方法构造一个）与当前块最“接近”的像素块。</p><p>预测编码可以用于处理视频中的时间和空间域的冗余。视频处理中的预测编码主要分为两大类：帧内预测和帧间预测。</p><p>帧内预测：预测值与实际值位于同一帧内，用于消除图像的空间冗余；帧内预测的特点是压缩率相对较低，然而可以独立解码，不依赖其他帧的数据；通常视频中的关键帧都采用帧内预测。<br>帧间预测：帧间预测的实际值位于当前帧，预测值位于参考帧，用于消除图像的时间冗余；帧间预测的压缩率高于帧内预测，然而不能独立解码，必须在获取参考帧数据之后才能重建当前帧。</p><p>通常在视频码流中，I帧全部使用<strong>帧内</strong>编码，P帧/B帧中的数据可能使用<strong>帧内或者帧间</strong>编码。</p><p>运动估计（Motion Estimation）和运动补偿（Motion Compensation）是消除图像序列时间方向相关性的有效手段。上文介绍的DCT变换、量化、熵编码的方法是在一帧图像的基础上进行，通过这些方法可以消除图像内部各像素间在空间上的相关性。实际上图像信号除了空间上的相关性之外，还有时间上的相关性。例如对于像新闻联播这种背景静止，画面主体运动较小的数字视频，每一幅画面之间的区别很小，画面之间的相关性很大。对于这种情况我们没有必要对每一帧图像单独进行编码，而是可以只对相邻视频帧中变化的部分进行编码，从而进一步减小数据量，这方面的工作是由运动估计和运动补偿来实现的。</p><p><strong>运动估计</strong>技术一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，例如一帧图像的大小为1280<em>720，首先将其以网格状的形式分成40</em>45个尺寸为16<em>16的彼此没有重叠的图像块，然后在前一图像或者后一个图像某个搜索窗口的范围内为每一个图像块寻找一个与之最为相似的图像块。这个搜寻的过程叫做运动估计。通过计算最相似的图像块与该图像块之间的位置信息，可以得到一个<strong>运动矢量</strong>。这样在编码过程中就可以将当前图像中的块与参考图像运动矢量所指向的最相似的图像块相减，得到一个<strong>残差图像块</strong>，由于残差图像块中的每个像素值很小，所以在压缩编码中可以获得更高的压缩比。这个相减过程叫<em>*运动补偿</em></em>。</p><p>由于编码过程中需要使用参考图像来进行运动估计和运动补偿，因此参考图像的选择显得很重要。一般情况下编码器的将输入的每一帧图像根据其参考图像的不同分成3种不同的类型：I（Intra）帧、B（Bidirection prediction）帧、P（Prediction）帧。如图所示。</p><p><img src="https://pic2.zhimg.com/80/v2-765f92a473a8241b057b7128b0b3e18d_720w.jpg" alt="img"></p><p>如图所示，I帧只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。显然，由于I帧没有消除时间方向的相关性，所以压缩比相对不高。P帧在编码过程中使用一个前面的I帧或P帧作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码。B帧的编码方式与P帧相似，惟一不同的地方是在编码过程中它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。由此可见，每一个P帧的编码需要利用一帧图像作为参考图像，而B帧则需要两帧图像作为参考。相比之下，B帧比P帧拥有更高的压缩比。</p><h3 id="音频压缩"><a href="#音频压缩" class="headerlink" title="音频压缩"></a>音频压缩</h3><p>MPEG利用人的听觉特性来达到压缩声音数据的目的；这种压缩编码称为<strong>感知声音编码</strong>（Perceptual Coding）。</p><p>这种“听觉特性”表现在三个方面：<strong>响度，音调和掩蔽效应</strong>。</p><p>对于音调，人耳的听觉范围20-20000Hz。主观听觉单位Mel = 1000log(1+f).所谓的掩蔽效应指一种频率的声音阻碍另一种频率声音被听到的现象。</p><p><img src="视频压缩算法设计/image-20201222153455563.png" alt="image-20201222153455563"></p><p><img src="视频压缩算法设计/image-20201222153710385.png" alt="image-20201222153710385" style="zoom: 67%;" /></p><p>MPEG采用两种类型的感知编码：</p><ul><li>感知子带编码</li></ul><p><img src="视频压缩算法设计/image-20201222153929601.png" alt="image-20201222153929601" style="zoom:67%;" /></p><ul><li><p>Dolby AC-3编码</p><p><img src="视频压缩算法设计/image-20201222154011808.png" alt="image-20201222154011808" style="zoom:67%;" /></p></li></ul><hr><h1 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h1><h2 id="I帧的JPEG编码"><a href="#I帧的JPEG编码" class="headerlink" title="I帧的JPEG编码"></a>I帧的JPEG编码</h2><p>首先，我们将BGR图像转换为YCbCr图像。</p><p>原始图像：</p><p><img src="视频压缩算法设计/rgb_in.jpg" alt="rgb_in"></p><p>Y通道图</p><p><img src="视频压缩算法设计/Y.jpg" alt="Y"></p><p>Cb通道图</p><p><img src="视频压缩算法设计/V.jpg" alt="V"></p><p>Cr通道图</p><p><img src="视频压缩算法设计/U.jpg" alt="U"></p><h2 id="DCT"><a href="#DCT" class="headerlink" title="DCT"></a>DCT</h2><p>需要先将图片格式从<code>CV_8UC3</code>转换为<code>CV_64FC3</code>。这里8C表示像素数据类型unit8，C3表示三个通道。发现三个通道图像基本上是黑色，初始怀疑自己是否犯了技术性错误，后来尝试重构图像，还是能得到原图，说明没有错误，DCT得到本来就是稀疏矩阵。</p><p>重建的Y图</p><p><img src="视频压缩算法设计/Recoverd_Y_image.jpg" alt="Recoverd_Y_image"></p><p>重建Cb图</p><p><img src="视频压缩算法设计/Recoverd_V_image.jpg" alt="Recoverd_V_image"></p><p>重建的Cr图</p><p><img src="视频压缩算法设计/Recoverd_U_image.jpg" alt="Recoverd_U_image"></p><p>最终合成的BGR</p><p><img src="视频压缩算法设计/Recovered_DstImage-1609051779633.jpg" alt="Recovered_DstImage"></p><p>可以看到明显有失真。</p><p>我们在通道压缩时定义了一个阈值T，低于此阈值的像素会被设为0.我们将其从40改为10，发现图像质量明显改善。</p><p><img src="视频压缩算法设计/Recovered_DstImage-1609053088968.jpg" alt="Recovered_DstImage"></p><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据压缩</tag>
      
      <tag>多媒体技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「参考」Ceph配置参数conf</title>
    <link href="/2020/12/15/Ceph%20%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <url>/2020/12/15/Ceph%20%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Ceph-配置参数"><a href="#Ceph-配置参数" class="headerlink" title="Ceph 配置参数"></a>Ceph 配置参数</h1><blockquote><p>涉及pool, PG, CRUSH的配置参数。</p><p>参考<a href="https://docs.ceph.com/en/latest/rados/configuration/pool-pg-config-ref/">官方文档</a></p></blockquote><p>一个典型的Ceph配置文件如下：</p><pre><code class="hljs routeros">[global]# By default, Ceph makes 3 replicas of objects. <span class="hljs-keyword">If</span> you want <span class="hljs-keyword">to</span> make four# copies of an object the<span class="hljs-built_in"> default </span>value--a primary copy <span class="hljs-keyword">and</span> three replica# copies--reset the<span class="hljs-built_in"> default </span>values as shown <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;osd pool default size&#x27;</span>.# <span class="hljs-keyword">If</span> you want <span class="hljs-keyword">to</span> allow Ceph <span class="hljs-keyword">to</span> write a lesser number of copies <span class="hljs-keyword">in</span> a degraded# state, <span class="hljs-builtin-name">set</span> <span class="hljs-string">&#x27;osd pool default min size&#x27;</span> <span class="hljs-keyword">to</span> a number less than the# <span class="hljs-string">&#x27;osd pool default size&#x27;</span> value.osd<span class="hljs-built_in"> pool default </span>size = 3  # Write an object 3 times.osd<span class="hljs-built_in"> pool default </span>min size = 2 # Allow writing two copies <span class="hljs-keyword">in</span> a degraded state.# Ensure you have a realistic number of placement groups. We recommend# approximately 100 per OSD. E.g., total number of OSDs multiplied by 100# divided by the number of replicas (i.e., osd<span class="hljs-built_in"> pool default </span>size). So <span class="hljs-keyword">for</span># 10 OSDs <span class="hljs-keyword">and</span> osd<span class="hljs-built_in"> pool default </span>size = 4, we<span class="hljs-string">&#x27;d recommend approximately</span><span class="hljs-string"># (100 * 10) / 4 = 250.</span><span class="hljs-string">        # always use the nearest power of 2</span><span class="hljs-string"></span><span class="hljs-string">osd pool default pg num = 256</span><span class="hljs-string">osd pool default pgp num = 256</span></code></pre><div class="note note-primary">            <p>笔者注：</p><p>关于PG和PGP：</p><ul><li><p>PG =放置组( Placement Group)<br>PGP =用于放置的放置组(Placement Group for Placement purpose)</p><p>pg_num = 映射到OSD的PG的数量，它必须是2的幂次。</p><p>当对任何一个池增加pg_num时，该池的每个PG都会分裂成一半，但它们都将始终映射到其父OSD。</p><p>在此之前，Ceph不会开始重新平衡。 现在，当您为同一池增加pgp_num值时，PG开始从父级迁移到其他OSD，并且群集重新平衡开始。 这就是PGP扮演重要角色的方式。</p></li></ul>          </div><hr><blockquote><p>标记为※的是笔者认为比较重要的或者需要重点理解的配置项。供参考。</p></blockquote><h2 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h2><h3 id="※mon-max-pool-pg-num"><a href="#※mon-max-pool-pg-num" class="headerlink" title="※mon max pool pg num"></a>※mon max pool pg num</h3><ul><li><p>描述</p><p>每个池的最大放置组数。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>65536</code></p></li></ul><h3 id="※mon-pg-create-interval"><a href="#※mon-pg-create-interval" class="headerlink" title="※mon pg create interval"></a>※mon pg create interval</h3><ul><li><p>描述</p><p>在同一Ceph OSD守护进程中创建PG之间的秒数。[interval含义参考PG那篇博文]</p></li><li><p>类型</p><p>浮动</p></li><li><p>默认</p><p><code>30.0</code></p></li></ul><h3 id="mon-pg-stuck-threshold"><a href="#mon-pg-stuck-threshold" class="headerlink" title="mon pg stuck threshold"></a>mon pg stuck threshold</h3><ul><li><p>描述</p><p>PG被认为阻塞的秒数。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>300</code></p></li></ul><h3 id="mon-pg-min-inactive"><a href="#mon-pg-min-inactive" class="headerlink" title="mon pg min inactive"></a>mon pg min inactive</h3><ul><li><p>描述</p><p>如果PG保持不活动状态的时间<code>mon_pg_stuck_threshold</code>超过此设置的时间，将在群集日志中发出一个<code>HEALTH_ERR</code>信号。非正数表示禁用。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>1</code></p></li></ul><h3 id="mon-pg-warn-min-per-osd"><a href="#mon-pg-warn-min-per-osd" class="headerlink" title="mon pg warn min per osd"></a>mon pg warn min per osd</h3><ul><li><p>描述</p><p>如果每个OSD中的PG的平均数量低于此数量，则在群集日志中发出 <code>HEALTH_WARN</code>。（非正数禁用此功能）</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>30</code></p></li></ul><h3 id="mon-pg-warn-min-objects"><a href="#mon-pg-warn-min-objects" class="headerlink" title="mon pg warn min objects"></a>mon pg warn min objects</h3><ul><li><p>描述</p><p>如果群集中的对象总数低于此数目，则不发出警告</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>1000</code></p></li></ul><h3 id="mon-pg-warn-min-pool-objects"><a href="#mon-pg-warn-min-pool-objects" class="headerlink" title="mon pg warn min pool objects"></a>mon pg warn min pool objects</h3><ul><li><p>描述</p><p>对象号低于此数字的池不发出警告</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>1000</code></p></li></ul><h3 id="mon-pg-check-down-all-threshold"><a href="#mon-pg-check-down-all-threshold" class="headerlink" title="mon pg check down all threshold"></a>mon pg check down all threshold</h3><ul><li><p>描述</p><p>降低OSD百分比的阈值之后，我们将检查所有PG的陈旧状态。</p></li><li><p>类型</p><p>浮动</p></li><li><p>默认</p><p><code>0.5</code></p></li></ul><h3 id="mon-pg-warn-max-object-skew"><a href="#mon-pg-warn-max-object-skew" class="headerlink" title="mon pg warn max object skew"></a>mon pg warn max object skew</h3><ul><li><p>描述</p><p>如果某个特定池的平均对象数大于整个池的平均对象数，在群集日志中发出<code>HEALTH_WARN</code> 。（零或非正数将禁用此功能）。请注意，此选项适用于管理者。<code>mon pg warn max object skew</code></p></li><li><p>类型</p><p>浮动</p></li><li><p>默认</p><p><code>10</code></p></li></ul><h3 id="mon-delta-reset-interval"><a href="#mon-delta-reset-interval" class="headerlink" title="mon delta reset interval"></a>mon delta reset interval</h3><ul><li><p>描述</p><p>在将pg delta重置为0之前，处于非活动状态的秒数。我们跟踪每个池的已用空间的delta，因此，例如，对于我们来说，更容易理解恢复的进度或缓存层的性能。但是，如果没有报告某个池的活动，我们只需重置该池的增量历史记录即可。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>10</code></p></li></ul><h3 id="mon-osd-max-op-age"><a href="#mon-osd-max-op-age" class="headerlink" title="mon osd max op age"></a>mon osd max op age</h3><ul><li><p>描述</p><p>关注之前的最大操作年龄（使其为2的幂）。如果请求被阻止的时间超过此限制，则将发出<code>HEALTH_WARN</code>。</p></li><li><p>类型</p><p>浮动</p></li><li><p>默认</p><p><code>32.0</code></p></li></ul><h2 id="OSD"><a href="#OSD" class="headerlink" title="OSD"></a>OSD</h2><h3 id="osd-pg-bits"><a href="#osd-pg-bits" class="headerlink" title="osd pg bits"></a>osd pg bits</h3><ul><li><p>描述</p><p>每个Ceph OSD守护程序的放置组位数。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>6</code></p></li></ul><h3 id="osd-pgp-bits"><a href="#osd-pgp-bits" class="headerlink" title="osd pgp bits"></a>osd pgp bits</h3><ul><li><p>描述</p><p>PGP的每个Ceph OSD守护程序的位数。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>6</code></p></li></ul><h3 id="※osd-crush-chooseleaf-type"><a href="#※osd-crush-chooseleaf-type" class="headerlink" title="※osd crush chooseleaf type"></a>※osd crush chooseleaf type</h3><ul><li><p>描述</p><p><code>chooseleaf</code>在CRUSH规则中使用的存储桶类型。使用顺序等级而不是名称。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>1</code>。通常，一台主机包含一个或多个Ceph OSD守护程序。</p></li></ul><h3 id="※osd-crush-initial-weight"><a href="#※osd-crush-initial-weight" class="headerlink" title="※osd crush initial weight"></a>※osd crush initial weight</h3><ul><li><p>描述</p><p>将新添加的osds的初始权重添加到crushmap中。【参考crush那篇文章】</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>the size of newly added osd in TB</code>。默认情况下，新添加的osd的初始压缩重量设置为以TB为单位的卷大小。有关详细信息，请参见对<a href="https://docs.ceph.com/en/latest/rados/operations/crush-map#weightingbucketitems">存储桶项目</a>进行<a href="https://docs.ceph.com/en/latest/rados/operations/crush-map#weightingbucketitems">加权</a>。</p></li></ul><h3 id="※osd-pool-default-crush-rule"><a href="#※osd-pool-default-crush-rule" class="headerlink" title="※osd pool default crush rule"></a>※osd pool default crush rule</h3><ul><li><p>描述</p><p>创建复制池时要使用的默认CRUSH规则。</p></li><li><p>类型</p><p>8位整数</p></li><li><p>默认</p><p><code>-1</code>，这意味着“<strong>选择数字ID最低的规则并使用它</strong>”。这是为了在没有规则0的情况下创建池。</p></li></ul><h3 id="※osd-pool-erasure-code-stripe-unit"><a href="#※osd-pool-erasure-code-stripe-unit" class="headerlink" title="※osd pool erasure code stripe unit"></a>※osd pool erasure code stripe unit</h3><ul><li><p>描述</p><p>设置用于纠删码池的对象条带块的默认大小（以字节为单位）。每个大小为S的对象将存储为N条，每个数据块接收字节。每个字节的条带<code>N*strip_unit</code>将分别进行编码/解码。可以通过纠删码配置文件中的设置<code>strip_unit</code>来覆盖此选项 。</p></li><li><p>类型</p><p>无符号32位整数</p></li><li><p>默认</p><p><code>4096</code></p></li></ul><h3 id="※osd-pool-default-size"><a href="#※osd-pool-default-size" class="headerlink" title="※osd pool default size"></a>※osd pool default size</h3><ul><li><p>描述</p><p>设置池中对象的副本数。预设值与相同 。<code>ceph osd pool set &#123;pool-name&#125; size &#123;size&#125;</code></p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>3</code></p></li></ul><h3 id="※osd-pool-default-min-size"><a href="#※osd-pool-default-min-size" class="headerlink" title="※osd pool default min size"></a>※osd pool default min size</h3><ul><li><p>描述</p><p>设置池中对象的最小写入副本数，以确认对客户端的写入操作。如果未达到最小值，则Ceph将不会确认对客户端的写入，<strong>这可能会导致数据丢失</strong>。在<code>degraded</code>模式下运行时，此设置可确保最少数量的副本。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>0</code>，表示没有特别的下限。如果<code>0</code>，最小值为。<code>size - (size / 2)</code></p></li></ul><h3 id="※osd-pool-default-pg-num"><a href="#※osd-pool-default-pg-num" class="headerlink" title="※osd pool default pg num"></a>※osd pool default pg num</h3><ul><li><p>描述</p><p>池的默认放置组数。默认值是一样<code>pg_num</code>用<code>mkpool</code>。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>32</code></p></li></ul><h3 id="osd-pool-default-pgp-num"><a href="#osd-pool-default-pgp-num" class="headerlink" title="osd pool default pgp num"></a>osd pool default pgp num</h3><ul><li><p>描述</p><p>池放置的默认放置组数。默认值是一样<code>pgp_num</code>用<code>mkpool</code>。PG和PGP应该相等（目前）。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>8</code></p></li></ul><h3 id="osd-pool-default-flags"><a href="#osd-pool-default-flags" class="headerlink" title="osd pool default flags"></a>osd pool default flags</h3><ul><li><p>描述</p><p>新池的默认标志。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>0</code></p></li></ul><h3 id="osd-max-pgls"><a href="#osd-max-pgls" class="headerlink" title="osd max pgls"></a>osd max pgls</h3><ul><li><p>描述</p><p>要列出的展示位置组的最大数量。请求大量请求的客户端可以占用Ceph OSD守护程序。</p></li><li><p>类型</p><p>无符号64位整数</p></li><li><p>默认</p><p><code>1024</code></p></li><li><p>注意</p><p>默认应该没问题。</p></li></ul><h3 id="osd-min-pg-log-entries"><a href="#osd-min-pg-log-entries" class="headerlink" title="osd min pg log entries"></a>osd min pg log entries</h3><ul><li><p>描述</p><p>修剪日志文件时要保留的最小放置组日志数。</p></li><li><p>类型</p><p>32位Int Unsigned</p></li><li><p>默认</p><p><code>250</code></p></li></ul><h3 id="osd-max-pg-log-entries"><a href="#osd-max-pg-log-entries" class="headerlink" title="osd max pg log entries"></a>osd max pg log entries</h3><ul><li><p>描述</p><p>修剪日志文件时要保留的放置组日志的最大数量。</p></li><li><p>类型</p><p>32位Int Unsigned</p></li><li><p>默认</p><p><code>10000</code></p></li></ul><h3 id="osd-default-data-pool-replay-window"><a href="#osd-default-data-pool-replay-window" class="headerlink" title="osd default data pool replay window"></a>osd default data pool replay window</h3><ul><li><p>描述</p><p>OSD等待客户端重播请求的时间（以秒为单位）。</p></li><li><p>类型</p><p>32位整数</p></li><li><p>默认</p><p><code>45</code></p></li></ul><h3 id="osd-max-pg-per-osd-hard-ratio"><a href="#osd-max-pg-per-osd-hard-ratio" class="headerlink" title="osd max pg per osd hard ratio"></a>osd max pg per osd hard ratio</h3><ul><li><p>描述</p><p>在OSD拒绝创建新PG之前，集群允许的每个OSD PG数量的比率。如果OSD服务的PG数量超过<code>osd max pg per osd hard ratio*mon max pg per osd</code>，则OSD停止创建新的PG 。</p></li><li><p>类型</p><p>浮动</p></li><li><p>默认</p><p><code>2</code></p></li></ul><h3 id="※osd-recovery-priority"><a href="#※osd-recovery-priority" class="headerlink" title="※osd recovery priority"></a>※osd recovery priority</h3><ul><li><p>描述</p><p>工作队列中恢复的优先级。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>5</code></p></li></ul><h3 id="※osd-recovery-op-priority"><a href="#※osd-recovery-op-priority" class="headerlink" title="※osd recovery op priority"></a>※osd recovery op priority</h3><ul><li><p>描述</p><p>如果不覆盖池，则用于恢复操作的默认优先级。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>3</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>PG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ceph字典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「核心」Ceph学习三部曲之三:迁移之美——PG读写流程与状态迁移详解</title>
    <link href="/2020/12/15/%E8%BF%81%E7%A7%BB%E4%B9%8B%E7%BE%8EPG%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/12/15/%E8%BF%81%E7%A7%BB%E4%B9%8B%E7%BE%8EPG%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="迁移之美——PG读写流程与状态迁移详解"><a href="#迁移之美——PG读写流程与状态迁移详解" class="headerlink" title="迁移之美——PG读写流程与状态迁移详解"></a>迁移之美——PG读写流程与状态迁移详解</h1><div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！由于篇幅较大，建议先看看完理论部分的术语再看官方实践部分，最后到理论部分搜索关键字进行理解。</p><p>参考《Ceph设计与实现》谢型果等，第四章。以及<a href="https://docs.ceph.com/en/latest/rados/operations/placement-groups/">官方PG教程</a>。</p>          </div><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h1><p>PG是Ceph最难理解的部分之一，但是它也是Ceph最精妙有意思的部分。</p><p>Placement Groups。即归置组（又称放置组）。Ceph对所有的存储资源都进行池化管理，对对象进行两级映射存储$Objects\rightarrow PGs \rightarrow OSDs $</p><ul><li><p>第一级映射是静态的，负责将任何前端类型的应用数据按照固定大小进行切割、编号后作为随机哈希函数输入，均匀映射至PG，以实现负载均衡。</p></li><li><p>第二级映射实现PG到OSD的映射。</p></li></ul><p>PG最引人关注的特性是它可以在OSD之间自由的迁移，这是Ceph赖以实现自动数据恢复、自动数据平衡等高级特性的基础。因为PG的数量远小于对象的数量，因此以PG为单位进行操作更具灵活性。</p><p><img src="/img/ceph-arch.png" alt=""></p><p>存储池中的对象到OSD的映射是通过PG来完成。一方面，存储池中PG数目决定了其并发处理多个对象的能力；另一方面，过多的PG会消耗大量CPU，同时容易使得磁盘长期处于过载状态。（经验表明：磁盘利用率保持在70%左右可以使得I/O并发能力和平均相应时延最佳）。</p><p>因此在创建存储池时，需要合理的指定PG的数目，一般将每个OSD中PG限制在100个左右最佳。</p><p>需要注意的是，创建存储池中指定的PG数目其实是指<strong>逻辑PG数目</strong>。为了数据的可靠性，Ceph会将每个逻辑PG转换为多个实例PG，由它们负责将对象的不同备份或者部分写入不同的OSD。</p><p>如果使用多副本，那么每个逻辑PG被转换为与副本数相等的PG实例。处于数据一致性考虑，我们可以选择Paxos作为数据分布一致性算法，但这样过于重量级。其实我们只需要在PG实例中选择一个主要的PG作为通用的入口进行操作分发或者集中（例如peering）。</p><p>如果使用纠删码，每个逻辑PG会被分为k+m个实例。与多副本不同，这些PG只保存每个对象的一个分片（shard），所以需要对其身份进行严格区分。同样，需要在PG实例中选择一个主要的PG。</p><p>按照约定，主要PG由CRUSH返回的第一个OSD充当。PGID由CRUSH计算，使得PG在所有OSD之间均匀分布。</p><h2 id="1-1-术语和约定"><a href="#1-1-术语和约定" class="headerlink" title="1.1 术语和约定"></a>1.1 术语和约定</h2><ul><li><p>PGID</p><p>PG有一个全局唯一的ID——$PGID$，所有的pool由Monitor统一管理，由pool-id+PG在pool内唯一ID+shard（仅适用于纠删码存储池）组成。</p></li><li><p>OS</p><p>指对象存储的种类（Object Store）例如FileStore和BlueStore。</p></li></ul><ul><li><p>Info</p><p>PG内基本元数据信息。</p></li><li><p>Log </p><p>基于Eversion顺序记录所有客户端发起的修改操作的历史信息，为后续提供历史操作回溯和数据同步的依据。</p></li><li><p>Authoritative History</p><p>指权威日志。它是Peering过程中进行数据同步的依据，通过交换Info并基于一定的规则从所有的PG实例中选举产生。通过重放权威日志，可以使得PG内部每个对象的版本号达成一致。</p></li><li><p>PGBackend</p><p>字面意思是PG后端。负责将对原始对象的操作转化为副本之间的分布式操作。对于多副本而言是<code>ReplicatedBackend</code>；对于纠删码而言是<code>ECBackend</code>。</p></li><li><p>Epoch</p><p>一般情况下指OSDMap（OSDMap 是 Ceph 集群中所有 OSD 的信息）的版本号，由Monitor生成，总是单调递增。Epoch变化意味着OSDMap发生变化，需要通过一定的策略扩散至所有客户端和位于服务端的OSD。</p></li><li><p>Version </p><p>version指本次修改生效之后的版本号。</p></li><li><p>Eversion</p><p>由Epoch和Version组成。Version总是当前的Primary产生，连续单调增，和Epoch一起标志一次PG内修改操作。如223’23。</p></li><li><p>Interval</p><p>指OSDMap一个连续的Epoch的持续时间，Interval和具体的PG绑定。</p></li><li><p>Acting Set</p><p>指一个有序的OSD集合。当前或者曾在某个Interval负责承载对应PG的PG实例。通常与Up Set相同，但有时候设置了PG Temp会导致两者不相同。</p></li><li><p>Primary</p><p>指Acting Set的第一个OSD，负责处理来自客户端的读写请求，同时也是peering的发起者和协调者。</p></li><li><p>Peering</p><p>指归属于同一个PG的所有PG实例就本PG所存储的全部对象以及对象相关的元数据操作进行协商并最终一致的过程。</p><p>Peering 基于Log和Info进行。这里的达成一致，并不表示每个PG实例都能获得最新的内容。事实上，为例尽快恢复对外业务，一旦Peering完成，在满足条件下就可以切换为Active状态，后续的数据恢复可以在后台进行。</p></li><li><p>Recovery</p><p>指针对PG某些实例进行数据同步的过程，其最终目标是将PG重新变为Active+Clean状态。它可以在后台进行。</p></li><li><p>Backfill</p><p>Backfill字面意思是回填，是Recovery的一种特殊场景，指Peering完成后，如果基于当前的权威日志无法对Up Set当中的某些PG实例实现增量同步，则通过完全拷贝当前的Primary所有对象的方式进行<strong>全量同步</strong>。</p></li><li><p>PG Temp</p><p>作为PG临时载体的OSD集合。Peering过程中，如果当前的Interval通过CRUSH计算的Up Set不合理（例如Up Set中的一些OSD新加入集群，根本没有PG的任何历史信息），那么可以通知OSDMonitor设置PG Temp的方式来显式的指定一些仍然具有相对完备PG信息的OSD加入Acting Set，使得Acting Set中的OSD再完成Peering之后能够临时处理客户端发起的读写请求，以尽可能减少业务中断的时间。上述过程会导致Up Set和Acting Set临时不一致。UpSet是CRUSH原始计算的映射结果；因为Peering过程中不能处理客户端读写请求，引入PG Temp可以缩短业务中断的时间，当Up Set中的副本在后台通过Recovery 或者Backfill 完成数据同步时，此时可以通知OSDMonitor取消PG Temp.</p><div class="note note-warning">            <ul><li>之所以需要PG Temp来修改OSDMap，是因为需要同步通知到所有客户端，让它们后续将读写请求发送到Acting Set而不是Up Set中的Primary。</li><li>PG Temp生效之后，PG将处于Remapped状态。</li><li>Peering完成之后，Up Set中与Acting Set不一致的OSD将在后台通过Recovery或者Backfill的方式与当前的Primary进行数据同步；数据同步完成后，PG需要重新修改PG Temp为空集合，完成Acting Set至Up Set的切换，此时取消Remapped标记。</li></ul>          </div></li><li><p>Stray</p><p>指PG所在的OSD不是PG当前的Acting Set中。</p></li></ul><p><img src="/img/ceph-d.png" alt="img"></p><blockquote><p>上图1：客户侧，Monitor和 Primary、Replica的关系</p></blockquote><p><img src="/img/ceph_io2.png" alt="img"></p><blockquote><p>上图2：正常的读写流程</p><p>客户侧先产生一个cluster handle（也就是后文所说的op）。之后连接monitor，再从Primary OSD进行读写。</p></blockquote><p><img src="/img/ceph-e.jpg" alt="img"></p><blockquote><p>上图3：Backfill的读写流程. 由于一些OSD离线太久，或者新的OSD加入到集群导致PG实例整体迁移，上图明显属于后者，需要通过Backfill指定临时主进行全增量同步并且选择新的Primary。</p></blockquote><p>客户端读写流程详细分析：</p><ol><li>OSD收到客户端发出的读写请求，将其封装为一个op（客户端发出的读写请求），并基于其携带的PGID发送至对应PG。</li><li>PG收到op之后，完成一系列检查，所有条件均满足后，开始真正执行op。<ul><li>如果op只包含读操作，那么直接执行同步读（对应多副本），或者异步读（对应纠删码），等待操作完成后向客户端应答。</li><li>如果op包含写操作，首先由primary基于op生成一个针对原始对象的事务及相关操作，然后将其提交给PGBackend安装备份策略转化为每个PG实例（包含所有primary和所有Replica）真正需要执行的本地事务并进行分发，当primary收到所有副本的写入完成应答之后，对应的op执行完成，此时由primary向客户端回应写完成。</li></ul></li></ol><h2 id="1-2-PG快速定位对象"><a href="#1-2-PG快速定位对象" class="headerlink" title="1.2 PG快速定位对象"></a>1.2 PG快速定位对象</h2><blockquote><p>对应参考书 2.2.1 PG</p></blockquote><p>首先由特定类型的Client根据其操作的对象名计算出一个32位的哈希值，然后根据其操作的对象名计算出一个32位的哈希值，然后根据归属的pool及此时的哈希值，通过简单的计算，比如取模，即可找到最终承载该对象的PG。</p><p>我们发现如果pool内的PG数目如果能写成$2^n$形式，那么其低n比特都是相同的。我们将$2^n-1$称为PG的<strong>掩码</strong>。否则，若PG不能写成$2^n$的形式，则不能保证针对不同的输入低n比特相同这一“稳定”的性质。（比如有12个PG，那么对于属于同一个pool的PGID只有低两位相同）</p><p>因此一种行之有效的方法是用掩码代替取模。取hash低n-1位，即$hash\&amp;(2^n-1)$ .但这种映射存在问题，如果PG数目不能被2整除，那么采用这种方式会导致空穴，也就是取模结果没有实际PG对应。</p><p>比如一个pool有12个PG，n=4，但是12-15这些值都浪费了：</p><blockquote><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><p>我们可以想办法压缩空间 ，$hash\&amp;(2^{n-1}-1)$，使得不能被2整除的PGID仍能被合理映射。</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table></div><p>如果$hash\&amp;(2^{n}-1)&lt;pg_num$，那么可以直接返回$hash\&amp;(2^n-1)$.</p><p>否则，我们返回$hash\&amp;(2^{n-1}-1)$.</p><p>在参考书上被称为稳定哈希（stable hash）。</p></blockquote><p>Ceph主要设计理念之一是高扩展性。当集群中PG增加，新的PG会被随机均匀地映射至所有OSD上。作为stable hash的输入的PG数目已经发生变化，导致某些对象从旧PG重新映射至新PG，因此需要转移这部分对象，我们称为<strong>PG分裂</strong>（这也是为什么PG数目必须是2的次幂的原因！）。</p><h1 id="2-详细剖析PG读写流程"><a href="#2-详细剖析PG读写流程" class="headerlink" title="2 详细剖析PG读写流程"></a>2 详细剖析PG读写流程</h1><h2 id="2-1-消息接收与分发"><a href="#2-1-消息接收与分发" class="headerlink" title="2.1 消息接收与分发"></a>2.1 消息接收与分发</h2><p>OSD绑定的Public Messenger 收到客户端发送的读写请求后，通过OSD注册的回调函数——<code>ms_fast_dispatch</code>进行快速派发：</p><ul><li>基于消息(Messenger)创建一个op， 用于对消息进行跟踪，并记录消息携带的Epoch。</li><li>查找OSD关联的客户端会话上下文，，将op加入其内部的<code>waiting_on_map</code>队列，获取OSDMap，，并将其与<code>waiting_on_map</code>队列的所有op进行逐一比较——如果OSD当前的OSDMap的Epoch不小于op所携带的Epoch，则进一步将其派发至OSD的<code>op_shardedwq</code>队列（OSD内部的工作队列）；否则直接终止派发。</li><li>如果会话的上下文的<code>waiting_on_map</code>不为空，说明至少存在一个op，其携带的Epoch比OSDMap更新，此时将其加入OSD全局<code>session_waiting_for_map</code>集合，该集合汇集了当前所有需要等待OSD更新完OSDMap之后才能继续处理的会话上下文；否则将对应的会话从<code>session_waiting_for_map</code>中移除。</li></ul><p>上面有些概念我们先抛砖引玉，下面我们具体讲</p><h2 id="2-2-do-request"><a href="#2-2-do-request" class="headerlink" title="2.2 do_request"></a>2.2 do_request</h2><p><code>do_request</code>作为PG处理op的第一步，主要完成全局（PG级别的）检查：</p><ul><li>Epoch——如果op携带的Epoch更新，那么需要等待PG完成OSDMap同步之后才能进行处理。</li><li><p>op能否被直接丢弃——一些可能的场景有：</p><ul><li>op对应的客户端链接已经断开</li><li>收到op时，PG当前已经切换到一个更新的Interval（OSD生成一个连续Epoch的间隔），后续客户端会重发。</li><li>op在PG分裂之前发送，后续客户端会重发。</li></ul></li><li><p>PG自身的状态如果不为Active，op同样会被阻塞。</p><p>PG内部维护了许多不同类型的重试队列，保证请求按顺序被处理。当对应限制解除之后，op会重新进入<code>op_shardedwq</code>，等待被PG执行。</p></li></ul><h2 id="2-3-do-op"><a href="#2-3-do-op" class="headerlink" title="2.3 do_op"></a>2.3 do_op</h2><p>do_op进行对象级别的检查：</p><p>1）按照op携带的操作类型，初始化op中各种标志位。</p><p>2）完成对op的合法性校验，不合法的情况包括：1.PG包含op所携带的对象；2.op之间携带可以并发执行的标志 ；3. 客户端权限不足；4. op携带对象名称、key或者命名空间长度超过最大限制（只有在FileStore下存在此限制）5.op对应客户端被纳入黑名单 6. op在集群被标记为Full之前发送 7. PG所在的OSD存储空间不足 8. op包含写操作并且企图访问快照对象 9. op包含写操作并且一次写入量太大（超过<code>osd_max_write_size</code>）。</p><p>3）检查op携带的对象是否不可读或者处于降级状态或者正在被scrub（读取数据对象并重新计算校验和），加入相应队列。</p><p>4）检查op是否为重发（基于op的repid在当前的Log中查找，如果找到说明为重发）。</p><p>5）获取对象上下文，创建OpContext对op进行跟踪，并通过<code>execute_ctx</code>真正开始执行op。</p><blockquote><p>💬关于可用存储空间控制</p><p>Ceph使用四个配置项，<code>mon_osd_full_ratio</code>、 <code>mon_osd_nearfull_ratio</code>、<code>osd_backfill_full_ratio</code>（OSD空间利用率大于此值，PG被拒绝以backfill方式迁入）、<code>osd_failsafe_full_ratio</code>（防止OSD磁盘被100%写满的最后一道屏障）。 </p><p>每个OSD通过<strong>心跳</strong>机制周期性的检测自身空间利用率，并上报至Monitor。<code>osd_backfill_full_ratio</code>的存在意义是有些数据迁移是自动触发的，我们无法预料到自动数据平衡后数据会落到哪个磁盘，因此必须设置此项进行控制。</p><p>💬关于对象上下文 (原书134页图4-3)</p><p>对象上下文主要保存了对象OI(Object Info)和SS(Snap Set)属性。同时表明对象是否仍然存在。查找head对象上下文相对简单，如果没有在缓存中命中，直接在磁盘中读取即可。然而如果op直接操作快照或者对象克隆，这个过程将变得很复杂。其难点在于一个克隆对象可以对应多个快照，因此需要根据快照序列号定位到某个特定的克隆对象，然后通过分析其位于OI中的snap属性才能进一步判断快照序列号是否位于克隆对象之中。</p></blockquote><h2 id="2-4-execute-ctx"><a href="#2-4-execute-ctx" class="headerlink" title="2.4 execute_ctx"></a>2.4 execute_ctx</h2><p><code>execute</code>是真正执行op的步骤。它首先基于当前的快照模式，更新OpContext中的快照上下文(SnapContext)——如果是自定义快照模式，直接基于op携带的快照信息更新；否则基于PGPool更新。 </p><p>为了保证数据的一致性，所以包含修改操作的PG会预先由Primary通过<code>prepare_transcation</code>封装为一个PG事务，然后由不同类型的PGBackend负责转化为OS(objectStore,笔者注)能够识别的本地事务，最后在副本间分发和同步。</p><h2 id="2-5-事务准备"><a href="#2-5-事务准备" class="headerlink" title="2.5 事务准备"></a>2.5 事务准备</h2><p>针对多副本，因为每个副本保存的对象完全相同，所以由Primary生成的PG事务也可以直接作为每个副本的本地事务直接执行。引入纠删码之后，每个副本保存的都是独一无二的分片，所以需要对原始对象的整体操作（对应PG操作）和每个分片操作（对应OS事务）加以区分。</p><p>本节介绍如何基于op生成PG级别的事务，这个过程通过<code>prepare_transaction</code>完成。</p><ol><li>通过<code>do_osd_ops</code>生成原始op对应的PG事务。</li><li>如果op针对<code>head</code>对象操作，通过<code>make_writable</code>检查是否需要预先执行克隆操作。</li><li>通过<code>finish_ctx</code>检查是否需要创建或者删除<code>snapdir</code>对象，生成日志，并更新对象的OI及SS属性。</li></ol><p>下面我们具体介绍相关流程：</p><h3 id="1-do-osd-ops"><a href="#1-do-osd-ops" class="headerlink" title="1 do_osd_ops"></a>1 do_osd_ops</h3><ol><li>检查write操作携带的<code>trancate_seq</code>，并和对象上下文保存的<code>truncate_seq</code>比较从而判定客户端执行write操作和trimtrunc/truncate操作的真实顺序，并对write操作涉及的逻辑地址范围进行修正。</li><li>检查本地写入逻辑地址范围是否合法——例如我们当前限制对象大小不超过100GB。(对应<code>osd_max_object_size</code>)。</li><li>将write对象转化为PGTransaction中的事务。</li><li>如果是满对象写（包括新写或者覆盖写），或者为追加写并且之前存在数据校验和，则重新计算并更新OI中数据校验和，作为后续执行Deep Scrub的依据；否则清除校验和。在OpContext中积累本次write修改的逻辑地址范围以及其它统计（例如写操作次数、写入字节数），同时更新对象大小。</li></ol><h3 id="2-make-writable"><a href="#2-make-writable" class="headerlink" title="2 make_writable"></a>2 make_writable</h3><p>如果op针对head对象进行修改</p><ol><li>判断head对象是否需要执行克隆：取对象当前的SnapSet，和OpContext中SnapContext 中内容进行比较——如果SnapSet中最新的快照序列号比SnapContext中最新的快照序列号小，说明自上次快照之后，又产生新的快照。此时不能直接对head对象进行修改，而是需要先执行克隆（默认为全对象克隆）。如果SnapContext携带了多个新的快照序列号，那么所有比SnapSet中更新的快照序列号都将关联至同一个克隆对象。</li></ol><blockquote><p>这里有一个特殊情况——如果当前操作为删除head对象，并且该对象自创建之后没有经历任何修改（此时SnapSet为空），也需要该head对象正常执行克隆后再删除，后续将创建一个snapdir对象来转移这些快照及相关的克隆信息。</p></blockquote><ol><li>创建克隆对象，需要同步更新SS属性中相关信息：<ul><li>在<code>clones</code>集合中记录当前克隆对象中最新快照序列号。</li><li>在<code>clone_size</code>集合中更新当前克隆对象的大小——因为默认使用全对象克隆，所以克隆对象大小为执行克隆时head对象head对象的实时大小。</li><li>在<code>clone_overlap</code>集合中记录当前克隆对象与前一个克隆对象之间的重合部分。</li></ul></li><li>为克隆对象生成一条新的、独立的日志，更新op中日志版本号。</li><li>最后，基于SnapContext更新对象SS属性中快照信息。</li></ol><h3 id="3-finish-ctx"><a href="#3-finish-ctx" class="headerlink" title="3 finish_ctx"></a>3 finish_ctx</h3><p>顾名思义，<code>finish_ctx</code>完成事务准备阶段最后的清理工作。</p><p>1）如果创建head对象并且snapdir对象存在，则删除snapdir对象，同时生成一条删除snapdir对象的日志；如果删除head对象并且对象仍然被快照引用，则创建snapdir对象，同时生成一条创建snapdir对象的日志，并将head对象的OI和SS属性用snapdir’对象转存</p><p>2）如果对象存在，则更新对象OI属性——例如version、last_reqid、mtime等；进一步，如果是head对象，同步更新其SS属性。</p><p>3）生成一条op操作原始对象的日志，并追加至现有的OpContext中的日志集合中。</p><p>4）在OpContext关联的对象上下文中应用最新的对象状态和SS上下文。</p><h2 id="2-6-注册回调函数"><a href="#2-6-注册回调函数" class="headerlink" title="2.6  注册回调函数"></a>2.6  注册回调函数</h2><p>PG事务准备后，如果是纯粹的读操作，如果是同步读（对于多副本），op已经执行完毕，此时可以直接向客户端应答；如果是异步读（针对纠删码），则将op挂入PG内部的异步读队列，等待异步读完成之后再向客户端应答。</p><p>如果是写操作，则注册如下几类回调函数：</p><ul><li><code>on_commit</code>——执行时，向客户端发送写入完成应答；</li><li><code>on_success</code>——执行时，进行与Watch\Notify相关的处理；</li><li><code>on_finish</code>——执行时，删除OpContext。</li></ul><h2 id="2-7-事务分发与同步"><a href="#2-7-事务分发与同步" class="headerlink" title="2.7 事务分发与同步"></a>2.7 事务分发与同步</h2><p>事务的分发与同步由Primary完成，具体而言是通过RepGather实现的。RepGather被提交到PGBackend，后者负责将PG事务转化为每个副本之间的本地事务之后再进行分发。</p><p>对于纠删码而言，当涉及覆盖写时，如果改写的部分不足一个完整条带（指写入的起始地址或者数据长度没有进行条带对齐），则需要执行RMW，这期间需要多次执行补齐读、重新生成完整条带并重新计算校验块、单独生成每个副本的事务并构造消息进行分发（Write）、同时在必要时执行范围克隆和对PG日志进行修正，以支持Peering期间的回滚操作。</p><h1 id="3-PG-状态迁移详解"><a href="#3-PG-状态迁移详解" class="headerlink" title="3 PG 状态迁移详解"></a>3 PG 状态迁移详解</h1><p>PG状态分为外部状态和内部状态，其中外部状态是可以直接被用户感知的。</p><blockquote><p>​                                                                    PG外部状态表</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">PG状态</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">Activating</td><td style="text-align:left">Peering已经完成，PG正在等待所有PG实例同步并固化Peering结果（Info、Log）</td></tr><tr><td style="text-align:center">Active</td><td style="text-align:left">PG可以正常处理来自客户端的读写请求</td></tr><tr><td style="text-align:center">Backfilling</td><td style="text-align:left">见前面术语——Backfill部分</td></tr><tr><td style="text-align:center">Clean</td><td style="text-align:left">PG当前不存在待修复的对象，Acting Set与Up Set一致，并且大小等于存储池副本数</td></tr><tr><td style="text-align:center">Creating</td><td style="text-align:left">PG正在被创建</td></tr><tr><td style="text-align:center">Deep</td><td style="text-align:left">PG正在进行对象一致性扫描（总是与Scrubbing同时出现）</td></tr><tr><td style="text-align:center">Scrubbing</td><td style="text-align:left">PG正在进行对象一致性扫描，但Scrubbing仅扫描元数据</td></tr><tr><td style="text-align:center">Degraded</td><td style="text-align:left">Peering完成后，PG检测到任意一个PG实例存在不一致的对象；或者当前ActingSet小于存储池副本数。</td></tr><tr><td style="text-align:center">Down</td><td style="text-align:left">Peering过程中，PG检测到某个Interval中，当前剩余的OSD不足以完成数据修复</td></tr><tr><td style="text-align:center">Incomplete</td><td style="text-align:left">Peering过程中，由于：1）无法获得权威日志 2）通过<code>choose_acting</code>选出的Acting Set后续不足以完成数据修复（例如针对纠删码，存活的副本数小于k）</td></tr><tr><td style="text-align:center">Inconsistent</td><td style="text-align:left">PG通过Scrub检测到某些对象在PG实例间出现不一致（主要是因为静默错误）</td></tr><tr><td style="text-align:center">Peered</td><td style="text-align:left">指Peering完成，但是PG当前的ActingSet小于存储池规定的最小副本数。</td></tr><tr><td style="text-align:center">Recovering</td><td style="text-align:left">PG正在对不一致对象进行同步/修复。</td></tr><tr><td style="text-align:center">Remapped</td><td style="text-align:left">Peering完成，PG当前的Acting Set和Up Set出现不一致。</td></tr><tr><td style="text-align:center">Repair</td><td style="text-align:left">PG在下一次执行Scrub的过程中，如果发现存在不一致的对象，并且能够进行修复，则自动进行修复。</td></tr><tr><td style="text-align:center">Stale</td><td style="text-align:left">Monitor检测到当前Primary所在的OSD宕机；Primary超时未向Monitor上报心跳信息。</td></tr><tr><td style="text-align:center">Undersized</td><td style="text-align:left">PG当前的Acting Set小于存储池副本数</td></tr></tbody></table></div><div class="note note-primary">            <p>注意上述外部状态是可以叠加的。比如Active+clean表示一切正常。</p>          </div><h2 id="3-1-状态机描述"><a href="#3-1-状态机描述" class="headerlink" title="3.1 状态机描述"></a>3.1 状态机描述</h2><p><img src="\img\PG_DFA.png" style="zoom: 80%;" /></p><h2 id="3-2-具体流程分析"><a href="#3-2-具体流程分析" class="headerlink" title="3.2 具体流程分析"></a>3.2 具体流程分析</h2><h2 id="1-创建PG"><a href="#1-创建PG" class="headerlink" title="1 创建PG"></a>1 创建PG</h2><p>OSDMonitor收到存储池创建命令之后，最终通过PGMonitor异步向每个OSD下发批量创建PG命令。创建PG是在Primary主导下进行的。Replica会在随后由Primary发起的Peering过程中自动被创建。</p><h2 id="2-Peering"><a href="#2-Peering" class="headerlink" title="2 Peering"></a>2 Peering</h2><p>所有需要执行Peering 的PG也会专门安排一个peering_wq工作队列，当PG从peering_wq出列时：</p><ol><li>创建一个RecoveryCtx，用于批量处理所有PG与Peering相关的消息，例如Query(Log, Info等)，Notify等。</li><li>逐个PG处理：取OSD最新的OSDMap，通过advance_pg检查PG是否需要执行OSDMap更新操作。如果为否，说明直接由Peering事件触发，将该事件从PG内部的peering_queue出列，投递到PG内部的状态机进行处理；如果为是，则在advance_pg内部执行OSDMap更新操作，完成之后再将PG再次加入peering_wq队列。</li><li>检查是否需要通知Monitor设置本OSD的<code>up_thru</code>（我们规定PG在切换至新的Interval之后，成功完成Peering并重新开始接受客户端读写请求之前，必须先通知OSDMonitor设置其归属的up_thru参数）.</li><li>批量派发RecoveryCtx中积累的Query\Notify消息。</li></ol><p>下面是几个必须的操作，包括GetInfo, GetLog, GetMissing和Activate</p><p>GetInfo：获取PG元数据信息。</p><p>GetLog：开始着手进行日志同步。按照以下原则：</p><ul><li>优先选取具有最新内容的日志（即Info中的<code>last_update</code>最大）；</li><li>如果有多份满足1）的日志，优先选择保存更多日志条目的日志，即Info中<code>log_tail</code>最小；</li><li>如果有多份满足2）的日志，优先选择当前的Primary。</li></ul><p>GetMissing</p><p>Missing列表记录了自身所有需要通过Recovery进行修复的对象信息。只保留两个：</p><ul><li><code>need</code>：对象被同步的目标版本号。</li><li><code>have</code>：对象当前归属PG实例的本地版本号。</li></ul><p>当Primary收到每个Peer的本地日志之后，可以通过日志合并的方式得到每个Peer的missing列表，这一过程是通过解决日志分歧得到的。</p><p>为解决日志分歧，我们先将所有日志按照对象进行分类——即所有针对同一个对象操作的分歧日志都使用同一个队列进行管理，然后逐个队列进行管理。我们假定最老的那条分歧日志生效之前对应的版本号为prior_version，则针对每个队列的处理 都可以归结为以下五种情形：</p><ul><li>本地存在比分歧日志更新的日志。</li><li>对象此前不存在。此时可以直接删除对象。</li><li>对象当前位于missing列表之中（例如上一次peering完成之后，Primary刚更新了自己的missing列表，但是其中的对象还没来得及修复，系统发生断电）。</li><li>对象不在missing列表之中同时所有分歧日志都可以回滚。此时将所有分歧日志按照从新到老的顺序依次进行回滚。</li><li>对象不在missing列表之中并且至少存在一条分歧日志不可回滚。此时将本地对象直接删除，将其加入missing列表，同时设置其need为prior_version，have为0.</li></ul><p>Activate</p><p>在PG正式变为Active状态接受客户端请求之前，还必须先固化本次Peering的结果（也就是写入磁盘，开机bootstrap），遇到系统掉电时不会前功尽弃；同时需要初始化后续在后台执行的Recovery或者Backfill所依赖的元数据信息。以上过程便是Activate。</p><p>下面我们重点对两个元数据进行分析：</p><ul><li><code>last_epoch_started</code></li></ul><p>它本来用于指示上一次peering成功时完成的epoch，但是因为peering涉及在多个osd之间进行数据和状态同步，所以存在进度不一致的可能。 为此我们设计两个<code>last_epoch_started</code>，一个用于标识每个参与本次Peering的PG实例本地Activate已经完成，直接作为本身Info的子属性存盘；另一个保存在Info的History属性下，由Primary在检测到所有副本的Activate过程都完成后统一更新和存盘。</p><ul><li><code>MissingLoc</code></li></ul><p>在进行Recovery之前我们需要先引入一种同时包含所有missing条目和它们（目标版本）所在位置信息的全局数据结构，称为<code>MissingLoc</code>，它包含两个子表，分别是<code>needs_recovery_map</code>和<code>missing_loc</code>.它们分别保存当前PG的所有待修复对象，以及这些对象的目标版本可能同时存在于多个PG实例之上。因为目标版本可能位于多个PG实例之上，注意<code>missing_loc</code>不是一个PG而是一些PG的集合。后者由Primary统一生成。</p><p>生成<code>missing_loc</code>需要两步：首先，将所有的Peer missing列表之中的条目依次加入到needs_recovery_map之中；其次，以每个Peeri的Info和missing列表作为输入，针对<code>needs_recovery_map</code>中的每个对象逐一进行检查，以进一步确认其目标版本的位置信息并填充<code>missing_loc</code>.</p><p>成功生成<code>MissingLoc</code>之后，如果<code>needs_recovery_map</code>不为空，即存在任何需要被Recovery的对象，则Primary设置自身状态为<strong>Degraded+Activating</strong>；进一步，如果Primary检测到当前的Acting Set小于存储池副本数，则同时设置为<strong>Undersized</strong>状态。之后，Primary通过本地OS接口开始固化Peering结构；当Primary检测自身以及所有Peer的Activate操作都完成时，通过向状态机投递一个<code>AllReplicasActivated</code>事件来清除自身的Activating状态和Creating状态。同时检测PG此时Acting Set是否小于存储池最小副本数，如果小于，则设置PG状态为<strong>Peered</strong>并终止后续处理，否则将PG设置为Active，同时将之前来自客户端被阻塞的op重新入列。</p><p>随后PG进入<strong>Active</strong>状态，可以正常执行客户端的读写请求。</p><h2 id="3-Recovery"><a href="#3-Recovery" class="headerlink" title="3 Recovery"></a>3 Recovery</h2><p>Recovery是在Primary检测到自身或者任意一个peer存在待修复的对象进行的操作。为了防止集群中大量PG同时执行Recovery造成客户端响应速度过慢，需要限制Recovery。我们有几种配置项可供修改：</p><ul><li><code>osd_max_bakfills</code>: 单个OSD运行同时执行Recovery或者Backfill的PG实例个数。 注意虽然单个PG的Recovery或者Backfill不能并发，但是不同PG的Recovery和Backfill可以并发。</li><li><code>osd_max_push_cost/osd_max_push_objects</code>:指示通过Push操作执行Recovery时，以OSD为单位，单个op所能携带的字节数，对象数。</li><li><code>osd_recovery_max_active</code>: 单个OSD允许同时执行Recovery的对象数。</li><li><code>osd_recovery_op_priority</code>: 指示Recovery op的默认优先级，它将与客户端op进行竞争，优先级设置越低，竞争劣势更大。</li><li><code>osd_recovery_sleep</code>: Recovery op每次在<code>op_shardedwq</code>中被处理前，设置此参数将导致对应的服务线程先休眠对应的时间。</li></ul><p>不难看出，考虑到集群总IOPS和带宽有限，可以通过降低Recovery权重，或者通过QoS对Recovery总的IOPS和带宽加以限制，可以有效抑制Recovery对资源的消耗。</p><p>Recovery有以下两种方式：</p><ol><li><code>pull</code>: 指Primary自身存在待修复对象，由Primary按照<code>missing_loc</code>选择合适的副本去拉取待修复对象目标版本到本地，完成修复。</li><li><code>push</code>: 指Primary感知到一个或者多个Replica当前存在待修复对象，主动推送每个待修复对象目标版本至相应的Replica，然后在本地完成修复。</li></ol><p>Primary必须先完成自我修复才能修复别的Replica。它是基于日志进行的：</p><ul><li>日志中的<code>last_requested</code>用于指示Recovery的起始版本号，在Activate中生成。因此我们首先将所有待修复对象按照日志版本号进行顺序排列，找到版本号不小于<code>last_requested</code>的第一个对象，记为v；</li><li>如果不为head对象，那么检查是否需要优先修复head对象后者snapdir对象；</li><li>根据具体的PGBackend生成一个Pull类型的op；</li><li>更新last_requested，使其指向v；</li><li>如果尚未达到单次最大修复数码，则从顺序队列中处理下一个待修复对象；否则返回。</li></ul><p>以多副本为例子，因为PG日志中并未记录任何关于修改的详细信息，目前都是通过简单的全对象拷贝，因而效率低下，这也是Ceph为人所诟病的地方。</p><h2 id="4-Backfill"><a href="#4-Backfill" class="headerlink" title="4 Backfill"></a>4 Backfill</h2><p>Backfill的理论依据是“PG中所有对象可以基于全精度哈希排序”，所以是按照从小到大对当前对象进行遍历，并依次将它们按照全对象拷贝的方式写入待Backfill的PG实例。</p><p>当空的PG Temp在新的OSDMap生效之后，PG关联的Acting Set和Up Set重新变得一致，再次经过Peering之后，PG最终进入<strong>Active+Clean</strong>状态，此时PG一切恢复正常，可以删除不必要的副本（Stray）。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>PG的主要定位如下：</p><ul><li>作为存储池的基本组成单位，负责执行存储池所绑定的副本策略。</li><li>以OSD作为单位，进行副本分布，将前端应用任何针对PG中原始对象的操作，转化为OSD所能理解的事务操作，并保证副本之间的强一致性。</li></ul><p>不足之处在于：因为PG日志中并未记录任何关于修改的详细信息，目前都是通过简单的全对象拷贝，因而效率低下，这也是Ceph为人所诟病的地方。</p><hr><h1 id="——"><a href="#——" class="headerlink" title="——"></a>——</h1><h1 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h1><h2 id="0-官方的指导和讲解"><a href="#0-官方的指导和讲解" class="headerlink" title="0 官方的指导和讲解"></a>0 官方的指导和讲解</h2><p>数据的持久性以及所有OSD之间的均匀分配都需要更多的放置组，但应将其数量减少到最少，以节省CPU和内存。</p><h3 id="0-1-数据持久性"><a href="#0-1-数据持久性" class="headerlink" title="0.1 数据持久性"></a>0.1 数据持久性</h3><p>OSD发生故障后，数据丢失的风险会增加，直到完全恢复其中包含的数据为止。让我们想象一下在单个放置组中导致永久性数据丢失的情况：</p><ul><li>OSD失败，并且它包含的对象的所有副本均丢失。对于放置组中的所有对象，副本的数量突然从三个减少到两个。</li><li>Ceph通过选择一个新的OSD来重新创建所有对象的第三个副本，从而开始对该放置组的恢复。</li><li>在同一放置组内的另一个OSD在新OSD完全填充第三份副本之前发生故障。某些对象将只有一个幸存副本。</li><li>Ceph选择了另一个OSD并保持复制对象以恢复所需的副本数。</li><li>在同一放置组内的第三个OSD在恢复完成之前发生故障。如果此OSD包含对象的唯一剩余副本，则它将永久丢失。</li></ul><p>在三个副本池中包含10个OSD和512个放置组的群集中，CRUSH将为每个放置组提供三个OSD。最后，每个OSD将托管（512 * 3）/ 10 =〜150个放置组。当第一个OSD发生故障时，以上情形将因此同时开始恢复所有150个放置组的操作。</p><p>恢复的150个放置组可能均匀分布在剩余的9个OSD上。因此，每个剩余的OSD都有可能将对象的副本发送给所有其他对象，并且还可能接收一些要存储的新对象，因为它们已成为新放置组的一部分。</p><p>完成恢复所需的时间完全取决于Ceph集群的架构。假设每个OSD由一台机器上的1TB SSD托管，并且所有OSD都连接到10Gb / s交换机，并且单个OSD的恢复将在M分钟内完成。如果每台计算机使用不带SSD日志的微调器和1Gb / s开关的两个OSD，则速度至少要慢一个数量级。</p><p>在这种大小的群集中，放置组的数量几乎对数据持久性没有影响。可能是128或8192，恢复速度不会变慢或变快。</p><p><strong>但是，将相同的Ceph群集增加到20个OSD而不是10个OSD可能会加快恢复速度，从而显着提高数据的持久性</strong>。现在，每个OSD只能参与约75个放置组，而不是只有10个OSD时的约150个放置组，并且仍然需要全部19个剩余OSD执行相同数量的对象副本才能恢复。但是，如果10个OSD必须每个复制大约100GB，则现在它们必须每个复制50GB。如果网络是瓶颈，恢复将以两倍的速度进行。换句话说，当OSD数量增加时，恢复速度会更快。</p><p>如果该群集增长到40个OSD，则每个OSD将仅托管约35个放置组。如果OSD死亡，则恢复将保持更快的速度，除非它被另一个瓶颈阻止。但是，如果该群集增长到200个OSD，则每个OSD将仅托管约7个放置组。如果OSD死亡，则在这些放置组中最多将有约21（7 * 3）个OSD之间发生恢复：恢复将比有40个OSD时花费更长的时间，这意味着应该增加放置组的数量。</p><p>无论恢复时间有多短，第二个OSD在进行过程中都有可能发生故障。在上述10个OSD集群中，如果其中任何一个失败，则〜17个放置组（即，已恢复的〜150/9个放置组）将只有一个幸存副本。并且，如果剩余的8个OSD中的任何一个失败，则两个放置组的最后一个对象很可能会丢失（即，〜17/8个放置组，仅恢复了一个剩余副本）。</p><p>当群集的大小增加到20个OSD时，丢失三个OSD会损坏的放置组的数量会减少。第二个OSD丢失将降低〜4个（即，恢复到约75个/ 19个放置组），而不是〜17个，而第三个OSD丢失则仅在它是包含尚存副本的四个OSD之一时才丢失数据。换句话说，如果在恢复时间范围内丢失一个OSD的概率为0.0001％，则它从具有10个OSD的群集中的17 <em> 10 </em> 0.0001％变为具有20个OSD的群集中的4 <em> 20 </em> 0.0001％。</p><p><strong><u>简而言之，更多OSD意味着更快的恢复速度和更低的导致安置组的永久损失的级联故障风险。就数据持久性而言，在少于50个OSD的群集中，具有512或4096个放置组大致等效。</u></strong></p><p>注意：添加到群集中的新OSD可能需要很长时间才能分配有分配给它的放置组。但是，不会降低任何对象的质量，也不会影响群集中包含的数据的持久性。</p><h3 id="0-2-池中的对象分布"><a href="#0-2-池中的对象分布" class="headerlink" title="0.2 池中的对象分布"></a>0.2 池中的对象分布</h3><p>理想情况下，对象在每个放置组中均匀分布。由于CRUSH计算每个对象的放置组，但实际上不知道该放置组内每个OSD中存储了多少数据，因此放置组数与OSD数之比可能会显着影响数据的分布。</p><p>例如，如果在三个副本池中有一个用于十个OSD的放置组，则仅使用三个OSD，因为CRUSH别无选择。当有更多的放置组可用时，对象更有可能在其中均匀分布。CRUSH还尽一切努力在所有现有的放置组中平均分配OSD。</p><p>只要放置组比OSD多一个或两个数量级，则分布应该均匀。例如，用于3个OSD的256个放置组，用于10个OSD的512或1024个放置组等。</p><p>数据分布不均可能是由OSD与放置组之间的比率以外的因素引起的。由于CRUSH没有考虑对象的大小，因此一些非常大的对象可能会造成不平衡。假设有100万个4K对象（共4GB）均匀分布在10个OSD的1024个放置组中。他们将在每个OSD上使用4GB / 10 = 400MB。如果将一个400MB对象添加到池中，则支持放置对象的放置组的三个OSD将填充400MB + 400MB = 800MB，而其余七个将仅占据400MB。</p><h3 id="0-3-内存，CPU和网络使用率"><a href="#0-3-内存，CPU和网络使用率" class="headerlink" title="0.3 内存，CPU和网络使用率"></a>0.3 内存，CPU和网络使用率</h3><p>对于每个放置组，OSD和MON始终需要内存，网络和CPU，并且在恢复期间甚至更多。通过对放置组内的对象进行聚类来共享此开销是它们存在的主要原因之一。</p><p><strong><u>最小化放置组的数量可以节省大量资源。</u></strong></p><h3 id="0-4-选择放置组的数量"><a href="#0-4-选择放置组的数量" class="headerlink" title="0.4 选择放置组的数量"></a>0.4 选择放置组的数量</h3><p><strong><u>如果您有超过50个OSD，我们建议每个OSD大约有50-100个放置组</u></strong>，以平衡资源使用，数据持久性和分发。如果OSD少于50个，则最好在上述<a href="https://docs.ceph.com/en/latest/rados/operations/placement-groups/?#preselection">预选</a>中进行<a href="https://docs.ceph.com/en/latest/rados/operations/placement-groups/?#preselection">选择</a>。对于单个对象池，您可以使用以下公式获取基准</p><script type="math/tex; mode=display">Total \ PGs = \frac{OSDs*100}{pool\_size}</script><p>$pool_size$在副本池表示副本数，而在纠删码池表示$K+M$</p><p>然后，您应该检查结果是否与您设计Ceph集群的方式有意义，以最大程度地提高<a href="https://docs.ceph.com/en/latest/rados/operations/placement-groups/?#data-durability">数据持久性</a>， <a href="https://docs.ceph.com/en/latest/rados/operations/placement-groups/?#object-distribution">对象分配</a>并最小化<a href="https://docs.ceph.com/en/latest/rados/operations/placement-groups/?#resource-usage">资源使用</a>。</p><p>结果应始终<strong>四舍五入到最接近的2的幂</strong>。</p><p>只有2的幂可以平衡放置组中的对象数量。其他值将导致OSD上的数据分布不均。它们的使用应仅限于从两个方的一种逐步增加到另一种。</p><p>例如，对于具有200个OSD和3个副本的池大小的群集，您可以如下估算PG的数量</p><script type="math/tex; mode=display">\frac{200 \times 100}{3} = 6667</script><p>最近的2的次幂是8192.</p><p>当使用多个数据池存储对象时，您需要确保在每个池的放置组数量与每个OSD的放置组数量之间取得平衡，以便获得合理的放置组总数，从而使每个OSD的方差很小而不会增加系统资源的负担或使对等进程太慢。</p><p>例如，一个由10个池组成的群集，每个池在10个OSD上具有512个放置组，则总共有5120个放置组分布在10个OSD上，即每个OSD 512个放置组。那不会使用太多资源。但是，如果创建了1,000个池，每个池有512个放置组，则OSD将分别处理约50,000个放置组，并且将需要更多的资源和时间来进行对等。</p><p>您可能会发现<a href="http://ceph.com/pgcalc/">PGCalc</a>工具很有帮助。这是一个很有意思的工具。</p><blockquote><p><strong>建议的PG计数背后的逻辑</strong></p><p>( Target PGs per OSD ) x ( OSD # ) x ( %Data )/ ( Size )</p><ol><li>如果以上计算的值小于<strong>（OSD＃）/（Size）</strong>的值，则该值将更新为<strong>（OSD＃）/（Size）的值</strong>。这是通过为每个池向每个OSD分配至少一个主PG或辅助PG来确保均匀的负载/数据分配。</li><li>然后将输出值舍入到<strong>最接近的2的幂</strong>。<br><strong>提示：</strong>最接近的2的幂提供了<a href="http://ceph.com/docs/master/rados/operations/crush-map/">CRUSH</a>算法效率的少量提高。</li><li>如果最接近的2的幂比原始值低<strong>25％</strong>以上，则使用下一个更高的2的幂。</li></ol><p><strong>目的</strong></p><ul><li>此计算的目的和上面“关键”部分所述的目标范围是为了确保有足够的放置组，以便在整个群集中进行均匀的数据分布，同时每个OSD PG的PG值不够高，从而在恢复期间引起问题和/或回填操作。</li></ul><p><strong>无效或无效池的影响：</strong></p><ul><li>空池或其他非活动池不应被认为有助于整个群集中的数据均匀分布。</li><li>但是，与这些空/非活动池关联的PG仍会消耗内存和CPU开销。</li></ul></blockquote><hr><h2 id="1-设置放置组数"><a href="#1-设置放置组数" class="headerlink" title="1 设置放置组数"></a>1 设置放置组数</h2><p>要设置池中的放置组数量，必须在创建池时指定放置组的数量。有关详细信息，请参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools#createpool">创建池</a>。即使在创建池之后，您也可以使用以下方法更改放置组的数量：</p><pre><code class="hljs pgsql">ceph osd pool <span class="hljs-keyword">set</span> &#123;pool-<span class="hljs-type">name</span>&#125; pg_num &#123;pg_num&#125;</code></pre><p>增加放置组的数量之后，还必须增加放置（<code>pgp_num</code>）的放置组的数量，群集才能重新平衡。该<code>pgp_num</code>会是将由CRUSH算法可考虑放置位置的组数。增加会<code>pg_num</code>拆分放置组，但数据将不会迁移到较新的放置组，直到放置的放置组，即<code>pgp_num</code>增加的值<code>pgp_num</code> 应等于<code>pg_num</code>。要增加用于放置的放置组的数量，请执行以下操作：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> &#123;pool-name&#125; pgp_num &#123;pgp_num&#125;</code></pre><p>减少PG数量时，<code>pgp_num</code>将自动为您调整。</p><div class="note note-primary">            <p>笔者注：</p><p>关于PG和PGP：</p><ul><li><p>PG =放置组( Placement Group)<br>PGP =用于放置的放置组(Placement Group for Placement purpose)</p><p>pg_num = 映射到OSD的PG的数量，它必须是2的幂次。</p><p>当对任何一个池增加pg_num时，该池的每个PG都会<strong>分裂</strong>成一半，但它们都将始终映射到其父OSD。</p><p>在此之前，Ceph不会开始重新平衡。 现在，当您为同一池增加pgp_num值时，PG开始从父级迁移到其他OSD，并且群集重新平衡开始。 这就是PGP扮演重要角色的方式。</p></li></ul>          </div><h2 id="2-获取放置组的数量"><a href="#2-获取放置组的数量" class="headerlink" title="2 获取放置组的数量"></a>2 获取放置组的数量</h2><p>要获取池中的放置组数，请执行以下操作：</p><pre><code class="hljs pgsql">ceph osd pool <span class="hljs-keyword">get</span> &#123;pool-<span class="hljs-type">name</span>&#125; pg_num</code></pre><h2 id="3-Auto-scaling"><a href="#3-Auto-scaling" class="headerlink" title="3 Auto_scaling"></a>3 Auto_scaling</h2><h3 id="自动调整"><a href="#自动调整" class="headerlink" title="自动调整"></a>自动调整</h3><p>这是一种自动调整PG的方式。有三个参数<code>off</code>, <code>on</code>,<code>warn</code>. 当设置为off就需要人为控制PG数目。</p><p>要为现有池设置自动缩放模式，请执行以下操作：</p><pre><code class="hljs pgsql">ceph osd pool <span class="hljs-keyword">set</span> &lt;pool-<span class="hljs-type">name</span>&gt; pg_autoscale_mode &lt;mode&gt;</code></pre><p>例如，要在pool上启用自动缩放<code>foo</code>，请执行以下操作：</p><pre><code class="hljs pgsql">ceph osd pool <span class="hljs-keyword">set</span> foo pg_autoscale_mode <span class="hljs-keyword">on</span></code></pre><p>您还可以使用以下命令配置<code>pg_autoscale_mode</code>应用于以后创建的任何池的默认值：</p><pre><code class="hljs routeros">ceph<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> global osd_pool_default_pg_autoscale_mode &lt;mode&gt;</code></pre><h2 id="4-Autoscale-status"><a href="#4-Autoscale-status" class="headerlink" title="4 Autoscale_status"></a>4 Autoscale_status</h2><h3 id="查看PG缩放建议"><a href="#查看PG缩放建议" class="headerlink" title="查看PG缩放建议"></a>查看PG缩放建议</h3><p>您可以使用以下命令查看每个池，池的相对利用率以及对PG计数的任何建议更改：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>autoscale-status</code></pre><p>输出将类似于：</p><pre><code class="hljs apache"><span class="hljs-attribute">POOL</span>    SIZE  TARGET SIZE  RATE  RAW CAPACITY   RATIO  TARGET RATIO  EFFECTIVE RATIO PG_NUM  NEW PG_NUM  AUTOSCALE<span class="hljs-attribute">a</span>     <span class="hljs-number">12900</span>M                <span class="hljs-number">3</span>.<span class="hljs-number">0</span>        <span class="hljs-number">82431</span>M  <span class="hljs-number">0</span>.<span class="hljs-number">4695</span>                                     <span class="hljs-number">8</span>         <span class="hljs-number">128</span>  warn<span class="hljs-attribute">c</span>         <span class="hljs-number">0</span>                 <span class="hljs-number">3</span>.<span class="hljs-number">0</span>        <span class="hljs-number">82431</span>M  <span class="hljs-number">0</span>.<span class="hljs-number">0000</span>        <span class="hljs-number">0</span>.<span class="hljs-number">2000</span>           <span class="hljs-number">0</span>.<span class="hljs-number">9884</span>      <span class="hljs-number">1</span>          <span class="hljs-number">64</span>  warn<span class="hljs-attribute">b</span>         <span class="hljs-number">0</span>        <span class="hljs-number">953</span>.<span class="hljs-number">6</span>M   <span class="hljs-number">3</span>.<span class="hljs-number">0</span>        <span class="hljs-number">82431</span>M  <span class="hljs-number">0</span>.<span class="hljs-number">0347</span>                                     <span class="hljs-number">8</span>              warn</code></pre><p><strong>SIZE</strong>是存储在池中的数据量。<strong>TARGET SIZE</strong>（如果存在）是管理员指定的数据量，管理员希望最终将其存储在此池中。系统使用两个值中的较大者进行计算。</p><p><strong>RATE</strong>是池的乘数，它确定要消耗多少原始存储容量。例如，3个副本池的比率为3.0，而k = 4，m = 2纠删码池的比率为1.5。</p><p><strong>RAW CAPACITY</strong>是OSD上负责存储此池（可能还有其他池）数据的原始存储容量的总量。 <strong>比率</strong>是该池消耗的总容量的比率（即比率=大小*比率/原始容量）。</p><p><strong>TARGET RATIO</strong>（如果存在）是管理员已指定他们希望该池相对于设置了目标比率的其他池消耗的存储比率。如果同时指定了目标大小字节和比率，则比率优先。</p><p><strong>EFFECTIVE RATIO</strong>是通过两种方式进行调整后的目标比率：</p><ol><li>减去设置了目标大小的池预期使用的任何容量</li><li>设定目标比率后，对池中的目标比率进行标准化，以便它们共同针对其余空间。例如，target_ratio 1.0的4个池的有效比率为0.25。</li></ol><p>系统使用实际比率和有效比率中的较大者进行计算。</p><p><strong>PG_NUM</strong>是该池的当前PG数量（如果<code>pg_num</code> 正在进行更改，则为该池正在使用的PG的当前数量）。 系统认为应该将<code>pg_num</code>更改为<strong>NEW PG_NUM</strong>。它始终是2的幂，并且仅在“理想”值与当前值的差异大于3时才存在。</p><p>最后一列，<strong>AUTOSCALE</strong>，是池<code>pg_autoscale_mode</code>，并将于要么<code>on</code>，<code>off</code>或<code>warn</code>。</p><h2 id="5-Automated-scaling"><a href="#5-Automated-scaling" class="headerlink" title="5 Automated_scaling"></a>5 Automated_scaling</h2><h3 id="自动缩放"><a href="#自动缩放" class="headerlink" title="自动缩放"></a>自动缩放</h3><p>最简单的方法是允许群集根据使用情况自动扩展PG。Ceph将查看整个系统的PG的总可用存储量和目标数量，查看每个池中存储了多少数据，并尝试相应地分配PG。该系统的方法相对保守，仅当当前PG（<code>pg_num</code>）数量比其认为的数量多3倍时才对池进行更改。</p><p>每个OSD的PG的目标数量基于可 <code>mon_target_pg_per_osd</code>配置（默认值：100），可以通过以下方式进行调整：</p><pre><code class="hljs routeros">ceph<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> global mon_target_pg_per_osd 100</code></pre><p>自动缩放器将分析池并在每个子树的基础上进行调整。因为每个池可能映射到不同的CRUSH规则，并且每个规则可能在不同的设备之间分配数据，所以Ceph将考虑独立使用层次结构的每个子树。例如，映射到ssd类的OSD的池和映射到hdd类的OSD的池将分别具有最佳PG计数，这取决于这些相应设备类型的数量。</p><h2 id="6-指定期望池大小"><a href="#6-指定期望池大小" class="headerlink" title="6 指定期望池大小"></a>6 指定期望池大小</h2><p>首次创建集群或池时，它将消耗集群总容量的一小部分，并且在系统中似乎只需要少量的放置组。但是，在大多数情况下，群集管理员会很好地知道哪些池会随着时间消耗掉大部分系统容量。通过将此信息提供给Ceph，可以从一开始就使用更合适数量的PG，从而避免进行后续调整 <code>pg_num</code>以及在进行这些调整时与移动数据相关的开销。</p><p>池的<em>目标大小</em>可以通过两种方式指定：要么以池的绝对大小（即字节）为单位，要么以相对于具有一<code>target_size_ratio</code>组其他池的权重为单位。</p><p>例如，：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> mypool target_size_bytes 100T</code></pre><p>会告诉系统mypool预计会占用100 TiB的空间。或者，：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> mypool target_size_ratio 1.0</code></pre><p>会告诉系统mypool与<code>target_size_ratio</code>set的其他池相比预期消耗1.0 。如果mypool是群集中唯一的池，则意味着预期使用了总容量的100％。如果第二个池的<code>target_size_ratio</code> 1.0，则两个池都将使用50％的群集容量。</p><p>您还可以在创建时使用命令的可选参数<code>--target-size-bytes &lt;bytes&gt;</code>或参数<code>--target-size-ratio &lt;ratio&gt;</code>设置池的目标大小。</p><p>请注意，如果指定了不可能的目标大小值（例如，容量大于整个群集的容量），则会发出健康警告（<code>POOL_TARGET_SIZE_BYTES_OVERCOMMITTED</code>）。</p><p>如果为池指定了<code>target_size_ratio</code>和<code>target_size_bytes</code>，则仅考虑比率，并发出运行状况警告（<code>POOL_HAS_TARGET_SIZE_BYTES_AND_RATIO</code>）。</p><h2 id="7-设置PG的下界"><a href="#7-设置PG的下界" class="headerlink" title="7 设置PG的下界"></a>7 设置PG的下界</h2><p>也可以为一个池指定最小数量的PG。这对于确定执行IO时客户端将看到的并行度的数量的下限很有用，即使池中大多数都是空的。设置下限可以防止Ceph将PG编号减少（或建议减少）到配置的编号以下。</p><p>您可以使用以下方法设置池的最小PG数量：</p><pre><code class="hljs pgsql">ceph osd pool <span class="hljs-keyword">set</span> &lt;pool-<span class="hljs-type">name</span>&gt; pg_num_min &lt;num&gt;</code></pre><p>您还可以使用命令的可选参数在创建池时指定最小PG计数。<code>--pg-num-min &lt;num&gt;``ceph osd pool create</code></p><h2 id="8-获取集群的PG统计信息"><a href="#8-获取集群的PG统计信息" class="headerlink" title="8 获取集群的PG统计信息"></a>8 获取集群的PG统计信息</h2><p>要获取集群中放置组的统计信息，请执行以下操作：</p><pre><code class="hljs dos">ceph pg dump [--<span class="hljs-built_in">format</span> &#123;<span class="hljs-built_in">format</span>&#125;]</code></pre><p>有效格式为<code>plain</code>（默认）和<code>json</code>。</p><h2 id="9-获取卡住的PG的统计信息"><a href="#9-获取卡住的PG的统计信息" class="headerlink" title="9 获取卡住的PG的统计信息"></a>9 获取卡住的PG的统计信息</h2><p>要获取处于指定状态的所有放置组的统计信息，请执行以下操作：</p><pre><code class="hljs coq">ceph pg dump_stuck inactive|<span class="hljs-type">unclean</span>|<span class="hljs-type">stale</span>|<span class="hljs-type">undersized</span>|<span class="hljs-type">degraded</span> [--format &lt;format&gt;] [-t|<span class="hljs-type">--threshold</span> &lt;seconds&gt;]</code></pre><p><strong>inactive</strong>放置组无法处理读写，因为它们正在等待OSD包含最新数据。</p><p><strong>unclean</strong>放置组包含未复制所需次数的对象。他们应该正在恢复。</p><p><strong>stale</strong>放置组处于未知状态-承载它们的OSD暂时未向监视集群报告（由配置<code>mon_osd_report_timeout</code>）。</p><p>有效格式为<code>plain</code>（默认）和<code>json</code>。阈值定义了放置组停留在返回的统计信息中之前所停留的最小秒数（默认为300秒）。</p><h2 id="10-获取PG-Map"><a href="#10-获取PG-Map" class="headerlink" title="10 获取PG Map"></a>10 获取PG Map</h2><p>要获取特定放置组的放置组映射，请执行以下操作：</p><pre><code class="hljs applescript">ceph pg map &#123;pg-<span class="hljs-built_in">id</span>&#125;</code></pre><p>例如：</p><pre><code class="hljs apache"><span class="hljs-attribute">ceph</span> pg map <span class="hljs-number">1</span>.<span class="hljs-number">6</span>c</code></pre><p>Ceph将返回放置组图，放置组和OSD状态：</p><pre><code class="hljs angelscript">osdmap e13 pg <span class="hljs-number">1.6</span>c (<span class="hljs-number">1.6</span>c) -&gt; up [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] acting [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]</code></pre><p>解释一下，这里表示 pg 1.6c被映射到 编号为 [1,0]的两个OSD上。 Acting 表示Acting Set。</p><h2 id="11-获取PG统计信息"><a href="#11-获取PG统计信息" class="headerlink" title="11 获取PG统计信息"></a>11 获取PG统计信息</h2><p>要检索特定放置组的统计信息，请执行以下操作：</p><pre><code class="hljs puppet">ceph <span class="hljs-keyword">pg</span> &#123;pg-<span class="hljs-built_in">id</span>&#125; <span class="hljs-keyword">query</span></code></pre><p> 这里的query其实是一种元数据信息，部分形式如下：</p><pre><code class="hljs clojure">&#123;<span class="hljs-string">&quot;snap_trimq&quot;</span>: <span class="hljs-string">&quot;[]&quot;</span>,    <span class="hljs-string">&quot;snap_trimq_len&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;state&quot;</span>: <span class="hljs-string">&quot;active+clean&quot;</span>,    <span class="hljs-string">&quot;epoch&quot;</span>: <span class="hljs-number">236</span>,    <span class="hljs-string">&quot;up&quot;</span>: [        <span class="hljs-number">1</span>,        <span class="hljs-number">2</span>,        <span class="hljs-number">0</span>    ],    <span class="hljs-string">&quot;acting&quot;</span>: [        <span class="hljs-number">1</span>,        <span class="hljs-number">2</span>,        <span class="hljs-number">0</span>    ],    <span class="hljs-string">&quot;acting_recovery_backfill&quot;</span>: [        <span class="hljs-string">&quot;0&quot;</span>,        <span class="hljs-string">&quot;1&quot;</span>,        <span class="hljs-string">&quot;2&quot;</span>    ],    <span class="hljs-string">&quot;info&quot;</span>: &#123;        <span class="hljs-string">&quot;pgid&quot;</span>: <span class="hljs-string">&quot;1.0&quot;</span>,        <span class="hljs-string">&quot;last_update&quot;</span>: <span class="hljs-string">&quot;223&#x27;23&quot;</span>,        <span class="hljs-string">&quot;last_complete&quot;</span>: <span class="hljs-string">&quot;223&#x27;23&quot;</span>,        <span class="hljs-string">&quot;log_tail&quot;</span>: <span class="hljs-string">&quot;0&#x27;0&quot;</span>,        <span class="hljs-string">&quot;last_user_version&quot;</span>: <span class="hljs-number">23</span>,        <span class="hljs-string">&quot;last_backfill&quot;</span>: <span class="hljs-string">&quot;MAX&quot;</span>,        <span class="hljs-string">&quot;purged_snaps&quot;</span>: [],        <span class="hljs-string">&quot;history&quot;</span>: &#123;            <span class="hljs-string">&quot;epoch_created&quot;</span>: <span class="hljs-number">2</span>,            <span class="hljs-string">&quot;epoch_pool_created&quot;</span>: <span class="hljs-number">2</span>,            <span class="hljs-string">&quot;last_epoch_started&quot;</span>: <span class="hljs-number">221</span>,            <span class="hljs-string">&quot;last_interval_started&quot;</span>: <span class="hljs-number">220</span>,            <span class="hljs-string">&quot;last_epoch_clean&quot;</span>: <span class="hljs-number">221</span>,            <span class="hljs-string">&quot;last_interval_clean&quot;</span>: <span class="hljs-number">220</span>,            <span class="hljs-string">&quot;last_epoch_split&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;last_epoch_marked_full&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;same_up_since&quot;</span>: <span class="hljs-number">220</span>,            <span class="hljs-string">&quot;same_interval_since&quot;</span>: <span class="hljs-number">220</span>,            <span class="hljs-string">&quot;same_primary_since&quot;</span>: <span class="hljs-number">212</span>,            <span class="hljs-string">&quot;last_scrub&quot;</span>: <span class="hljs-string">&quot;189&#x27;21&quot;</span>,            <span class="hljs-string">&quot;last_scrub_stamp&quot;</span>: <span class="hljs-string">&quot;2020-12-14T06:56:57.181447+0800&quot;</span>,            <span class="hljs-string">&quot;last_deep_scrub&quot;</span>: <span class="hljs-string">&quot;189&#x27;20&quot;</span>,            <span class="hljs-string">&quot;last_deep_scrub_stamp&quot;</span>: <span class="hljs-string">&quot;2020-12-13T04:09:17.431508+0800&quot;</span>,            <span class="hljs-string">&quot;last_clean_scrub_stamp&quot;</span>: <span class="hljs-string">&quot;2020-12-14T06:56:57.181447+0800&quot;</span>,            <span class="hljs-string">&quot;prior_readable_until_ub&quot;</span>: <span class="hljs-number">0</span>        &#125;,...&#125;</code></pre><p>我们可以看到很多理论部分讲过的元数据，比如 up 、acting、info、epoch、peer、interval等。<code>snap_trimq</code>表示快照删除队列。</p><p>当前的版本号为236.</p><h2 id="12-Scrub一个放置组"><a href="#12-Scrub一个放置组" class="headerlink" title="12 Scrub一个放置组"></a>12 Scrub一个放置组</h2><p>关于Scrub的含义，我们在《Ceph纠删码部署》已经介绍了，Scrub指数据扫描，通过读取对象数据并重新计算校验和，再与之前存储在对象属性的校验和进行比对，以判断有无静默错误（磁盘自身无法感知的错误）。要Scrub，请执行以下操作：</p><pre><code class="hljs pf">ceph pg <span class="hljs-keyword">scrub</span> &#123;pg-id&#125;</code></pre><p>Ceph检查主节点和任何副本节点，生成放置组中所有对象的目录并进行比较，以确保没有丢失或不匹配的对象，并且它们的内容一致。假设所有副本都匹配，则最终的语义扫描可确保所有与快照相关的对象元数据都是一致的。通过日志报告错误。</p><p>要从特定池中清理所有放置组，请执行以下操作：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>scrub &#123;pool-name&#125;</code></pre><h2 id="12-设置PG-Backfill-Recovery的优先级"><a href="#12-设置PG-Backfill-Recovery的优先级" class="headerlink" title="12 设置PG Backfill/Recovery的优先级"></a>12 设置PG Backfill/Recovery的优先级</h2><p>请注意，这些命令可能会破坏Ceph内部优先级计算的顺序，因此请谨慎使用！特别是，如果您有多个当前共享相同底层OSD的池，并且某些特定的池比其他池更重要，则建议您使用以下命令以更好的顺序重新排列所有池的恢复/回填优先级：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> &#123;pool-name&#125; recovery_priority &#123;value&#125;</code></pre><p>例如，如果您有10个池，则可以将最重要的一个优先级设置为10，下一个9，等等。或者您可以不理会大多数池，而说3个重要的池分别设置为优先级1或优先级3、2、1。</p><p>在恢复或者回填比用户op的优先级更高的时候。我们可以执行：</p><pre><code class="hljs applescript">ceph pg force-recovery &#123;pg-<span class="hljs-built_in">id</span>&#125; [&#123;pg-<span class="hljs-built_in">id</span> <span class="hljs-comment">#2&#125;] [&#123;pg-id #3&#125; ...]</span>ceph pg force-backfill &#123;pg-<span class="hljs-built_in">id</span>&#125; [&#123;pg-<span class="hljs-built_in">id</span> <span class="hljs-comment">#2&#125;] [&#123;pg-id #3&#125; ...]</span></code></pre><p>如果您认为这是一个不好的决定，请使用：</p><pre><code class="hljs applescript">ceph pg cancel-force-recovery &#123;pg-<span class="hljs-built_in">id</span>&#125; [&#123;pg-<span class="hljs-built_in">id</span> <span class="hljs-comment">#2&#125;] [&#123;pg-id #3&#125; ...]</span>ceph pg cancel-force-backfill &#123;pg-<span class="hljs-built_in">id</span>&#125; [&#123;pg-<span class="hljs-built_in">id</span> <span class="hljs-comment">#2&#125;] [&#123;pg-id #3&#125; ...]</span></code></pre><p>这将从这些PG中删除“ force”标志，并将以默认顺序对其进行处理。同样，这不会影响当前正在处理的放置组，只会影响仍在排队的放置组。</p><p>恢复或回填组后，将自动清除“ force”标志。</p><p>同样，您可以使用以下命令强制Ceph首先对指定池中的所有放置组执行恢复或回填：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>force-recovery &#123;pool-name&#125;ceph osd<span class="hljs-built_in"> pool </span>force-backfill &#123;pool-name&#125;</code></pre><p>要么：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>cancel-force-recovery &#123;pool-name&#125;ceph osd<span class="hljs-built_in"> pool </span>cancel-force-backfill &#123;pool-name&#125;</code></pre><p>如果您改变主意，则可以恢复到默认的恢复或回填优先级。</p><h2 id="13-还原丢失"><a href="#13-还原丢失" class="headerlink" title="13 还原丢失"></a>13 还原丢失</h2><p>如果群集丢失了一个或多个对象，并且您决定放弃对丢失数据的搜索，则必须将未找到的对象标记为<code>lost</code>。</p><p>如果已查询所有可能的位置并且仍然丢失了对象，则可能必须放弃丢失的对象。鉴于异常的异常组合使集群能够了解恢复写本身之前执行的写，这是可能的。</p><p>当前唯一受支持的选项是“还原”，它可以回滚到该对象的先前版本，或者（如果是新对象）则完全忘记它。要将“未找到”的对象标记为“丢失”，请执行以下操作：</p><pre><code class="hljs puppet">ceph <span class="hljs-keyword">pg</span> &#123;pg-<span class="hljs-built_in">id</span>&#125; <span class="hljs-keyword">mark_unfound_lost</span> <span class="hljs-keyword">revert</span>|delete</code></pre><div class="note note-danger">            <p>重要：</p><p>请谨慎使用此功能，因为它可能会使期望对象存在的应用程序感到困惑(confused)。</p>          </div><hr><p>EOF</p>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>PG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ceph理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>距离向量路由选择算法——DV</title>
    <link href="/2020/12/15/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95DV/"/>
    <url>/2020/12/15/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95DV/</url>
    
    <content type="html"><![CDATA[<h1 id="DV"><a href="#DV" class="headerlink" title="DV"></a><em>DV</em></h1><p>获取全局的路由信息是代价很高的，我们需要一种分布式的、异步的、迭代的、自我终止的算法，这便是DV（$Distance  vector$），它是路由器中真正运行的算法，直到现在！</p><p>这儿的自我终止指：即没有计算应该停止的信号，它就停止了。</p><p>我们首先讨论最低路径开销之间的一种重要关系。令$d_x(y)$是从节点x到y的最低开销，由著名的Bellman-Ford方程：</p><script type="math/tex; mode=display">d_x(y)=min_v\{c(x,v)+d_v(y)\}</script><p>$c(x,y)$表示x与y之间的边的开销。这正是Dijkstra算法的核心思路。</p><p>我们令$D_x(y)$为节点x到邻近的每一个节点y的<strong>距离向量</strong>。</p><p>每个节点不时的向每个邻居发送它的距离向量副本。当节点x从它任何一个邻居v收到一个新的距离向量，它就保存，然后根据Bellford-man方程更新自己的距离向量，如果自己的距离向量发生改变，那么它向所有邻居广播更新后的距离向量。令人惊奇的是，只要所有节点都异步地交换它们的距离向量，每个开销$D_x(y)$都会收敛到$d_x(y)$!!!</p><p>当然，这样的异步策略也有问题：比如我们有一个这样的图，$c(x,y)=4,c(y,z)=1,c(x,z)=5$,然后在某一时刻c(x,y)变为60.然后节点y重新计算开销$D_y(x)=min\{c(y,x)+D_x(x),c(y,z)+D_z(x)\}=min\{60+0,1+5\}=6$。这显然是不对的。那么这种现象被称为<strong>路由选择环路</strong>，报文会不断在y，z节点循环，他将持续60-6=44次！这个问题有时被称为<strong>无穷计数</strong>。</p><p>除此之外，在DV算法，一个节点可向任何节点通告其不正确的最低路径开销（有意或无意的）,从而导致整个网络发生故障！</p><h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a><em>OSPF</em></h1><p>随着路由器数目变得巨大，涉及路由选择信息的通信计算和存储开销将接近无穷大。为此人们涉及了自治系统（AS）,它在一个ISP中由路由器和链路互联而形成。在一个自治系统内运行的路由算法称为自治系统内部路由选择协议。</p><p>OSPF全称是 Open Shortest Path First 开放最短路优先。OSPF是一种链路状态协议，它使用洪泛链路状态协议以及Dijkstra最低开销路径算法，每台路由器都有整个自治网络的完整拓扑图。由管理员确定各条链路的开销，比如把所有链路开销设为1从而实现最小跳数；或者选择将链路权重与链路容量成反比来配置，不鼓励使用低带宽链路。</p><p>OSPF的优势如下：</p><ol><li>安全。能够鉴别OSPF路由器之间的交换，使用MD5之类的加密算法。</li><li>多条相同开销的路径。</li><li>对单播和多播路由的综合支持。</li><li>支持在单个AS中 的层次结构。</li></ol><h1 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a><em>BGP</em></h1><p>BGP Border Gateway protocol , 边界网关协议是AS间选择协议</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图算法</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小白投资入门（煎炸卤炖）</title>
    <link href="/2020/12/14/%E5%B0%8F%E7%99%BD%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8/"/>
    <url>/2020/12/14/%E5%B0%8F%E7%99%BD%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="小白投资入门（煎炸卤炖）"><a href="#小白投资入门（煎炸卤炖）" class="headerlink" title="小白投资入门（煎炸卤炖）"></a>小白投资入门（煎炸卤炖）</h1><p>写这个博客表明笔者准备开始炒股了，当然任何事情都是万事开头难，希望与君共勉，踩坑。</p><p>假如小Q有1W元，如何投资才能获得最大收益：</p><ol><li>存银行</li><li>炒股</li><li>购买保险</li><li>购买基金</li><li>购买黄金</li><li>购买房地产</li><li>购买期货</li><li>全部换成美元</li><li>全部换成日元</li><li>研究“如何让钱无性生殖”</li></ol><p>上面问题便是笔者写博客的初衷，弄清楚这些问题不是简单是事，除了问题10以外。</p><h1 id="1基本概念"><a href="#1基本概念" class="headerlink" title="1基本概念"></a>1基本概念</h1><p>所谓股票，就是股份制公司发行的所有权凭证。那么公司为什么要发行股票呢？一般是为了凑集资金，非上市公司和上市公司都可以发行股票，只是非上市公司的股票不能在证券交易所交易而已。</p><h2 id="证券"><a href="#证券" class="headerlink" title="证券"></a>证券</h2><p>证券是多种经济权益凭证的统称，有很多分类，比如股票和证券。</p><h2 id="证券交易所"><a href="#证券交易所" class="headerlink" title="证券交易所"></a>证券交易所</h2><p>专门进行证券交易的场所。我国目前有四大证券交易所，分别是1990年11月26日成立的上海证券交易所，简称上交所或者沪市；1990年12月1日成立的深圳证券交易所，简称深交所；此外还有香港证券交易所和成都证券交易所。</p><p>证券交易所本身是一家公司，也可以上市，比如香港证券交易所的股票代码是00388。</p><h2 id="股市"><a href="#股市" class="headerlink" title="股市"></a>股市</h2><p>股市就是股票市场，是已经发行的股票转让、买卖和流通的场所，在我国就是指证券交易所，又称二级市场。</p><h2 id="IPO"><a href="#IPO" class="headerlink" title="IPO"></a>IPO</h2><p>指首次公开募股。通常是新上市的公司第一次发售股票。</p><h2 id="如何炒股？"><a href="#如何炒股？" class="headerlink" title="如何炒股？"></a>如何炒股？</h2><p>炒股时盈亏是兵家常事，但是如果想长期盈利，我们需要掌握正确的投资理念和搭建适合自己的交易体系，并严格指定好交易策略才能实现长期盈利。</p><h2 id="证券公司"><a href="#证券公司" class="headerlink" title="证券公司"></a>证券公司</h2><p>就是专门经营证券交易所的交易商，俗称券商。投资者通过在券商处开设账户从而去交易放在证券交易所的股票。</p><h2 id="证券账户"><a href="#证券账户" class="headerlink" title="证券账户"></a>证券账户</h2><p>我国规定每个投资者最多拥有三个账户。目前有线上和线下两种方式，最常用线上的券商包括【同花顺APP】和【东方财富】。它们的区别是，同花顺本身是一家上市公司，股票代码300033，而不是一家券商。而东方财富本身是一家券商，股票代码300059.</p><h2 id="三方管存"><a href="#三方管存" class="headerlink" title="三方管存"></a>三方管存</h2><p>全称是<strong><em>客户交易结算资金第三方管存</em></strong>，在券商开户时必须指定一张银行卡，买卖股票的资金都通过这个银行账户。</p><h1 id="2-如何看数据"><a href="#2-如何看数据" class="headerlink" title="2 如何看数据"></a>2 如何看数据</h1><h2 id="指数与点数"><a href="#指数与点数" class="headerlink" title="指数与点数"></a>指数与点数</h2><p>指数指金融机构事先制定好规则，选取一部分股票作为样本，按照某种计算方法编制乘的一组数字，目的是为了反映市场情况的变动。</p><ul><li><p>上证指数</p><p>全称【上海证券综合指数】，俗称<strong>大盘</strong>。它是把在上海证券交易所上市的所有股票按照特定的规则编制而成的一个指数，自1991年7月15日开始实时发布，一开始就是100点。其中中石油、中石化称为【两桶油】。银行、证券、保险俗称为【金三胖】。</p></li><li><p>深圳成指</p><p>全称【深圳成分股指数】，代码为399001. 它是取市场上最有代表性的500家公司编制的股票，基点为1000。</p></li><li><p>中小板指</p><p>从深交所中小板上市的所有股票中选取100只编制的股票。代码399005.</p></li><li><p>创业板指</p><p>从深交所创业板上市的所有股票中选取100只编制的股票。代码399006.</p></li><li><p>沪深300</p><p>000300</p></li><li><p>上证50</p><p>000016</p></li><li><p>中证500</p><p>主要挑选沪深两地的中小盘股票，在上海为000905，在深圳为399905.</p></li></ul><p><img src="/img/1607942239006.jpeg" alt="1607942239006"></p><h2 id="板块"><a href="#板块" class="headerlink" title="板块"></a>板块</h2><p>指证券交易所不同的交易市场，目的是支持不同类型的公司。</p><p>上交所包含主板和科创板两个。上交所主板股票代码一般以「600」、「601」或「603」开头。科创板一般以「688」开头，比如「金山办公」为688111.</p><p>深交所包括主板、中小板、创业板三个板块，中小板是专为中小型公司所开设的，创业板与其它板块区别较大，主要是因为公司在创业板上市要求更加宽松，所以上市后股票风险性更大，因而开通创业板必须去线下营业点而且要签一堆风险声明并且录视频。 深市主板代码以「000」开头，中小板以「002」开头，创业板以「300」开头。</p><h2 id="全球"><a href="#全球" class="headerlink" title="全球"></a>全球</h2><p>可以查看全球市场的大概情况，最上面是我国的沪深指数，往下依次是股指期货、汇率指数、全球商品。</p><p>「恒生指数」是香港的，「日经指数」是日本的，「富时A50」是富时指数公司选取中国市值最大的50家公司创建的指数，</p><p>「道琼斯」「纳斯达克」「标普500」是美国的，美股和「富时A50」可以影响A股走势。</p><h2 id="A股"><a href="#A股" class="headerlink" title="A股"></a>A股</h2><p>我国股市的大概情况，有三个板块，「沪深」「板块」「科创板」。</p><p>「沪深」页面最上面的上证指数、深证成指和创业板是我国A股最主要的三个指数，下面是市场概况，全部股票的涨停比例和跌停涨停比，再往下是股票排行，比如涨幅榜和跌幅榜等。</p><p>「板块」主要显示行业板块的情况，最上面是涨幅前三名的板块和跌幅前三名的板块。其中第三个页面是「创业板」，这个板块是2019年刚刚创立的，主要是支持我国科技创新的发展，对投资者而言具有较高的<strong>门槛</strong>和较大的<strong>风险</strong>。</p><h2 id="交易界面"><a href="#交易界面" class="headerlink" title="交易界面"></a>交易界面</h2><p>我们可以看到账户情况，比如总资产、浮动盈亏和当日盈亏等情况，也可以买入、卖出、撤单、持仓和查询，申购新股、国债逆回购、可转债、银证转账等功能</p><p>那么我们如何进行交易呢？</p><ul><li>通过搜索或自选解码进入股票的详情页面</li><li>点击最下面的「下单」按钮，有「分时下单」和「交易下单」两种。默认为「分时下单」。</li><li>点击「买」按钮，再次跳出新的买卖页面。</li><li>设定好合适价格，输入想要买入的数量，然后点击最下面的红色「买入」按钮。</li><li>最后会跳出询问页面，确认之前提交的信息是否有误等。点击「确认买入」</li></ul><h2 id="股市开市时间及股票交易费用"><a href="#股市开市时间及股票交易费用" class="headerlink" title="股市开市时间及股票交易费用"></a>股市开市时间及股票交易费用</h2><p>我国A股交易时间为周一至周五上午9：30-11：30，下午13：00-15：00， 其中9：15-9：25，下午14：57-15：00是集合竞价的时间，具体概念我们后面再讲。</p><p>股票交易一般包含以下几种费用：</p><ul><li>佣金：券商收取，买卖都要收，每笔最低5元，如果超过后则按万分之3或万分之2.5.</li><li>印花税：国税局收取，卖出股票时收取，比例为成交金额的0.1%</li><li>过户费：上交所收取，交易沪市股票时收取，为成交金额的0.002%。</li><li>规费：视券商而定。</li></ul><h2 id="K线"><a href="#K线" class="headerlink" title="K线"></a>K线</h2><p>k线图又称为蜡烛图、日本线、阴阳线。它源于日本德川幕府时代。它是一个竖着的长方体，如下图所示。</p><p><img src="/img/1607943017765.jpeg" alt="1607943017765" style="zoom:67%;" /></p><p>如果上影线较长，上方抛压较大，股价上涨后又被砸了回来，有长下影线则表示下方买盘较强，股价跌了下去又被买了回来。红色表示阳K线，绿色表示阴K线。红表示涨，即开盘价小于收盘价，绿表示跌。</p><p><img src="/img/1607943072426.jpeg" alt="1607943072426"></p><p><strong>注意不要把技术指标当作买卖的标准。</strong></p><p>我们有【假阴线】和【假阳线】两种说法，假阳线指收盘价比前一根K线的收盘价要低。假阳线表示收盘价全部比各自前一天的收盘价要高</p><p><img src="/img/v2-e6d2b7984a2228522f4012c2af96436e.jpg" alt="v2-e6d2b7984a2228522f4012c2af96436e"></p><h2 id="均线"><a href="#均线" class="headerlink" title="均线"></a>均线</h2><h2 id="成交量"><a href="#成交量" class="headerlink" title="成交量"></a>成交量</h2><h2 id="MACD"><a href="#MACD" class="headerlink" title="MACD"></a>MACD</h2>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>股票</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「参考」Ceph Pool</title>
    <link href="/2020/12/14/ceph%20pool/"/>
    <url>/2020/12/14/ceph%20pool/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本期主要介绍Ceph pool的操作，需要您事先部署成功Ceph集群！</p><p>主要参考<a href="https://docs.ceph.com/en/latest/rados/operations/pools/">官方pool教程</a>。</p>          </div><h1 id="Ceph-pool"><a href="#Ceph-pool" class="headerlink" title="Ceph pool"></a>Ceph pool</h1><p>池是用于存储对象的逻辑分区。</p><p>当首次部署群集而不创建池时，Ceph使用默认池来存储数据。pool具有以下特性：</p><ul><li><strong>弹性</strong>：可以设置允许多少OSD发生故障而不丢失数据。对于复制池，它是对象的所需副本数/副本数。典型的配置存储一个对象和一个附加副本（即<code>size=2</code>），但是您可以确定副本/副本的数量。对于<a href="https://docs.ceph.com/en/latest/rados/operations/erasure-code">纠删码池</a>，它是编码块的数量<code>m=2</code></li><li><strong>放置组</strong>(PG)：可以设置池的放置组数。一个典型的配置每个OSD使用大约100个放置组，以提供最佳的平衡，而不会消耗太多的计算资源。设置多个池时，请确保为池和整个群集设置合理数量的放置组。</li><li><strong>CRUSH规则</strong>：将数据存储在池中时，对象及其副本（或用于纠删码池的块）在群集中的位置由CRUSH规则控制。如果默认规则不适用于您的用例，则可以为池创建自定义的CRUSH规则。</li><li><strong>快照</strong>：使用创建快照时，可以有效地为特定池拍摄快照。<code>ceph osd pool mksnap</code></li></ul><p>要列出群集的池，请执行：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph osd lspools</span></code></pre><h2 id="1-创建一个池"><a href="#1-创建一个池" class="headerlink" title="1 创建一个池"></a>1 创建一个池</h2><p>在创建池之前，我们有必要修改Ceph配置文件，它位于<code>\etc\ceph.conf</code>，典型的ceph配置文件如下：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>create &#123;pool-name&#125; [&#123;pg-num&#125; [&#123;pgp-num&#125;]] [replicated] \     [crush-rule-name] [expected-num-objects]ceph osd<span class="hljs-built_in"> pool </span>create &#123;pool-name&#125; [&#123;pg-num&#125; [&#123;pgp-num&#125;]]   erasure \     [erasure-code-profile] [crush-rule-name] [expected_num_objects] [<span class="hljs-attribute">--autoscale-mode</span>=&lt;on,off,warn&gt;]</code></pre><p>我们对几个比较重要的参数进行讲解：</p><ul><li><code>replicated|erasure</code></li></ul><p>官方有这样一句话。副本池需要更多的空间但是实现了Ceph所有操作，而纠删码池只实现了一部分的功能。主要是因为纠删码不支持omap，所以只能采用FileStore。</p><p>实例：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>create ecpool erasure</code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="2-将池关联到应用程序"><a href="#2-将池关联到应用程序" class="headerlink" title="2 将池关联到应用程序"></a>2 将池关联到应用程序</h2><p>池在使用前需要与应用程序关联。将与CephFS一起使用的池或RGW自动创建的池自动关联。打算与RBD一起使用的池应使用该<code>rbd</code>工具进行初始化（有关更多信息，请参见<a href="https://docs.ceph.com/en/latest/rbd/rados-rbd-cmds/#create-a-block-device-pool">块设备命令</a>）。</p><p>对于其他情况，您可以手动将自由格式的应用程序名称关联到池。</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>application <span class="hljs-builtin-name">enable</span> &#123;pool-name&#125; &#123;application-name&#125;</code></pre><p>提示：</p><p>CephFS使用应用程序名称<code>cephfs</code>，RBD使用应用程序名称<code>rbd</code>，而RGW使用应用程序名称<code>rgw</code>。</p><h2 id="3-设置池配额"><a href="#3-设置池配额" class="headerlink" title="3 设置池配额"></a>3 设置池配额</h2><p>您可以将池配额设置为每个池的最大字节数和/或最大对象数。</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">pool </span><span class="hljs-built_in">set-quota</span> &#123;<span class="hljs-string">pool-name&#125;</span> [<span class="hljs-string">max_objects </span>&#123;<span class="hljs-string">obj-count&#125;</span>] [<span class="hljs-string">max_bytes </span>&#123;<span class="hljs-string">bytes&#125;</span>]</code></pre><p>例如：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">pool </span><span class="hljs-built_in">set-quota</span> <span class="hljs-string">data </span><span class="hljs-string">max_objects </span><span class="hljs-string">10000</span></code></pre><p>要删除配额，请将其值设置为<code>0</code>。</p><h2 id="4-删除池"><a href="#4-删除池" class="headerlink" title="4 删除池"></a>4 删除池</h2><p>要删除池，请执行：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>delete &#123;pool-name&#125; [&#123;pool-name&#125; --yes-i-really-really-mean-it]</code></pre><p>要删除池，必须在Monitor的配置中将mon_allow_pool_delete标志设置为true。否则，他们将拒绝删除池。</p><p>有关更多信息，请参见<a href="https://docs.ceph.com/en/latest/rados/configuration/mon-config-ref">Monitor Configuration</a>。</p><p>如果您为自己创建的池创建了自己的规则，则在不再需要池时应考虑删除它们：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">get</span> &#123;pool-name&#125; crush_rule</code></pre><p>例如，如果规则是“ 123”，则可以像这样检查其他池：</p><pre><code class="hljs gradle">ceph osd <span class="hljs-keyword">dump</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;^pool&quot;</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;crush_rule 123&quot;</span></code></pre><p>通过ceph osd dump可以查看monitor的映射信息，包括epoch，fsid和crush rule等。返回结果如下</p><pre><code class="hljs pgsql">pool <span class="hljs-number">1</span> <span class="hljs-string">&#x27;device_health_metrics&#x27;</span> replicated size <span class="hljs-number">3</span> min_size <span class="hljs-number">2</span> crush_rule <span class="hljs-number">0</span> object_hash rjenkins pg_num <span class="hljs-number">1</span> pgp_num <span class="hljs-number">1</span> autoscale_mode <span class="hljs-keyword">on</span> last_change <span class="hljs-number">13</span> flags hashpspool stripe_width <span class="hljs-number">0</span> pg_num_min <span class="hljs-number">1</span> application mgr_devicehealthpool <span class="hljs-number">2</span> <span class="hljs-string">&#x27;cephfs_data&#x27;</span> replicated size <span class="hljs-number">3</span> min_size <span class="hljs-number">2</span> crush_rule <span class="hljs-number">0</span> object_hash rjenkins pg_num <span class="hljs-number">32</span> pgp_num <span class="hljs-number">32</span> autoscale_mode <span class="hljs-keyword">on</span> last_change <span class="hljs-number">17</span> flags hashpspool stripe_width <span class="hljs-number">0</span> application cephfspool <span class="hljs-number">3</span> <span class="hljs-string">&#x27;cephfs_metadata&#x27;</span> replicated size <span class="hljs-number">3</span> min_size <span class="hljs-number">2</span> crush_rule <span class="hljs-number">0</span> object_hash rjenkins pg_num <span class="hljs-number">32</span> pgp_num <span class="hljs-number">32</span> autoscale_mode <span class="hljs-keyword">on</span> last_change <span class="hljs-number">18</span> flags hashpspool stripe_width <span class="hljs-number">0</span> pg_autoscale_bias <span class="hljs-number">4</span> pg_num_min <span class="hljs-number">16</span> recovery_priority <span class="hljs-number">5</span> application cephfspool <span class="hljs-number">4</span> <span class="hljs-string">&#x27;ecpool&#x27;</span> erasure profile toy_ec size <span class="hljs-number">3</span> min_size <span class="hljs-number">2</span> crush_rule <span class="hljs-number">1</span> object_hash rjenkins pg_num <span class="hljs-number">16</span> pgp_num <span class="hljs-number">16</span> autoscale_mode <span class="hljs-keyword">on</span> last_change <span class="hljs-number">65</span> flags hashpspool,ec_overwrites stripe_width <span class="hljs-number">8192</span> application rgw</code></pre><p>如果没有其他池使用该自定义规则，则可以从群集中删除该规则。</p><p>如果您创建的用户严格地具有不再存在的池的权限，则也应该考虑删除这些用户：</p><pre><code class="hljs dust"><span class="xml">ceph auth ls | grep -C 5 </span><span class="hljs-template-variable">&#123;pool-name&#125;</span><span class="xml">ceph auth del </span><span class="hljs-template-variable">&#123;user&#125;</span></code></pre><h2 id="5-重命名池"><a href="#5-重命名池" class="headerlink" title="5 重命名池"></a>5 重命名池</h2><p>要重命名池，请执行：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>rename &#123;current-pool-name&#125; &#123;new-pool-name&#125;</code></pre><p>如果重命名池，并且您具有针对经过身份验证的用户的每个池功能，则必须使用新的池名称更新用户的功能（即上限）。</p><h2 id="6-显示池统计信息"><a href="#6-显示池统计信息" class="headerlink" title="6 显示池统计信息"></a>6 显示池统计信息</h2><p>要显示池的利用率统计信息，请执行：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">rados df</span></code></pre><p>返回如下</p><pre><code class="hljs apache"><span class="hljs-attribute">POOL_NAME</span>                 USED  OBJECTS  CLONES  COPIES  MISSING_ON_PRIMARY  UNFOUND  DEGRADED  RD_OPS       RD  WR_OPS      WR  USED COMPR  UNDER COMPR<span class="hljs-attribute">cephfs_data</span>                <span class="hljs-number">0</span> B        <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>                   <span class="hljs-number">0</span>        <span class="hljs-number">0</span>         <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> B       <span class="hljs-number">0</span>     <span class="hljs-number">0</span> B         <span class="hljs-number">0</span> B          <span class="hljs-number">0</span> B<span class="hljs-attribute">cephfs_metadata</span>        <span class="hljs-number">156</span> KiB       <span class="hljs-number">22</span>       <span class="hljs-number">0</span>      <span class="hljs-number">66</span>                   <span class="hljs-number">0</span>        <span class="hljs-number">0</span>         <span class="hljs-number">0</span>     <span class="hljs-number">362</span>  <span class="hljs-number">382</span> KiB      <span class="hljs-number">70</span>  <span class="hljs-number">24</span> KiB         <span class="hljs-number">0</span> B          <span class="hljs-number">0</span> B<span class="hljs-attribute">device_health_metrics</span>   <span class="hljs-number">15</span> KiB        <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">3</span>                   <span class="hljs-number">0</span>        <span class="hljs-number">0</span>         <span class="hljs-number">0</span>      <span class="hljs-number">17</span>   <span class="hljs-number">17</span> KiB      <span class="hljs-number">19</span>  <span class="hljs-number">19</span> KiB         <span class="hljs-number">0</span> B          <span class="hljs-number">0</span> B<span class="hljs-attribute">ecpool</span>                  <span class="hljs-number">12</span> KiB        <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">3</span>                   <span class="hljs-number">0</span>        <span class="hljs-number">0</span>         <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> B       <span class="hljs-number">3</span>   <span class="hljs-number">3</span> KiB         <span class="hljs-number">0</span> B          <span class="hljs-number">0</span> B<span class="hljs-attribute">total_objects</span>    <span class="hljs-number">24</span><span class="hljs-attribute">total_used</span>       <span class="hljs-number">3</span>.<span class="hljs-number">0</span> GiB<span class="hljs-attribute">total_avail</span>      <span class="hljs-number">57</span> GiB<span class="hljs-attribute">total_space</span>      <span class="hljs-number">60</span> GiB</code></pre><p>此外，要获取特定池或全部池的I / O信息，请执行以下操作：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>stats [&#123;pool-name&#125;]</code></pre><h2 id="7-制作池快照"><a href="#7-制作池快照" class="headerlink" title="7 制作池快照"></a>7 制作池快照</h2><p>要制作池的快照，请执行：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>mksnap &#123;pool-name&#125; &#123;snap-name&#125;</code></pre><h2 id="8-删除池快照"><a href="#8-删除池快照" class="headerlink" title="8 删除池快照"></a>8 删除池快照</h2><p>要删除池的快照，请执行：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span>rmsnap &#123;pool-name&#125; &#123;snap-name&#125;</code></pre><h2 id="9-设置对象副本数"><a href="#9-设置对象副本数" class="headerlink" title="9 设置对象副本数"></a>9 设置对象副本数</h2><p>要设置复制池上对象副本的数量，请执行以下操作：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> &#123;poolname&#125; size &#123;num-replicas&#125;</code></pre><div class="note note-danger">            <p>重要</p><p><code>{num-replicas}</code>包括所述对象本身。如果您需要该对象和该对象的两个副本，以总共三个对象的实例，请指定<code>3</code>。</p>          </div><p>例如：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> data size 3</code></pre><p>您可以为每个池执行此命令。<strong>注意：</strong>对象在降级模式下接受的I / O可能少于副本。要设置I / O所需的最小副本数，应使用该设置。例如：<code>pool size``min_size</code></p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> data min_size 2</code></pre><p>这样可以确保数据池中的任何对象都不会收到少于<code>min_size</code>副本的I / O。</p><h2 id="10-获取对象副本数"><a href="#10-获取对象副本数" class="headerlink" title="10 获取对象副本数"></a>10 获取对象副本数</h2><p>要获取对象副本的数量，请执行以下操作：</p><pre><code class="hljs gradle">ceph osd <span class="hljs-keyword">dump</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;replicated size&#x27;</span></code></pre><p>Ceph将列出池，并突出显示该属性。默认情况下，ceph创建一个对象的两个副本（共三个副本，或3个大小）。<code>replicated size</code></p><h2 id="11-池值"><a href="#11-池值" class="headerlink" title="11 池值"></a>11 池值</h2><p>要将值设置为池，请执行以下操作：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> &#123;pool-name&#125; &#123;key&#125; &#123;value&#125;</code></pre><p>您可以为以下键设置值：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">compression_algorithm</span></code></pre><ul><li><p>描述</p><p>设置用于基础BlueStore的内联压缩算法。此设置将覆盖<a href="https://docs.ceph.com/en/latest/rados/configuration/bluestore-config-ref/#inline-compression">全局设置</a>的。<code>bluestore compression algorithm</code></p></li><li><p>类型</p><p>串</p></li><li><p>有效设定</p><p><code>lz4</code>，<code>snappy</code>，<code>zlib</code>，<code>zstd</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">compression_mode</span></code></pre><ul><li><p>描述</p><p>为基础BlueStore设置嵌入式压缩算法的策略。此设置将覆盖<a href="http://docs.ceph.com/en/latest/rados/configuration/bluestore-config-ref/#inline-compression">全局设置</a>的。<code>bluestore compression mode</code></p></li><li><p>类型</p><p>串</p></li><li><p>有效设定</p><p><code>none</code>，<code>passive</code>，<code>aggressive</code>，<code>force</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">compression_min_blob_size</span></code></pre><ul><li><p>描述</p><p>小于此大小的块永远不会被压缩。此设置将覆盖<a href="http://docs.ceph.com/en/latest/rados/configuration/bluestore-config-ref/#inline-compression">全局设置</a>的。<code>bluestore compression min blob *</code></p></li><li><p>类型</p><p>无符号整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">compression_max_blob_size</span></code></pre><ul><li><p>描述</p><p>大于此的块<code>compression_max_blob_size</code>在压缩之前会分解为较小的斑点大小 。</p></li><li><p>类型</p><p>无符号整数</p></li></ul><pre><code class="hljs arduino"><span class="hljs-built_in">size</span></code></pre><ul><li><p>描述</p><p>设置池中对象的副本数。有关更多详细信息，请参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#set-the-number-of-object-replicas">设置对象副本数</a>。仅复制池。</p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">min_size</span></code></pre><ul><li><p>描述</p><p>设置I / O所需的最小副本数。有关更多详细信息，请参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#set-the-number-of-object-replicas">设置对象副本数</a>。对于擦除编码池，应将其设置为大于“ k”的值，因为如果我们将IO的值设置为“ k”，则不会出现冗余，并且如果OSD永久性故障，数据将会丢失。有关更多信息，请参见<a href="https://docs.ceph.com/en/latest/rados/operations/erasure-code">擦除代码</a></p></li><li><p>类型</p><p>整数</p></li><li><p>版</p><p><code>0.54</code> 以上</p></li></ul><pre><code class="hljs pgsql">pg_num</code></pre><ul><li><p>描述</p><p>计算数据放置时要使用的放置组的有效数量。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>优于<code>pg_num</code>当前值。</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">pgp_num</span></code></pre><ul><li><p>描述</p><p>计算数据放置时要使用的放置的有效放置组数。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>等于或小于<code>pg_num</code>。</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">crush_rule</span></code></pre><ul><li><p>描述</p><p>用于在集群中映射对象放置的规则。</p></li><li><p>类型</p><p>串</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">allow_ec_overwrites</span></code></pre><ul><li><p>描述</p><p>是否写入擦除代码池可以更新对象的一部分，因此cephfs和rbd可以使用它。有关更多详细信息，请参见 <a href="https://docs.ceph.com/en/latest/rados/operations/erasure-code#erasure-coding-with-overwrites">带覆盖的擦除编码</a>。</p></li><li><p>类型</p><p>布尔型</p></li><li><p>版</p><p><code>12.2.0</code> 以上</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hashpspool</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置HASHPSPOOL标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">nodelete</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置NODELETE标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li><li><p>版</p><p>版 <code>FIXME</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">nopgchange</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置NOPGCHANGE标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li><li><p>版</p><p>版 <code>FIXME</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">nosizechange</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置NOSIZECHANGE标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li><li><p>版</p><p>版 <code>FIXME</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">write_fadvise_dontneed</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置WRITE_FADVISE_DONTNEED标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">noscrub</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置NOSCRUB标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">nodeep-scrub</span></code></pre><ul><li><p>描述</p><p>在给定的池上设置/取消设置NODEEP_SCRUB标志。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>1个设置标志，0个未设置标志</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_type</span></code></pre><ul><li><p>描述</p><p>对高速缓存池启用命中集跟踪。有关其他信息，请参见<a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom Filter</a>。</p></li><li><p>类型</p><p>串</p></li><li><p>有效设定</p><p><code>bloom</code>，<code>explicit_hash</code>，<code>explicit_object</code></p></li><li><p>默认</p><p><code>bloom</code>。其他值用于测试。</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_count</span></code></pre><ul><li><p>描述</p><p>要为高速缓存池存储的命中集的数量。该数字越高，<code>ceph-osd</code>守护程序消耗的RAM就越多。</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p><code>1</code>。代理尚未处理&gt; 1。</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_period</span></code></pre><ul><li><p>描述</p><p>高速缓存池的命中设置周期的持续时间（以秒为单位）。该数字越高，<code>ceph-osd</code>守护程序消耗的RAM就越多 。</p></li><li><p>类型</p><p>整数</p></li><li><p>例</p><p><code>3600</code> 1小时</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_fpp</span></code></pre><ul><li><p>描述</p><p><code>bloom</code>匹配集类型的误报概率。有关其他信息，请参见<a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom Filter</a>。</p></li><li><p>类型</p><p>双</p></li><li><p>有效范围</p><p>0.0-1.0</p></li><li><p>默认</p><p><code>0.05</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_target_dirty_ratio</span></code></pre><ul><li><p>描述</p><p>在缓存分层代理将其刷新到后备存储池之前，包含修改后的（脏）对象的缓存池的百分比。</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>.4</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_target_dirty_high_ratio</span></code></pre><ul><li><p>描述</p><p>在缓存分层代理将其以较高速度刷新到后备存储池之前，包含修改后的（脏）对象的缓存池的百分比。</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>.6</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_target_full_ratio</span></code></pre><ul><li><p>描述</p><p>在缓存分层代理将其从缓存池中驱逐之前，包含未修改（干净）对象的缓存池的百分比。</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>.8</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">target_max_bytes</span></code></pre><ul><li><p>描述</p><p><code>max_bytes</code>触发阈值时，Ceph将开始刷新或逐出对象 。</p></li><li><p>类型</p><p>整数</p></li><li><p>例</p><p><code>1000000000000</code> ＃1-TB</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">target_max_objects</span></code></pre><ul><li><p>描述</p><p><code>max_objects</code>触发阈值时，Ceph将开始刷新或逐出对象 。</p></li><li><p>类型</p><p>整数</p></li><li><p>例</p><p><code>1000000</code> ＃1M个对象</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_grade_decay_rate</span></code></pre><ul><li><p>描述</p><p>两个连续命中点之间的温度衰减率</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>0-100</p></li><li><p>默认</p><p><code>20</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_search_last_n</span></code></pre><ul><li><p>描述</p><p>计算hit_sets中最多N个出现以进行温度计算</p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>0-hit_set_count</p></li><li><p>默认</p><p><code>1</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_min_flush_age</span></code></pre><ul><li><p>描述</p><p>缓存分层代理将对象从缓存池刷新到存储池之前的时间（以秒为单位）。</p></li><li><p>类型</p><p>整数</p></li><li><p>例</p><p><code>600</code> 10分钟</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_min_evict_age</span></code></pre><ul><li><p>描述</p><p>缓存分层代理将对象从缓存池中逐出之前的时间（以秒为单位）。</p></li><li><p>类型</p><p>整数</p></li><li><p>例</p><p><code>1800</code> 30分钟</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">fast_read</span></code></pre><ul><li><p>描述</p><p>在擦除编码池上，如果打开此标志，则读取请求将对所有分片发出子读取，并等待直到接收到足够的分片以解码以服务于客户端。对于jerasure和isaerasure插件，一旦返回第一个K答复，就会使用从这些答复中解码的数据立即满足客户的请求。这有助于权衡一些资源以获得更好的性能。当前，仅擦除编码池支持此标志。</p></li><li><p>类型</p><p>布尔型</p></li><li><p>默认值</p><p><code>0</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">scrub_min_interval</span></code></pre><ul><li><p>描述</p><p>负载低时最小时间间隔（以秒为单位）。如果为0，则使用config中的osd_scrub_min_interval值。</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>0</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">scrub_max_interval</span></code></pre><ul><li><p>描述</p><p>池清理的最大时间间隔（以秒为单位），与群集负载无关。如果为0，则使用config中的osd_scrub_max_interval值。</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>0</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">deep_scrub_interval</span></code></pre><ul><li><p>描述</p><p>池“深度”清理的时间间隔（以秒为单位）。如果为0，则使用config中的osd_deep_scrub_interval值。</p></li><li><p>类型</p><p>双</p></li><li><p>默认</p><p><code>0</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">recovery_priority</span></code></pre><ul><li><p>描述</p><p>设置值后，它将增加或减少计算出的预留优先级。此值的范围必须在-10到10之间。对于不太重要的池，请使用负优先级，以使它们的优先级低于任何新池。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>0</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">recovery_op_priority</span></code></pre><ul><li><p>描述</p><p>指定该池的恢复操作优先级，而不要指定<code>osd_recovery_op_priority</code>。</p></li><li><p>类型</p><p>整数</p></li><li><p>默认</p><p><code>0</code></p></li></ul><h2 id="12-获取池值"><a href="#12-获取池值" class="headerlink" title="12 获取池值"></a>12 获取池值</h2><p>要从池中获取值，请执行以下操作：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">get</span> &#123;pool-name&#125; &#123;key&#125;</code></pre><p>您可能会获得以下键的值：</p><pre><code class="hljs arduino"><span class="hljs-built_in">size</span></code></pre><ul><li><p>描述</p><p>看<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#size">大小</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">min_size</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#min-size">min_size</a></p></li><li><p>类型</p><p>整数</p></li><li><p>版</p><p><code>0.54</code> 以上</p></li></ul><pre><code class="hljs pgsql">pg_num</code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#pg-num">pg_num</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">pgp_num</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#pgp-num">pgp_num</a></p></li><li><p>类型</p><p>整数</p></li><li><p>有效范围</p><p>等于或小于<code>pg_num</code>。</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">crush_rule</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#crush-rule">rush_rule</a></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_type</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#hit-set-type">hit_set_type</a></p></li><li><p>类型</p><p>串</p></li><li><p>有效设定</p><p><code>bloom</code>，<code>explicit_hash</code>，<code>explicit_object</code></p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_count</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#hit-set-count">hit_set_count</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_period</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#hit-set-period">hit_set_period</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">hit_set_fpp</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#hit-set-fpp">hit_set_fpp</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_target_dirty_ratio</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#cache-target-dirty-ratio">cache_target_dirty_ratio</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_target_dirty_high_ratio</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#cache-target-dirty-high-ratio">cache_target_dirty_high_ratio</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_target_full_ratio</span></code></pre><ul><li><p>描述</p><p>请参阅<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#cache-target-full-ratio">cache_target_full_ratio</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">target_max_bytes</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#target-max-bytes">target_max_bytes</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">target_max_objects</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#target-max-objects">target_max_objects</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_min_flush_age</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#cache-min-flush-age">cache_min_flush_age</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">cache_min_evict_age</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#cache-min-evict-age">cache_min_evict_age</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">fast_read</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#fast-read">fast_read</a></p></li><li><p>类型</p><p>布尔型</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">scrub_min_interval</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#scrub-min-interval">scrub_min_interval</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">scrub_max_interval</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#scrub-max-interval">scrub_max_interval</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">deep_scrub_interval</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#deep-scrub-interval">deep_scrub_interval</a></p></li><li><p>类型</p><p>双</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">allow_ec_overwrites</span></code></pre><ul><li><p>描述</p><p>参见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#allow-ec-overwrites">allow_ec_overwrites</a></p></li><li><p>类型</p><p>布尔型</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">recovery_priority</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#recovery-priority">recovery_priority</a></p></li><li><p>类型</p><p>整数</p></li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">recovery_op_priority</span></code></pre><ul><li><p>描述</p><p>见<a href="https://docs.ceph.com/en/latest/rados/operations/pools/#recovery-op-priority">recovery_op_priority</a></p></li><li><p>类型</p><p>整数</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ceph实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kNN算法实现人脸识别</title>
    <link href="/2020/12/12/kNN%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <url>/2020/12/12/kNN%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="kNN算法实现人脸识别"><a href="#kNN算法实现人脸识别" class="headerlink" title="kNN算法实现人脸识别"></a>kNN算法实现人脸识别</h1><blockquote><p>代表论文：</p><p><a href="http://www.stanford.edu/~hastie/Papers/dann_IEEE.pdf">http://www.stanford.edu/~hastie/Papers/dann_IEEE.pdf</a></p></blockquote><p>kNN算法属于监督学习，而且是一种典型的“懒惰学习算法”，kNN算法流程如下：</p><p>  1）算距离：给定测试对象，计算它与训练集中的每个对象的距离<br>  2）找邻居：圈定距离最近的k个训练对象，作为测试对象的近邻<br>  3）做分类：根据这k个近邻归属的主要类别，来对测试对象分类</p><script type="math/tex; mode=display">d(x,y) = \sqrt{\sum\limits_{i=1}^{n}(x_i-y_i)^2}</script><p>k太小，分类结果易受噪声点影响；k太大，近邻中又可能包含太多的其它类别的点。（对距离加权，可以降低k值设定的影响）<br>k值通常是采用交叉检验来确定（以k=1为基准）<br>经验规则：k一般低于训练样本数的平方根</p><p>1、优点<br>简单，易于理解，易于实现，无需估计参数，无需训练<br>适合对稀有事件进行分类（例如当流失率很低时，比如低于0.5%，构造流失预测模型）<br>特别适合于多分类问题(multi-modal,对象具有多个类别标签)，例如根据基因特征来判断其功能分类，kNN比SVM的表现要好</p><p>2、缺点<br>懒惰算法，对测试样本分类时的计算量大，内存开销大，评分慢<br>可解释性较差，无法给出决策树那样的规则</p><h2 id="人脸识别指标"><a href="#人脸识别指标" class="headerlink" title="人脸识别指标"></a>人脸识别指标</h2><p>虽然跑库的时候我们一般还是看Accuracy或者Recall，不过其实实际应用的时候更多的是会用TAR(True Accept Rate)和FAR(False Accept Rate)。</p><p><img src="https://www.zhihu.com/equation?tex=FAR+%3D+%5Cfrac%7B%E9%9D%9E%E5%90%8C%E4%BA%BA%E5%88%86%E6%95%B0%3ET%7D%7B%E9%9D%9E%E5%90%8C%E4%BA%BA%E6%AF%94%E8%BE%83%E7%9A%84%E6%AC%A1%E6%95%B0%7D++%5C%5C" alt="[公式]"></p><p>这个指标的意思是我们拿一对不同的人的照片去测试的时候，如果两个人的特征向量之差超过了设定的阈值（也就是把这两个人认成了同一个人）的次数比上所有不同的人的pairs的对比次数。也就是把不同的人识别成同一个人的概率啦。当然是越小越好</p><p>那么TAR则是表示正确接受的比例。就是同一个人的照片被判别为同一个人的概率。</p><p><img src="https://www.zhihu.com/equation?tex=TAR+%3D+%5Cfrac%7B%E5%90%8C%E4%BA%BA%E5%88%86%E6%95%B0%3ET%7D%7B%E5%90%8C%E4%BA%BA%E6%AF%94%E8%BE%83%E7%9A%84%E6%AC%A1%E6%95%B0%7D+%5C%5C" alt="[公式]"></p><p>一般我们会计算的是在FAR为多少（比如 <img src="https://www.zhihu.com/equation?tex=10%5E%7B-3%7D" alt="[公式]"> ）的情况下TAR为多少</p><p><img src="https://img2018.cnblogs.com/blog/1011838/201901/1011838-20190123203347054-1083715070.png" alt="sklearn算法选择"></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p><strong>1.最小-最大规范化</strong><br>最小-最大规范化对原始数据进行线性变换，变换到[0,1]区间（也可以是其他固定最小最大值的区间）</p><p><em>x[n] = (x[n] - min) / (max - min)</em></p><p><strong>2. 标准化（Standardization or Mean Removal and Variance Scaling)</strong><br>变换后各维特征有0均值，单位方差。也叫z-score规范化（零均值规范化）。计算方式是将特征值减去均值，除以标准差。</p><p><em>x[n] = (x[n] - mean) / stdev</em></p><p><strong>3. L2-Normalization ( 人脸识别中会用到 )</strong><br>Normalization主要思想是对每个样本计算其p-范数，然后对该样本中每个元素除以该范数，这样处理的结果是使得每个处理后样本的p-范数（l1-norm,l2-norm）等于1。<br>p-范数的计算公式：<em>||X||p = ( |x1|^p + |x2|^p +…+ |xn|^p ）^1/p</em><br>该方法主要应用于文本分类和聚类中。例如，对于两个TF-IDF向量的l2-norm进行点积，就可以得到这两个向量的余弦相似性。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「研究向」Redis中跳表实现原理</title>
    <link href="/2020/12/01/%E3%80%90%E7%A0%94%E7%A9%B6%E5%90%91%E3%80%91Redis%E4%B8%AD%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2020/12/01/%E3%80%90%E7%A0%94%E7%A9%B6%E5%90%91%E3%80%91Redis%E4%B8%AD%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="跳表-SkipList的实现原理"><a href="#跳表-SkipList的实现原理" class="headerlink" title="跳表 SkipList的实现原理"></a>跳表 SkipList的实现原理</h1><h2 id="XII-跳跃表（Skip-list）实现排序"><a href="#XII-跳跃表（Skip-list）实现排序" class="headerlink" title="XII 跳跃表（Skip list）实现排序"></a>XII 跳跃表（Skip list）实现排序</h2><blockquote><h4 id="1206-设计跳表-这一题可以帮助我们快速理解跳表原理。"><a href="#1206-设计跳表-这一题可以帮助我们快速理解跳表原理。" class="headerlink" title="1206. 设计跳表  这一题可以帮助我们快速理解跳表原理。"></a><a href="https://leetcode-cn.com/problems/design-skiplist/">1206. 设计跳表  </a>这一题可以帮助我们快速理解跳表原理。</h4><p>这种数据结构是由<a href="https://en.wikipedia.org/wiki/William_Pugh">William Pugh</a>发明的，最早出现于他在1990年发表的论文《<a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>》</p></blockquote><p>跳跃表是一种<strong>随机化</strong>的数据结构，基于<strong>并联</strong>的链表，其效率相当于二叉查找树，查找和删除均为$O(logn)$。有序的链表加上附加的前进链接。</p><p><img src="/img/1506_skiplist.gif" alt="img"></p><p>为避免插入节点时保持上下节点的节点数之比为2：1的麻烦，跳表不要求上下相邻两层的节点数有严格的对应关系，而是为每个节点随机选择一个层数（level），比如一个节点随机出层数为3，那么就把它链入第1层到第3层这三层链表中。</p><p><img src="http://zhangtielei.com/assets/photos_redis/skiplist/skiplist_insertions.png" alt="skiplist插入形成过程"></p><p>我们可以看到，每一个节点的层数是随机的，而且插入一个节点不会影响其它节点的层数。因此插入操作只需要修改插入节点前后的指针，而不需要对很多节点进行调整。这就降低了插入操作的时间复杂度。并且在性能上优于平衡树。</p><p>下面我们介绍插入操作计算随机层数的过程：</p><ul><li>首先，每一个节点肯定有第1层的指针</li><li>如果一个节点有第i层指针(i≥1)指针，即节点已在1层到第i层链表中，那么它有第（i+1）层指针的概率为p。</li><li>节点的最大层数不允许超过一个最大值，记为<code>MAX_LEVEL</code></li></ul><p>这个计算随机层数的伪码如下所示：</p><pre><code class="hljs pgsql">randomLevel()    <span class="hljs-keyword">level</span> := <span class="hljs-number">1</span>    // random()返回一个[<span class="hljs-number">0.</span>.<span class="hljs-number">.1</span>)的随机数    <span class="hljs-keyword">while</span> random() &lt; p <span class="hljs-keyword">and</span> <span class="hljs-keyword">level</span> &lt; MaxLevel <span class="hljs-keyword">do</span>        <span class="hljs-keyword">level</span> := <span class="hljs-keyword">level</span> + <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">level</span></code></pre><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><pre><code class="hljs ini"><span class="hljs-attr">p</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span><span class="hljs-attr">MaxLevel</span> = <span class="hljs-number">32</span></code></pre><p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p><ul><li>节点层数至少为1。而大于1的节点层数，满足一个概率分布。</li><li>节点层数恰好等于1的概率为1-p。</li><li>节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。</li><li>节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。</li><li>节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。</li><li>……</li></ul><p>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：</p><script type="math/tex; mode=display">(1-p)+2p(1-p)+3p^2(1-p)+.... = (1-p)\sum\limits_{k=1}^{+\infin}=(1-p)\frac{1}{(1-p)^2}=\frac1{1-p}</script><p>现在很容易计算出：</p><ul><li>当p=1/2时，每个节点所包含的平均指针数目为2；</li><li>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。</li><li></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「核心」Ceph学习三部曲之二:CEPH 纠删码操作&amp;API</title>
    <link href="/2020/11/26/ceph%E7%BA%A0%E5%88%A0%E7%A0%81%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/11/26/ceph%E7%BA%A0%E5%88%A0%E7%A0%81%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本blog包括理论和实践两个部分，力求深入浅出，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第三章。以及<a href="https://docs.ceph.com/en/latest/rados/operations/erasure-code/">官方纠删码教程</a>。</p>          </div><h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><h2 id="Ceph-纠删码操作"><a href="#Ceph-纠删码操作" class="headerlink" title="Ceph 纠删码操作"></a>Ceph 纠删码操作</h2><hr><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>K ——数据块数。</p><p>M——编码块数。</p><p>N——条带中块的个数，$N=K+M$。</p><p>块（chunk）——将对象基于纠删码进行编码时，每次编码将产生若干大小的块（要求是有序的），Ceph通过数量相等的PG将这些块分别存储至不同的OSD之中。每次编码时，序号相同的块总是由同一个PG负责存储。</p><p>条带（stripe）——如果待编码的对象太大，无法一次性完成，那么可以分成多次进行，每次完成编码的部分称为一个条带。其大小为k*块大小。</p><p>分片（shard）——同一个对象所有序号相同的块位于同一个PG之上，它们组成的对象的一个分片。</p><p>rate——空间利用率，即$K/N$</p><h2 id="1-Ceph纠删码库"><a href="#1-Ceph纠删码库" class="headerlink" title="1 Ceph纠删码库"></a>1 Ceph纠删码库</h2><p>Ceph的默认纠删码库是Jerasure，即Jerasure库；除此之外还有 Clay, ISA-L, LRC, Shec(Octopus版本15.2.5).<br>当管理员创建一个erasure-coded后端时，可以指定数据块和代码块参数。Jerasure库是第三方提供的中间件。Ceph环境安装时，已经默认安装了Jerasure库。</p><h2 id="1-1-一个简单的纠删码池样例"><a href="#1-1-一个简单的纠删码池样例" class="headerlink" title="1.1 一个简单的纠删码池样例"></a>1.1 一个简单的纠删码池样例</h2><p>最简单的erasure pool等效于RAID5，至少需要3个主机：【更多关于池的操作可以参考《Ceph pool》博文】</p><pre><code class="hljs routeros">$ ceph osd<span class="hljs-built_in"> pool </span>create ecpool erasurepool <span class="hljs-string">&#x27;ecpool&#x27;</span> created$ echo ABCDEFGHI | rados --pool ecpool put NYAN -$ rados --pool ecpool <span class="hljs-builtin-name">get</span> NYAN -ABCDEFGHI</code></pre><h2 id="1-2-获取纠删码配置文件"><a href="#1-2-获取纠删码配置文件" class="headerlink" title="1.2 获取纠删码配置文件"></a>1.2 获取纠删码配置文件</h2><p>最简单的 k = 2, m = 2, 允许两个节点同时失效。相当于三副本，但是空间节省了。</p><pre><code class="hljs routeros">$ ceph osd erasure-code-profile <span class="hljs-builtin-name">get</span> default<span class="hljs-attribute">k</span>=2<span class="hljs-attribute">m</span>=2<span class="hljs-attribute">plugin</span>=jerasure<span class="hljs-attribute">crush-failure-domain</span>=host<span class="hljs-attribute">technique</span>=reed_sol_van</code></pre><p>选择正确的配置文件很重要，因为在创建池之后无法对其进行修改：需要创建具有不同配置文件的新池，并且将先前池中的所有对象都移到新的池中。</p><p>概要文件的最重要参数是<em>K</em>，<em>M</em>和 <em>rush-failure域，</em>因为它们定义了存储开销和数据持久性。例如，如果所需的架构必须承受两个机架的损失，而存储开销(m/k*100%)为开销的67％，则可以定义以下配置文件：</p><pre><code class="hljs routeros">$ ceph osd erasure-code-profile <span class="hljs-builtin-name">set</span> myprofile \   <span class="hljs-attribute">k</span>=3 \   <span class="hljs-attribute">m</span>=2 \   <span class="hljs-attribute">crush-failure-domain</span>=rack$ ceph osd<span class="hljs-built_in"> pool </span>create ecpool 128 erasure myprofile #128在这类是PG的数量$ echo ABCDEFGHI | rados --pool ecpool put NYAN -$ rados --pool ecpool <span class="hljs-builtin-name">get</span> NYAN -ABCDEFGHI</code></pre><p>该<em>NYAN</em>对象将在三个（被划分<em>K = 3</em>）和两个附加 <em>的块</em>将被创建（<em>M = 2</em>）。<em>M</em>的值定义了在不丢失任何数据的情况下可以同时丢失多少个OSD。所述<code>crush-failure-domain=rack</code>将创建一个CRUSH规则，以确保没有两个<code>chunks</code>被存储在同一个机架。</p><pre><code class="hljs vim">ceph osd erasure-code-<span class="hljs-keyword">profile</span> <span class="hljs-keyword">ls</span> #显示所有<span class="hljs-keyword">profile</span>ceph osd erasure-code-<span class="hljs-keyword">profile</span> rm &#123;profilr&#125; #删除特定<span class="hljs-keyword">profile</span></code></pre><p>读写文件test.txt</p><pre><code class="hljs cmake">rados -p ecpool put <span class="hljs-keyword">test</span> <span class="hljs-keyword">test</span>.txtrados -p ecpool get <span class="hljs-keyword">test</span> <span class="hljs-keyword">file</span>.txt</code></pre><p>更多信息在 <a href="https://docs.ceph.com/en/latest/rados/operations/erasure-code-profile">erasure code profiles</a></p><p><img src="/img/nyan.png" alt="img"></p><p>上图展示的是一种最简单的情况，我们称之为“满条带写”，向k=3，m=2的纠删码存储池写入NYAN对象。针对同一个逻辑PG，将对象分片并写入不同的PG实例。每个PG实例都认为字节保存的是一个完整而独立的对象。因此其保存的内容在逻辑上是连续的，以块大小为单位。5个OSD最终都向名为“NYAN”的对象写入三个字节，它们在对象内的逻辑地址都为[0,2]。</p><h2 id="1-3-写覆盖"><a href="#1-3-写覆盖" class="headerlink" title="1.3 写覆盖"></a>1.3 写覆盖</h2><p>默认情况下，纠删码池仅适用于执行完整对象写入和追加的RGW之类的用途。</p><p>自从luminous版本，每个池设置启用对纠删码池的<strong>部分写</strong>入。这使RBD和CephFS将其数据存储在纠删码池中：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> ec_pool allow_ec_overwrites <span class="hljs-literal">true</span></code></pre><p>这是针对bluestore的osd，这是因为bluestore的校验和用于检测deep-scrub 期间的bitrot和其它损坏。除了不安全之外，overwrite还将降低性能。</p><p>纠删码不支持<code>omap</code>,因此需要和RBD和CephFS一起使用，必须指示它们将数据存储在ec池中，并将元数据存储在复制池中。对于RBD，这意味着<code>--data-pool</code>在图像创建过程中使用纠删码池：</p><pre><code class="hljs brainfuck"><span class="hljs-comment">rbd</span> <span class="hljs-comment">create</span> --<span class="hljs-comment">size</span> <span class="hljs-comment">1G</span> --<span class="hljs-comment">data</span><span class="hljs-literal">-</span><span class="hljs-comment">pool</span> <span class="hljs-comment">ec_pool</span> <span class="hljs-comment">replicated_pool/image_name</span><span class="hljs-comment"></span></code></pre><p>对于CephFS，可以在文件系统创建过程中或通过<a href="https://docs.ceph.com/en/latest/cephfs/file-layouts">文件布局</a>将纠删码池设置为默认数据池。</p><h2 id="1-4-缓存层"><a href="#1-4-缓存层" class="headerlink" title="1.4 缓存层"></a>1.4 缓存层</h2><p>纠删码比副本需要更多资源，并且缺失<code>omap</code>这样的功能。为了克服这些限制，需要设置一个<a href="https://docs.ceph.com/en/latest/rados/operations/cache-tiering">缓存层</a></p><pre><code class="hljs dsconfig">$ <span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">tier </span><span class="hljs-string">add </span><span class="hljs-string">ecpool </span><span class="hljs-string">hot-storage</span><span class="hljs-string">$</span> <span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">tier </span><span class="hljs-string">cache-mode </span><span class="hljs-string">hot-storage </span><span class="hljs-string">writeback</span><span class="hljs-string">$</span> <span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">tier </span><span class="hljs-built_in">set-overlay</span> <span class="hljs-string">ecpool </span><span class="hljs-string">hot-storage</span></code></pre><p>将放置热存储池的ecpool 在<em>写回</em> 模式。提供灵活性和速度。</p><h2 id="1-5-恢复"><a href="#1-5-恢复" class="headerlink" title="1.5 恢复"></a>1.5 恢复</h2><p>如果纠删码池丢失了一些碎片，则必须从其他碎片中恢复它们。通常，这涉及读取其余分片，重建数据并将其写入新对等方。在Octopus中，只要至少有<em>K个</em>碎片可用，擦除编码池就可以恢复。（使用少于<em>K个分</em>片，您实际上已经丢失了数据！）</p><p>在使用Octopus之前，即使<em>min_size</em>大于<em>K</em>，擦除编码池也至少需要<em>min_size分</em>片可用。（我们通常建议min_size为<em>K + 2</em>或更大，以防止写入和数据丢失。）这种保守的决定是在设计新的池模式时出于谨慎考虑而做出的，但是这也意味着丢失OSD但没有数据丢失的池无法进行操作恢复并开始活动，而无需手动干预来更改<em>min_size</em>。</p><h2 id="2-OSD-erasure-code-profile-参数"><a href="#2-OSD-erasure-code-profile-参数" class="headerlink" title="2 OSD erasure-code-profile 参数"></a>2 OSD erasure-code-profile 参数</h2><p>通用</p><pre><code class="hljs routeros">ceph osd erasure-code-profile <span class="hljs-builtin-name">set</span> &#123;name&#125; \     [&#123;<span class="hljs-attribute">directory</span>=directory&#125;] \     [&#123;<span class="hljs-attribute">plugin</span>=plugin&#125;] \     [&#123;<span class="hljs-attribute">stripe_unit</span>=stripe_unit&#125;] \     [&#123;<span class="hljs-attribute">key</span>=value&#125; <span class="hljs-built_in">..</span>.] \     [--force]</code></pre><ul><li><p><code>&#123;directory&#125;:string</code></p><p>设置从中加载擦除代码插件的<strong>目录</strong>名称. 默认<code>/ usr / lib / ceph / erasure-code</code></p></li><li><p><code>crush-failure-domain=&#123;bucket-type&#125;</code></p><p>确保一个桶两个数据块没有相同的容灾域. 它被用于创建 CRUSH 规则 <strong>step chooseleaf host</strong>. 默认host。</p></li><li><p><code>crush-device-class=&#123;device-class&#125;</code></p><p>使用CRUSH映射中的Crush设备类名称，将布局限制为特定类（例如 <code>ssd</code>或<code>hdd</code>）的设备。</p></li><li><p><code>&#123;plugin&#125;:string</code></p><p>默认: <code>jerasure</code> ,  可选<code>isa\ lrc \shec\clay</code></p></li></ul><h2 id="2-1-jerasure"><a href="#2-1-jerasure" class="headerlink" title="2.1 jerasure"></a>2.1 jerasure</h2><pre><code class="hljs sql">ceph osd erasure-code-profile <span class="hljs-keyword">set</span> &#123;<span class="hljs-keyword">name</span>&#125; \     <span class="hljs-keyword">plugin</span>=jerasure \     k=&#123;<span class="hljs-keyword">data</span>-chunks&#125; \     m=&#123;coding-chunks&#125; \     technique=&#123;reed_sol_van|reed_sol_r6_op|cauchy_orig|cauchy_good|liberation|blaum_roth|liber8tion&#125; \     [crush-root=&#123;root&#125;] \     [crush-<span class="hljs-keyword">failure</span>-<span class="hljs-keyword">domain</span>=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;] \     [crush-device-<span class="hljs-keyword">class</span>=&#123;device-<span class="hljs-keyword">class</span>&#125;] \     [<span class="hljs-keyword">directory</span>=&#123;<span class="hljs-keyword">directory</span>&#125;] \     [<span class="hljs-comment">--force]</span></code></pre><p>我们可以选择具体技术<code>technique</code>。更灵活的技术是<em>reed_sol_van</em>：足以设置<em>k</em>和<em>m</em>。该<em>cauchy_good</em>技术可以更快，但你需要选择的<em>PACKETSIZE</em> 小心。从只能使用<em>m = 2</em>进行配置的意义上来说，所有<em>reed_sol_r6_op</em>，<em>liberation</em>， <em>blaum_roth</em>，<em>liber8tion</em>都是<em>RAID6</em>等效项。</p><h2 id="2-2-ISA"><a href="#2-2-ISA" class="headerlink" title="2.2 ISA"></a>2.2 ISA</h2><pre><code class="hljs sql">ceph osd erasure-code-profile <span class="hljs-keyword">set</span> &#123;<span class="hljs-keyword">name</span>&#125; \     <span class="hljs-keyword">plugin</span>=isa \     technique=&#123;reed_sol_van|cauchy&#125; \     [k=&#123;<span class="hljs-keyword">data</span>-chunks&#125;] \     [m=&#123;coding-chunks&#125;] \     [crush-root=&#123;root&#125;] \     [crush-<span class="hljs-keyword">failure</span>-<span class="hljs-keyword">domain</span>=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;] \     [crush-device-<span class="hljs-keyword">class</span>=&#123;device-<span class="hljs-keyword">class</span>&#125;] \     [<span class="hljs-keyword">directory</span>=&#123;<span class="hljs-keyword">directory</span>&#125;] \     [<span class="hljs-comment">--force]</span></code></pre><h2 id="2-3-LRC"><a href="#2-3-LRC" class="headerlink" title="2.3 LRC"></a>2.3 LRC</h2><pre><code class="hljs sql">ceph osd erasure-code-profile <span class="hljs-keyword">set</span> &#123;<span class="hljs-keyword">name</span>&#125; \     <span class="hljs-keyword">plugin</span>=lrc \     k=&#123;<span class="hljs-keyword">data</span>-chunks&#125; \     m=&#123;coding-chunks&#125; \     l=&#123;locality&#125; \     [crush-root=&#123;root&#125;] \     [crush-locality=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;] \     [crush-<span class="hljs-keyword">failure</span>-<span class="hljs-keyword">domain</span>=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;] \     [crush-device-<span class="hljs-keyword">class</span>=&#123;device-<span class="hljs-keyword">class</span>&#125;] \     [<span class="hljs-keyword">directory</span>=&#123;<span class="hljs-keyword">directory</span>&#125;] \     [<span class="hljs-comment">--force]</span></code></pre><p><em>LRC</em>创建本地校验块，使用更少的存活OSD。例如，如果<em>lrc</em>配置为 <em>k = 8</em>，<em>m = 4</em>和<em>l = 4</em>，它将为每4个OSD创建一个额外的奇偶校验块。当1个OSD丢失时，只能使用4个OSD（而不是8个）来恢复它。</p><h2 id="2-4-SHEC"><a href="#2-4-SHEC" class="headerlink" title="2.4 SHEC"></a>2.4 SHEC</h2><pre><code class="hljs sql">ceph osd erasure-code-profile <span class="hljs-keyword">set</span> &#123;<span class="hljs-keyword">name</span>&#125; \     <span class="hljs-keyword">plugin</span>=shec \     [k=&#123;<span class="hljs-keyword">data</span>-chunks&#125;] \     [m=&#123;coding-chunks&#125;] \     [c=&#123;durability-estimator&#125;] \     [crush-root=&#123;root&#125;] \     [crush-<span class="hljs-keyword">failure</span>-<span class="hljs-keyword">domain</span>=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;] \     [crush-device-<span class="hljs-keyword">class</span>=&#123;device-<span class="hljs-keyword">class</span>&#125;] \     [<span class="hljs-keyword">directory</span>=&#123;<span class="hljs-keyword">directory</span>&#125;] \     [<span class="hljs-comment">--force]</span></code></pre><ul><li><p><code>c=&#123;durability-estimator&#125;:int</code></p><p>奇偶校验块的数量，每个奇偶校验块包括其计算范围内的每个数据块。该数字用作<strong>耐久性估算器</strong>。例如，如果c = 2，则2个OSD可以关闭而不会丢失数据。默认为2.</p></li></ul><h2 id="2-5-CLAY"><a href="#2-5-CLAY" class="headerlink" title="2.5 CLAY"></a>2.5 CLAY</h2><p>全称是coupled-layer.  此编码目标是在修复时减少网络带宽和磁盘IO。</p><p>令d为修复时沟通的OSD数量。比如Jerasure中k=8，m=4，修复1GiB数据</p><p>需要下载8GiB数据。</p><p>在clay中允许设置d， $k+1\le d\le k+m-1$。默认情况下$d=k+m-1$，这将最大化节省网络带宽和磁盘IO。比如 k = 8, m = 4, d = 11. <em>则</em>当单个OSD发生故障时，将沟通d = 11 osds并从每个插件中下载250MiB，导致总下载量为11 X 250MiB = 2.75GiB。下面提供了更多常规参数。当对存储量达到TB级的信息的机架进行维修时，好处是巨大的。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Plugin</th><th style="text-align:left">磁盘IO总量</th></tr></thead><tbody><tr><td style="text-align:left">Jeraure</td><td style="text-align:left">$kS$</td></tr><tr><td style="text-align:left">Clay</td><td style="text-align:left">$dS/(d−k+1)=(k+m−1)S/m$</td></tr></tbody></table></div><p>其中<em>S</em>是正在修复的单个OSD上存储的数据量。在上表中，我们使用了<em>d</em>的最大可能值，因为这将导致从OSD故障恢复所需的最小数据下载量。</p><pre><code class="hljs sql">ceph osd erasure-code-profile <span class="hljs-keyword">set</span> &#123;<span class="hljs-keyword">name</span>&#125; \     <span class="hljs-keyword">plugin</span>=clay \     k=&#123;<span class="hljs-keyword">data</span>-chunks&#125; \     m=&#123;coding-chunks&#125; \     [d=&#123;helper-chunks&#125;] \     [scalar_mds=&#123;<span class="hljs-keyword">plugin</span>-<span class="hljs-keyword">name</span>&#125;] \     [technique=&#123;technique-<span class="hljs-keyword">name</span>&#125;] \     [crush-<span class="hljs-keyword">failure</span>-<span class="hljs-keyword">domain</span>=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;] \     [<span class="hljs-keyword">directory</span>=&#123;<span class="hljs-keyword">directory</span>&#125;] \     [<span class="hljs-comment">--force]</span></code></pre><ul><li><p><code>d=&#123;helper-chunks&#125;</code></p><p>恢复单个块期间请求发送数据的OSD数量。需要选择<em>d</em>，以使k + 1 &lt;= d &lt;= k + m-1。在较大的<em>d</em>，节省越多。默认 k + m -1.</p></li><li><p><code>scalar_mds=&#123;jerasure|isa|shec&#125;</code></p><p><strong>scalar_mds</strong>指定在分层构造中用作构建块的插件。可以是<em>jerasure</em>，<em>isa</em>，<em>shec之一</em></p></li><li><p><code>technique=&#123;technique&#125;</code></p><p><strong>technique</strong>指定将在指定的“ scalar_mds”插件中采用的技术。支持的技术是’reed_sol_van’，’reed_sol_r6_op’，’cauchy_orig’，’cauchy_good’，’liber8tion’用于jerasure，’reed_sol_van’，’cauchy’用于isa和’single’，’multiple’用于shec。</p><p>默认reed_sol_van (for jerasure, isa), single (for shec)</p></li></ul><blockquote><h2 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h2><p>Clay代码是矢量代码，因此能够节省磁盘IO和网络带宽，并且能够以称为子块的更精细的粒度查看和操作块中的数据。Clay代码的块中子块的数量由下式给出：</p><blockquote><p>子块计数= $q^{(k+m)/q}$， $q=d−k+1$</p></blockquote><p>在OSD修复期间，从可用OSD请求的帮助者信息只是块的一小部分。实际上，修复期间访问的块内子块的数量由下式给出：</p><blockquote><p>修复子块计数= $\frac{sub—-chunk \: count}{q}$</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>对于<em>k = 4</em>，<em>m = 2</em>，<em>d = 5的配置</em>，子块计数为8，修复子块计数为4。因此，在修复期间仅读取一半的块。</li><li>当<em>k = 8</em>，<em>m = 4</em>，<em>d = 11时</em>，子块计数为64，修复子块计数为16。从可用OSD中读取四分之一的块以修复故障块。</li></ol><h2 id="如何在给定工作量的情况下选择配置"><a href="#如何在给定工作量的情况下选择配置" class="headerlink" title="如何在给定工作量的情况下选择配置"></a>如何在给定工作量的情况下选择配置</h2><p>块中所有子块中只有几个子块被读取。这些子块不必连续存储在块中。为了获得最佳的磁盘IO性能，读取连续的数据很有帮助。因此，建议您选择条带大小，以使子块大小足够大。</p><p>对于给定的条带大小（这是基于固定的工作负载），选择<code>k</code>，<code>m</code>，<code>d</code>使得：</p><blockquote><p>子块大小= $\frac{stripe-size}{k sub-chunk count}$ = 4KB，8KB，12KB…</p></blockquote><ol><li>对于条带大小较大的大型工作负载，很容易选择k，m，d。例如，考虑大小为64MB的条带大小，选择<em>k = 16</em>，<em>m = 4</em>和<em>d = 19</em>将导致子块计数为1024，子块大小为4KB。</li><li>对于较小的工作负载，<em>k = 4</em>，<em>m = 2</em>是一个很好的配置，可同时带来网络和磁盘IO的好处。</li></ol><h2 id="与LRC的比较"><a href="#与LRC的比较" class="headerlink" title="与LRC的比较"></a>与LRC的比较</h2><p>还设计了本地可恢复代码（LRC），以便在网络带宽方面节省单个OSD恢复期间的磁盘IO。但是，LRC的重点是使修复（d）期间接触的OSD数量保持最少，但这是以存储开销为代价的。clay代码有一个存储开销 m/k。在<em>lrc</em>的情况下，除奇偶校验外，它还存储（k + m）/ d个奇偶<code>m</code>校验，从而导致存储开销（m +（k + m）/ d）/ k。两个<em>粘土</em>和<em>LRC</em> 可以从任何的故障中恢复<code>m</code>的OSD。</p><blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">参量</th><th style="text-align:left">磁盘IO，存储开销（LRC）</th><th style="text-align:left">磁盘IO，存储开销（CLAY）</th></tr></thead><tbody><tr><td style="text-align:left">（k = 10，m = 4）</td><td style="text-align:left">7 * S，0.6（d = 7）</td><td style="text-align:left">3.25 * S，0.4（d = 13）</td></tr><tr><td style="text-align:left">（k = 16，m = 4）</td><td style="text-align:left">4 * S，0.5625（d = 4）</td><td style="text-align:left">4.75 * S，0.25（d = 19）</td></tr></tbody></table></div></blockquote><p><code>S</code>是恢复单个OSD的存储数据量。</p></blockquote><h2 id="覆盖写思考"><a href="#覆盖写思考" class="headerlink" title="覆盖写思考"></a>覆盖写思考</h2><p>因为数据更新必须以条带为单位进行，如果覆盖写的起始或者结束位置没有进行条带对齐，那么不足一个完整条带的部分，其写入只能通过“读取完整条带→修改数据→基于条带重新计算校验数据→写入（被修改部分和校验和）”。这个过程被称为RMW。</p><p>整个RMW过程补齐读阶段最耗时，由两种解决思路：1. 减少RMW次数，2.如果RMW不可避免，那么尽量减少补齐读的数据量。一种常见的做法是引入写缓存。将驻留于缓存的写操作进行合并。 另外是尽可能减少读的次数，基于被修改写的数据范围预先计算出需要执行补齐读的块，而不是每次都执行满条带写。</p><h2 id="Scrub的问题"><a href="#Scrub的问题" class="headerlink" title="Scrub的问题"></a>Scrub的问题</h2><p>Scrub指数据扫描，通过读取对象数据并重新计算校验和，再与之前存储在对象属性的校验和进行比对，以判断有无静默错误（磁盘自身无法感知的错误）。目前Ceph纠删码没有自动修复功能。其中Scrub只扫描元数据，而Deep Scrub对对象整体进行扫描。</p><p>例如对象大小为4MB，那么每4KB原始数据采用CRC32生成固定四个字节的校验和，则整个对象的校验和最大只能是4KB，这显然无法直接使用对象扩展属性存储，而只能使用对象的omap存储(kv pairs)，但是纠删码目前不支持omap! </p><p>Ceph中纠删码一直未达到商业水平，无外乎以下几个原因：</p><ul><li>相较于多副本，纠删码实现更复杂</li><li>相较于多副本，纠删码性能较差，尤其是读性能。其最适合的场景一般是追加写或者删除。</li></ul><p>这也是笔者的研究方向，路漫漫其修远兮，吾将上下而求索。</p><hr><h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><h2 id="纠删码库介绍"><a href="#纠删码库介绍" class="headerlink" title="纠删码库介绍"></a>纠删码库介绍</h2><h2 id="1-Jerasure"><a href="#1-Jerasure" class="headerlink" title="1 Jerasure"></a>1 Jerasure</h2><p>2007 James给出了RS-RAID一个开源实现。<a href="http://jerasure.org/jerasure/jerasure">official</a> ，<a href="https://github.com/tsuraan/Jerasure">github</a></p><p>Jerasure库包括以下5个模块：</p><ul><li><code>galois.h/.c</code>提供伽罗华域的算术运算。</li><li><code>jerasure.h/.c</code>提供了绝大部分的核心函数。包括矩阵的编解码，位矩阵变换，矩阵转置和位矩阵转置。</li><li><code>reedsol.h/.c</code>支持RS编解码和优化和的RS码。</li><li><code>caucy.h/.c</code> 支持Caucy RS编解码和最优Caucy编码。</li><li><code>caucy_best_r6.h/.c</code> 基于Caucy矩阵的RAID-6优化。</li><li><code>liberation.h/.c</code> 支持Liberartion RAID-6编码, Blaum-Roth 编码，和Liber8tion RAID-6编码。 Liberation是一种低密度MDS。这三种编码采用位矩阵来实现，其性能远优于现有的RS和EVENNODD，在某种情况下也优于RDP编码。</li></ul><p>下标汇总了Jerasure-2.0库常见的参数和其含义：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">k</td><td style="text-align:center">数据盘个数</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">校验盘个数</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">字长</td></tr><tr><td style="text-align:center">packetsize</td><td style="text-align:center">包大小</td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">每个盘待编码或者解码的字节数</td></tr><tr><td style="text-align:center">matrix</td><td style="text-align:center">编码矩阵</td></tr><tr><td style="text-align:center">bitmatrix</td><td style="text-align:center">位矩阵</td></tr><tr><td style="text-align:center">dataptrs</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">erasures</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">erased</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">schdule</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">row k ones</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dm ids</td></tr></tbody></table></div><p>针对RAID-6，Jerasure作了两类优化：</p><ul><li><p>对乘2运算进行优化</p></li><li><p>直接对编码矩阵进行改造，得到最小密度RAID6. 这类矩阵很稀疏，计算量较少。目前有三种</p><ul><li>Liberation: 要求W必须是素数</li><li>Blaum-Roth: 要求W+1必须是素数</li><li>Lber8tion: 要求W必须等于8</li></ul><p>这三种编码效率相当。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>纠删码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「核心」Ceph学习三部曲之一:A First Glance At Crush</title>
    <link href="/2020/11/25/A%20first%20glance%20at%20CRUSH/"/>
    <url>/2020/11/25/A%20first%20glance%20at%20CRUSH/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第一章。以及<a href="https://docs.ceph.com/en/latest/rados/operations/crush-map/?s">官方CRUSH教程</a>。</p>          </div><h1 id="浅析CRUSH算法"><a href="#浅析CRUSH算法" class="headerlink" title="浅析CRUSH算法"></a>浅析CRUSH算法</h1><blockquote><p>CRUSH论文地址：<a href="https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf">https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf</a></p><p>一个通过增加额外时间维度来提升性能的方案，MapX（FAST2020‘）：<a href="https://www.usenix.org/system/files/fast20-wang_li.pdf">https://www.usenix.org/system/files/fast20-wang_li.pdf</a></p></blockquote><h1 id="1-CRUSH背景"><a href="#1-CRUSH背景" class="headerlink" title="1. CRUSH背景"></a>1. CRUSH背景</h1><p>大部分存储系统将数据写入到存储设备之后，数据很少在设备之间相互移动，这会导致一个潜在问题，即使是一个数据分布趋于完美的系统，随着时间的迁移，新的空闲设备不断加入，老设备不断退出，数据变得不均匀。<br>一种可行方案是将数据以足够小的粒度打散，均匀分布于整个存储系统，这样做有两个问题:</p><ul><li>如果设备数量发生变化， 如何最小化迁移量使得整个系统尽快恢复平衡。</li><li>在大型（PB以上）分布式存储系统，为保证数据可靠性一般采用多副本或者纠删码，如何合理分布它们。。</li></ul><p>CRUSH: Controlled Replication Under Scalable Hashing<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="WEIL, S. A., BRANDT, S. A., MILLER, E. L., AND MALTZAHN,C. Crush: Controlled, scalable, decentralized placement of replicateddata. In SC’06: Proceedings of the 2006 ACM/IEEE Conference onSupercomputing (2006), IEEE, pp. 31–31.">[1]</span></a></sup> 基于可扩展哈希的受控副本分布策略。<br>它基于伪随机数哈希算法，以数据唯一标识符、当前存储集群拓扑以及数据备份策略作为输入，可以随时随地通过计算获取数据所在的底层存储设备的位置并之间与其通信，从而避免查表，失效去中心化和高度并发。</p><h1 id="2-Straw选择算法"><a href="#2-Straw选择算法" class="headerlink" title="2. Straw选择算法"></a>2. Straw选择算法</h1><p>网络中不同层级具有不同容忍灾难的能力，称之为容灾域。</p><p><img src="/img/image-20201128210418154.png" alt="image-20201128210418154"></p><p>Sage weil一共设计了四种选择算法，并按照添加删除数据的性能进行比较。结论是：考虑到存储空间需求爆炸式增长，在大型分布式存储系统中某些部件故障是常态，以及数据性可靠性要求，Straw将是不错的选择。我们重点分析。</p><ul><li>straw算法将所有元素（设备）比作吸管，为每个元素随机计算一个长度，最后从中选择长度最长的那个元素作为结果输出，这个过程被形象地称为抽签（draw）。</li><li>CRUSH引入了权重（weight）来区分不同容量的设备。大容量设备理应获得更大的权重。设输入为x，元素编号为i，权重为w，随机数种子为r。每根“吸管”的长度是根据权重决定的,i.e.$f(w_i)$。</li></ul><script type="math/tex; mode=display">C(r,x) = max_i(f(w_i)hash(x,r,i))</script><blockquote><p>其实这里的x是输入PGID。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Wang L, Zhang Y, Xu J, et al. {MAPX}: Controlled Data Migration in the Expansion of Decentralized Object-Based Storage Systems[C]//18th {USENIX} Conference on File and Storage Technologies ({FAST} 20). 2020: 1-11.">[2]</span></a></sup>[2.1]节</p></blockquote><ul><li>当添加一个元素，straw会随机将一些原有元素中的数据随机映射至新加入的元素中；当删除一个元素x，straw会将全部数据重新映射到除x以外所有元素。</li></ul><p>当然straw也存在问题</p><ul><li>Straw算法将所有元素按权重逆序排列后逐个计算每个元素的Item_straw，会导致最终选择结果不断取决于每个元素自身权重还与集合当助其他元素强相关。因而会引起不相干的数据迁移。因而Sage Weil进行修正：在计算straw长度时仅使用元素自身的权重。从而得到straw改进算法straw2。</li></ul><p>原Straw算法：</p><pre><code class="hljs cpp">max_x = <span class="hljs-number">-1</span>max_item = <span class="hljs-number">-1</span><span class="hljs-keyword">for</span> each item:x = hash(input,r)x = x*item_straw<span class="hljs-keyword">if</span> x &gt; max_x:max_x = xmax_item = item<span class="hljs-keyword">return</span> max_item</code></pre><p>Straw2算法：</p><pre><code class="hljs properties"><span class="hljs-attr">max_x</span> = <span class="hljs-string">-1</span><span class="hljs-attr">max_item</span> = <span class="hljs-string">-1</span><span class="hljs-attr">for</span> <span class="hljs-string">each item:</span><span class="hljs-attr">x</span> = <span class="hljs-string">hash(input,r)</span><span class="hljs-attr">x</span> = <span class="hljs-string">ln(x/65536)/weight</span><span class="hljs-attr">if</span> <span class="hljs-string">x &gt; max_x:</span><span class="hljs-attr">max_x</span> = <span class="hljs-string">x</span><span class="hljs-attr">max_item</span> = <span class="hljs-string">item</span><span class="hljs-attr">return</span> <span class="hljs-string">max_item</span></code></pre><p>上述逻辑中，针对输入input和随机因子r执行哈希后，结果落在[0,65536]之间，x/65536必然小于1，取其自然对数ln(x/65536)后结果为负值，将其除以自身权重后，表现为权重越大，x越大，从而体现了我们所期望的每个元素对于抽签结果的正反馈作用。</p><h1 id="3-CRUSH算法"><a href="#3-CRUSH算法" class="headerlink" title="3 . CRUSH算法"></a>3 . CRUSH算法</h1><ul><li>针对特定输入x，CRUSH将输出一个包含n个不同存储对象的集合。我们称集群的拓扑为 Cluster Map , 不同数据分布是通过制定不同的placement rule实现的，它实际是一组包括最大副本数或纠删码策略、容灾级别的自定义约束条件。</li><li>x和cluster map和placement rule是CRUSH的哈希函数输入参数。因为使用伪随机哈希函数，CRUSH选择每个目标存储对象概率是相对独立的。</li></ul><h2 id="3-1-Cluster-Map"><a href="#3-1-Cluster-Map" class="headerlink" title="3.1 Cluster Map"></a>3.1 Cluster Map</h2><p><img src="/img/cluster_map.png" alt="image-20201128210954633"></p><p>实现上cluster map具有诸如 “数据中心→机架→主机→磁盘”这样的树状层次关系。每个叶子节点都是真实的物理设备（比如磁盘）称为device；所有的中间节点称为bucket；根节点称为root，是整个集群的入口。每个节点都用于唯一的数字ID和类型，但是只有叶子节点采用与非负ID。父节点的权重是所有孩子节点权重之和。</p><p>CRUSH放置策略可在故障域中分布对象副本，同时保持所需的分布。例如，为了解决并发故障的可能性，可能需要确保数据副本位于使用不同架子，机架，电源，控制器和/或物理位置的设备上。CRUSH算法通过（i）将故障域的信息（如共享电源或网络）编码到群集图中，并（ii）让管理员定义用于指定副本放置方式的放置规则，从而支持可靠约束副本放置的灵活约束。 通过递归选择存储桶项目。</p><p>常见的节点层级</p><ul><li><code>osd</code> (or <code>device</code>)</li><li><code>host</code></li><li><code>chassis</code></li><li><code>rack</code></li><li><code>row</code></li><li><code>pdu</code> 电源分配单元</li><li><code>pod</code></li><li><code>room</code></li><li><code>datacenter</code></li><li><code>zone</code></li><li><code>region</code></li><li><code>root</code></li></ul><p><img src="/img/cluster_mapdemo.png" alt="image-20201128211039048"></p><h2 id="3-2-数据分布策略——Placement-Rule"><a href="#3-2-数据分布策略——Placement-Rule" class="headerlink" title="3.2 数据分布策略——Placement Rule"></a>3.2 数据分布策略——Placement Rule</h2><p>CRUSH算法的核心包括三个步骤：TAKE，SELECT和EMIT。<br>$TAKE(a)$：从cluster_map选择指定编号的bucket并放入工作向量作为下一级SELECT的输入。系统默认采用root作为输入。</p><p><img src="/img/crush1.png" style="zoom:67%;" /></p><p>$SELECT(n,t)$:从bucket随机选择指定类型和数量的item。n: number，t: type。type可以设为 容灾域类型，比如rack 或host。Ceph当前支持两种备份策略——多副本和纠删码，相应的有两种选择方法first n 和 indep. 主要区别是纠删码要求结果是有序的。</p><ul><li><p>$f$在这里表示失败的尝试数，初始设为0.</p></li><li><p>$r$表示副本编号，它的范围是[1,n]。</p></li><li>CRUSH采用深度优先搜索方式遍历所有副本。</li></ul><p><img src="/img/crush2.png" style="zoom:67%;" /></p><p>我们下面再看一下选择算法。</p><p><img src="/img/crush4.png" alt="image-20201129194851670"></p><ul><li>（左图）first n：比如 n = 6， select(6, disk), 当第二个item被拒绝，其余节点会填充空位。尝试次数f 将更新 副本编号r。</li><li>（右图）每一个队列有概率上独立的顺序，这儿$f_r = 1, r’=r+f_rn=8$，对应device:h，因此会用h进行“填充”。</li></ul><p>因为在容灾域模式下会产生递归调用，所以还需要限制产生递归调用时作为下一级输入的全局尝试次数（<code>choose_total_tries</code>），因为这个限制会导致递归调用时全局尝试次数成倍增长，按照递归的概念，多次递归后这个全局尝试次数应该成指数增长，但是实际上至多调用一次，所以这里是将原始尝试次数放大N倍后作为下一级输入的全局尝试数，实现上采用一个布尔变量（<code>chooseleaf_descent_once</code>,i.e. “first n”）进行控制，如果为真，则在产生递归调用至多重试一次，否则则不进行重试，由调用者自身进行重试。N由<code>chooseleaf_vary_r</code>进行决定。</p><p><img src="/img/crush5.png" alt="image-20201129195221719" style="zoom:67%;" /></p><p>这儿的$b.c(r’,x)$即为第二节谈到的 Bucket Choose ， 我们采用Straw2算法。<br>如果得到的结果不是目标类型，则继续向下递归。并设置重试标记$retry_bucket$为true.</p><p><img src="../img/crush6.png" alt="image-20201129195537731" style="zoom:67%;" /></p><p>当输出已经在输出条目中或者发生冲突或过载时，如果$f_r\ge 3$会执行29行。冲突（Collision）： 选中的条目已经存在于输出条目列表之中。<br>OSD过载或失效：</p><ol><li>由于集群规模较小，导致集群PG总数有限，CRUSH输入不够。</li><li>CRUSH本身缺陷，每次选择是单个条目被选中的独立概率，但是CRUSH所要求的副本策略使得针对同一个输入、多个副本直接的选择变成了条件概率。</li></ol><p>在老的CRUSH实现，为了避免每次回到初始输入的bucket下重试，可以在当前的bucket下直接进行重试。此时同样需要对局部尝试次数进行限制，称为(<code>choose_local_retries</code>)。</p><p>$Overload(o,x)$</p><p>除了由容量计算得到的真实权重之外，Ceph还设置了可以人工调整的权重（reweight）。算法正常选中一个OSD之后，最后还基于此reweight进行一次过载测试，如果测试失败，则将仍然拒绝该item。<br>我们可以通过设置reweight介于[0,0x10000]之间，如果为0就不能通过测试，为0x10000就是一定会通过测试。在实际应用中通过降低过载OSD或者增加空闲reweight都可以触发数据在OSD之间重新分布。并且可以区分暂时失效的OSD和永久失效的OSD。</p><p><img src="/img/reweight.png" alt="reweight" style="zoom:67%;" /></p><p>$EMIT$:输出最终选择结果给上级调用者并返回。</p><p><img src="/img/crush8.png" alt="image-20201129195731168" style="zoom:67%;" /></p><p>总结</p><p>我们以firstn为例展示从指定bucket查找指定数量item的过程。</p><p><img src="/img/crush9.png" alt="image-20201129195815305"></p><hr><h1 id="4-操作CRUSH"><a href="#4-操作CRUSH" class="headerlink" title="4 操作CRUSH"></a>4 操作CRUSH</h1><p>1 查看osd tree （含权重）</p><pre><code class="hljs dos">sudo ceph osd <span class="hljs-built_in">tree</span></code></pre><pre><code class="hljs lsl">ID  CLASS  WEIGHT   TYPE NAME       STATUS  REWEIGHT  PRI-AFF<span class="hljs-number">-1</span>         <span class="hljs-number">0.05846</span>  root <span class="hljs-section">default</span>                             <span class="hljs-number">-5</span>         <span class="hljs-number">0.01949</span>      host node3                            <span class="hljs-number">1</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.1</span>       up   <span class="hljs-number">1.00000</span>  <span class="hljs-number">1.00000</span><span class="hljs-number">-3</span>         <span class="hljs-number">0.01949</span>      host node4                            <span class="hljs-number">0</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.0</span>       up   <span class="hljs-number">1.00000</span>  <span class="hljs-number">1.00000</span><span class="hljs-number">-7</span>         <span class="hljs-number">0.01949</span>      host node5                            <span class="hljs-number">2</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.2</span>       up   <span class="hljs-number">1.00000</span>  <span class="hljs-number">1.00000</span></code></pre><p><code>ID</code>: 每个节点在集群唯一ID。<code>class</code>：每个节点的类别。<code>weight</code>:每个节点的权重。</p><p>2 查看整个集群空间利用率</p><pre><code class="hljs dos">sudo ceph osd df <span class="hljs-built_in">tree</span></code></pre><pre><code class="hljs angelscript">ID  CLASS  WEIGHT   REWEIGHT  SIZE    RAW USE  DATA     OMAP    META      AVAIL   %USE  VAR   PGS  STATUS  TYPE NAME     <span class="hljs-number">-1</span>         <span class="hljs-number">0.05998</span>         -  <span class="hljs-number">60</span> GiB  <span class="hljs-number">3.0</span> GiB  <span class="hljs-number">2.4</span> MiB  <span class="hljs-number">59</span> KiB   <span class="hljs-number">3.0</span> GiB  <span class="hljs-number">57</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>    -          root <span class="hljs-keyword">default</span>  <span class="hljs-number">-5</span>         <span class="hljs-number">0.00999</span>         -  <span class="hljs-number">20</span> GiB  <span class="hljs-number">1.0</span> GiB  <span class="hljs-number">824</span> KiB  <span class="hljs-number">18</span> KiB  <span class="hljs-number">1024</span> MiB  <span class="hljs-number">19</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>    -              host node3 <span class="hljs-number">1</span>    ssd  <span class="hljs-number">0.00999</span>   <span class="hljs-number">1.00000</span>  <span class="hljs-number">20</span> GiB  <span class="hljs-number">1.0</span> GiB  <span class="hljs-number">824</span> KiB  <span class="hljs-number">18</span> KiB  <span class="hljs-number">1024</span> MiB  <span class="hljs-number">19</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>   <span class="hljs-number">81</span>      up          osd<span class="hljs-number">.1</span> <span class="hljs-number">-3</span>         <span class="hljs-number">0.01999</span>         -  <span class="hljs-number">20</span> GiB  <span class="hljs-number">1.0</span> GiB  <span class="hljs-number">824</span> KiB  <span class="hljs-number">17</span> KiB  <span class="hljs-number">1024</span> MiB  <span class="hljs-number">19</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>    -              host node4 <span class="hljs-number">0</span>    ssd  <span class="hljs-number">0.01999</span>   <span class="hljs-number">1.00000</span>  <span class="hljs-number">20</span> GiB  <span class="hljs-number">1.0</span> GiB  <span class="hljs-number">824</span> KiB  <span class="hljs-number">17</span> KiB  <span class="hljs-number">1024</span> MiB  <span class="hljs-number">19</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>   <span class="hljs-number">81</span>      up          osd<span class="hljs-number">.0</span> <span class="hljs-number">-7</span>         <span class="hljs-number">0.03000</span>         -  <span class="hljs-number">20</span> GiB  <span class="hljs-number">1.0</span> GiB  <span class="hljs-number">828</span> KiB  <span class="hljs-number">24</span> KiB  <span class="hljs-number">1024</span> MiB  <span class="hljs-number">19</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>    -              host node5 <span class="hljs-number">2</span>    ssd  <span class="hljs-number">0.03000</span>   <span class="hljs-number">1.00000</span>  <span class="hljs-number">20</span> GiB  <span class="hljs-number">1.0</span> GiB  <span class="hljs-number">828</span> KiB  <span class="hljs-number">24</span> KiB  <span class="hljs-number">1024</span> MiB  <span class="hljs-number">19</span> GiB  <span class="hljs-number">5.01</span>  <span class="hljs-number">1.00</span>   <span class="hljs-number">81</span>      up          osd<span class="hljs-number">.2</span>                        TOTAL  <span class="hljs-number">60</span> GiB  <span class="hljs-number">3.0</span> GiB  <span class="hljs-number">2.4</span> MiB  <span class="hljs-number">61</span> KiB   <span class="hljs-number">3.0</span> GiB  <span class="hljs-number">57</span> GiB  <span class="hljs-number">5.01</span>                                   MIN/MAX VAR: <span class="hljs-number">1.00</span>/<span class="hljs-number">1.00</span>  STDDEV: <span class="hljs-number">0</span></code></pre><h2 id="4-1-Rules"><a href="#4-1-Rules" class="headerlink" title="4.1 Rules"></a>4.1 Rules</h2><p>查看集群的rules</p><pre><code class="hljs crmsh">sudo ceph osd crush <span class="hljs-keyword">rule</span> ls</code></pre><pre><code class="hljs ebnf"><span class="hljs-attribute">replicated_rule</span><span class="hljs-attribute">ecpool</span></code></pre><p>你也能打印出rules的细节</p><pre><code class="hljs crmsh">sudo ceph osd crush <span class="hljs-keyword">rule</span> dump</code></pre><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">&quot;rule_id&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">&quot;rule_name&quot;</span>: <span class="hljs-string">&quot;replicated_rule&quot;</span>,        <span class="hljs-attr">&quot;ruleset&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">&quot;min_size&quot;</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">&quot;max_size&quot;</span>: <span class="hljs-number">10</span>,        <span class="hljs-attr">&quot;steps&quot;</span>: [            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;take&quot;</span>,                <span class="hljs-attr">&quot;item&quot;</span>: <span class="hljs-number">-1</span>,                <span class="hljs-attr">&quot;item_name&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>            &#125;,            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;chooseleaf_firstn&quot;</span>,                <span class="hljs-attr">&quot;num&quot;</span>: <span class="hljs-number">0</span>,                <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;host&quot;</span>            &#125;,            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;emit&quot;</span>            &#125;        ]    &#125;,    &#123;        <span class="hljs-attr">&quot;rule_id&quot;</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">&quot;rule_name&quot;</span>: <span class="hljs-string">&quot;ecpool&quot;</span>,        <span class="hljs-attr">&quot;ruleset&quot;</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">&quot;min_size&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">&quot;max_size&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">&quot;steps&quot;</span>: [            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;set_chooseleaf_tries&quot;</span>,                <span class="hljs-attr">&quot;num&quot;</span>: <span class="hljs-number">5</span>            &#125;,            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;set_choose_tries&quot;</span>,                <span class="hljs-attr">&quot;num&quot;</span>: <span class="hljs-number">100</span>            &#125;,            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;take&quot;</span>,                <span class="hljs-attr">&quot;item&quot;</span>: <span class="hljs-number">-1</span>,                <span class="hljs-attr">&quot;item_name&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>            &#125;,            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;chooseleaf_indep&quot;</span>,                <span class="hljs-attr">&quot;num&quot;</span>: <span class="hljs-number">0</span>,                <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;host&quot;</span>            &#125;,            &#123;                <span class="hljs-attr">&quot;op&quot;</span>: <span class="hljs-string">&quot;emit&quot;</span>            &#125;        ]    &#125;]</code></pre><h2 id="4-2-Device-class"><a href="#4-2-Device-class" class="headerlink" title="4.2 Device class"></a>4.2 Device class</h2><p>可以通过以下命令设置device的类别（<code>hdd</code>, <code>ssd</code>, or <code>nvme</code>）</p><pre><code class="hljs dsconfig"><span class="hljs-string">sudo </span><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">crush </span><span class="hljs-built_in">set-device-class</span> &lt;<span class="hljs-string">class&gt;</span> &lt;<span class="hljs-string">osd-name&gt;</span> [...]</code></pre><p>可以通过以下命令更改为其它类别</p><pre><code class="hljs ruby">sudo ceph osd crush rm-device-<span class="hljs-class"><span class="hljs-keyword">class</span> &lt;osd-<span class="hljs-title">name</span>&gt; [...]</span></code></pre><p>如果我们想创建新的placement rule</p><pre><code class="hljs dsconfig"><span class="hljs-string">sudo </span><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">crush </span><span class="hljs-string">rule </span><span class="hljs-built_in">create-replicated</span> &lt;<span class="hljs-string">rule-name&gt;</span> &lt;<span class="hljs-string">root&gt;</span> &lt;<span class="hljs-string">failure-domain&gt;</span> &lt;<span class="hljs-string">class&gt;</span></code></pre><p>对于pool而言就是</p><pre><code class="hljs routeros">sudo ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> &lt;pool-name&gt; crush_rule &lt;rule-name&gt;</code></pre><p>通过为使用中的每个仅包含该类设备的设备类创建一个“影子” CRUSH层次结构来实现设备类。然后，CRUSH规则可以在影子层次结构上分布数据。</p><pre><code class="hljs ada">sudo ceph osd crush tree <span class="hljs-comment">--show-shadow</span></code></pre><pre><code class="hljs lsl">ID  CLASS  WEIGHT   TYPE NAME         <span class="hljs-number">-2</span>    ssd  <span class="hljs-number">0.05846</span>  root <span class="hljs-section">default</span>~ssd  <span class="hljs-number">-6</span>    ssd  <span class="hljs-number">0.01949</span>      host node3~ssd <span class="hljs-number">1</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.1</span>     <span class="hljs-number">-4</span>    ssd  <span class="hljs-number">0.01949</span>      host node4~ssd <span class="hljs-number">0</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.0</span>     <span class="hljs-number">-8</span>    ssd  <span class="hljs-number">0.01949</span>      host node5~ssd <span class="hljs-number">2</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.2</span>     <span class="hljs-number">-1</span>         <span class="hljs-number">0.05846</span>  root <span class="hljs-section">default</span>      <span class="hljs-number">-5</span>         <span class="hljs-number">0.01949</span>      host node3     <span class="hljs-number">1</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.1</span>     <span class="hljs-number">-3</span>         <span class="hljs-number">0.01949</span>      host node4     <span class="hljs-number">0</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.0</span>     <span class="hljs-number">-7</span>         <span class="hljs-number">0.01949</span>      host node5     <span class="hljs-number">2</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.2</span></code></pre><h2 id="4-3-权重集"><a href="#4-3-权重集" class="headerlink" title="4.3 权重集"></a>4.3 权重集</h2><p>权重集使群集可以根据群集的详细信息（层次结构，池等）执行数值优化，以实现平衡分配。</p><p>支持两种类型的权重集，目前支持两种类型的weight set：</p><ul><li>Compat权重集，针对集群每个节点而设计的权重，具有良好的向后兼容性。</li><li>Per-pool权重集，针对数据池的权重集。</li></ul><h2 id="4-4-修改CRUSH-Map"><a href="#4-4-修改CRUSH-Map" class="headerlink" title="4.4 修改CRUSH Map"></a>4.4 修改CRUSH Map</h2><p>要在正在运行的群集的CRUSH映射中添加或移动OSD，请执行以下操作：</p><pre><code class="hljs sql">sudo ceph osd crush <span class="hljs-keyword">set</span> &#123;<span class="hljs-keyword">name</span>&#125; &#123;weight&#125; root=&#123;root&#125; [&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">type</span>&#125;=&#123;<span class="hljs-keyword">bucket</span>-<span class="hljs-keyword">name</span>&#125; ...]</code></pre><p>{name}指osd名称</p><h2 id="4-5-调整OSD权重¶"><a href="#4-5-调整OSD权重¶" class="headerlink" title="4.5 调整OSD权重¶"></a>4.5 调整OSD权重<a href="https://docs.ceph.com/en/latest/rados/operations/crush-map/#adjust-osd-weight">¶</a></h2><p>要在正在运行的群集的CRUSH映射中调整OSD的CRUSH权重，请执行以下操作：</p><pre><code class="hljs dust"><span class="xml">sudo ceph osd crush reweight </span><span class="hljs-template-variable">&#123;name&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;weight&#125;</span></code></pre><p>要从正在运行的群集的CRUSH映射中删除OSD，请执行以下操作：</p><pre><code class="hljs routeros">sudo ceph osd crush <span class="hljs-builtin-name">remove</span> &#123;name&#125;</code></pre><p>要在正在运行的集群的CRUSH映射中添加存储桶，请执行以下 命令：<code>sudo ceph osd crush add-bucket</code></p><pre><code class="hljs smali">sudo ceph osd crush<span class="hljs-built_in"> add-bucket </span>&#123;bucket-name&#125; &#123;bucket-type&#125;</code></pre><p>要将存储桶移动到CRUSH地图层次结构中的其他位置或位置，请执行以下操作：</p><pre><code class="hljs sqf">sudo ceph osd crush <span class="hljs-built_in">move</span> &#123;bucket-<span class="hljs-built_in">name</span>&#125; &#123;bucket-<span class="hljs-built_in">type</span>&#125;=&#123;bucket-<span class="hljs-built_in">name</span>&#125;, [...]</code></pre><p>要从CRUSH层次结构中删除存储桶，请执行以下操作：</p><pre><code class="hljs routeros">sudo ceph osd crush <span class="hljs-builtin-name">remove</span> &#123;bucket-name&#125;</code></pre><h2 id="4-6-创建一个Compat权重集"><a href="#4-6-创建一个Compat权重集" class="headerlink" title="4.6 创建一个Compat权重集"></a>4.6 创建一个Compat权重集</h2><p>要创建<em>兼容的权重集</em>：</p><pre><code class="hljs livecodeserver">sudo ceph osd crush weight-<span class="hljs-built_in">set</span> <span class="hljs-built_in">create</span>-compat</code></pre><p>兼容重量组的重量可以通过以下方式调整：</p><pre><code class="hljs applescript">sudo ceph osd crush weight-<span class="hljs-keyword">set</span> reweight-compat &#123;<span class="hljs-built_in">name</span>&#125; &#123;weight&#125;</code></pre><p>可以用以下方法删除：</p><pre><code class="hljs routeros">sudo ceph osd crush weight-<span class="hljs-builtin-name">set</span> rm-compat</code></pre><h2 id="4-7-创建per-pool的权重集"><a href="#4-7-创建per-pool的权重集" class="headerlink" title="4.7 创建per-pool的权重集"></a>4.7 创建per-pool的权重集</h2><p>要为特定池创建权重集，请执行以下操作：</p><pre><code class="hljs sql">sudo ceph osd crush weight-<span class="hljs-keyword">set</span> <span class="hljs-keyword">create</span> &#123;pool-<span class="hljs-keyword">name</span>&#125; &#123;<span class="hljs-keyword">mode</span>&#125;</code></pre><p>调整权重：</p><pre><code class="hljs applescript">sudo ceph osd crush weight-<span class="hljs-keyword">set</span> reweight &#123;pool-<span class="hljs-built_in">name</span>&#125; &#123;<span class="hljs-built_in">item</span>-<span class="hljs-built_in">name</span>&#125; &#123;weight [...]&#125;</code></pre><p>要列出现有的权重集，请执行以下操作：</p><pre><code class="hljs routeros">sudo ceph osd crush weight-<span class="hljs-builtin-name">set</span> ls</code></pre><p>要删除，请执行以下操作：</p><pre><code class="hljs applescript">sudo ceph osd crush weight-<span class="hljs-keyword">set</span> rm &#123;pool-<span class="hljs-built_in">name</span>&#125;</code></pre><h2 id="4-8-为副本创建规则"><a href="#4-8-为副本创建规则" class="headerlink" title="4.8 为副本创建规则"></a>4.8 为副本创建规则</h2><pre><code class="hljs dsconfig"><span class="hljs-string">sudo </span><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">crush </span><span class="hljs-string">rule </span><span class="hljs-built_in">create-replicated</span> &#123;<span class="hljs-string">name&#125;</span> &#123;<span class="hljs-string">root&#125;</span> &#123;<span class="hljs-string">failure-domain-</span><span class="hljs-string">type&#125;</span> [&#123;<span class="hljs-string">class&#125;</span>]</code></pre><h2 id="4-9-为纠删码创建规则"><a href="#4-9-为纠删码创建规则" class="headerlink" title="4.9 为纠删码创建规则"></a>4.9 为纠删码创建规则</h2><p>对于纠删码（EC）池，需要做出相同的基本决策：故障域是什么，层次结构中的哪个节点将数据放置在（通常为<code>default</code>）下，并且放置位置将限制为特定的设备类。但是，纠删码池的创建方式略有不同，因为需要根据所使用的删除代码仔细构建它们。因此，您必须在<em>纠删码配置文件中</em>包含此信息。使用配置文件创建池时，将根据该规则显式或自动创建CRUSH规则。</p><p>纠删码配置文件可以列出：</p><pre><code class="hljs vim">sudo ceph osd erasure-code-<span class="hljs-keyword">profile</span> <span class="hljs-keyword">ls</span></code></pre><p>查看某个特定配置</p><pre><code class="hljs vim">sudo ceph osd erasure-code-<span class="hljs-keyword">profile</span> <span class="hljs-built_in">get</span> &#123;<span class="hljs-keyword">profile</span>-name&#125;</code></pre><p>通常，绝对不要修改配置文件。而是在创建新池或为现有池创建新规则时创建并使用新配置文件。</p><p>感兴趣的纠删码配置文件属性为：</p><blockquote><ul><li><strong>rush-root</strong>：要在其下放置数据的CRUSH节点的名称[默认值：<code>default</code>]。</li><li><strong>rush-failure-domain</strong>：在其上分配擦除编码分片的CRUSH存储桶类型[默认值：<code>host</code>]。</li><li><strong>rush-device-class</strong>：放置数据的设备类[默认：无，表示使用了所有设备]。</li><li><strong>k</strong>和<strong>m</strong>（对于<code>lrc</code>插件，为<strong>l</strong>）：它们确定擦除代码分片的数量，影响最终的CRUSH规则。</li></ul></blockquote><p>定义配置文件后，您可以使用以下方法创建CRUSH规则：</p><pre><code class="hljs dsconfig"><span class="hljs-string">sudo </span><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">crush </span><span class="hljs-string">rule </span><span class="hljs-built_in">create-erasure</span> &#123;<span class="hljs-string">name&#125;</span> &#123;<span class="hljs-string">profile-name&#125;</span><span class="hljs-comment">#&#123;name&#125;为规则名称</span></code></pre><p>可以通过以下方式删除池未使用的规则：</p><pre><code class="hljs pgsql">sudo ceph osd crush <span class="hljs-keyword">rule</span> rm &#123;<span class="hljs-keyword">rule</span>-<span class="hljs-type">name</span>&#125;</code></pre><h2 id="4-10-自定义CRUSH规则♥"><a href="#4-10-自定义CRUSH规则♥" class="headerlink" title="4.10 自定义CRUSH规则♥"></a>4.10 自定义CRUSH规则♥</h2><blockquote><p><a href="https://docs.ceph.com/en/latest/rados/operations/crush-map-edits/">https://docs.ceph.com/en/latest/rados/operations/crush-map-edits/</a></p></blockquote><p>我们可以通过CLI来很方便的修改CRUSH各项配置，但是如果修改项目过多，而集群较多，直接编辑CRUSH map 会是更好的选择。在一些特殊情况下，比如集群HDD和SSD和NVME混合则必须单独配置CRUSH rules。</p><h3 id="（1）获取CRUSH-Map"><a href="#（1）获取CRUSH-Map" class="headerlink" title="（1）获取CRUSH Map"></a>（1）获取CRUSH Map</h3><pre><code class="hljs dts">sudo ceph osd getcrushmap -<span class="hljs-class">o </span>&#123;compilefilename&#125;</code></pre><p>之后我们将其解码为txt</p><pre><code class="hljs dts">crushtool -<span class="hljs-class">d </span>&#123;compilefilename&#125; -<span class="hljs-class">o </span>&#123;outputfilename&#125;.txt</code></pre><p>例如 </p><pre><code class="hljs css"><span class="hljs-selector-tag">crushtool</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-tag">mycrushmap</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">mycrushmap</span><span class="hljs-selector-class">.txt</span></code></pre><p>典型的crush map如下:</p><p>它包含6个部分：</p><ol><li><strong>可调项：</strong> tunable</li><li><strong>设备：</strong>设备是存储数据的单个OSD。</li><li><strong>types</strong>：存储桶<code>types</code>定义在CRUSH层次结构中使用的存储桶的类型。存储桶由存储位置（例如，行，机架，机箱，主机等）及其分配的权重的分层聚合组成。</li><li><strong>存储桶：</strong>定义存储桶类型后，必须定义层次结构中的每个节点，其类型以及它包含的设备或其他节点。</li><li><strong>规则：</strong>规则定义有关数据如何在层次结构中的各个设备之间分配的策略。</li><li>choice_args <strong>：</strong> Choose_args是与层次结构关联的替代权重，这些权重已进行调整以优化数据放置。单个choose_args映射可以用于整个集群，也可以为每个单独的池创建一个映射。</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> begin crush map</span>tunable choose_local_tries 0tunable choose_local_fallback_tries 0tunable choose_total_tries 50tunable chooseleaf_descend_once 1tunable chooseleaf_vary_r 1tunable chooseleaf_stable 1tunable straw_calc_version 1tunable allowed_bucket_algs 54<span class="hljs-meta">#</span><span class="bash"> devices</span>device 0 osd.0 class ssddevice 1 osd.1 class ssddevice 2 osd.2 class ssd<span class="hljs-meta">#</span><span class="bash"> types</span>type 0 osdtype 1 hosttype 2 chassistype 3 racktype 4 rowtype 5 pdutype 6 podtype 7 roomtype 8 datacentertype 9 zonetype 10 regiontype 11 root<span class="hljs-meta">#</span><span class="bash"> buckets</span>host node4 &#123;        id -3           # do not change unnecessarily        id -4 class ssd         # do not change unnecessarily        # weight 0.020        alg straw2        hash 0  # rjenkins1        item osd.0 weight 0.020&#125;...root default &#123;        id -1           # do not change unnecessarily        id -2 class ssd         # do not change unnecessarily        # weight 0.060        alg straw2        hash 0  # rjenkins1        item node4 weight 0.020        item node3 weight 0.010        item node5 weight 0.030&#125;<span class="hljs-meta">#</span><span class="bash">rules</span>rule replicated_rule &#123;        id 0        type replicated        min_size 1        max_size 10        step take default        step chooseleaf firstn 0 type host        step emit&#125;rule ecpool &#123;        id 1        type erasure        min_size 3        max_size 3        step set_chooseleaf_tries 5        step set_choose_tries 100        step take default        step chooseleaf indep 0 type host        step emit&#125;...<span class="hljs-meta">#</span><span class="bash"> choose_args</span>choose_args 4 &#123;  &#123;    bucket_id -1    weight_set [      [ 0.020 0.010 0.030 ]    ]  &#125;&#125;...<span class="hljs-meta">#</span><span class="bash"> end crush map</span></code></pre><p>我们对ruleset中参数稍作解释</p><p><code>step</code> 包括三个部分 take, chooseleaf, emit</p><ul><li>chooseleaf, 容灾域模式，可以替换为choose，即非容灾域模式。</li><li>firstn, 两种选择算法之一，参看前面理论部分，可以替换为indep.</li><li>0, 表示由具体的调用者指定输出的副本数，例如不同的pool可以使用同一套ruleset（拥有相同的备份策略），但是可以拥有不同的副本数。</li><li>type，对应chooseleaf操作，指示输出必须是分布在由本选项指定类型的、不同的bucket之下的叶子节点；对应choose操作，指示输出类型。</li></ul><p><code>set_chooseleaf_tries</code>: 容灾域下产生递归调用时的尝试次数。</p><p><code>set_choose_tries</code>: 非容灾域下产生递归调用的尝试次数。</p><p><code>min_size</code>: 如果池中的副本数少于此数量，则CRUSH将 <strong>不会</strong>选择此规则。</p><p><code>max_size</code>: 如果池中的副本数量超过此数量，则CRUSH将 <strong>不会</strong>选择此规则。</p><blockquote><p><code>firstn</code> 与 <code>indep</code></p><ul><li>描述</li></ul><p>控制在CRUSH映射中标记了项目（OSD）时CRUSH使用的替换策略。<strong>如果此规则将用于复制池，则应使用<code>firstn</code>；如果是擦除编码池，则应使用<code>indep</code></strong>。原因与先前选择的设备发生故障时它们的行为有关。假设您有一个PG存储在OSD 1、2、3、4、5上。然后3下降。在“ firstn”模式下，CRUSH只需将其计算调整为选择1和2，然后选择3，但发现它已关闭，因此它重试并选择4和5，然后继续选择一个新的OSD6。因此最终的CRUSH映射更改为1、2、3、4、5-&gt; 1、2、4、5、6。但是，如果要存储EC池，则意味着您只需更改映射到OSD 4、5和6的数据！因此，“独立”模式试图不这样做。相反，您可以期望它在选择失败的OSD 3时再次尝试并选择6，以进行以下最终转换：1，2，3，4，5-&gt; 1，2，6，4，5</p></blockquote><div class="note note-danger">            <p>重要 :给定的CRUSH规则可以分配给多个池，但是单个池不可能具有多个CRUSH规则。</p>          </div><h3 id="（2）修改并编译CRUSH-Map"><a href="#（2）修改并编译CRUSH-Map" class="headerlink" title="（2）修改并编译CRUSH Map"></a>（2）修改并编译CRUSH Map</h3><p>我们需要进行编译才能被ceph识别</p><pre><code class="hljs dts">crushtool - <span class="hljs-class">c </span>&#123;decompiled_filename&#125; -<span class="hljs-class">o </span>&#123;compiled_filename&#125;</code></pre><h3 id="（3）测试"><a href="#（3）测试" class="headerlink" title="（3）测试"></a>（3）测试</h3><p>例如我们打印出输入范围为[0,9]、副本数3，采用编号为0的ruleset映射的结果。</p><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo</span> <span class="hljs-comment">crushtool</span> <span class="hljs-literal">-</span><span class="hljs-comment">i</span> <span class="hljs-comment">&#123;compiled_filename&#125;</span> --<span class="hljs-comment">test</span> --<span class="hljs-comment">min</span><span class="hljs-literal">-</span><span class="hljs-comment">x</span> <span class="hljs-comment">0</span> --<span class="hljs-comment">max</span><span class="hljs-literal">-</span><span class="hljs-comment">x</span> <span class="hljs-comment">9</span> --<span class="hljs-comment">num</span><span class="hljs-literal">-</span><span class="hljs-comment">rep</span> <span class="hljs-comment">3</span> --<span class="hljs-comment">ruleset</span> <span class="hljs-comment">0\</span><span class="hljs-comment"></span> --<span class="hljs-comment">show_mappings</span></code></pre><pre><code class="hljs angelscript">CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">0</span> [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">1</span> [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">2</span> [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">3</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">4</span> [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">5</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">6</span> [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">7</span> [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">8</span> [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]CRUSH rule <span class="hljs-number">0</span> x <span class="hljs-number">9</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]</code></pre><p>也可以仅统计结果分布情况，输入变为[0,100000]</p><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo</span> <span class="hljs-comment">crushtool</span> <span class="hljs-literal">-</span><span class="hljs-comment">i</span> <span class="hljs-comment">mycrushmap</span> --<span class="hljs-comment">test</span> --<span class="hljs-comment">min</span><span class="hljs-literal">-</span><span class="hljs-comment">x</span> <span class="hljs-comment">0</span> --<span class="hljs-comment">max</span><span class="hljs-literal">-</span><span class="hljs-comment">x</span> <span class="hljs-comment">100000</span> --<span class="hljs-comment">num</span><span class="hljs-literal">-</span><span class="hljs-comment">rep</span> <span class="hljs-comment">3\</span><span class="hljs-comment"></span> --<span class="hljs-comment">ruleset</span> <span class="hljs-comment">0</span> --<span class="hljs-comment">show_utilization</span></code></pre><pre><code class="hljs yaml"><span class="hljs-string">rule</span> <span class="hljs-number">0</span> <span class="hljs-string">(replicated_rule),</span> <span class="hljs-string">x</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">..100000,</span> <span class="hljs-string">numrep</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><span class="hljs-string">..3</span><span class="hljs-string">rule</span> <span class="hljs-number">0</span> <span class="hljs-string">(replicated_rule)</span> <span class="hljs-string">num_rep</span> <span class="hljs-number">3</span> <span class="hljs-string">result</span> <span class="hljs-string">size</span> <span class="hljs-string">==</span> <span class="hljs-attr">2:</span><span class="hljs-number">3</span><span class="hljs-string">/100001</span><span class="hljs-string">rule</span> <span class="hljs-number">0</span> <span class="hljs-string">(replicated_rule)</span> <span class="hljs-string">num_rep</span> <span class="hljs-number">3</span> <span class="hljs-string">result</span> <span class="hljs-string">size</span> <span class="hljs-string">==</span> <span class="hljs-attr">3:</span><span class="hljs-number">99998</span><span class="hljs-string">/100001</span>  <span class="hljs-attr">device 0:</span> <span class="hljs-attr">stored :</span> <span class="hljs-number">100001</span> <span class="hljs-attr">expected :</span> <span class="hljs-number">100001</span>  <span class="hljs-attr">device 1:</span> <span class="hljs-attr">stored :</span> <span class="hljs-number">99998</span> <span class="hljs-attr">expected :</span> <span class="hljs-number">100001</span>  <span class="hljs-attr">device 2:</span> <span class="hljs-attr">stored :</span> <span class="hljs-number">100001</span> <span class="hljs-attr">expected :</span> <span class="hljs-number">100001</span></code></pre><p>需要注意的是，除了叶子节点，其它的层级均为虚拟的，例如下面这个例子，我们让所有副本都必须分布在编号为0,1,2者三个特定的osd上。</p><p>可以通过如下语句声明存储桶：</p><pre><code class="hljs clojure">[bucket-type] [bucket-name] &#123;        id [a unique negative numeric ID]        weight [the relative capacity/capability of the item(<span class="hljs-name">s</span>)]        alg [the bucket type: uniform | list | tree | straw | straw2 ]        hash [the hash type: <span class="hljs-number">0</span> by default]        item [item-name] weight [weight]&#125;</code></pre><pre><code class="hljs routeros">vim mycrushmap.txthost virtualhost&#123;id -14#weight 3.00alg straw2hash 0 # rejenkins1item osd.0 weight 1.00item osd.1 weight 1.00item osd.2 weight 1.00&#125;<span class="hljs-comment">#rules</span>rule customized_ruleset&#123;ruleset 1<span class="hljs-built_in">type </span>replicated min_size 1max_size 10<span class="hljs-keyword">step</span> take virtualhost<span class="hljs-keyword">step</span> chooseleaf firstn 0<span class="hljs-built_in"> type </span>osd<span class="hljs-keyword">step</span> emit&#125;</code></pre><h3 id="（4）注入集群"><a href="#（4）注入集群" class="headerlink" title="（4）注入集群"></a>（4）注入集群</h3><pre><code class="hljs dts">sudo ceph osd setcrushmap -<span class="hljs-class">i </span>&#123;compiledfilename&#125;</code></pre><h2 id="4-11数据重平衡"><a href="#4-11数据重平衡" class="headerlink" title="4.11数据重平衡"></a>4.11数据重平衡</h2><p>找到空间利用率比较高的osd然后执行</p><pre><code class="hljs \">sudo ceph osd reweight &#123;osd_num_id&#125; &#123;reweight&#125;</code></pre><p>当然也可以批量调整：目前有两种模式</p><ul><li>按照OSD当前的空间利用率(<code>reweight-by-utilization</code>) ;</li><li>按照PG在OSD之间的分布(<code>reweight-by-pg</code>)。</li></ul><p>为防止影响前端业务，可以先进行测试，这会触发PG进行迁移量统计。</p><p>例如：</p><pre><code class="hljs dust"><span class="xml">sudo ceph osd test-reweight-by-utilization </span><span class="hljs-template-variable">&#123;oload&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;max_change&#125;</span><span class="xml">\</span><span class="hljs-template-variable">&#123;max_osds&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;--no-increasing&#125;</span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">oload</td><td style="text-align:center">可选；整型，≥100，默认值120；当且仅当某个OSD的空间利用率大于等于集群瓶颈空间利用率的overload/100时，调整其reweight</td></tr><tr><td style="text-align:center">max_change</td><td style="text-align:center">可选，浮点数，[0,1]；默认受<code>mon_reweight_max_change</code>控制，目前为0.05.每次调整reweight的最大幅度，即调整上限。实际每个osd调整幅度取决于自身空间利用率与集群平均空间利用率的偏离程度——偏离越多调整越大</td></tr><tr><td style="text-align:center">max_osds</td><td style="text-align:center">可选，整型，默认受<code>mon_reweight_max_osds</code>控制，目前为4.每次至多调整的osd数目。</td></tr><tr><td style="text-align:center">—no-increasing</td><td style="text-align:center">可选,字符类型，如果携带，则从不将reweight进行上调（上调指将当前的underload的OSD权重调大，让其分担更多PG）；如果不携带，至多将OSD的reweight调整至1.0/</td></tr></tbody></table></div><p>使用以下参数进行确认</p><pre><code class="hljs dust"><span class="xml">sudo ceph osd reweight-by-utilization </span><span class="hljs-template-variable">&#123;oload&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;max_change&#125;</span><span class="xml">\</span><span class="hljs-template-variable">&#123;max_osds&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;--no-increasing&#125;</span></code></pre><blockquote><p>合理设置weights</p><p>Ceph将weights表示为两倍，从而可以进行精细调整。 weight是设备容量之间的相对差。 我们建议将1.00用作1TB存储设备的相对重量。 在这种情况下，权重为0.5代表大约500GB，权重为3.00代表大约3TB。 较高级别的存储桶的权重是该存储桶聚合的所有叶子项的总和。</p><p>桶项目weight是一维的，但您也可以计算项目重量以反映存储驱动器的性能。 例如，如果您有许多1TB驱动器，其中一些具有较低的数据传输速率，而另一些具有较高的数据传输速率，则即使它们具有相同的容量（例如，硬盘的权重为0.80），也可以对其进行不同的加权。 第一组总吞吐量较低的驱动器，以及1.20第二组总吞吐量较高的驱动器）。</p></blockquote><hr><p>2020/12/22更新</p><h2 id="MapX-lt-span-class-”hint—top-hint—rounded”-aria-label-”Wang-L-Zhang-Y-Xu-J-et-al-MAPX-Controlled-Data-Migration-in-the-Expansion-of-Decentralized-Object-Based-Storage-Systems-C-18th-USENIX-Conference-on-File-and-Storage-Technologies-FAST-20-2020-1-11"><a href="#MapX-lt-span-class-”hint—top-hint—rounded”-aria-label-”Wang-L-Zhang-Y-Xu-J-et-al-MAPX-Controlled-Data-Migration-in-the-Expansion-of-Decentralized-Object-Based-Storage-Systems-C-18th-USENIX-Conference-on-File-and-Storage-Technologies-FAST-20-2020-1-11" class="headerlink" title="MapX&lt;span class=”hint—top hint—rounded” aria-label=”Wang L, Zhang Y, Xu J, et al. {MAPX}: Controlled Data Migration in the Expansion of Decentralized Object-Based Storage Systems[C]//18th {USENIX} Conference on File and Storage Technologies ({FAST} 20). 2020: 1-11."></a>MapX<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=”hint—top hint—rounded” aria-label=”Wang L, Zhang Y, Xu J, et al. {MAPX}: Controlled Data Migration in the Expansion of Decentralized Object-Based Storage Systems[C]//18th {USENIX} Conference on File and Storage Technologies ({FAST} 20). 2020: 1-11.</h2><p>“&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; (FAST20’) 中对CRUSH算法的改进</p><p>传统的CRUSH架构如下图（图1）</p><p><img src="/img/mapx1.png" alt="image-20201224164010122" style="zoom:80%;" /></p><p>传统的CRUSH算法在增加节点时会导致大量的数据迁移，导致系统性能下降。下图（图2）模拟了两个模拟CRUSH集群在扩展时发生的数据迁移。</p><p><img src="/img/mapx2.png" alt="image-20201224162115959" style="zoom:80%;" /></p><p>定性的表示，数据迁移量可以高达hΔw/W，其中h是层次结构中的级别数，而Δw和W是扩展权重以及 所有OSD的总重量.</p><p>存储系统通常在集群扩展时会避免数据迁移，这会导致数据暂时不平衡。比如，Haystack和HDFS采用中心目录来避免已有的对象受到影响。因此本文思考通过加入适当的中心化成分来优化CRUSH。</p><p><img src="/img/mapx3.png" alt="image-20201224163557319" style="zoom:67%;" /></p><p>上图(3)表示，MAPX对每次扩展记录为“一层”。MAPX 会加入select到placement rule当中。可与传统CRUSH对比理解。为了支持时间维度的映射并且对CRUSH改动最小，我们在root下插入一个虚拟层，每一个虚拟节点表示一个扩展层。 虚拟层使MAPX能够通过在将新对象映射到新层之前对CRUSH算法进行进一步处理来实现无迁移扩展。 由于新层不会影响旧层的权重，因此旧对象在旧层中的放置不会改变。</p><h3 id="映射对象到PG"><a href="#映射对象到PG" class="headerlink" title="映射对象到PG"></a>映射对象到PG</h3><p>在每次扩展中，都会为新层分配一定数量的新创建的PG，每个PG的时间戳（$t_{pgs}$）等于该层的扩展时间（$t_l$）。 写入/读取对象O（带有创建时间戳记$t_0$）时，我们首先通过以下方法计算O的PG的ID（pgid）：</p><script type="math/tex; mode=display">pgid =Hash(name) \text{ mod INIT_PG_NUM[j]} + \sum\limits_{i=0}^{j-1}\text{INIT_PG_NUM[i]}</script><p>这里name表示对象名，<code>INT_PG_NUM[i]</code>表示PG第i层的初始值，并且第j层拥有最小的时间标签$t_l\le t_O$，PG可能会重新映射到其他层，例如进行负载平衡（第3.2节），<code>INIT_PG_NUM</code>是层的常量，因此从对象到PG的映射是不可变的。<br>   因此，每个对象在创建过程中都映射到负责的PG，所有PG中的最新时间戳$t_{pgs}≤t_O$。 例如，图3（b）中的三个RBD1，RBD2和RBD3是分别在layer0，layer1和layer2扩展之后创建的。  RBD1，RBD2和RBD3的对象将使用三层的<code>INIT_PG_NUM</code>分别计算其在layer0，layer1和layer2内的PG。</p><h3 id="将PG映射到OSD"><a href="#将PG映射到OSD" class="headerlink" title="将PG映射到OSD"></a>将PG映射到OSD</h3><p><img src="/img/mapx4.png" alt="image-20201224170254087" style="zoom:67%;" /></p><p>下面我们看下这篇文章具体是如何改进CRUSH的。</p><ul><li><p>如果type不是“layer”那么就等同于原始CRUSH算法（2~4行）。</p></li><li><p>否则，我们将初始化一个图层数组，该数组按图层时间戳的升序（第5行）存储当前正在处理的存储桶（通常是根目录）下的所有图层。 我们还在第6到8行初始化num层（层数），pg（放置组）和〜o（输出列表）。然后循环（第9-21行）在层阵列中添加数字层 到输出列表〜o。 在大多数情况下，层数为 1，PG可以在一层中映射到OSD，也有number很大的情况，比如在两个扩展层进行镜像。</p></li><li>请注意，对象的副本不一定都放置在最新层上。 例如，假设最后一个扩展（第2层）在图3（a）中仅添加了两个机柜（即m = 2），但是第二个<code>select()</code>函数（<code>select(3,cabinet)</code>）需要三个机柜。 这将导致第一个<code>select()</code>函数<code>(select(1,layer)</code> 被调用两次，以满足遵循CRUSH回溯机制的规则：当<code>select()</code>函数无法在“ layer”存储桶下选择足够的项目时，MAPX 将保留（而不是放弃）选定的项目，并回溯到根以选择上一层下面的缺少的项目。 第12至14行检查先前的<code>select()</code>是否选择了图层，如果是，我们将继续进行下一个循环，以避免执行回溯时重复的图层选择。 仔细检查可确保算法1正确处理此情况，并分别为第一个和第二个<code>select()</code>函数返回layer2和layer1。</li></ul><h3 id="迁移控制"><a href="#迁移控制" class="headerlink" title="迁移控制"></a>迁移控制</h3><p>由于原始CRUSH的随机性和均匀性，基于MAPX的免迁移放置算法可在每层内提供（统计）负载平衡，当当前层的负载增加到与先前层相同的水平时，通过适时扩展群集来实现不同层之间的近似负载平衡。但是，层的负载可能由于例如对象的移除，OSD的故障或不可预测的工作负载变化而改变。 例如，在图3中，当第一个扩展（第1层）的负载与原始集群（第0层）的负载一样高时，该集群可能会执行第二个扩展（第2层），但随后会有大量 删除第1层的对象，因此前两层的负载可能会变得不平衡。<br>  为了解决潜在的负载不平衡问题，我们设计了三种灵活的策略来动态管理MAPX中的负载，即放置组重新映射，群集收缩和层合并。</p><p><strong>PG重新映射</strong>。  MAPX支持通过动态重新映射PG来控制对象数据的迁移。 每个PG都有两个时间戳，即等于PG初始层扩展时间的静态时间戳（$t_{pgs}$）和可以设置为任何层的扩展时间的动态时间戳（$t_{pgd}$）。 与使用静态时间戳的从对象到PG的映射不同，从PG到图层的映射是通过将PG的动态时间戳与图层的时间戳进行比较来进行的（算法1中的第11行）。 因此，可以通过操纵动态时间戳（如图3（b）所示）将PG轻松地重新映射到任何层，该时间戳将通过增量映射更新通知所有OSD和客户端。  PG的时间戳存储开销适中。 例如，如果我们为每个PG时间戳使用一个字节索引（指向相应层的时间戳），该索引最多支持$2^8$层= 256层），并且假设一台机器有20个OSD，每个OSD负责200个PG，则 1000个机器集群的时间戳的内存开销为1000×20×200×2×1B = 8MB。<br>   <strong>集群收缩</strong>。 当层的负载低于阈值时，MAPX会通过从集群中删除该层的设备（例如OSD，机器和机架）来收缩集群，这是集群扩展的逆向操作。<br>   给定要从群集中删除的层Ω，我们首先将Ω中的所有PG根据其总权重分配给其余层（为简单起见，重新分配不考虑层的实际负载），然后将PG迁移到 通过重新映射确定目标层（如上所述）。 缩小后，逻辑上保留了Ω层（没有物理设备或PG），并且它的<code>INIT_PG_NUM</code>不会更改，以免影响从对象到PG的映射（根据等式（2））。<br>   <strong>层合并</strong>。  MAPX通过层合并来平衡两层（Ω和Ω’）的负载，这可以通过将一层（Ω’）的扩展时间设置为与另一层（Ω）相同的扩展时间来轻松实现。</p><p>我们通过将物理设备ID和该层的时间戳连接起来，为特定层（即，特定虚拟节点下方）的内部设备分配了虚拟设备ID。 <u>我们使用虚拟节点的权重字段来记录图层的时间戳，并将其与PG的动态时间戳进行比较以进行图层选择</u>。<br>   MAPX不适合用于一般对象存储，主要是因为维护和检索任意对象的时间戳很重要。 按对象时间戳维护的开销与维护中央目录的开销类似，因此在诸如CRUSH和MAPX的集中式放置方法中应避免这种开销。<br>   但是，MAPX适用于各种基于对象的存储系统，例如块存储（Ceph-RBD ）和文件存储（Ceph-FS），其中对象时间戳可以保持为更高级别 元数据。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>Ceph-RBD</strong>    </p><p>Ceph-RBD。 我们已经为Ceph-RBD（RADOS块设备）实现了基于元数据的时间戳检索机制。  Ceph将RBD的元数据（例如数据对象名称的前缀以及卷，快照，条带等信息）存储在其<code>rbd_header</code>结构中，当客户端通过<code>rbd_open</code>挂载RBD时将检索该元数据。 由于RBD的对象可以在任何扩展之后创建，因此我们继承当前层的时间戳（创建对象时）作为对象的时间戳。 因此，我们在<code>rbd_header</code>结构中添加了一个每个对象的索引（称为对象时间戳<code>object_timestamp</code>），该索引指向每一层的扩展时间。 额外元数据的存储开销适中。 例如，如果我们为每个对象索引使用一个字节，而每个对象为4MB，则4TB RBD的对象时间戳数组的存储开销最多为4TB/4MB×1B = 1MB。</p><p><strong>CephFS</strong></p><p> 我们还（部分）为CephFS（Ceph文件系统）实现了时间戳检索机制。<br>   Ceph将文件元数据（包括文件创建时间）存储在inode结构中。 客户端在打开文件时读取inode并获取文件创建时间。 当前，我们让文件的所有对象继承文件的时间戳，以便我们可以按文件的粒度控制时维映射。 我们还计划支持更精细的对象时间戳维护。 如果文件大小超过阈值T（例如T = 100 MB），我们可以将其划分为每个小于100 MB的子文件。 文件的元数据既维护了从文件到其子文件的映射，又维护了每个子文件的创建时间戳，因此我们可以以子文件的粒度控制时间维度映射。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="/img/mapx6.png" alt="image-20201224174039878" style="zoom:150%;" /></p><blockquote><p>​                                        左图4，第99百分位 I/O延迟对比；右图5 ，IOPS对比</p></blockquote><p>我们使用Ceph所有参数的默认值，但<code>OSD_max_backfills</code>除外。 如第1节所述，Ceph通过实现级优化减轻了CRUSH的迁移问题。 它使用参数<code>OSD_max_back_fill≥1</code>在数据迁移导致的性能下降的严重性和持续时间之间进行权衡。默认情况下，Ceph将参数<code>OSD_max_backfills</code>设置为1，这使迁移具有最低优先级，因此PG中的对象可能以极低的速度迁移。 尽管部分缓解了降级问题，但将<code>OSD_max_backfills</code>设置为1会大大延长迁移时间，并在迁移完成之前大大增加写入负载：等待迁移的PG写入将首先对原始OSD执行，然后异步进行 迁移到目标OSD。<br>   显然，这使Ceph遭受的性能下降的幅度较小，但时间较长。 我们设置<code>OSD_max_backfills=10</code>，在此实验中更合理，因此可以优先考虑迁移，以证明MAPX和CRUSH在算法级别上的差异。 </p><p>​    图4显示了第99个百分位尾延迟的评估结果。 请注意，云存储方案通常关心的是（第99、99.9或99.99个百分位）尾部延迟，而不是平均延迟或中值延迟，以确保SLA（服务等级保障协议）。  MAPX的性能比CRUSH高出4.25倍，这主要是因为CRUSH中的迁移与正常的I / O请求严重竞争。 在此实验中，MAPX始终使用初始群集的六个OSD来满足I / O请求，因为它不会将现有RBD迁移到新OSD。 相比之下，CRUSH分别使用六个，九个和十二个OSD，但是CRUSH引起的数据迁移会严重降低性能，这对于延迟敏感的应用程序是不可接受的。<br>   图5分别显示了MAPX和CRUSH中IOPS的评估结果。 每个结果均为20次运行的平均值，我们省略了误差线，因为与平均值的方差相对较小（小于5％）。 与延迟测试类似，在IOPS测试中，MAPX的性能明显优于CRUSH，最高可达到74.3％，这是因为CRUSH的数据迁移可以应付正常的I / O请求。</p><p><img src="A first glance at CRUSH/image-20201224200625534.png" alt="image-20201224200625534" style="zoom:80%;" /></p><blockquote><p>图7：MAPX和CRUSH的第99个百分点的I / O延迟（在群集收缩期间）。</p></blockquote><p><img src="A first glance at CRUSH/image-20201224200711635.png" alt="image-20201224200711635" style="zoom:80%;" /></p><blockquote><p>图8：在MAPX中合并的层中受影响的PG的数量（四个扩展之后）。 由于CRUSH不支持合并，因此我们在每次CRUSH扩展后测量受影响的PG的数量以供参考。</p></blockquote><p>我们使用CrushTool模拟MAPX中的图层合并。<br>   我们采用三向复制，其中每个对象在三个OSD上存储三个副本。 最初，存储集群由5个机架组成，每个机架有20台计算机。 一台机器有20个OSD。 总共有100台机器和2000个OSD，可存储20万个PG。 我们将集群扩展了四倍。 在每个扩展中，我们将一个机架的新层（包含20台计算机和400个OSD）添加到一个新层，并在新层中添加40,000个新PG。 显然，MAPX将所有新PG映射到新添加的OSD上，因此不会发生迁移。 四个扩展之后，总共有9个机架，180台机器和3600个OSD，可存储360,000个PG。 然后，我们合并第一扩展和第二扩展的40台机器，并测量MAPX中的合并影响了多少个PG。<br>   结果如图8所示，其中MAPX中的图层合并影响了两个合并图层的所有80,000 PG中的70,910 PG。  MAPX的层合并中受影响的PG的相对较高比例取决于作为参考，我们还模拟了CRUSH中的四个扩展，其中让群集最初具有360,000个PG，并且在扩展期间不添加新PG，因为否则CRUSH会将映射从对象更改为PG，从而导致更多PG迁移。<br>  图8还显示了CRUSH的每次扩展会影响多少PG。 例如，当机器数量从160增加到180时，几乎90％的PG在第四次扩展中都受到影响。</p><hr><h2 id="引用和参考文献"><a href="#引用和参考文献" class="headerlink" title="引用和参考文献"></a>引用和参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>WEIL, S. A., BRANDT, S. A., MILLER, E. L., AND MALTZAHN,C. Crush: Controlled, scalable, decentralized placement of replicateddata. In <em>SC</em>’06: Proceedings of the 2006 ACM/IEEE Conference on<em>Supercomputing</em> (2006), IEEE, pp. 31–31.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Wang L, Zhang Y, Xu J, et al. {MAPX}: Controlled Data Migration in the Expansion of Decentralized Object-Based Storage Systems[C]//18th {USENIX} Conference on File and Storage Technologies ({FAST} 20). 2020: 1-11.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ceph</tag>
      
      <tag>理论</tag>
      
      <tag>crush</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「入门部署」Ceph-ansible部署集群</title>
    <link href="/2020/11/24/Ceph-ansible%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    <url>/2020/11/24/Ceph-ansible%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Ceph-ansible部署踩坑日记"><a href="#Ceph-ansible部署踩坑日记" class="headerlink" title="Ceph-ansible部署踩坑日记"></a>Ceph-ansible部署踩坑日记</h1><blockquote><p>官方文档：<a href="https://docs.ceph.com/projects/ceph-ansible/en/latest/">https://docs.ceph.com/projects/ceph-ansible/en/latest/</a></p></blockquote><h1 id="Quick-Deployment-快速部署"><a href="#Quick-Deployment-快速部署" class="headerlink" title="Quick Deployment:快速部署"></a>Quick Deployment:快速部署</h1><div class="note note-danger">            <p>Important:</p><p>ceph-deploy 不再经常性维护， 并且在高于Nautilus的版本没有进行过测试。不推荐使用! </p>          </div><p><strong>Cephadm</strong>：Cephadm完美支持新的编排API、CLI和仪表盘特性，可用于快速部署Octopus及更新版本的Ceph集群。Cephadm更加简单，且不依赖其它自动化部署工具，但该工具不支持部署旧版本的Ceph（如14的Nautilus），所有Ceph进程也是运行在容器中的，意味着在修改源码的情况下还需要制作新的镜像，比较麻烦。<strong>官方文档中指出，Cephadm暂时不推荐用于生产环境。</strong></p><p><strong>Rook</strong>：可以把Ceph部署在Kubernetes集群中运行。与1类似的是，Ceph也是运行在容器中的。</p><blockquote><p>上述的两种方法都是容器部署</p></blockquote><p>第三方部署工具</p><p>【推荐👍】 <strong>ceph-ansible</strong>. 它被广泛使用。ceph-ansible未与Nautlius和Octopus中引入的新的Orchestrator API集成在一起，这意味着更新的管理功能和仪表板集成不可用。</p><p><a href="https://github.com/SUSE/DeepSea">DeepSea</a>使用Salt安装Ceph。</p><p><a href="https://jaas.ai/ceph-mon">jaas.ai/ceph-mon</a>使用Juju安装Ceph。</p><p><a href="https://github.com/openstack/puppet-ceph">github.com/openstack/puppet-ceph</a> 通过Puppet安装Ceph。</p><p>官方的最低要求是 <strong>3</strong> Monitors + <strong>3</strong> Managers + <strong>3</strong> OSDs 。 我们尝试用虚拟机搭建最小集群。</p><p>在运行ceph-mon守护程序的每个节点上，还应该设置一个ceph-mgr守护程序。</p><div class="table-container"><table><thead><tr><th style="text-align:center">虚拟机节点名称</th><th style="text-align:center">职责</th><th style="text-align:center">IP地址</th></tr></thead><tbody><tr><td style="text-align:center">ceph-master (w/ source-code compiled)</td><td style="text-align:center">mon0 + mgr0+osd0(部署节点)</td><td style="text-align:center">192.168.161.134</td></tr><tr><td style="text-align:center">ceph-node1</td><td style="text-align:center">mon1+mgr1</td><td style="text-align:center">192.168.161.130</td></tr><tr><td style="text-align:center">ceph-node2</td><td style="text-align:center">mon2+mgr2</td><td style="text-align:center">192.168.161.131</td></tr><tr><td style="text-align:center">ceph-osd1</td><td style="text-align:center">osd1</td><td style="text-align:center">192.168.161.132</td></tr><tr><td style="text-align:center">ceph-osd2</td><td style="text-align:center">osd2</td><td style="text-align:center">192.168.161.133</td></tr></tbody></table></div><div class="note note-primary">            <p>小技巧：我们可以先在1台虚拟机上配置好通用的预备环境，再克隆出另外的2台，随后调整部分配置后即可（如IP、主机名等）。克隆后记得重新生成网卡MAC地址</p>          </div><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>关闭firewalld，设置selinux为disabled状态，设置ssh免密登录，配置时钟同步服务。</p><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> ufw status<span class="hljs-comment">#查看防火墙状态 active:开启 inactive：关闭</span></code></pre><pre><code class="hljs puppet"><span class="hljs-comment"># mon作为控制节点</span>sudo apt install openssh-serverssh-keygen -t rsa ssh-copy-<span class="hljs-keyword">id</span> &#123;<span class="hljs-built_in">hostname</span>&#125;@&#123;ip&#125;<span class="hljs-comment">#复制密钥到各节点</span><span class="hljs-keyword">ssh</span> &#123;<span class="hljs-built_in">hostname</span>&#125;@&#123;ip&#125;</code></pre><p>mon节点作为时钟同步节点</p><pre><code class="hljs stylus">sudo apt install ntpsudo vim /etc/ntp.conf#在/etc/ntp.conf添加<span class="hljs-selector-id">#server</span> <span class="hljs-number">127.127</span>.<span class="hljs-number">1.0</span><span class="hljs-selector-id">#fudge</span> <span class="hljs-number">127.127</span>.<span class="hljs-number">1.0</span> stratum <span class="hljs-number">10</span>#并注释下列四行<span class="hljs-selector-id">#pool</span> <span class="hljs-number">0</span><span class="hljs-selector-class">.ubuntu</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst<span class="hljs-selector-id">#pool</span> <span class="hljs-number">1</span><span class="hljs-selector-class">.ubuntu</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst<span class="hljs-selector-id">#pool</span> <span class="hljs-number">2</span><span class="hljs-selector-class">.ubuntu</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst<span class="hljs-selector-id">#pool</span> <span class="hljs-number">3</span><span class="hljs-selector-class">.ubuntu</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst</code></pre><p>在其它节点</p><pre><code class="hljs routeros">sudo apt install ntpdate openssh-server --assume-yessudo /etc/init.d<span class="hljs-built_in">/ntp </span>restart sudo systemctl <span class="hljs-builtin-name">enable</span> ntp.service #启动ntpsudo ntpdate &#123;mon-hostname&#125;</code></pre><p>会得到矫正的时间</p><pre><code class="hljs routeros">Nov 06:31:02 ntpdate[8540]: adjust time<span class="hljs-built_in"> server </span>192.168.161.129 offset 0.097653 sec</code></pre><p>有可能出现 name or server not known 错误</p><p>在每个节点 \etc\hosts 加入所有其它节点映射，比如</p><pre><code class="hljs accesslog"><span class="hljs-number">192.168.161.129</span>  ceph-master</code></pre><p>再ping 或者 nslookup测试一下就行。</p><div class="note note-warning">            <p>不要在同一个节点同时安装ntp和ntpdate</p>          </div><p>另一种方法是直接和aliyun服务器同步，在ntp.conf末尾加上<code>server ntp.aliyun.com</code></p><p>再重启</p><pre><code class="hljs routeros">sudo /etc/init.d<span class="hljs-built_in">/ntp </span>restart</code></pre><h2 id="ceph-ansible-😁"><a href="#ceph-ansible-😁" class="headerlink" title="ceph-ansible 😁"></a>ceph-ansible <a href="https://docs.ceph.com/projects/ceph-ansible/en/latest/index.html#configuration-and-usage">😁</a></h2><blockquote><p>参考：<a href="https://www.cnblogs.com/zyxnhr/p/10543814.html">https://www.cnblogs.com/zyxnhr/p/10543814.html</a> 写的非常细致。</p><p><a href="https://blog.csdn.net/liuzhupeng/article/details/106767126">https://blog.csdn.net/liuzhupeng/article/details/106767126</a></p></blockquote><p> 三要素：inventory file, playbook and configuration。</p><p>Dependency: <code>python2</code>所有节点</p><p>首先测试能否连通其它节点</p><pre><code class="hljs routeros">ansible all -m<span class="hljs-built_in"> ping </span>#注意这儿不能加sudo，否则会permission denied</code></pre><p>如果没有问题</p><pre><code class="hljs arcade">node1 | <span class="hljs-function"><span class="hljs-params">SUCCESS</span> =&gt;</span> &#123;    <span class="hljs-string">&quot;ansible_facts&quot;</span>: &#123;        <span class="hljs-string">&quot;discovered_interpreter_python&quot;</span>: <span class="hljs-string">&quot;/usr/bin/python&quot;</span>    &#125;,    <span class="hljs-string">&quot;changed&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-string">&quot;ping&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>&#125;node2 | <span class="hljs-function"><span class="hljs-params">SUCCESS</span> =&gt;</span> &#123;    <span class="hljs-string">&quot;ansible_facts&quot;</span>: &#123;        <span class="hljs-string">&quot;discovered_interpreter_python&quot;</span>: <span class="hljs-string">&quot;/usr/bin/python3&quot;</span>    &#125;,    <span class="hljs-string">&quot;changed&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-string">&quot;ping&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>&#125;node3 | <span class="hljs-function"><span class="hljs-params">SUCCESS</span> =&gt;</span> &#123;    <span class="hljs-string">&quot;ansible_facts&quot;</span>: &#123;        <span class="hljs-string">&quot;discovered_interpreter_python&quot;</span>: <span class="hljs-string">&quot;/usr/bin/python3&quot;</span>    &#125;,    <span class="hljs-string">&quot;changed&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-string">&quot;ping&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>&#125;</code></pre><ol><li><h3 id="我们首先安装ceph-ansble"><a href="#我们首先安装ceph-ansble" class="headerlink" title="我们首先安装ceph-ansble."></a>我们首先安装ceph-ansble.</h3></li></ol><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ceph/</span>ceph-ansible.gitgit checkout <span class="hljs-variable">$branch</span> <span class="hljs-comment">#默认master分支</span>pip install -r requirements.txt sudo apt install ansible</code></pre><ol><li><h3 id="再配置inventory"><a href="#再配置inventory" class="headerlink" title="再配置inventory"></a>再配置inventory</h3></li></ol><p>在 /etc/ansible/下创建<code>hosts</code>文件，clients节点不应该与mon osd等重叠。在最新版本，还需要设置<code>[monitoring]</code>. 个人感觉和mon节点设成一样就行了。</p><pre><code class="hljs csharp">[<span class="hljs-meta">mons</span>]node1node2node3[<span class="hljs-meta">osds</span>]node1node2node3[<span class="hljs-meta">rgws</span>]node1node2node3[<span class="hljs-meta">clients</span>]node4node5[<span class="hljs-meta">mgrs</span>]node1node2node3[<span class="hljs-meta">monitoring</span>]node1node2node3</code></pre><ol><li><strong>然后在下载下来的ansible目录下拷贝文件，根据节点的角色拷贝具体的文件</strong></li></ol><pre><code class="hljs stylus">#除了site<span class="hljs-selector-class">.yml</span>.sample，all<span class="hljs-selector-class">.yml</span>.sample是必须要修改的之外，其他文件根据要安装的角色自行修改cp site<span class="hljs-selector-class">.yml</span><span class="hljs-selector-class">.sample</span> site.ymlcp group_vars/osds<span class="hljs-selector-class">.yml</span><span class="hljs-selector-class">.sample</span> group_vars/osds.ymlcp group_vars/clients<span class="hljs-selector-class">.yml</span><span class="hljs-selector-class">.sample</span> group_vars/clients.ymlcp group_vars/mons<span class="hljs-selector-class">.yml</span><span class="hljs-selector-class">.sample</span> group_vars/mons.ymlcp group_vars/mgrs<span class="hljs-selector-class">.yml</span><span class="hljs-selector-class">.sample</span> group_vars/mgrs.ymlcp group_vars/all<span class="hljs-selector-class">.yml</span><span class="hljs-selector-class">.sample</span> group_vars/all.yml</code></pre><ol><li><h3 id="配置all-yml"><a href="#配置all-yml" class="headerlink" title="配置all.yml"></a>配置all.yml</h3></li></ol><p>我们需要修改osds.yml部分：</p><pre><code class="hljs yaml"><span class="hljs-string">--</span><span class="hljs-attr">dummy:</span><span class="hljs-attr">ceph_release_num:</span>  <span class="hljs-attr">octopus:</span> <span class="hljs-number">15</span><span class="hljs-attr">cluster:</span> <span class="hljs-string">ceph-test</span><span class="hljs-attr">ceph_origin:</span> <span class="hljs-string">repository</span><span class="hljs-attr">ceph_repository:</span> <span class="hljs-string">community</span><span class="hljs-attr">ceph_mirror:</span> <span class="hljs-string">https://mirrors.aliyun.com/ceph/</span><span class="hljs-attr">ceph_stable_key:</span> <span class="hljs-string">https://mirrors.aliyun.com/ceph/keys/release.asc</span><span class="hljs-attr">ceph_stable_release:</span> <span class="hljs-string">octopus</span><span class="hljs-attr">monitor_interface:</span> <span class="hljs-string">ens33</span><span class="hljs-attr">monitor_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.161</span><span class="hljs-number">.135</span><span class="hljs-attr">ip_version:</span> <span class="hljs-string">ipv4</span><span class="hljs-attr">public_network:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.161</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><span class="hljs-attr">cluster_network:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; public_network | regex_replace(&#x27; &#x27;, &#x27;&#x27;) &#125;&#125;</span>&quot;</span><span class="hljs-attr">osd_mkfs_type:</span> <span class="hljs-string">xfs</span><span class="hljs-attr">osd_mkfs_options_xfs:</span> <span class="hljs-string">-f</span> <span class="hljs-string">-i</span> <span class="hljs-string">size=2048</span><span class="hljs-attr">osd_mount_options_xfs:</span> <span class="hljs-string">noatime,largeio,inode64,swalloc</span><span class="hljs-attr">osd_objectstore:</span> <span class="hljs-string">bluestore</span><span class="hljs-attr">dashboard_enabled:</span> <span class="hljs-literal">False</span></code></pre><p>devices：指定osd使用的硬盘</p><p>osd_scenario：collocated启用并置journal  【笔者没有找到】</p><p>下面是一些trick</p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo fdisk -l <span class="hljs-comment">#查看磁盘信息</span></code></pre><p>查看你的更改</p><pre><code class="hljs vim">$<span class="hljs-keyword">grep</span> -v <span class="hljs-string">&#x27;^#&#x27;</span> <span class="hljs-keyword">all</span>.yml | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&#x27;^&amp;&#x27;</span> <span class="hljs-keyword">all</span>.yml</code></pre><p>或者查看所有修改后文件</p><pre><code class="hljs \">grep -Ev &quot;^$|^\s*#&quot;  *.yml</code></pre><ol><li><h3 id="配置osd"><a href="#配置osd" class="headerlink" title="配置osd"></a>配置osd</h3></li></ol><pre><code class="hljs arcade">devices:   - <span class="hljs-regexp">/dev/</span>vdb   - <span class="hljs-regexp">/dev/</span>vdc   - <span class="hljs-regexp">/dev/</span>vdd</code></pre><ol><li><h3 id="定义ansible的入口文件"><a href="#定义ansible的入口文件" class="headerlink" title="定义ansible的入口文件"></a>定义ansible的入口文件</h3></li></ol><pre><code class="hljs vala">- hosts:  - mons<span class="hljs-meta">#  - agents</span>  - osds<span class="hljs-meta">#  - mdss</span><span class="hljs-meta">#  - rgws</span><span class="hljs-meta">#  - nfss</span><span class="hljs-meta">#  - restapis</span><span class="hljs-meta">#  - rbdmirrors</span>  - clients  - mgrs<span class="hljs-meta">#  - iscsi-gws</span></code></pre><ol><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li></ol><pre><code class="hljs 1c">ansible-playbook  site.yml <span class="hljs-meta">#注意同样没有sudo</span></code></pre><pre><code class="hljs routeros">PLAY RECAP *********************************************************************node1                      : <span class="hljs-attribute">ok</span>=340  <span class="hljs-attribute">changed</span>=33   <span class="hljs-attribute">unreachable</span>=0    <span class="hljs-attribute">failed</span>=0    <span class="hljs-attribute">skipped</span>=547  <span class="hljs-attribute">rescued</span>=0    <span class="hljs-attribute">ignored</span>=0   node2                      : <span class="hljs-attribute">ok</span>=109  <span class="hljs-attribute">changed</span>=12   <span class="hljs-attribute">unreachable</span>=0    <span class="hljs-attribute">failed</span>=0    <span class="hljs-attribute">skipped</span>=261  <span class="hljs-attribute">rescued</span>=0    <span class="hljs-attribute">ignored</span>=0   node3                      : <span class="hljs-attribute">ok</span>=112  <span class="hljs-attribute">changed</span>=12   <span class="hljs-attribute">unreachable</span>=0    <span class="hljs-attribute">failed</span>=0    <span class="hljs-attribute">skipped</span>=260  <span class="hljs-attribute">rescued</span>=0    <span class="hljs-attribute">ignored</span>=0   INSTALLER STATUS ***************************************************************Install Ceph Monitor           : Complete (0:00:32)Install Ceph Manager           : Complete (0:00:09)Install Ceph OSD               : Complete (0:00:34)Install Ceph<span class="hljs-built_in"> Client </span>           : Complete (0:00:31)</code></pre><p>如果<code>failed=1</code>那就说明安装失败，你需要根据错误进行修改，如果打印的信息太少，你可以使用</p><pre><code class="hljs css"><span class="hljs-selector-tag">ansible-playbook</span> <span class="hljs-selector-tag">-vvv</span> <span class="hljs-selector-tag">site</span><span class="hljs-selector-class">.yml</span></code></pre><p>来打印更多信息。</p><ol><li><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h3></li></ol><p>接下来我们看看集群健康状况 ，在ceph-mon节点执行</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph -s</span></code></pre><p>有可能会提示ceph RADOS object not found. 笔者怀疑是 /etc/ceph/下的conf文件名不是ceph所以导致无法识别出集群，后来干脆把集群名字改成<code>ceph</code>。是不是很傻X呢？</p><pre><code class="hljs apache"><span class="hljs-attribute">cluster</span>:  <span class="hljs-attribute">id</span>:     <span class="hljs-number">0</span>d<span class="hljs-number">3</span>c<span class="hljs-number">793</span>b-<span class="hljs-number">1</span>ee<span class="hljs-number">0</span>-<span class="hljs-number">43</span>ca-<span class="hljs-number">8</span>f<span class="hljs-number">28</span>-<span class="hljs-number">6</span>dbf<span class="hljs-number">695578</span>cf  <span class="hljs-attribute">health</span>: HEALTH_OK <span class="hljs-attribute">services</span>:  <span class="hljs-attribute">mon</span>: <span class="hljs-number">1</span> daemons, quorum node<span class="hljs-number">2</span> (age <span class="hljs-number">5</span>m)  <span class="hljs-attribute">mgr</span>: node<span class="hljs-number">2</span>(active, since <span class="hljs-number">5</span>m)  <span class="hljs-attribute">mds</span>: cephfs:<span class="hljs-number">1</span> &#123;<span class="hljs-number">0</span>=node<span class="hljs-number">3</span>=up:active&#125; <span class="hljs-number">2</span> up:standby  <span class="hljs-attribute">osd</span>: <span class="hljs-number">3</span> osds: <span class="hljs-number">3</span> up (since <span class="hljs-number">3</span>m), <span class="hljs-number">3</span> in (since <span class="hljs-number">4</span>m) <span class="hljs-attribute">task</span> status:  <span class="hljs-attribute">scrub</span> status:      <span class="hljs-attribute">mds</span>.node<span class="hljs-number">3</span>: idle <span class="hljs-attribute">data</span>:  <span class="hljs-attribute">pools</span>:   <span class="hljs-number">3</span> pools, <span class="hljs-number">65</span> pgs  <span class="hljs-attribute">objects</span>: <span class="hljs-number">22</span> objects, <span class="hljs-number">2</span>.<span class="hljs-number">2</span> KiB  <span class="hljs-attribute">usage</span>:   <span class="hljs-number">3</span>.<span class="hljs-number">0</span> GiB used, <span class="hljs-number">57</span> GiB / <span class="hljs-number">60</span> GiB avail  <span class="hljs-attribute">pgs</span>:     <span class="hljs-number">65</span> active+clean</code></pre><p>以及<code>sudo fidsk -l</code> 查看osd分配磁盘。</p><p>查看osd 拓扑。这有助于我们理解CRUSH算法。</p><pre><code class="hljs dos">sudo ceph osd <span class="hljs-built_in">tree</span></code></pre><pre><code class="hljs lsl">ID  CLASS  WEIGHT   TYPE NAME       STATUS  REWEIGHT  PRI-AFF<span class="hljs-number">-1</span>         <span class="hljs-number">0.05846</span>  root <span class="hljs-section">default</span>                             <span class="hljs-number">-5</span>         <span class="hljs-number">0.01949</span>      host node3                            <span class="hljs-number">1</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.1</span>       up   <span class="hljs-number">1.00000</span>  <span class="hljs-number">1.00000</span><span class="hljs-number">-3</span>         <span class="hljs-number">0.01949</span>      host node4                            <span class="hljs-number">0</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.0</span>       up   <span class="hljs-number">1.00000</span>  <span class="hljs-number">1.00000</span><span class="hljs-number">-7</span>         <span class="hljs-number">0.01949</span>      host node5                            <span class="hljs-number">2</span>    ssd  <span class="hljs-number">0.01949</span>          osd<span class="hljs-number">.2</span>       up   <span class="hljs-number">1.00000</span>  <span class="hljs-number">1.00000</span></code></pre><p>EOF</p><hr><p>优质博文参考：<a href="https://blog.51cto.com/14210294/2353243">https://blog.51cto.com/14210294/2353243</a></p><p><a href="https://www.cnblogs.com/zyxnhr/p/10543814.html">https://www.cnblogs.com/zyxnhr/p/10543814.html</a></p><hr><h2 id="Trouble-Shooting"><a href="#Trouble-Shooting" class="headerlink" title="Trouble Shooting"></a>Trouble Shooting</h2><ol><li>Devices are not disjoint</li></ol><p>设备存在交集。如果存储方式是bluestore, 那么block，wal和db必须是不同的存储盘。并且：</p><pre><code class="hljs angelscript">$ mount | grep osdtmpfs on /var/lib/ceph/osd/ceph<span class="hljs-number">-0</span> type tmpfs (rw,relatime,seclabel)$ ls -Alh /var/lib/ceph/osd/ceph<span class="hljs-number">-0</span>lrwxrwxrwx. <span class="hljs-number">1</span> ceph ceph <span class="hljs-number">19</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> block -&gt; /dev/ceph-pool/osd0lrwxrwxrwx. <span class="hljs-number">1</span> root root <span class="hljs-number">22</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> block.db -&gt; /dev/ceph-pool/osd0.dblrwxrwxrwx. <span class="hljs-number">1</span> root root <span class="hljs-number">23</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> block.wal -&gt; /dev/ceph-pool/osd0.wal-rw-------. <span class="hljs-number">1</span> ceph ceph <span class="hljs-number">37</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> ceph_fsid-rw-------. <span class="hljs-number">1</span> ceph ceph <span class="hljs-number">37</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> fsid-rw-------. <span class="hljs-number">1</span> ceph ceph <span class="hljs-number">55</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> keyring-rw-------. <span class="hljs-number">1</span> ceph ceph  <span class="hljs-number">6</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> ready-rw-------. <span class="hljs-number">1</span> ceph ceph <span class="hljs-number">10</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> type-rw-------. <span class="hljs-number">1</span> ceph ceph  <span class="hljs-number">2</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">36</span> whoami</code></pre>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构</tag>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「基础理论」CEPH 基础介绍</title>
    <link href="/2020/11/22/CEPH%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <url>/2020/11/22/CEPH%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="CEPH基础理论学习"><a href="#CEPH基础理论学习" class="headerlink" title="CEPH基础理论学习"></a>CEPH基础理论学习</h1><blockquote><p>参考<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Weil S A, Brandt S A, Miller E L, et al. Ceph: A scalable, high-performance distributed file system[C]//Proceedings of the 7th symposium on Operating systems design and implementation. 2006: 307-320.">[2]</span></a></sup></p></blockquote><hr><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="1-Ceph简介"><a href="#1-Ceph简介" class="headerlink" title="1 Ceph简介"></a><strong>1 Ceph简介</strong></h2><blockquote><p>Ceph是一个统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。它是一个统一的存储系统，既支持传统的块、文件存储协议，例如SAN和NAS，也支持新兴的对象存储协议，如S3和Swift，这使得Ceph理论上可以满足时下一切主流的存储应用的要求。</p></blockquote><p>Ceph项目最早起源于Sage就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。</p><ul><li>Ceph摒弃了传统的集中式存储元数据的方案，采用CRUSH算法，数据分布均衡，并行度高。</li><li>考虑了容灾区的隔离，能够实现各类负载的副本放置规则，例如跨机房，机架感知。</li><li>能够支持上千个存储节点的规模，支持TB到PB级的数据。</li></ul><p><strong>高可用性</strong></p><ul><li>a. 副本数可以灵活控制。</li><li>b. 支持故障域分隔，数据强一致性。</li><li>c. 多种故障场景自动进行修复自愈。</li><li>d. 没有单点故障，自动管理。</li></ul><p><strong>高可扩展性</strong></p><ul><li>a. 去中心化。</li><li>b. 扩展灵活。</li><li>c. 随着节点增加而线性增长。</li></ul><p><strong>特性丰富</strong></p><p>a. 支持三种存储接口：块存储、文件存储、对象存储。</p><p>b. 支持自定义接口，支持多种语言驱动。</p><p>特点：</p><ul><li><p>高性能</p></li><li><p>高可用性</p></li><li><p>高可扩展性</p></li><li><p>特性丰富</p></li></ul><p><strong>支持三种接口</strong>：</p><ul><li>Object：有原生的API，而且也兼容Swift和S3的API。</li><li>Block：支持精简配置、快照、克隆。</li><li>File：Posix接口，支持快照。</li></ul><p><img src="\img\ceph-st1.jpg" alt="640?wx_fmt=png"></p><ul><li><p>Monitor</p><p><code>ceph-mon</code>，一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。<a href="http://docs.ceph.org.cn/glossary/#term-ceph-monitor"><em>Ceph Monitor</em></a>维护着展示集群状态的各种图表，包括监视器图、 OSD 图、归置组（ PG ）图、和 CRUSH 图。 Ceph 保存着发生在Monitors 、 OSD 和 PG上的每一次状态变更的历史信息（称为 epoch ）。通常至少需要三个监视器才能实现冗余和高可用性。</p></li><li><p>Manager</p><p><a href="https://docs.ceph.com/en/latest/glossary/#term-Ceph-Manager">Ceph Manager</a>守护进程（<code>ceph-mgr</code>）负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager守护进程还托管基于python的模块，以管理和公开Ceph集群信息，包括基于Web的<a href="https://docs.ceph.com/en/latest/mgr/dashboard/#mgr-dashboard">Ceph仪表板</a>和 <a href="https://docs.ceph.com/en/latest/mgr/restful">REST API</a>。通常，至少需要两个管理器才能实现高可用性。</p></li><li><p>OSD</p><p>OSD全称Object Storage Daemon（<code>ceph-osd</code>），也就是负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。<a href="http://docs.ceph.org.cn/glossary/#term-56"><em>Ceph OSD 守护进程</em></a>（ Ceph OSD ）的功能是存储数据，处理数据的复制、恢复、回填、再均衡，并通过检查其他OSD 守护进程的心跳来向 Ceph Monitors 提供一些监控信息。当 Ceph 存储集群设定为有2个副本时，至少需要2个 OSD 守护进程，集群才能达到 <code>active+clean</code> 状态（ Ceph 默认有3个副本，但你可以调整副本数）</p></li></ul><ul><li><p>MDS</p><p>MDS全称Ceph Metadata Server（<code>ceph-mds</code>），是CephFS服务依赖的元数据服务。<a href="http://docs.ceph.org.cn/glossary/#term-63"><em>Ceph 元数据服务器</em></a>（ MDS ）为 <a href="http://docs.ceph.org.cn/glossary/#term-45"><em>Ceph 文件系统</em></a>存储元数据（也就是说，Ceph 块设备和 Ceph 对象存储不使用MDS ）。元数据服务器使得 POSIX 文件系统的用户们，可以在不对 Ceph 存储集群造成负担的前提下，执行诸如 <code>ls</code>、<code>find</code> 等基本命令。</p></li></ul><ul><li><p>Object</p><p>Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。</p></li></ul><ul><li><p>PG</p><p>PG全称Placement Groups归置组，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。</p></li></ul><ul><li><p>RADOS</p><p>RADOS全称Reliable Autonomic Distributed Object Store （可靠自治的分布式对象存储），是Ceph集群的<strong>精华</strong>，用户实现数据分配、Failover等集群操作。具有自愈，自管理能力的智能存储节点构建的高可靠，自治，分布式对象存储系统。</p></li></ul><ul><li><p>Libradio</p><p>Librados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。</p></li></ul><ul><li><p>CRUSH<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="  Weil S A Brandt S A , Miller E L , et al. CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data[C]// IEEE Sc Conference. ACM, 2006.">[1]</span></a></sup></p><p>CRUSH是Ceph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。</p></li></ul><ul><li><p>RBD</p><p>RBD全称RADOS block device，是Ceph对外提供的块设备服务。采用全分布式，可靠的块设备访问接口，同时提供Linux内核态和用户态客户端访问支持，以及QEMU/KVM驱动。</p></li></ul><ul><li><p>RGW</p><p>RGW全称RADOS gateway，基于Bucket的REST网关，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。</p></li></ul><ul><li><p>CephFS</p><p>CephFS全称Ceph File System，是Ceph对外提供的文件系统服务。与POSIX兼容，同时提供Linux内核态用户端和FUSE访问支持。</p></li></ul><blockquote><p>基于 RADOS 的 Ceph 对象存储集群包括两类守护进程：term:对象存储守护进程（ OSD ）把存储节点上的数据存储为对象； term:Ceph 监视器（ MON ）维护集群运行图的主拷贝。一个 Ceph 集群可以包含数千个存储节点，最简系统至少需要一个监视器和两个 OSD 才能做到数据复制。</p></blockquote><h3 id="Ceph架构"><a href="#Ceph架构" class="headerlink" title="Ceph架构"></a>Ceph架构</h3><p><img src="CEPH基础理论/image-20201231160559413.png" alt="image-20201231160559413"></p><p>系统架构。 客户端通过直接与OSD通信来执行文件I / O。 每个进程可以直接链接到客户端实例，也可以与已安装的文件系统进行交互。</p><h3 id="ceph读写流程"><a href="#ceph读写流程" class="headerlink" title="ceph读写流程"></a>ceph读写流程</h3><p>Read：</p><ul><li>Client app 发送读请求，RADOS将请求发送给Primary OSD。</li><li>主要OSD在本地磁盘读数据并完成读请求。</li></ul><p>Write:</p><ul><li><p>Client App 写数据，RADOS将数据发送给Primary OSD。</p></li><li><p>Primary OSD识别Replica OSDs并且向他们发送数据，由他们写数据到本地磁盘。</p></li><li>Replica OSDs 完成写并通知Primary OSD。</li><li>Primary OSDs 通知client APP 写完成。</li><li><img src="\img\ceph-b.png" alt="image-20201122180847737"></li></ul><h3 id="三种存储方式"><a href="#三种存储方式" class="headerlink" title="三种存储方式"></a>三种存储方式</h3><h4 id="1-块设备"><a href="#1-块设备" class="headerlink" title="1. 块设备"></a>1. 块设备</h4><p><strong>典型设备：</strong> 磁盘阵列，硬盘</p><p>主要是将裸磁盘空间映射给主机使用的。</p><p><strong>优点：</strong></p><ul><li>通过RAID与LVM（逻辑卷管理）等手段，对数据提供了保护。</li><li>多块廉价的硬盘组合起来，提高容量。</li><li>多块磁盘组合出来的逻辑盘，提升读写效率。</li></ul><p><strong>缺点：</strong></p><ul><li>采用SAN架构组网时，光纤交换机，造价成本高。</li><li>主机之间无法共享数据。</li></ul><p><strong>使用场景：</strong></p><ul><li>docker容器、虚拟机磁盘存储分配。</li><li>日志存储。</li><li>文件存储。</li><li>…</li></ul><h4 id="2-文件存储"><a href="#2-文件存储" class="headerlink" title="2.文件存储"></a>2.文件存储</h4><p><strong>典型设备：</strong> FTP、NFS服务器<br> 为了克服块存储文件无法共享的问题，所以有了文件存储。<br> 在服务器上架设FTP与NFS服务，就是文件存储。</p><p><strong>优点：</strong></p><ul><li>造价低，随便一台机器就可以了。</li><li>方便文件共享。</li></ul><p><strong>缺点：</strong></p><ul><li>读写速率低。</li><li>传输速率慢。</li></ul><p><strong>使用场景：</strong></p><ul><li>日志存储。</li><li>有目录结构的文件存储。</li><li>…</li></ul><h4 id="3-对象存储"><a href="#3-对象存储" class="headerlink" title="3.对象存储"></a>3.对象存储</h4><p><img src="\img\ceph-c.jpg" alt="img"></p><p><strong>典型设备：</strong> 内置大容量硬盘的分布式服务器(swift, s3)<br> 多台服务器内置大容量硬盘，安装上对象存储管理软件，对外提供读写访问功能。</p><p><strong>优点：</strong></p><ul><li>具备块存储的读写高速。</li><li>具备文件存储的共享等特性。</li></ul><p><strong>使用场景：</strong> (适合更新变动较少的数据)</p><ul><li>图片存储。</li><li>视频存储。</li><li>…</li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><hr><h2 id="2-Ceph-I-O流程和数据分布"><a href="#2-Ceph-I-O流程和数据分布" class="headerlink" title="2 Ceph I/O流程和数据分布"></a>2 Ceph I/O流程和数据分布</h2><p><img src="\img\ceph-d.png" alt="img"></p><p><img src="\img\ceph_io2.png" alt="img"></p><p><strong>步骤：</strong></p><ol><li>client 创建cluster handler。</li><li>client 读取配置文件。</li><li>client 连接上monitor，获取集群map信息。</li><li>client 读写io 根据crushmap 算法请求对应的主osd数据节点。</li><li>主osd数据节点同时写入另外两个副本节点数据。</li><li>等待主节点以及另外两个副本节点写完数据状态。</li><li>主节点及副本节点写入状态都成功后，返回给client，io写入完成。</li></ol><h3 id="新主I-O流程图"><a href="#新主I-O流程图" class="headerlink" title="新主I/O流程图"></a>新主I/O流程图</h3><p><img src="\img\ceph-e.jpg" alt="img"></p><p><strong>步骤：</strong></p><ol><li>client连接monitor获取集群map信息。</li><li>同时新主osd1由于没有pg数据会主动上报monitor告知让osd2临时接替为主。</li><li>临时主osd2会把数据全量同步给新主osd1。</li><li>client IO读写直接连接临时主osd2进行读写。</li><li>osd2收到读写io，同时写入另外两副本节点。</li><li>等待osd2以及另外两副本写入成功。</li><li>osd2三份数据都写入成功返回给client, 此时client io读写完毕。</li><li>如果osd1数据同步完毕，临时主osd2会交出主角色。</li><li>osd1成为主节点，osd2变成副本。</li></ol><h3 id="Ceph-I-O算法流程"><a href="#Ceph-I-O算法流程" class="headerlink" title="Ceph I/O算法流程"></a>Ceph I/O算法流程</h3><p><img src="\img\ceph-arch.png" alt="img"></p><ol><li>File用户需要读写的文件。File-&gt;Object映射：</li></ol><ul><li>a. ino (File的元数据，File的唯一id)。</li><li>b. ono(File切分产生的某个object的序号，默认以4M切分一个块大小)。</li><li>c. oid(object id: ino + ono)。</li></ul><ol><li>Object是RADOS需要的对象。Ceph指定一个静态hash函数计算oid的值，将oid映射成一个近似均匀分布的伪随机值，然后和mask按位相与，得到pgid。Object-&gt;PG映射：</li></ol><ul><li>a. hash(oid) &amp; mask-&gt; pgid 。</li><li>b. mask = PG总数m(m为2的整数幂)-1 。</li></ul><ol><li>PG(Placement Group),用途是对object的存储进行组织和位置映射, (类似于redis cluster里面的slot的概念) 一个PG里面会有很多object。采用CRUSH算法，将pgid代入其中，然后得到一组OSD。PG-&gt;OSD映射：</li></ol><ul><li>a. CRUSH(pgid)-&gt;(osd1,osd2,osd3) 。</li></ul><pre><code class="hljs ini"><span class="hljs-attr">locator</span> = object_name<span class="hljs-attr">obj_hash</span> =  hash(locator)<span class="hljs-attr">pg</span> = obj_hash % num_pg<span class="hljs-attr">osds_for_pg</span> = crush(pg)  <span class="hljs-comment"># returns a list of osds</span><span class="hljs-attr">primary</span> = osds_for_pg[<span class="hljs-number">0</span>]<span class="hljs-attr">replicas</span> = osds_for_pg[<span class="hljs-number">1</span>:]</code></pre><h3 id="Ceph-RBD-IO流程"><a href="#Ceph-RBD-IO流程" class="headerlink" title="Ceph RBD IO流程"></a>Ceph RBD IO流程</h3><p><img src="/img/ceph-f.png" alt="img"></p><ol><li><p>客户端创建一个pool，需要为这个pool指定pg的数量。</p></li><li><p>创建pool/image rbd设备进行挂载。</p></li><li><p>用户写入的数据进行切块，每个块的大小默认为4M，并且每个块都有一个名字，名字就是object+序号。</p></li><li><p>将每个object通过pg进行副本位置的分配。</p></li><li><p>pg根据cursh算法会寻找3个osd，把这个object分别保存在这三个osd上。</p></li><li><p>osd上实际是把底层的disk进行了格式化操作，一般部署工具会将它格式化为xfs文件系统。</p></li><li><p>object的存储就变成了存储一个文rbd0.object1.file。</p></li></ol><p><img src="/img/ceph-g.png" alt="img"></p><p><strong>客户端写数据osd过程：</strong></p><ol><li>采用的是librbd的形式，使用librbd创建一个块设备，向这个块设备中写入数据。</li><li>在客户端本地同过调用librados接口，然后经过pool，rbd，object、pg进行层层映射,在PG这一层中，可以知道数据保存在哪3个OSD上，这3个OSD分为主从的关系。</li><li>客户端与primay OSD建立SOCKET 通信，将要写入的数据传给primary OSD，由primary OSD再将数据发送给其他replica OSD数据节点。</li></ol><h3 id="Ceph-Pool和PG分布情况"><a href="#Ceph-Pool和PG分布情况" class="headerlink" title="Ceph Pool和PG分布情况"></a>Ceph Pool和PG分布情况</h3><p><img src="/img/ceph-h.jpg" alt="img"></p><ul><li><p>pool是ceph存储数据时的逻辑分区，它起到namespace的作用。</p></li><li><p>每个pool包含一定数量(可配置)的PG。</p></li><li><p>PG里的对象被映射到不同的Object上。</p></li><li><p>pool是分布到整个集群的。</p></li><li><p>pool可以做故障隔离域，根据不同的用户场景不一进行隔离。</p></li></ul><h3 id="Ceph-数据扩容PG分布"><a href="#Ceph-数据扩容PG分布" class="headerlink" title="Ceph 数据扩容PG分布"></a>Ceph 数据扩容PG分布</h3><p><strong>场景数据迁移流程：</strong></p><ul><li>现状3个OSD, 4个PG</li><li>扩容到4个OSD, 4个PG</li></ul><p><strong>扩容前</strong></p><p><img src="/img/ceph-i.jpg" alt="img"></p><p><strong>扩容后</strong></p><p><img src="/img/ceph-j.png" alt="img"></p><p><strong>说明</strong><br>每个OSD上分布很多PG, 并且每个PG会自动散落在不同的OSD上。如果扩容那么相应的PG会进行迁移到新的OSD上，保证PG数量的均衡。</p><h3 id="PG状态及其含义"><a href="#PG状态及其含义" class="headerlink" title="PG状态及其含义"></a>PG状态及其含义</h3><div class="table-container"><table><thead><tr><th style="text-align:center">PG状态</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">down</td><td style="text-align:left">Peering过程中，PG检测到某个Interval中，当前剩余的OSD不足以完成数据修复</td></tr><tr><td style="text-align:center">repair</td><td style="text-align:left">PG正在被检查，被发现的任何不一致都将尽可能的被修复</td></tr><tr><td style="text-align:center">peering（等待互联）</td><td style="text-align:left">PG处于 peering 过程中, peering 由主 osd 发起的使存放 PG 副本的所有 OSD 就 PG 的所有对象和元素数据的状态达成一致的过程, peering 过程完成后, 主 OSD 就可以接受客户端写请求.</td></tr><tr><td style="text-align:center">active</td><td style="text-align:left">当 ceph 完成 peering 过程, pg 将会变成 active, active 状态意味着 pg 中的数据变得可用, 主 pg 将可执行读写操作 .</td></tr><tr><td style="text-align:center">clean</td><td style="text-align:left">干净态。前不存在待修复的对象， Acting Set和Up Set内容一致，并且大小等于存储池的副本数</td></tr><tr><td style="text-align:center">replay（重做）</td><td style="text-align:left">某OSD崩溃后，PG正在等待客户端重新发起操作</td></tr><tr><td style="text-align:center">degraded</td><td style="text-align:left">1.PG 处于 active+degraded 原因是因为 OSD 是处于活跃, 但并没有完成所有的对象副本写入, PG 中部分对象的副本数量未达到规定的数量.当 OSD 重新上线, OSD 将会重新恢复,  假如 OSD DOWN 并且 degraded 状态持续, CEPH 会标记 DOWN OSD, 并会对集群迁移相关 OSD 的数据, 对应时间由<code>mon osd down out interval</code> 参数决定 .</td></tr><tr><td style="text-align:center">inconsistent</td><td style="text-align:left">PG通过Scrub检测到某些对象在PG实例间出现不一致（主要是因为静默错误）</td></tr><tr><td style="text-align:center">recovering</td><td style="text-align:left">PG正在对不一致对象进行同步/修复。</td></tr><tr><td style="text-align:center">back filling</td><td style="text-align:left">当新 OSD 加入集群, CRUSH 将会为集群新添加的 OSD 重新分配 PG, 强制新的 OSD 接受重新分配的 PG 并把一定数量的负载转移到新 OSD 中,back filling OSD 会在后台处理, 当 backfilling 完成, 新的 OSD 完成后, 将开始对请求进行服务</td></tr><tr><td style="text-align:center">remapped</td><td style="text-align:left">当 pg 改变, 数据从旧的 osd 迁移到新的 osd, 新的主 osd 应该请求将会花费一段时间, 在这段时间内, 将会继续向旧主 osd 请求服务, 直到 PG 迁移完成, 当数据迁移完成, mapping 将会使用新的 OSD 响应主 OSD 服务</td></tr><tr><td style="text-align:center">stale（旧）</td><td style="text-align:left">当 ceph 使用 heartbeat 确认主机与进程是否运行, ceph osd daemon 可能由于网络临时故障, 获得一个卡住状态 (stuck state) 没有得到心跳回应 默认, osd daemon 会每 0.5 秒报告 PG, up 状态, 启动与故障分析, 假如 PG 中主 OSD 因为故障没有回应 monitor 或者其他 OSD 报告 主 osd down, 那么 monitor 将会标记 PG stale</td></tr><tr><td style="text-align:center">scrubbing</td><td style="text-align:left">scrubbing（清理中）, PG 在做一致性校验</td></tr><tr><td style="text-align:center">inactive</td><td style="text-align:left">inactive ：PG 很长时间没有显示为 active 状态, (不可执行读写请求), PG 不可以执行读写, 因为等待 OSD 更新数据到最新的备份状态</td></tr><tr><td style="text-align:center">unclean</td><td style="text-align:left">unclean：PG 很长时间都不是 clean 状态 (不可以完成之前恢复的操作), PG 包含对象没有完成相应的复制副本数量, 通常都要执行恢复操作。</td></tr><tr><td style="text-align:center">stale（新）</td><td style="text-align:left">stale：PG 状态很长时间没有被 ceph-osd 更新过, 标识存储在该 GP 中的节点显示为 DOWN, PG 处于 unknown 状态, 因为 OSD 没有报告 monitor 由 mon osd report timeout 定义超时时间</td></tr></tbody></table></div><hr><h2 id="3-Ceph心跳机制"><a href="#3-Ceph心跳机制" class="headerlink" title="3 Ceph心跳机制"></a>3 Ceph心跳机制</h2><p>心跳是用于节点间检测对方是否故障的，以便及时发现故障节点进入相应的故障处理流程。</p><p><strong>问题：</strong></p><ul><li>故障检测时间和心跳报文带来的负载之间做权衡。</li><li>心跳频率太高则过多的心跳报文会影响系统性能。</li><li>心跳频率过低则会延长发现故障节点的时间，从而影响系统的可用性。</li></ul><p><strong>故障检测策略应该能够做到：</strong></p><ul><li><strong>及时</strong>：节点发生异常如宕机或网络中断时，集群可以在可接受的时间范围内感知。</li><li><strong>适当的压力</strong>：包括对节点的压力，和对网络的压力。</li><li><strong>容忍网络抖动</strong>：网络偶尔延迟。</li><li><strong>扩散机制</strong>：节点存活状态改变导致的元信息变化需要通过某种机制扩展到整个集群。</li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p><img src="\img\ceph-webp.png" alt="img"></p><p><strong>OSD节点会监听public、cluster、front和back四个端口</strong></p><ul><li><strong>public端口</strong>：监听来自Monitor和Client的连接。</li><li><strong>cluster端口</strong>：监听来自OSD Peer的连接。</li><li><strong>front端口</strong>：供客户端连接集群使用的网卡, 这里临时给集群内部之间进行心跳。</li><li><strong>back端口</strong>：供客集群内部使用的网卡。集群内部之间进行心跳。</li><li><strong>hbclient</strong>：发送ping心跳的messenger。</li></ul><h3 id="Ceph-OSD之间相互心跳检测"><a href="#Ceph-OSD之间相互心跳检测" class="headerlink" title="Ceph OSD之间相互心跳检测"></a>Ceph OSD之间相互心跳检测</h3><p><img src="/img/ceph-k.jpg" alt="img"></p><ul><li>同一个PG内OSD互相心跳，他们互相发送PING/PONG信息。</li><li>每隔6s检测一次(实际会在这个基础上加一个随机时间来避免峰值)。</li><li>20s没有检测到心跳回复，加入failure队列。</li></ul><h3 id="Ceph-OSD与Mon心跳检测"><a href="#Ceph-OSD与Mon心跳检测" class="headerlink" title="Ceph OSD与Mon心跳检测"></a>Ceph OSD与Mon心跳检测</h3><p><img src="/img/ceph-l.jpg" alt="img"></p><p><strong>OSD报告给Monitor：</strong></p><ul><li>OSD有事件发生时（比如故障、PG变更）。</li><li>自身启动5秒内。</li><li>OSD周期性的上报给Monito<ul><li>OSD检查failure_queue中的伙伴OSD失败信息。</li><li>向Monitor发送失效报告，并将失败信息加入failure_pending队列，然后将其从failure_queue移除。</li><li>收到来自failure_queue或者failure_pending中的OSD的心跳时，将其从两个队列中移除，并告知Monitor取消之前的失效报告。</li><li>当发生与Monitor网络重连时，会将failure_pending中的错误报告加回到failure_queue中，并再次发送给Monitor。</li></ul></li></ul><p>Monitor统计下线OSD</p><ul><li>Monitor收集来自OSD的伙伴失效报告。</li><li>当错误报告指向的OSD失效超过一定阈值，且有足够多的OSD报告其失效时，将该OSD下线。</li></ul><h3 id="Ceph心跳检测总结"><a href="#Ceph心跳检测总结" class="headerlink" title="Ceph心跳检测总结"></a>Ceph心跳检测总结</h3><p>Ceph通过伙伴OSD汇报失效节点和Monitor统计来自OSD的心跳两种方式判定OSD节点失效。</p><ul><li><strong>及时</strong>：伙伴OSD可以在秒级发现节点失效并汇报Monitor，并在几分钟内由Monitor将失效OSD下线。</li><li><strong>适当的压力</strong>：由于有伙伴OSD汇报机制，Monitor与OSD之间的心跳统计更像是一种保险措施，因此OSD向Monitor发送心跳的间隔可以长达600秒，Monitor的检测阈值也可以长达900秒。Ceph实际上是将故障检测过程中中心节点的压力分散到所有的OSD上，以此提高中心节点Monitor的可靠性，进而提高整个集群的可扩展性。</li><li><strong>容忍网络抖动</strong>：Monitor收到OSD对其伙伴OSD的汇报后，并没有马上将目标OSD下线，而是周期性的等待几个条件：<ul><li>目标OSD的失效时间大于通过固定量osd_heartbeat_grace和历史网络条件动态确定的阈值。</li><li>来自不同主机的汇报达到mon_osd_min_down_reporters。</li><li>满足前两个条件前失效汇报没有被源OSD取消。</li></ul></li><li><strong>扩散</strong>：作为中心节点的Monitor并没有在更新OSDMap后尝试广播通知所有的OSD和Client，而是惰性的等待OSD和Client来获取。以此来减少Monitor压力并简化交互逻辑。</li></ul><h2 id="4-Ceph通信框架"><a href="#4-Ceph通信框架" class="headerlink" title="4 Ceph通信框架"></a>4 Ceph通信框架</h2><p><strong>Simple线程模式</strong></p><ul><li><strong>特点</strong>：每一个网络链接，都会创建两个线程，一个用于接收，一个用于发送。</li><li><strong>缺点</strong>：大量的链接会产生大量的线程，会消耗CPU资源，影响性能。</li></ul><p><strong>Async事件的I/O多路复用模式</strong></p><ul><li><strong>特点</strong>：这种是目前网络通信中广泛采用的方式。k版默认已经使用Asnyc了。</li></ul><p><strong>XIO方式使用了开源的网络通信库accelio来实现</strong></p><ul><li><strong>特点</strong>：这种方式需要依赖第三方的库accelio稳定性，目前处于试验阶段。</li></ul><h3 id="Ceph通信框架设计模式"><a href="#Ceph通信框架设计模式" class="headerlink" title="Ceph通信框架设计模式"></a>Ceph通信框架设计模式</h3><p><strong>设计模式(Subscribe/Publish)</strong></p><p>订阅发布模式又名观察者模式，它意图是“定义对象间的一种一对多的依赖关系，<br> 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新”。</p><p><img src="/img/ceph-m.jpg" alt="img"></p><p>Accepter监听peer的请求, 调用 SimpleMessenger::add_accept_pipe() 创建新的 Pipe 到 SimpleMessenger::pipes 来处理该请求。</p><p>Pipe用于消息的读取和发送。该类主要有两个组件，Pipe::Reader，Pipe::Writer用来处理消息读取和发送。</p><p>Messenger作为消息的发布者, 各个 Dispatcher 子类作为消息的订阅者, Messenger 收到消息之后，  通过 Pipe 读取消息，然后转给 Dispatcher 处理。</p><p>Dispatcher调度员是订阅者的基类，具体的订阅后端继承该类,初始化的时候通过 Messenger::add_dispatcher_tail/head 注册到 Messenger::dispatchers. 收到消息后，通知该类处理。</p><p>DispatchQueue该类用来缓存收到的消息, 然后唤醒 DispatchQueue::dispatch_thread 线程找到后端的 Dispatch 处理消息。</p><p><img src="/img/ceph-u.png" alt=""></p><h3 id="通信类框架图"><a href="#通信类框架图" class="headerlink" title="通信类框架图"></a>通信类框架图</h3><p><img src="/img/ceph-n.jpg" alt="img"></p><h3 id="通信数据格式"><a href="#通信数据格式" class="headerlink" title="通信数据格式"></a>通信数据格式</h3><p>通信协议格式需要双方约定数据格式。</p><p><strong>消息的内容主要分为三部分：</strong></p><ul><li>header //消息头类型消息的信封</li><li>user data //需要发送的实际数据<ul><li>payload     //操作保存元数据</li><li>middle      //预留字段</li><li>data       //读写数据</li></ul></li><li>footer       //消息的结束标记</li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> :</span> <span class="hljs-keyword">public</span> RefCountedObject &#123;<span class="hljs-keyword">protected</span>:  ceph_msg_header  header;      <span class="hljs-comment">// 消息头</span>  ceph_msg_footer  footer;      <span class="hljs-comment">// 消息尾</span>  bufferlist       payload;  <span class="hljs-comment">// &quot;front&quot; unaligned blob</span>  bufferlist       middle;   <span class="hljs-comment">// &quot;middle&quot; unaligned blob</span>  bufferlist       data;     <span class="hljs-comment">// data payload (page-alignment will be preserved where possible)</span>  <span class="hljs-comment">/* recv_stamp is set when the Messenger starts reading the</span><span class="hljs-comment">   * Message off the wire */</span>  <span class="hljs-keyword">utime_t</span> recv_stamp;       <span class="hljs-comment">//开始接收数据的时间戳</span>  <span class="hljs-comment">/* dispatch_stamp is set when the Messenger starts calling dispatch() on</span><span class="hljs-comment">   * its endpoints */</span>  <span class="hljs-keyword">utime_t</span> dispatch_stamp;   <span class="hljs-comment">//dispatch 的时间戳</span>  <span class="hljs-comment">/* throttle_stamp is the point at which we got throttle */</span>  <span class="hljs-keyword">utime_t</span> throttle_stamp;   <span class="hljs-comment">//获取throttle 的slot的时间戳</span>  <span class="hljs-comment">/* time at which message was fully read */</span>  <span class="hljs-keyword">utime_t</span> recv_complete_stamp;  <span class="hljs-comment">//接收完成的时间戳</span>  ConnectionRef connection;     <span class="hljs-comment">//网络连接</span>  <span class="hljs-keyword">uint32_t</span> magic = <span class="hljs-number">0</span>;           <span class="hljs-comment">//消息的魔术字</span>  bi::list_member_hook&lt;&gt; dispatch_q;    <span class="hljs-comment">//boost::intrusive 成员字段</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ceph_msg_header</span> &#123;</span>    __le64 seq;       <span class="hljs-comment">// 当前session内 消息的唯一 序号</span>    __le64 tid;       <span class="hljs-comment">// 消息的全局唯一的 id</span>    __le16 type;      <span class="hljs-comment">// 消息类型</span>    __le16 priority;  <span class="hljs-comment">// 优先级</span>    __le16 version;   <span class="hljs-comment">// 版本号</span>    __le32 front_len; <span class="hljs-comment">// payload 的长度</span>    __le32 middle_len;<span class="hljs-comment">// middle 的长度</span>    __le32 data_len;  <span class="hljs-comment">// data 的 长度</span>    __le16 data_off;  <span class="hljs-comment">// 对象的数据偏移量</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ceph_entity_name</span> <span class="hljs-title">src</span>;</span> <span class="hljs-comment">//消息源</span>    <span class="hljs-comment">/* oldest code we think can decode this.  unknown if zero. */</span>    __le16 compat_version;    __le16 reserved;    __le32 crc;       <span class="hljs-comment">/* header crc32c */</span>&#125; __attribute__ ((packed));<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ceph_msg_footer</span> &#123;</span>    __le32 front_crc, middle_crc, data_crc; <span class="hljs-comment">//crc校验码</span>    __le64  sig; <span class="hljs-comment">//消息的64位signature</span>    __u8 flags; <span class="hljs-comment">//结束标志</span>&#125; __attribute__ ((packed));</code></pre><hr><h2 id="5-Ceph-CRUSH算法"><a href="#5-Ceph-CRUSH算法" class="headerlink" title="5 Ceph CRUSH算法"></a>5 Ceph CRUSH算法</h2><blockquote><p>Controlled Replication Under Scalable Hashing, 可扩展哈希下的可控复制。以数据唯一标识符、当前存储集群的拓扑结构以及数据备份策略作为CRUSH输入，可以随时随地的通过计算获取数控所在的底层存储设备的位置并直接与其通信，从而避免查表操作，实现去中心化和高度并发。</p><p>CRUSH是一种伪随机算法，采用<strong>一致性哈希</strong>。</p><p>OSD MAP: 包含当前所有pool的状态，和所有OSD状态。</p><p>CRUSH MAP: 包含当前磁盘、服务器、机架的层次结构。</p><p>CRUSH Rules：数据映射的策略。以便灵活放置Object。</p></blockquote><h3 id="数据分布算法挑战"><a href="#数据分布算法挑战" class="headerlink" title="数据分布算法挑战"></a>数据分布算法挑战</h3><p><strong>数据分布和负载均衡</strong>：</p><ul><li>a. 数据分布均衡，使数据能均匀的分布到各个节点上。</li><li>b. 负载均衡，使数据访问读写操作的负载在各个节点和磁盘的负载均衡。</li></ul><p><strong>灵活应对集群伸缩</strong>：</p><ul><li>a. 系统可以方便的增加或者删除节点设备，并且对节点失效进行处理。</li><li>b. 增加或者删除节点设备后，能自动实现数据的均衡，并且尽可能少的迁移数据。</li></ul><p><strong>支持大规模集群</strong>：</p><ul><li>a. 要求数据分布算法维护的元数据相对较小，并且计算量不能太大。随着集群规模的增 加，数据分布算法开销相对比较小。</li></ul><h3 id="Ceph-CRUSH算法原理"><a href="#Ceph-CRUSH算法原理" class="headerlink" title="Ceph CRUSH算法原理"></a>Ceph CRUSH算法原理</h3><p><strong>CRUSH算法因子：</strong></p><ul><li>层次化的Cluster Map<br> 实际应用中设备具有形如“数据中心 → 机架→主机→磁盘”这样的树状层级，所以Cluster Map采用树来实现，每个叶子节点都是真实的最小物理存储设备，称为devices，而所有中间节点称为root，是整个集群的入口。每个节点都拥有唯一的数字ID和类型，但是只有叶子节点才拥有非负ID，表明它们是终端设备。</li></ul><blockquote><p>​                                                    下表展示了Cluster Map一些常见节点的层级</p></blockquote><ul><li>| 类型ID |  类型名称  |<br> | :——: | :————: |<br>|   0    |    osd     |<br> |   1    |    host    |<br> |   2    |  chassis   |<br> |   3    |    rack    |<br> |   4    |    row     |<br> |   5    |    pdu     |<br> |   6    |    pod     |<br> |   7    |    room    |<br> |   8    | datacenter |<br> |   9    |   region   |<br> |   10   |    root    |</li></ul><p><img src="/img/ceph-o.png" alt=" "></p><ul><li>CRUSH Map是一个树形结构，OSDMap更多记录的是OSDMap的属性(epoch/fsid/pool信息以及osd的ip等等)。</li></ul><p>叶子节点是device（也就是osd），其他的节点称为bucket节点，这些bucket都是虚构的节点，可以根据物理结构进行抽象，当然树形结构只有一个最终的根节点称之为root节点，中间虚拟的bucket节点可以是数据中心抽象、机房抽象、机架抽象、主机抽象等。</p><h3 id="数据分布策略Placement-Rules"><a href="#数据分布策略Placement-Rules" class="headerlink" title="数据分布策略Placement Rules"></a>数据分布策略Placement Rules</h3><p>在完成了使用clustermap建立对应的集群的拓扑结构描述后，可以定义placement rule 来完成<strong>数据映射</strong>.</p><p>这些操作有三种类型：</p><ul><li><p>take</p><p>take从cluster map选择指定编号的bucket ，并以此作为后续步骤的输入。例如系统默认以root节点作为输入。</p></li><li><p>select*</p><p>select从输入的bucket中随机选择指定类型和数量的条目。Ceph支持两种类型的备份策略，多副本和<strong>纠删码</strong>，对应两种算法，firstn和<strong>indep</strong>。以上两种算法都是dfs，无明显区别，唯一区别是纠删码是要求结果是有序的，i.e.总是返回指定长度的结果，如果对应条目不存在，采用空穴进行填充。</p><p>select操作也支持容灾模式，例如设置为rack，select保证所有选出的副本位于不同的机架上，也可以设置为host，即所有选出的副本位于不同的主机的磁盘上。</p></li><li><p>emit</p><p>输出最终的选择结果给上级调用并返回。</p></li></ul><p><strong>数据分布策略Placement Rules主要有特点：</strong></p><ul><li>a. 从CRUSH Map中的哪个节点开始查找</li><li>b. 使用那个节点作为故障隔离域</li><li>c. 定位副本的搜索模式（广度优先 or 深度优先）</li></ul><pre><code class="hljs bash">rule replicated_ruleset  <span class="hljs-comment">#规则集的命名，创建pool时可以指定rule集</span>&#123;    ruleset 0                <span class="hljs-comment">#rules集的编号，顺序编即可   </span>    <span class="hljs-built_in">type</span> replicated          <span class="hljs-comment">#定义pool类型为replicated(还有erasure模式)   </span>    min_size 1                <span class="hljs-comment">#pool中最小指定的副本数量不能小1</span>    max_size 10               <span class="hljs-comment">#pool中最大指定的副本数量不能大于10       </span>    step take default         <span class="hljs-comment">#查找bucket入口点，一般是root类型的bucket    </span>    step chooseleaf  firstn  0  <span class="hljs-built_in">type</span>  host <span class="hljs-comment">#选择一个host,并递归选择叶子节点osd     </span>    step emit        <span class="hljs-comment">#结束</span>&#125;</code></pre><h3 id="Bucket随机算法类型"><a href="#Bucket随机算法类型" class="headerlink" title="Bucket随机算法类型"></a>Bucket随机算法类型</h3><p><img src="/img/ceph-p.jpg" alt=""></p><p><strong>一般的buckets</strong>：适合所有子节点权重相同，而且很少添加删除item。</p><p><strong>list buckets</strong>：适用于集群扩展类型。增加item，产生最优的数据移动，查找item，时间复杂度O(n)。</p><p><strong>tree buckets</strong>：查找负责度是O (log n), 添加删除叶子节点时，其他节点node_id不变。</p><p><strong>straw buckets</strong>：允许所有项通过类似抽签的方式来与其他项公平“竞争”。定位副本时，bucket中的每一项都对应一个随机长度的straw，且拥有最长长度的straw会获得胜利（被选中），添加或者重新计算，子树之间的数据移动提供最优的解决方案。</p><h3 id="STRAW算法"><a href="#STRAW算法" class="headerlink" title="STRAW算法"></a>STRAW算法</h3><p>straw将所有元素比喻成吸管，针对指定输入，为每个元素随机计算一个长度，最后选择长度最长的那个元素作为结果输出，这个过程也被形象地称为抽签（draw），对应元素的长度称为签长。因为存储设备随着时间推移会趋于异构化，随意我们引入权重来让容量大的设备分担更多的数据，而容量小的设备分担更少的数据，从而使得数据在异构网络中也能获得合理的分布。</p><p>将所有元素按逆序排列，我们设签长为$L$，用$\triangle W_{pre}$表示当前元素与之前元素权重的差值，$R$表示剩余元素个数，$\triangle W_{next}$表示下一个元素与现在元素的权重差值,$S$表示累计权重占有的比重。</p><script type="math/tex; mode=display">S = \frac{\sum \triangle W_{pre}}{\sum \triangle W_{pre}+\triangle W_{next}}\\L = \prod{(1/S)^{1/R}}</script><p>再把L乘上0x10000。</p><p>上述算法，最终选择结果不仅与每个元素自身权重有关，还与集合中其它元素相关，修正后的straw2算法，则更加简单，</p><pre><code class="hljs properties"><span class="hljs-attr">max_x</span> = <span class="hljs-string">-1</span><span class="hljs-attr">max_item</span> = <span class="hljs-string">-1</span><span class="hljs-attr">foreach</span> <span class="hljs-string">in item:</span><span class="hljs-attr">x</span> = <span class="hljs-string">hash(input, r)</span><span class="hljs-attr">x</span> = <span class="hljs-string">ln(x/65536)/weight</span><span class="hljs-attr">if</span> <span class="hljs-string">x &gt; x_max:</span><span class="hljs-attr">x_max</span> = <span class="hljs-string">x</span><span class="hljs-attr">max_item</span> = <span class="hljs-string">item</span><span class="hljs-attr">return</span> <span class="hljs-string">max_item</span></code></pre><h3 id="CRUSH算法案例"><a href="#CRUSH算法案例" class="headerlink" title="CRUSH算法案例"></a>CRUSH算法案例</h3><p>集群中有部分sas和ssd磁盘，现在有个业务线性能及可用性优先级高于其他业务线，能否让这个高优业务线的数据都存放在ssd磁盘上。</p><p><strong>普通用户：</strong></p><p><img src="/img/ceph-q.jpg" alt="img"></p><p><strong>高优用户</strong></p><p><img src="/img/ceph-r.jpg" alt="img"></p><p>配置规则</p><p>作者：<img src="/img/ceph-t.jpg" alt="img"></p><p>限于篇幅，我们对CRUSH的介绍十分简略，更详细的请看<a href="https://durantthorvalds.top/2020/11/27/A%20first%20glance%20at%20CRUSH/">A First Galance At Crush</a>一文.</p><hr><h2 id="6-定制化Ceph-RBD-QOS"><a href="#6-定制化Ceph-RBD-QOS" class="headerlink" title="6 定制化Ceph RBD QOS"></a>6 定制化Ceph RBD QOS</h2><p>QoS （Quality of Service，服务质量）起源于网络技术，它用来解决网络延迟和阻塞等问题，能够为指定的网络通信提供更好的服务能力。</p><p>我们总的Ceph集群的iIO能力是有限的，比如带宽，IOPS。如何避免用户争取资源，如果保证集群所有用户资源的高可用性，以及如何保证高优用户资源的可用性。所以我们需要把有限的IO能力合理分配。</p><h3 id="Ceph-IO操作类型"><a href="#Ceph-IO操作类型" class="headerlink" title="Ceph IO操作类型"></a>Ceph IO操作类型</h3><ul><li><p><strong>ClientOp</strong>：来自客户端的读写I/O请求。</p></li><li><p><strong>SubOp</strong>：osd之间的I/O请求。主要包括由客户端I/O产生的副本间数据读写请求，以及由数据同步、数据扫描、负载均衡等引起的I/O请求。</p></li><li><p><strong>SnapTrim</strong>：快照数据删除。从客户端发送快照删除命令后，删除相关元数据便直接返回，之后由后台线程删除真实的快照数据。通过控制snaptrim的速率间接控制删除速率。</p></li><li><p><strong>Scrub</strong>：用于发现对象的静默数据错误，扫描元数据的Scrub和对象整体扫描的deep Scrub。</p></li><li><p><strong>Recovery</strong>：数据恢复和迁移。集群扩/缩容、osd失效/从新加入等过程。</p></li></ul><h2 id="7-CephFS"><a href="#7-CephFS" class="headerlink" title="7.CephFS"></a>7.CephFS</h2><p><img src="/img/ceph-lec.jpg" alt="image-20201122181939220"></p><h2 id="8-BlueStore-分布式对象存储"><a href="#8-BlueStore-分布式对象存储" class="headerlink" title="8.BlueStore 分布式对象存储"></a>8.BlueStore 分布式对象存储</h2><blockquote><p>与一般的FS相比，BlueStore绕过了系统的本地文件系统，由自身接管磁盘，所以其性能更好。并且充分考虑了对下一代全SSD以及全NVMe SSD闪存的支持。例如支持RocksDB。</p></blockquote><p>先介绍一些术语：</p><p>$ACID$，分别表示$Atomicity, Consistency,Isolation,Durability$。原子性，一致性，隔离性，持久性。一个支持事务$Transcation$d的系统必须支持这四种特性。</p><ol><li><strong>block-size</strong></li></ol><p>对磁盘进行操作的最小粒度（原子粒度），对普通的机械硬盘，最小粒度512字节，即一个扇区。现代SSD一般使用更大的块，4KB。</p><ol><li><strong>RMW（Read Modify Write）</strong></li></ol><p>指覆盖写，如果本次改写的内容不足一个磁盘块大小，那么需要先将对应的块读上来，然后将待修改的内容与原先的内容进行合并，最后将更新后的块重新写入原先的位置。 有两个问题：1. 额外的惩罚读 2. 因为要针对已有的内容执行覆盖写。解决方法是引入日志，数据线写入日志盘再更新数据盘。</p><ol><li><strong>COW（Copy On Write）</strong></li></ol><p>指当覆盖写发生时，不是直接更新磁盘对应位置的已有内容，而是重新在磁盘上分配一块新的空间，用于存放本次新写入的内容，这个过程也称为写时重定向。当新写完成，对应的地址更新时，即可释放原有数据对应的磁盘空间。</p><p>它自身的缺陷是：1. 破坏了数据在磁盘分布的物理连续性，经过多次COW后，前端任何大范围的顺序读后续都将变为随机读。在SSD普及后，这种情况有所好转。2. 将新的内容写入新块后，原有的块因为仍然保留了部分有效内容，所以COW之后不能释放。因为COW涉及空间重分配和地址指针重定向，所以COW将引入更多元数据。对存储系统而言，元数据的多少关乎功能的丰富与否。</p><p>BlueStore针对写操作综合运用了RMW和COW策略——任何一个写请求，根据磁盘的大小，将其切分为三个部分。<strong>首尾非块大小对齐部分</strong>，<strong>中间块大小对齐部分</strong>，然后针对中间块对齐部分采用<strong>COW策略</strong>，首尾非块对齐部分采用<strong>RMW策略</strong>。</p><p>BlueStore主要提供了读写两种类型的多线程访问接口，这些接口是基于PG粒度的。因为读请求可以并发，而写请求出于效率考虑一般被设计为异步，（所以PG内部使用读写锁来实现上述语义），实现上还需要为每个PG设计一个队列，用于对所有操作该PG的写请求进行保序。称为$OpSequencer$，不同类型的ObjectStore略有不同，在BlueStore实现中，$OpSequencer$包含两个FIFO。用于将所有进入覆盖写数据阶段的带日志写请求在线程池中再次进行排序。所有写请求通过标准的<code>queue_transcations</code>接口提交至BlueStore.</p><blockquote><p><a href="https://github.com/ceph/ceph/pull/9398">多对象事务语义支持参考</a></p></blockquote><h2 id="磁盘数据结构"><a href="#磁盘数据结构" class="headerlink" title="磁盘数据结构"></a>磁盘数据结构</h2><p>BlueStore习惯上磁盘格式用<code>_t</code>结尾而内存格式不以<code>_t</code>结尾并且只有首大写字母。所有元数据被设计成可以和用户数据分开存放，以键值对形式存放在$kvDB$中。</p><h3 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h3><p>ceph对所有存储资源进行池化管理。资源池(pool), 是一个虚拟概念，表示一组CRUSH规则的约束条件。比如我们可以针对不同的pool指定不同的备份策略，针对时延敏感的应用采用副本策略，而在一些不重要的应用采用纠删码。Ceph将任意类型的前端数据都抽象为对象，每一个对象 采用一定的策略可以生成一个全局唯一的对象标识符（$ObjectID,OID$）基于此策略的对象标识最终可以形成一个扁平的寻址空间，从而大大提高索引效率。</p><p>为了实现不同pool之间的策略隔离，Ceph引入了一个中间结构，称为PG，（归置组），实现两级映射。</p><ul><li>第一级映射是静态的，负责将任何前端类型 的应用数据按照固定的大小进行分割·编号作为伪随机哈希函数的输入，均匀映射至PG，以实现负载均衡。</li><li>第二集映射实现PG到OSD的映射，这级映射仍采用伪随机哈希函数，但是除输入的五安居唯一的PGID外，还引入了集群拓扑，并且使用CRUSH规则对计算过程进行调整，以帮助PG在不同OSD之间进行灵活迁移，进而实现数据可靠性和自动平衡等。最终pool以PG作为基本单位进行组织。</li></ul><p>为了维持扁平的寻址空间。PG也有一个全局唯一的ID——$PGID$，所有的pool由Monitor统一管理，集群内唯一pool-id。事实上，为了保证Monitor分布一致性，采用Paxos算法，我们只需要为pool内每个PG分配一个pool内唯一的编号即可。</p><blockquote><p>思考：如何使得同一个pool下的不同的PG低n位相同？</p><p>首先由特定类型的Client根据其操作的对象名计算出一个32位的哈希值，然后根据其操作的对象名计算出一个32位的哈希值，然后根据归属的pool及此时的哈希值，通过简单的计算，比如取模，即可找到最终承载该对象的PG。</p><p>我们发现如果pool内的PG数目如果能写成$2^n$形式，那么其低n比特都是相同的。我们将$2^n-1$称为PG的<strong>掩码</strong>。否则，若PG不能写成$2^n$的形式，则不能保证针对不同的输入低n比特相同这一“稳定”的性质。（比如有12个PG，那么对于属于同一个pool的PGID只有低两位相同）</p><p>因此一种行之有效的方法是用掩码代替取模。取hash低n-1位，即$hash\&amp;(2^n-1)$ .但这种映射存在问题，如果PG数目不能被2整除，那么采用这种方式会导致空穴，也就是取模结果没有实际PG对应。</p><p>比如一个pool有12个PG，n=4，但是12-15这些值都浪费了：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><p>我们可以想办法压缩空间 ，$hash\&amp;(2^{n-1}-1)$，使得不能被2整除的PGID仍能被合理映射。</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table></div><p>如果$hash\&amp;(2^{n}-1)&lt;pg_num$，那么可以直接返回$hash\&amp;(2^n-1)$.</p><p>否则，我们返回$hash\&amp;(2^{n-1}-1)$.</p><p>在参考书上被称为稳定哈希（stable hash）。</p></blockquote><p>Ceph主要设计理念之一是高扩展性。当集群中PG增加，新的PG会被随机均匀地映射至所有OSD上。作为stable hash的输入的PG数目已经发生变化，导致某些对象从旧PG重新映射至新PG，因此需要转移这部分对象，我们称为<strong>PG分裂</strong>。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>BlueStore中的对象非常类似于文件，其最基本单元是<strong>逻辑段</strong>（extent）.</p><p>可以写成 $\{offset, length , data\}$，</p><ul><li>offset表示对象逻辑偏移，从0开始编址</li><li>逻辑段长度</li><li>抽象数据类型</li></ul><p>—-更新中</p><p>参考资料</p><p><a href="https://www.jianshu.com/p/cc3ece850433">https://www.jianshu.com/p/cc3ece850433</a></p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Weil S A Brandt S A , Miller E L , et al. CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data[C]// IEEE Sc Conference. ACM, 2006.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Weil S A, Brandt S A, Miller E L, et al. Ceph: A scalable, high-performance distributed file system[C]//Proceedings of the 7th symposium on Operating systems design and implementation. 2006: 307-320.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语名谚语系列</title>
    <link href="/2020/11/19/%E6%AF%8E%E6%97%A5%E6%94%BE%E9%80%81%EF%BC%8D%E6%97%A5%E6%9C%AC%E3%81%AE%E8%AB%BA/"/>
    <url>/2020/11/19/%E6%AF%8E%E6%97%A5%E6%94%BE%E9%80%81%EF%BC%8D%E6%97%A5%E6%9C%AC%E3%81%AE%E8%AB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="毎日放送－日本の諺"><a href="#毎日放送－日本の諺" class="headerlink" title="毎日放送－日本の諺"></a>毎日放送－日本の諺</h1><p>每日一句日语谚语，让你口语和写作更地道一点吧。</p><p>1.　失敗は成功の元。　しっぱいはせいこうのもと。失败是成功之母。<br>2.　習うより慣れよ。习惯成自然。<br>3.　今日の後に今日なし。光阴似箭，日月如梭。<br>4.　急がは回れ。欲速则不达。<br>5.　人は見かけによらず。人不可貌相。<br>6.　覆水盆に返らず。ふくすいぼんにかえらず。覆水难收。<br>7.　石の上にも三年。功夫不负有心人。<br>8.　努力に勝る天才なし。どりょくにまさるてんさいなし。勤能补拙。<br>9.　私は神様ではない。人非圣贤，孰能无过。<br>10.　千里の道も一歩より。せんりのみちもいっぽより。千里之行始于足下。<br>11.　命あっての物種。いのちあってのものだね。留得青山在，不怕没柴烧。<br>12.　会うは別れの始め。あうのはわかれのはじめ。天下无不散之宴席。<br>13.　郷に入っては郷に従え。ごうにいればごうにしたがう。入乡随俗。<br>14.　怪我の功名。けがのこうめい。塞翁失马焉知非福。<br>15.　黒に染まれば黒くなる。くろにそまればくろくなる。近朱者赤近墨者黑。<br>16.　血は水より濃い。血浓于水。<br>17.　敵は本能寺にあり。てきはほんのうじにあり。醉翁之意不在酒。<br>18.　情けは人の為ならず。なさけないひとのためならず。好人有好报。<br>19.　火のない所に煙は立たぬ。无风不起浪。<br>20.　焼け石に水。杯水车薪。<br>21.　一を聞いて十を知る。举一反三。<br>22.　とおいいっかよりちかい隣。远亲不如近邻。<br>23.　かわいい娘には旅をさせよ。玉不琢不成器。<br>24.　三人寄れば文殊の知恵。三个臭皮匠顶一个诸葛亮。<br>25.　可愛い子には旅をさせよ。玉不琢不成器。<br>26.　たびはみちずれ、よはなさけ。在家靠亲戚，出门靠朋友。<br>27.　良薬は口に苦し。<br>28.　ねこにはんこ。明珠暗投。<br>29.　泣き面に蜂。なきつらにはち。雪上加霜。<br>30.　馬の耳に念仏。耳边风。<br>31.　氏より育て柄。后天教育比出身重要。<br>32.　芸は身を助く。技多不压身。<br>33.　得手に帆を揚げる。扬长避短。<br>34.　猿も木から落ちる。智者千虑，必有一失。<br>35.　若い時は二度無い。花无百日好，人无二度春。<br>36.　立て板に水。口若悬河。<br>37.　稼ぐに追いつく貧乏なし。勤劳致富。<br>38.　寝耳に水。晴天霹雳。<br>39.　鬼に金棒。如虎添翼。<br>40.　負けるが勝ち。胜负乃兵家常事。<br>41.　餅は餅屋。外行看热闹，内行看门道。<br>42.　地獄の沙汰も金次第。有钱能使鬼推磨。<br>43.　仏の顔も三度。人的忍耐是有限度的。<br>44.　損して得取れ。损人利己。<br>45.　自画自賛。<br>46.　自業自得。自作自受。<br>47.　人の噂も七十五日。风言风语长不了。<br>48.　人の花は赤い。什么都是别人的好。</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>文化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「入门部署」Ceph-deploy流程</title>
    <link href="/2020/11/19/Ceph-deploy%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/11/19/Ceph-deploy%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Ceph-deploy流程"><a href="#Ceph-deploy流程" class="headerlink" title="Ceph-deploy流程"></a>Ceph-deploy流程</h1><p>本文介绍了借助Ceph-deploy工具安装Ceph并搭建集群的过程。按照下文的步骤，你可以快速搭建一个基础的Ceph环境，并且了解Ceph集群的组成和工作原理。文章首先会简单介绍Ceph及其安装和环境部署方法，接着给出了预备环境的搭建过程，最后详细地列出了Ceph的安装及配置过程。本文附录还给出了Ceph的编译过程示例。</p><h2 id="1-Ceph基础"><a href="#1-Ceph基础" class="headerlink" title="1  Ceph基础"></a>1  Ceph基础</h2><h3 id="1-1-Ceph介绍"><a href="#1-1-Ceph介绍" class="headerlink" title="1.1 Ceph介绍"></a>1.1 Ceph介绍</h3><p>Ceph 是一个可靠的、自动重均衡、自动恢复的分布式存储系统，根据场景划分可以将 Ceph 分为三大块，分别是对象存储、块设备存储和文件系统服务。三种应用场景都在底层的RADOS之上运行，最后都会被转换成对象存储在各个pool的placement group(PG)中。</p><p>Ceph 的核心组件包括 Ceph OSD、Ceph Monitor、Ceph Manager和 Ceph MDS。</p><ul><li><em>Ceph OSD</em>：OSD 的英文全称是 Object Storage Device，它的主要功能是存储数据、复制数据、平衡数据、恢复数据等，Ceph OSD 的架构实现由物理磁盘驱动器、Linux文件系统和 Ceph OSD 服务组成。</li><li><em>Ceph Monitor</em>：负责监视 Ceph 集群，维护Ceph 集群的健康状态，同时维护着 Ceph 集群中的各种 Map 图，比如 OSD Map、Monitor Map、PG Map 和 CRUSH Map。</li><li><em>Ceph  Manager</em>: 负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率、当前性能指标和系统负载。</li><li><em>Ceph MDS</em>：全称是 Ceph MetaData Server，主要保存的文件系统服务的元数据，但对象存储和块存储设备是不需要使用该服务的。</li></ul><p>对于一个用于对象存储的Ceph集群来说，它至少需要部署一个Monitor服务、一个Manager服务和一个OSD服务。其中，这些组件可以部署在同一台机器，即一个机器可以拥有多个角色（服务）。</p><p>若要保证数据可靠性，系统中应当有多个OSD节点，以实现副本或纠删码功能。Ceph默认的策略是3副本，这意味着在该策略下集群中至少要有3个OSD节点才能正常运作。（副本策略和纠删码配置均可更改）</p><h3 id="1-2-Ceph的安装方法"><a href="#1-2-Ceph的安装方法" class="headerlink" title="1.2 Ceph的安装方法"></a>1.2 Ceph的安装方法</h3><p>Ceph主要编写的语言是C++，其代码规模可达100+万行，同时Ceph涉及的依赖软件众多，任何一个环节出问题都有可能导致Ceph安装失败，这对新手来说是一个挑战。</p><p> Ceph的安装方法有以下三种：</p><ol><li>手动编译安装。官方提供了依赖软件的安装脚本，源码中还自带CMake规则，生成对应makfile后由make调用gcc/g++编译完成。理论上Ceph的编译安装过程可以使用自动化工具简单几步就完成，但不同机器的系统和环境不同，先前安装的软件或者环境变量设置不当也有可能会给安装过程带来一些障碍。手动编译是比较容易出问题的，也是耗时最长的。一般来说在使用官方版本入门探索时不推荐手动安装。若要修改源代码，则必须使用手动方法安装。具体的手动编译安装流程见文章附录。</li><li>使用包管理工具安装。官方及各大开源镜像站都提供了官方标准版本的软件源，我们可以添加对应的密钥和仓库链接后，使用系统自带的包管理工具轻松安装。如Ubuntu/Debian中的apt，CentOS/RHEL中的yum。这种方法简单方便，但要注意只能安装官方标准版本。</li><li><p>使用部署工具安装。下文提及的自动化部署工具中带有Ceph组件的安装功能，如Ceph-deploy，它本质上还是调用包管理工具进行安装。（Docker等容器方法暂不在讨论范围之内）</p><p>简而言之，除了有修改源代码的需求外，一般优先推荐使用方法2或方法3安装Ceph。</p></li></ol><h3 id="1-3-Ceph的部署方法"><a href="#1-3-Ceph的部署方法" class="headerlink" title="1.3 Ceph的部署方法"></a>1.3 Ceph的部署方法</h3><p>Ceph是一个分布式存储系统，这意味着还需要一系列的配置文件、设置来告诉系统中的节点分别如何工作。在每一台节点上分别手动配置是可行的，但过程繁琐且复杂，还容易出问题，一般不推荐。下面我们介绍几种用于部署Ceph的自动化工具。</p><ol><li>Cephadm：它是在Ceph官方在新版本Octopus（15）中推行的全新部署工具。Cephadm完美支持新的编排API、CLI和仪表盘特性，可用于快速部署Octopus及更新版本的Ceph集群。Cephadm更加简单，且不依赖其它自动化部署工具，但该工具不支持部署旧版本的Ceph（如14的Nautilus），所有Ceph进程也是运行在容器中的，意味着在修改源码的情况下还需要制作新的镜像，比较麻烦。官方文档中指出，Cephadm暂时不推荐用于生产环境。</li><li>Rook：可以把Ceph部署在Kubernetes集群中运行。与1类似的是，Ceph也是运行在容器中的。</li><li>Ceph-deploy：在v14 Nautilus及之前的官方推荐部署工具（目前已不再维护）。其原理是借助ssh集中控制集群主机，让它们分别执行特定命令和传输配置文件。通过Ceph-deploy安装的Ceph是直接运行在目的主机的操作系统上的（而非容器），同时Ceph的安装与集群的部署是可以分开进行的。</li><li><p>其它：ceph-ansible、DeepSea、puppet-ceph等工具都需要第三方部署工具的支持。</p><p>假设我们有Ceph源代码修改的需求，1和2的容器运行环境会让事情变得更加复杂（如重新制作镜像并上传），使得快速修改代码后测试也变得困难，因此我们暂不采用。而Ceph-deploy工具比较灵活，无论是使用官方标准版本Ceph进行入门探索，亦或是测试修改源码后的Ceph，它都有较好的支持。虽然官方已不再维护，但对于一般科研用途而言，Ceph-deploy工具已经能够满足需求，可以帮助用户快速搭建出一个简单的Ceph集群。下文中我们将着重介绍基于Ceph-deploy的安装和部署流程。</p></li></ol><h2 id="2-预备条件"><a href="#2-预备条件" class="headerlink" title="2  预备条件"></a>2  预备条件</h2><p>下文将在Ubuntu 18.04的环境下，选择Ceph v14.2.13（Nautilus）作为目标版本，以使用Ceph-deploy 2.0.1安装和部署带3个OSD的Ceph纠删码集群为例，一步步地引导读者搭建出一个基础的Ceph环境。</p><p>要实现这一目标，我们需要准备3台机器，其中1台同时充当用于控制部署的admin_node。部署的控制也可以在另一个存储节点上进行，但这里为了方便理解我们指定node_0来控制部署流程。注意：经测试发现，当前版本的Ceph只能使用物理块设备来部署存储服务，因此每个存储节点都需要除系统盘外的额外一块空硬盘供Ceph使用，该硬盘将被重新格式化。</p><p>本文中的示例集群如下：</p><div class="table-container"><table><thead><tr><th>主机名</th><th>IP地址</th><th>角色</th></tr></thead><tbody><tr><td>node_0</td><td>192.168.248.100</td><td>deploy_admin  / monitor / manager / osd_0</td></tr><tr><td>node_1</td><td>192.168.248.101</td><td>osd_1</td></tr><tr><td>node_2</td><td>192.168.248.102</td><td>osd_2</td></tr></tbody></table></div><p> 我们将在虚拟机中进行演示，其中每个主机都含有8 GiB的RAM，60 GB的系统盘以及10 GB的数据盘。</p><p>（小技巧：我们可以先在1台虚拟机上配置好通用的预备环境，再克隆出另外的2台，随后调整部分配置后即可（如IP、主机名等）。克隆后记得重新生成网卡MAC地址）</p><h2 id="3-预备环境配置"><a href="#3-预备环境配置" class="headerlink" title="3  预备环境配置"></a>3  预备环境配置</h2><h3 id="3-1-网络配置"><a href="#3-1-网络配置" class="headerlink" title="3.1 网络配置"></a>3.1 网络配置</h3><p>所有节点都需要执行以下步骤。</p><ol><li><p>IP配置。最简单的方法是在GUI的设置中直接修改网络配置，也可以手动修改网络配置文件。这一步我们不再赘述。</p></li><li><p>修改主机名。修改文件 /etc/hostname ，把内容替换为对应的主机名。重启后生效。</p><pre><code class="hljs bash">$  sudo vim /etc/hostname   <span class="hljs-comment"># 以node_0为例，替换为如下内容</span>    node_0</code></pre></li><li><p>添加域名映射。修改 /etc/hosts ，添加对应映射内容：</p> <pre><code class="hljs bash">$  sudo vim /etc/hosts   <span class="hljs-comment"># 添加如下内容</span>192.168.248.100 node_0192.168.248.101 node_1192.168.248.102 node_2</code></pre></li></ol><h3 id="3-2-软件仓库配置"><a href="#3-2-软件仓库配置" class="headerlink" title="3.2 软件仓库配置"></a>3.2 软件仓库配置</h3><p>所有节点都需要执行以下步骤。</p><ol><li>建议使用国内软件源，如阿里、网易、清华、中科大、华科开源镜像站等，在后面安装包时能获得更好的体验。最简单的方法是在GUI中的“软件与更新”设置中选择国内源，手动配置则具体见 <a href="http://mirrors.ustc.edu.cn/help/ubuntu.html">http://mirrors.ustc.edu.cn/help/ubuntu.html</a></li><li><p>配置国内Ceph源。以中科大镜像站为例：</p> <pre><code class="hljs bash">$  wget -q -O- <span class="hljs-string">&#x27;http://mirrors.ustc.edu.cn/ceph/keys/release.asc&#x27;</span> | sudo apt-key add -$  <span class="hljs-built_in">echo</span> deb http://mirrors.ustc.edu.cn/ceph/debian-nautilus/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list$  vim ~/.bashrc  <span class="hljs-comment"># 添加如下内容</span><span class="hljs-built_in">export</span> CEPH_DEPLOY_REPO_URL=http://mirrors.ustc.edu.cn/ceph/debian-nautilus/ <span class="hljs-built_in">export</span> CEPH_DEPLOY_GPG_URL=http://mirrors.ustc.edu.cn/ceph/keys/release.asc$  <span class="hljs-built_in">source</span> ~/.bashrc$  sudo apt update</code></pre></li></ol><p>注意：其中URL处的“debian-nautilus”可以根据不同的目标Ceph版本和操作系统更改为不同的对应名称。</p><h3 id="3-3-Ceph专门用户"><a href="#3-3-Ceph专门用户" class="headerlink" title="3.3 Ceph专门用户"></a>3.3 Ceph专门用户</h3><p>我们将创建 cephuser 用户作为Ceph运行专门的用户。所有节点都需要执行以下步骤。</p><pre><code class="hljs bash">$  sudo useradd cephuser -m -d /home/cephuser -s /bin/bash$  sudo passwd cephuser  <span class="hljs-comment"># 输入密码</span>$  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cephuser ALL = (root) NOPASSWD:ALL&quot;</span> | sudo tee /etc/sudoers.d/cephuser$  sudo chmod 0440 /etc/sudoers.d/cephuser$  su cephuser</code></pre><h3 id="3-4-安装支撑软件"><a href="#3-4-安装支撑软件" class="headerlink" title="3.4 安装支撑软件"></a>3.4 安装支撑软件</h3><p>所有节点都需要执行以下步骤。</p><ul><li><p>安装ssh服务端</p>  <pre><code class="hljs bash">$  sudo apt-get install openssh-server</code></pre></li><li><p>安装python，用于执行ceph-deploy受控端的脚本</p>  <pre><code class="hljs bash">$  sudo apt install python-minimal</code></pre></li></ul><h3 id="3-5-使用ntp校准时间"><a href="#3-5-使用ntp校准时间" class="headerlink" title="3.5 使用ntp校准时间"></a>3.5 使用ntp校准时间</h3><p>分布式系统对时间尤其敏感，若系统中各个节点时间误差很大，有可能造成系统奔溃。我们使用ntp来校准时间，保证每台主机的时间对齐。所有节点都需要执行以下步骤。</p><ul><li><p>安装ntp</p>  <pre><code class="hljs bash">$  sudo apt install ntp</code></pre></li><li><p>启动ntp服务</p>  <pre><code class="hljs bash">$  sudo /etc/init.d/ntp restart $  sudo systemctl <span class="hljs-built_in">enable</span> ntp.service</code></pre></li><li><p>添加阿里云ntp服务器</p>  <pre><code class="hljs bash">$  sudo vim /etc/ntp.conf    <span class="hljs-comment"># 末尾添加 server ntp.aliyun.com</span>$  sudo /etc/init.d/ntp restart</code></pre></li></ul><h3 id="3-6-配置ssh无密码访问"><a href="#3-6-配置ssh无密码访问" class="headerlink" title="3.6 配置ssh无密码访问"></a>3.6 配置ssh无密码访问</h3><p>Ceph-deploy需要管理节点获得其它节点的ssh无密码访问权限。以下步骤只需在admin_node（node_0）上执行。</p><ul><li><p>创建密钥，一路回车选择默认值即可。</p>  <pre><code class="hljs bash">$  ssh-keygen</code></pre></li><li><p>把公钥复制到其它节点</p>  <pre><code class="hljs bash">$  ssh-copy-id node_1$  ssh-copy-id node_2</code></pre></li><li><p>配置ssh登录的默认指定用户名，为ceph-deploy做准备。</p>  <pre><code class="hljs bash">$  vim ~/.ssh/config  <span class="hljs-comment"># 添加如下内容</span>Host node_1 Hostname node_1 User cephuserHost node_2 Hostname node_2 User cephuser</code></pre></li></ul><h2 id="4-Ceph的安装与部署"><a href="#4-Ceph的安装与部署" class="headerlink" title="4  Ceph的安装与部署"></a>4  Ceph的安装与部署</h2><p>以下步骤如没有特别申明，均只需在admin_node（node_0）上执行。</p><h3 id="4-1-安装ceph-deploy"><a href="#4-1-安装ceph-deploy" class="headerlink" title="4.1 安装ceph-deploy"></a>4.1 安装ceph-deploy</h3><ul><li><p>前面已配置过ceph源，直接使用apt安装</p>  <pre><code class="hljs bash">$  sudo apt install ceph-deploy</code></pre></li><li><p>创建保存配置文件的工作环境</p>  <pre><code class="hljs bash">$  mkdir ~/ceph_cluster$  <span class="hljs-built_in">cd</span> ~/ceph_cluster/</code></pre></li></ul><h3 id="4-2-安装ceph"><a href="#4-2-安装ceph" class="headerlink" title="4.2 安装ceph"></a>4.2 安装ceph</h3><p>下面命令采用了ceph-deploy远程控制的方式安装仓库中的官方标准版本。若需要从本地（修改后）源码安装，请查看附录中的编译安装部分。</p><pre><code class="hljs bash">$  ceph-deploy install --no-adjust-repos node_0 node_1 node_2</code></pre><p>由于我们已在前面配置好了国内ceph源，所以使用—no-adjust-repos参数防止覆盖。</p><p>如果出现问题：</p><pre><code class="hljs oxygene">Runtime Error: <span class="hljs-keyword">module</span> <span class="hljs-keyword">platform</span> <span class="hljs-keyword">has</span> no attribute <span class="hljs-string">&#x27;linux_distribution&#x27;</span>.</code></pre><p>python3.7以后<code>platform.linux_distribution()</code>被移除了. 而笔者用的是3.8. </p><p>若安装成功，可在各个节点上分别打印出ceph的版本号。</p><pre><code class="hljs bash">$  ceph -vceph version 14.2.13 (1778d63e55dbff6cedb071ab7d367f8f52a8699f) nautilus (stable)</code></pre><h3 id="4-3-部署MON节点"><a href="#4-3-部署MON节点" class="headerlink" title="4.3 部署MON节点"></a>4.3 部署MON节点</h3><p>此次规划在 node_0 上部署 mon、mgr、osd 进程，node_1 和 node_2 仅部署 osd 进程。在 node_0 节点上执行，创建 1 个 MON 服务进程，配置并同步 ceph.conf 配置文件，不部署日志盘和缓存盘。 </p><ul><li><p>创建集群配置，其中     —cluster-network和 —public-network参数指定集群的子网，若不配置后面执行Ceph-deploy时可能会出错。</p>  <pre><code class="hljs bash">$  ceph-deploy new --cluster-network 192.168.248.0/24 --public-network 192.168.248.0/24 node_0</code></pre></li></ul><p>命令末尾的node_0 为打算部署 mon 的节点。执行成功后会在当前目录下会自动生成：ceph.conf、ceph.mon.keyring 两个文件外加一个 log 文件。</p><ul><li><p>部署MON节点，并收集密钥</p>  <pre><code class="hljs bash">$  ceph-deploy mon create-initial</code></pre></li></ul><p>执行完之后，本地目录下会生成若干keyring结尾的密钥文件</p><ul><li><p>同步集群配置文件及admin keyring文件</p>  <pre><code class="hljs bash">$  ceph-deploy admin node_0$  ceph-deploy admin node_1$  ceph-deploy admin node_2</code></pre></li><li><p>检查配置是否成功</p>  <pre><code class="hljs bash">$  ceph -s  cluster:    id:     f564cb33-e2c7-44cb-a645-df9d20824667    health: HEALTH_OK   services:    mon: 1 daemons, quorum node_0 (age 31s)    mgr: no daemons active    osd: 0 osds: 0 up, 0 <span class="hljs-keyword">in</span>   data:    pools:   0 pools, 0 pgs    objects: 0 objects, 0 B    usage:   0 B used, 0 B / 0 B avail    pgs:</code></pre></li></ul><p>若出现：</p><pre><code class="hljs bash">[errno 2] error connecting to the cluster</code></pre><p>则是文件权限的问题，可以通过下面命令更改文件夹权限</p><pre><code class="hljs bash">$  sudo chown cephuser:cephuser -R /etc/ceph</code></pre><p>或  加sudo执行ceph </p><h3 id="4-4-部署MGR节点"><a href="#4-4-部署MGR节点" class="headerlink" title="4.4 部署MGR节点"></a>4.4 部署MGR节点</h3><pre><code class="hljs bash">$  ceph-deploy mgr create node_0</code></pre><ul><li><p>检查配置是否成功</p>  <pre><code class="hljs bash">$  ceph -s  cluster:    id:     f564cb33-e2c7-44cb-a645-df9d20824667    health: HEALTH_OK   services:    mon: 1 daemons, quorum node_0 (age 111s)    mgr: node_0(active, since 2s)    osd: 0 osds: 0 up, 0 <span class="hljs-keyword">in</span>   data:    pools:   0 pools, 0 pgs    objects: 0 objects, 0 B    usage:   0 B used, 0 B / 0 B avail    pgs:</code></pre></li></ul><p>可以看到，mgr服务已运行在node_0上。</p><h3 id="4-5-部署OSD节点"><a href="#4-5-部署OSD节点" class="headerlink" title="4.5 部署OSD节点"></a>4.5 部署OSD节点</h3><p>本节只举例在使用磁盘 sdb 作为 OSD 数据盘的情况。</p><ul><li><p>先清除数据盘的格式与文件系统（在所有存储节点上执行）</p>  <pre><code class="hljs bash">$  sudo wipefs -af /dev/sdb</code></pre></li><li><p>分别在三个节点上创建OSD</p>  <pre><code class="hljs bash">$  ceph-deploy osd create --data /dev/sdb node_0$  ceph-deploy osd create --data /dev/sdb node_1 $  ceph-deploy osd create --data /dev/sdb node_2</code></pre></li><li><p>检查配置是否成功</p>  <pre><code class="hljs bash">$  ceph -s  cluster:    id:     f564cb33-e2c7-44cb-a645-df9d20824667    health: HEALTH_OK   services:    mon: 1 daemons, quorum node_0 (age 3m)    mgr: node_0(active, since 95s)    osd: 3 osds: 3 up (since 5s), 3 <span class="hljs-keyword">in</span> (since 5s)   data:    pools:   0 pools, 0 pgs    objects: 0 objects, 0 B    usage:   3.0 GiB used, 27 GiB / 30 GiB avail    pgs:</code></pre></li></ul><p>可以看到，我们成功启动了3个OSD，整个ceph集群获得了30 GiB的存储空间。</p><h3 id="4-6-配置纠删码池"><a href="#4-6-配置纠删码池" class="headerlink" title="4.6 配置纠删码池"></a>4.6 配置纠删码池</h3><p>至此我们的Ceph还没有存储任何的数据。下面我们将配置一个使用纠删码的池。</p><ul><li><p>创建自定义纠删码配置，以2+1的RS code配置为例</p>  <pre><code class="hljs bash">$  ceph osd erasure-code-profile <span class="hljs-built_in">set</span> toy_ec k=2 m=1</code></pre></li><li><p>查看配置</p>  <pre><code class="hljs bash">$  ceph osd erasure-code-profile get toy_eccrush-device-class=crush-failure-domain=hostcrush-root=defaultjerasure-per-chunk-alignment=<span class="hljs-literal">false</span>k=2m=1plugin=jerasuretechnique=reed_sol_vanw=8</code></pre></li><li><p>创建EC池</p>  <pre><code class="hljs bash">$  ceph osd pool create ecpool 16 16 erasure toy_ecpool <span class="hljs-string">&#x27;ecpool&#x27;</span> created</code></pre></li><li><p>启用对象存储应用</p>  <pre><code class="hljs bash">$  ceph osd pool application <span class="hljs-built_in">enable</span> ecpool rgwenabled application <span class="hljs-string">&#x27;rgw&#x27;</span> on pool <span class="hljs-string">&#x27;ecpool&#x27;</span></code></pre></li><li><p>测试ecpool</p>  <pre><code class="hljs bash">$  <span class="hljs-built_in">echo</span> ABCDEFGHI | rados --pool ecpool put NYAN -</code></pre></li><li><p>获取对象</p>  <pre><code class="hljs bash">$  rados --pool ecpool get NYAN -ABCDEFGHI</code></pre></li></ul><p>若正常输出内容，就意味着我们的Ceph基础集群搭建成功了。</p><p>如果需要进一步部署块存储、对象存储、文件存储三大组件，可参考官方文档（见参考资料6）。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>Ceph - a     scalable distributed storage system, <a href="https://github.com/ceph/ceph">https://github.com/ceph/ceph</a></li><li>BUG #13137:Ceph-deploy had failed to create cluster in LXC container, <a href="https://tracker.ceph.com/issues/13137">https://tracker.ceph.com/issues/13137</a></li><li>Ceph实战教程(一)让Ceph集群运行起来, <a href="https://blog.51cto.com/happylab/2474943">https://blog.51cto.com/happylab/2474943</a></li><li>Ceph v12.2     Luminous基于ubuntu16.04集群部署, <a href="https://segmentfault.com/a/1190000011581513">https://segmentfault.com/a/1190000011581513</a></li><li>Ceph Deployment - Ceph Documentation, <a href="https://docs.ceph.com/en/nautilus/rados/deployment/">https://docs.ceph.com/en/nautilus/rados/deployment/</a></li><li>Installation (ceph-deploy) — Ceph Documentation, <a href="https://docs.ceph.com/en/nautilus/start/">https://docs.ceph.com/en/nautilus/start/</a></li><li>分布式存储（Ceph）环境搭建指导书Ubuntu 18.04.3, <a href="https://bbs.huaweicloud.com/forum/thread-40539-1-1.html">https://bbs.huaweicloud.com/forum/thread-40539-1-1.html</a> </li></ol><hr><h2 id="附录-Ceph编译安装"><a href="#附录-Ceph编译安装" class="headerlink" title="附录  Ceph编译安装"></a>附录  Ceph编译安装</h2><p>下面我们以在 Ubuntu 18.04 上编译安装Ceph 14.2.13为例，演示如何正确编译Ceph源代码。</p><p>值得一提的是，官方提供的安装脚本有点小问题，若直接按照官方README步骤安装，可能会有很多麻烦。为了避免安装过程中出现错误，我们首先需要配置一点东西。</p><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="#1 环境配置"></a>#1 环境配置</h3><p>建议读者至少留50 GB的磁盘空闲空间用于编译和安装Ceph。</p><ul><li>配置Ubuntu国内源，见3.2小节。</li><li><p>增加toolchain-r源，为部分高版本的依赖工具链做准备。</p>  <pre><code class="hljs bash">$  wget http://mirror.cs.uchicago.edu/ubuntu-toolchain-r/key.pgp$  sudo apt-key add key.pgp$  sudo vim /etc/apt/sources.list.d/toolchain.list  <span class="hljs-comment"># 添加如下内容</span>deb [arch=amd64 lang=none] http://mirror.cs.uchicago.edu/ubuntu-toolchain-r bionic main$  sudo apt update</code></pre></li><li><p>修改为国内pypi源。修改 ~/.pip/pip.conf ，替换为以下内容。若不存在则新建该文件（夹）。</p>  <pre><code class="hljs ini"><span class="hljs-section">[global]</span><span class="hljs-attr">index-url</span> = https://pypi.doubanio.com/simple<span class="hljs-section">[install]</span><span class="hljs-attr">trusted-host</span> = pypi.doubanio.com</code></pre></li><li><p>安装curl</p>  <pre><code class="hljs bash">$  sudo apt install curl</code></pre></li><li><p>安装nodejs、npm（为ceph-dashboard组件准备）</p></li></ul><p>我们使用nvm来获取较新稳定版本的nodejs和npm。</p><pre><code class="hljs bash">$  curl -o- https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash$  nvm install --lts  <span class="hljs-comment"># 需重新打开终端，nvm才能生效</span></code></pre><p>检验是否安装成功<br><pre><code class="hljs bash">$  npm -v6.14.8$  node -vv14.15.0</code></pre></p><p>我们更换国内npm源以获得更好的体验</p><pre><code class="hljs bash">$  npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>检验是否安装成功</p><pre><code class="hljs bash">$  cnpm -vcnpm@6.1.1 (/home/yao/.nvm/versions/node/v14.15.0/lib/node_modules/cnpm/lib/parse_argv.js)npm@6.14.8 (/home/yao/.nvm/versions/node/v14.15.0/lib/node_modules/cnpm/node_modules/npm/lib/npm.js)node@14.15.0 (/home/yao/.nvm/versions/node/v14.15.0/bin/node)npminstall@3.28.0 (/home/yao/.nvm/versions/node/v14.15.0/lib/node_modules/cnpm/node_modules/npminstall/lib/index.js)prefix=/home/yao/.nvm/versions/node/v14.15.0 linux x64 5.4.0-42-generic registry=https://r.npm.taobao.org</code></pre><ul><li><p>安装angular（为ceph-dashboard组件准备）</p>  <pre><code class="hljs bash">$  cnpm install -g @angular/cli$  ng --version</code></pre></li></ul><h3 id="2-编译源码"><a href="#2-编译源码" class="headerlink" title="#2 编译源码"></a>#2 编译源码</h3><ul><li>获取源码。我们选择从中科大镜像站上下载tar包，其中链接末尾的版本号可更改为想要获取的指定版本数字。</li></ul><p>（若使用本地修改后的源代码进行编译可跳过）</p><pre><code class="hljs bash">$  wget http://mirrors.ustc.edu.cn/ceph/tarballs/ceph-14.2.13.tar.gz$  tar -zxvf ceph-14.2.13.tar.gz -C ~ <span class="hljs-comment"># 解压tar包</span></code></pre><ul><li><p>安装依赖软件</p>  <pre><code class="hljs bash">$  <span class="hljs-built_in">cd</span> ~/ceph-14.2.13$  sudo ./install-deps.sh</code></pre></li><li><p>生成makefile</p>  <pre><code class="hljs bash">$  ./do_cmake.sh</code></pre><p>  值得一提的是，默认编译的版本是debug版本，各种调试信息的输出可能会大大降低ceph的性能。若要编译非debug版本，应在调用cmake时传递参数<code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code></p><p>  我们还可以添加参数<code>-DWITH_MGR_DASHBOARD_FRONTEND=OFF</code>来跳过前端控制台dashboard（减少后面的编译和安装时间）。</p></li><li><p>开始编译</p>  <pre><code class="hljs bash">$  <span class="hljs-built_in">cd</span> build$  sudo make -j4</code></pre><p>  其中j后面的数字代表make多线程编译的线程数（建议设置为CPU物理核心个数）。若编译进程无故中断，重新执行上述make命令以继续即可。注意：有时候线程数过多会导致频繁奔溃，适当减少线程数可能效果会更好。</p></li><li><p>安装到系统</p>  <pre><code class="hljs bash">$  sudo make install$  sudo ldconfig</code></pre></li><li><p>验证是否安装成功</p>  <pre><code class="hljs bash">$  ceph -vceph version 14.2.13 (1778d63e55dbff6cedb071ab7d367f8f52a8699f) nautilus (stable)</code></pre></li></ul><p>如果顺利将显示所安装ceph的版本号。至此，编译安装成功。</p><h3 id="3-备注"><a href="#3-备注" class="headerlink" title="#3 备注"></a>#3 备注</h3><p>截止至本文完成时，Ceph官方的libboost软件仓库部分针对Ubuntu 16.04 (Xenial) 的安装包丢失，因此在Ubuntu 16.04上编译安装Ceph 14.2.13时会遇到依赖环境安装失败的情况（可能暂时无法解决）。</p>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「综述」纠删码综述</title>
    <link href="/2020/11/15/%E7%BA%A0%E5%88%A0%E7%A0%81%E5%9C%A8%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/11/15/%E7%BA%A0%E5%88%A0%E7%A0%81%E5%9C%A8%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="「综述」纠删码理论"><a href="#「综述」纠删码理论" class="headerlink" title="「综述」纠删码理论"></a>「综述」纠删码理论</h1><blockquote><p>2017年更新</p></blockquote><h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p>随着云存储和大数据技术的发展，存储系统面临越来越大的考验，主要体现在系统的可靠性方面。纠删码作为存储系统容错的主要方法越来越受到重视．本文介绍了最重要的一些纠删码。</p><p>目前冗余备份机制主要有两种，一种是数据完全备份机制，也就是通常所说的镜像方法，（mirrorred-method），又称为多副本技术，这类方法的优点是不需要专门的编码解码算法，缺点是磁盘利用率很低，适合于存储规模比较小的应用场景。另外一种就是纠删码方法（erasure code）。</p><h1 id="2-术语"><a href="#2-术语" class="headerlink" title="2 术语"></a>2 术语</h1><h2 id="2-1-存储效率和存储冗余度"><a href="#2-1-存储效率和存储冗余度" class="headerlink" title="2.1 存储效率和存储冗余度"></a>2.1 存储效率和存储冗余度</h2><p>​    <strong>存储效率 = 数据空间 /（数据空间 + 校验空间）</strong></p><p>​    对于三副本存储，其效率为1/3。除了存储效率指标，冗余存储系统还要存储冗余度和存储开销。</p><p>​    存储冗余度 = 1/存储效率</p><p>​    存储开销 = 校验空间/数据空间</p><h2 id="2-2-RCW和RMW"><a href="#2-2-RCW和RMW" class="headerlink" title="2.2 RCW和RMW"></a>2.2 RCW和RMW</h2><p>RCW针对写数据较多。Read Construct Write</p><script type="math/tex; mode=display">P_{new} = D1_{new} \oplus D2_{old}\oplus D3_{old}\oplus D4_{old}</script><p>RMW针对读数据较少。Read Modify Write</p><script type="math/tex; mode=display">P_{new} = D1_{old}\oplus P_{old}\oplus D1_{new}</script><p>此外还有COW，覆盖写。</p><h2 id="2-3-节点重构"><a href="#2-3-节点重构" class="headerlink" title="2.3 节点重构"></a>2.3 节点重构</h2><p>如果碰到永久性失效，需要恢复失效数据。根据重构过程中存储系统是否响应用户I/O请求分为在线重构和离线重构。前者是指重构的过程中同时响应IO请求。后者指系统独立进行重构。</p><p>对于容错能力为r的存储系统的平均数据丢失时间(mean time to data loss, $MTTDL$) 与失效数据恢复时间的r次方成反比，即失效数据恢复时间越长，系统节点再次失效的概率就越大，系统的有效性越差。 </p><h2 id="2-4-条带"><a href="#2-4-条带" class="headerlink" title="2.4 条带"></a>2.4 条带</h2><p>条带(stripe) 指 相同纠删码的所有信息的集合，它相当于一个算法的实例。一个存储系统可以看成是很多条带的集合，可以通过条带之间的轮转来实现负载的均衡。另一个类似的概念，是条块(strip)，它是同一条带内包含的元素的个数。</p><p>目前企业中，已经有利用大条带降低校验码比例以实现降低存储开销的先例，但是如何高效的生成大条带并不是容易的，尤其是降低生成大条带的带宽。</p><pre><code>                                                                 表 1 几种纠删码存储集群系统的特征分析</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">存储方案</th><th style="text-align:center">设计目标</th><th style="text-align:center">纠删码</th><th style="text-align:center">网络</th></tr></thead><tbody><tr><td style="text-align:center">Microsoft Aure Storage</td><td style="text-align:center">可扩展云存储</td><td style="text-align:center">RS码（k=12，r=4）</td><td style="text-align:center">TCP/IP over VL2 Ethernet</td></tr><tr><td style="text-align:center">Google GFS II</td><td style="text-align:center">分布式存储</td><td style="text-align:center">RS码（k=6，r=3）</td><td style="text-align:center">TCP/IP over Ethernet</td></tr><tr><td style="text-align:center">Facebook HDFS-RAID</td><td style="text-align:center">数据仓库</td><td style="text-align:center">RS码（k=10，r=4）</td><td style="text-align:center">TCP/IP</td></tr><tr><td style="text-align:center">Tahoe</td><td style="text-align:center">长期存储</td><td style="text-align:center">Vandermonde RS码</td><td style="text-align:center">TCP/IP</td></tr><tr><td style="text-align:center">Hydrastor</td><td style="text-align:center">内容寻址存储</td><td style="text-align:center">Caucy RS码（k=9，r=3）</td><td style="text-align:center">TCP/IP</td></tr><tr><td style="text-align:center">Cleversafe</td><td style="text-align:center">归档存储</td><td style="text-align:center">Caucy RS码</td><td style="text-align:center">TCP/IP</td></tr><tr><td style="text-align:center">Quantcast</td><td style="text-align:center">分布式存储</td><td style="text-align:center">RS码（k=6，r=3）</td><td style="text-align:center">TCP/IP</td></tr></tbody></table></div><h1 id="3-纠删码理论基础"><a href="#3-纠删码理论基础" class="headerlink" title="3 纠删码理论基础"></a>3 纠删码理论基础</h1><p>纠删码是一种前向纠错码，一般由四元组表示$(k,n,b,k’)$，通常$(k+r,k)$纠删码存储开销为$r/k$, 纠错能力上限为$r \le d_{min}-1$,其中$d_{min}$为纠删码最小列距。</p><p>符合条件的$d_{min}=r+1$编码称为MDS码（Minimal Distance Seperable Code），其能获得Singleton下界而具有最优存储效率$k/(k+r)$.目前业界普遍采用的纠删编码有，RS码，低密度奇偶校验码（LDPC）和阵列编码RAID码。</p><h2 id="3-1-Reed-Solomon编码"><a href="#3-1-Reed-Solomon编码" class="headerlink" title="3.1 Reed Solomon编码"></a>3.1 Reed Solomon编码</h2><p>RS码最多允许r个数据块丢失, 属于横式编码。</p><script type="math/tex; mode=display">\begin{equation}       %开始数学环境\left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置    a11 & a12 & ... & a1k\\  %第一行元素    a21 & a22 & ... & a2k\\  %第二行元素    \vdots & \vdots &&\vdots \\    ar1 & ar2 & ... & ark  \end{array}\right]                 %右括号\end{equation} × \left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置  D_1\\D_2\\\vdots\\D_r  \end{array}\right] = \left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置  P_1\\P_2\\\vdots\\P_r  \end{array}\right]</script><p>其中$[a_{ij}]$为转置冗余矩阵，有$Vandermonde$矩阵以及$Caucy$矩阵。</p><blockquote><p>RS码重构过程有一个至关重要条件，就是未出错信息对应的残余生成矩阵必须满足$GF(2^w)$上可逆条件。</p></blockquote><h3 id="Vandermonde编码"><a href="#Vandermonde编码" class="headerlink" title="Vandermonde编码"></a>Vandermonde编码</h3><blockquote><p>参考文献：<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="ReedIS, Solomon G. Polynomial code sover certain infinite fields[J]. Journal of the Society for Industrial and Applied Mathmetics, 1960, 8(2):300.">[1]</span></a></sup></p></blockquote><script type="math/tex; mode=display">\begin{equation}       %开始数学环境\left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置    1 & 0 & ... & 0\\  %第一行元素    0 & 1 & ... & 0\\  %第二行元素    \vdots & \vdots &&\vdots \\    0 & 0 & ... & 1 \\    1 & 1 & ... & 1 \\    1 & 2 & ... & k \\    \vdots & \vdots &&\vdots \\    1 & 2^{r-1} & ... & k^{r-1} \\  \end{array}\right]                 %右括号\end{equation} × \left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置  D_1\\D_2\\\vdots\\D_r  \end{array}\right] = \left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置  D_1\\D_2\\\vdots\\D_k\\P_1\\P_2\\\vdots\\P_r  \end{array}\right]</script><script type="math/tex; mode=display">where, \ P_i = \sum \limits_{j=1}^{k}j^{i-1}D_j, \ for \ \ 1\le i \le m</script><p>上述即为编码原理，如果需要解码的话，利用存活数据所对应的剩余生成矩阵与存活数据对应的列向量在Galois域$GF(2^w)$进行乘法运算得到失效数据。数据解码算法成立的必要条件是生成矩阵任意k个行向量在域$GF(2^w)$上是线性无关的。</p><p>$vandermonde$矩阵编码收到时间复杂度为$O(kr)$，解码的时间复杂度为$O(r^3)$。</p><p>然而这种编码有很大的缺陷，及分布矩阵A并不具有删除任意m行仍科比的特性，在<sup><a href="#fn_5" id="reffn_5">5</a></sup> 中进行了修正。这里不再赘述。</p><h3 id="Caucy编码"><a href="#Caucy编码" class="headerlink" title="Caucy编码"></a>Caucy编码</h3><blockquote><p>参考文献：<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Roth RM, LempelA. On MDS code via Caucy matrices[J]. IEEE Transformation Theory, 1989, 35(6):1314-1319.">[2]</span></a></sup>,<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Plank J, Luo J, Schuman C, et al. A performance evaluation and examination of open-source erasure codign library for storage[C]. Proc of the 7th USENIC Conf on File and Storage Technologies. Berkeley, CA: USENIX Association. 2009:253-266.">[3]</span></a></sup>,<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Plank J, Xu L. Optimizing Caucy Reed-Solomon codes for fault-tolerance network storage applications. Piscataway, NJ: IEEE, 2006:1 5:Plank J S , Ding Y . Note: Correction to the 1997 tutorial on Reed–Solomon coding[J]. Software Practice &amp; Experience, 2005, 35(2):189-194.">[4]</span></a></sup></p></blockquote><p>Vandermonde矩阵求逆的复杂度为$O(n^3)$，而柯西矩阵为了改善vandermonde的时间复杂度（最后可以优化到$O(n^2)$），①冗余矩阵采用了柯西矩阵，解码时间复杂度优化为$O(r^2)$；②将有限域中的每个数表示为比特位矩阵。注意柯西矩阵并不是唯一的。好的柯西矩阵一般性算法可以在<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Plank J, Xu L. Optimizing Caucy Reed-Solomon codes for fault-tolerance network storage applications. Piscataway, NJ: IEEE, 2006:1 5:Plank J S , Ding Y . Note: Correction to the 1997 tutorial on Reed–Solomon coding[J]. Software Practice &amp; Experience, 2005, 35(2):189-194.">[4]</span></a></sup>中找到。</p><script type="math/tex; mode=display">\begin{equation}       %开始数学环境\left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置    1 & 0 & ... & 0\\  %第一行元素    0 & 1 & ... & 0\\  %第二行元素    \vdots & \vdots &&\vdots \\    0 & 0 & ... & 1 \\    \frac{1}{x_1+y_1} & \frac{1}{x_1+y_2} & ... & \frac{1}{x_1+y_k} \\    \frac{1}{x_2+y_1} & \frac{1}{x_2+y_2} & ... & \frac{1}{x_2+y_k} \\    \vdots & \vdots &&\vdots \\    \frac{1}{x_r+y_1} & \frac{1}{x_r+y_2} & ... & \frac{1}{x_r+y_k} \\  \end{array}\right]                 %右括号\end{equation} × \left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置  D_1\\D_2\\\vdots\\D_r  \end{array}\right] = \left[                 %左括号  \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置  D_1\\D_2\\\vdots\\D_k\\P_1\\P_2\\\vdots\\P_r  \end{array}\right]</script><p>解码过程类似。</p><p>假设数据块$D_1$失效，为了解码出失效数据分块，所有存活数据对应的 剩余生成矩阵 与所有存活数据对应列向量进行乘法运算，得到原始数据列。</p><blockquote><p>补充 Galois域上的四则运算：</p><p>1、域</p><p>一组元素的集合，以及在集合上的四则运算，构成一个域。其中加法和乘法必须满足交换、结合和分配的规律。加法和乘法具有封闭性，即加法和乘法结果仍然是域中的元素。  </p><p>域中必须有加法单位元和乘法单位元，且每一个元素都有对应的加法逆元和乘法逆元。但不要求域中的 0 有乘法逆元。  </p><p>2、有限域</p><p>仅含有限多个元素的域。因为它由伽罗华所发现，因而又称为伽罗华域。</p><p>所以当我们说伽罗华域的时候，就是指有限域。</p><p>$GF（2^w）$表示含有$2^w$个元素的有限域。因为计算机一个字节由8位，所以最常用的是$GF(2^8)$, </p><p>3、单位元</p><p>Identity Element，也叫幺元，通常使用e来表示单位元。单位元和其他元素结合时，并不会改变那些元素。</p><p>对于二元运算，若$a<em>e=a$，e称为右单位元；若$e</em>a=a$，e称为左单位元，若$a<em>e=e</em>a=a$，则e称为单位元。</p><p>4、逆元</p><p>对于二元运算，若$a<em>b=e$，则a称为b的左逆元素，反之b称为a的右逆元素。若$a</em>b=b*a=e$，则称a为b的逆元，b为a的逆元。</p><p>5、本原多项式</p><p>域中不可约多项式是不能够进行因子分解的多项式， 本原多项式 （primitive polynomial）是一种特殊的不可约多项式。当一个域上的本原多项式确定了，这个域上的运算也就确定了。本原多项式一般通过查表可得，同一个域往往有多个本原多项式。</p><p>通过将域中的元素化为多项式形式，可以将域上的乘法运算转化为普通的多项式乘法再模本原多项式。</p><p><strong>本源多项式</strong></p><p>伽罗华域的元素可以通过该域上的本原多项式生成。通过本原多项式得到的域，其加法单位元都是 0 ，乘法单位元是1。且满足：</p><ul><li>多项式系数全部来自$GF(2)$</li><li>多项式中系数相同的项，可以基于$GF(2)$中的加法进行合并。</li></ul><p>以$GF(2^3)$为例，指数小于3的多项式共8个：$ 0 ， 1， x， x+1， x^2， x^2+1， x^2 + x， x^2+x+1$。其系数刚好就是000,001, 010, 011, 100, 101, 110, 111，是 0 到7这8个数的二进制形式。</p><p>$GF(2^3)$上有不只一个本原多项式，选一个本原多项式$x^3+x+1$，这8个多项式进行四则运算后 $mod (x^3+x+1)$的结果都是8个之中的某一个。因此这8个多项式构成一个有限域。</p><p>对于$GF(2^3)$，取素多项式为$x^3 + x+1$，那么多项式$x^2+x$的乘法逆元就是x+1。系数对应的二进制分别为110和011。此时，我们就认为对应的十进制数6和3互为逆元。</p><p><img src="/img/poly.png" alt="img"></p><blockquote><p>​                                                                        常用的本原多项式</p></blockquote><p><strong>通过本原多项式生成元素</strong></p><p>设$P(x)$是$GF（2^w）$上的某一个本原多项式，$GF（2^w）$的元素产生步骤是：<br><strong>1、给定一个初始集合，{$ { 0,1,x }$}；</strong><br><strong>2、将这个集合中的最后一个元素，即$x$，乘以$x$，如果结果的度大于等于$w$，则将结果$mod   P(x)$后加入集合；</strong><br><strong>3、直到集合有$2^w$个元素，此时最后一个元素乘以$x$再$mod   P(x)$的值等于1。</strong></p><p>例如，$GF(2^4)$含有16个元素，本原多项式为$P(x)=x^4+x+1$，除了 0 、1外，另外14个符号均由本原多项式生成。</p><p>注意到$x^{14}=x^3+1$，此时计算$x^{15}=x^{14}<em>x=(x^3+1)</em>x=x^4+x=1$，生成结束。</p><p><strong>多项式计算</strong></p><p>Galois域上四则运算是基于多项式运算的，对于$GF(2^w)$多项式系数只能取0或1. 合并多项式时，进行的是<strong>异或</strong>运算 比如 $x^4+x^4=x^4$, 多项式减法等于加法运算$x^4-x^4=x^4$。</p><p>乘法和除法：</p><ul><li><ol><li>将被乘数和乘数的二进制转换位对应的多项式表示</li></ol></li><li><ol><li>执行多项式乘法，将得到的结构针对$P(x)$取模</li></ol></li><li><ol><li>将2 得到的结果转化为对应的二进制表示</li></ol></li></ul><p>例如 </p><script type="math/tex; mode=display">3×7 = (x+1)(x^2+x+1)=x^3+x^2+x+x^2+x+1=x^3+1=9\\</script><p>或者直接利用本原多项式：</p><script type="math/tex; mode=display">3×7=x^4.x^{10}=x^{14}=9</script><p><strong>查表法</strong></p><p>如果以$gflog$和$gfilog$分别表示$GF(2^w)$中对数运算及其逆运算，由对数运算的性质：</p><script type="math/tex; mode=display">MN = gfilog(gflog(MN)) = gfilog(gflog(M)+gflog(N)) mod (2^w-1)\\M/N = gfilog(gflog(M/N)) = gfilog(gflog(M)-gflog(N)) mod (2^w-1)\\</script><p>注意：多项式 0 ，是无法用生成元生成的。g^0等于多项式1，而不是 0 。</p><p>  根据上文的$GF(2^4)$的元素表示，生成gflog表和gfilog表如下：</p><p><img src="/img/gflog.png" alt="img"></p><p>例如：</p><script type="math/tex; mode=display">3×7 = gfilog(gflog(3)+gflog(7)) = gfilog(4+10)= 9 \\3/7 = gfilog(gflog(3)-gflog(7)) = gfilog(4-10+15)= gfilog(9)=10 \\</script></blockquote><h2 id="3-2-LRC码和Pyramid码"><a href="#3-2-LRC码和Pyramid码" class="headerlink" title="3.2 LRC码和Pyramid码"></a>3.2 LRC码和Pyramid码</h2><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><hr><p><strong><em>\</em>主要文献参考列表**</strong></p><p>[1] 罗象宏，舒继武. 存储系统中的纠删码研究综述[J].计算机研究与发展, 49(1),2012:1-11.</p><p>[2] ReedIS, Solomon G. Polynomial code sover certain infinite fields[J]. Journal of the Society for Industrial and Applied Mathmetics, 1960, 8(2):300. </p><p>[3] Roth RM, LempelA. On MDS code via Caucy matrices[J]. IEEE Transformation Theory, 1989, 35(6):1314-1319.</p><p>[4] Plank J, Luo J, Schuman C, et al. A performance evaluation and examination of open-source erasure codign library for storage[C]. Proc of the 7th USENIC Conf on File and Storage Technologies. Berkeley, CA: USENIX Association. 2009:253-266.</p><p>[5] Plank J, Xu L. Optimizing Caucy Reed-Solomon codes for fault-tolerance network storage applications. Piscataway, NJ: IEEE, 2006:1.</p><p>[6] Blaum M, Farrell P, Tilborg H. Array Codes[M]. Amsterdam, Netherlands: Elsevier Science BV,1998.</p><p>[7] Blaum M, Brady J, Bruck J, et al. EVENODD: An efficient scheme for toleranting double disk failures in RAID architectures[J]. IEEE Transon Computer, 1995, 44(2):192-202.</p><p>[8] Corbett P, English B, Goel A, et al. Row - diagnoal refundant for doubled disk failure correction [C]. Proc of the 3rd USENIC Conf on File and Storage Technologies. Berkeley, CA: USENIX Association. 2004:2-15.</p><p>[9]Pamies Juarez L, Datta A, Oggier F. <a href="http://www.researchgate.net/publication/230569691_RapidRAID_Pipelined_Erasure_Codes_for_Fast_Data_Archival_in_DistributedStorage_Systems?ev=auth_pub">RapidRAID: Pipelined Erasure Codes for Fast Data Archival in Distributed Storage Systems</a>// Proceedings of the 2013 IEEE INFOCOM. Turin, Italy, 2013:1294 - 1302.</p><p>[10]Huang C , Simitci H , Xu Y , et al. Erasure coding in windows azure storage[C]// Proceedings of the 2012 USENIX conference on Annual Technical Conference. USENIX Association, 2012.</p><p>[11]Huang C , Chen M , Li J . Pyramid Codes: Flexible Schemes to Trade Space for Access Efficiency in Reliable Data Storage Systems[C]// IEEE International Symposium on Network Computing &amp; Applications. IEEE, 2007.</p><p>[12]Sathiamoorthy M , Asteris M , Papailiopoulos D , et al. XORing Elephants: Novel Erasure Codes for Big Data[J]. 2013.</p><p>[13]王意洁, 许方亮, 裴晓强. 分布式存储中的纠删码容错技术研究[J]. 计算机学报, 2017(01):236-255.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>ReedIS, Solomon G. Polynomial code sover certain infinite fields[J]. Journal of the Society for Industrial and Applied Mathmetics, 1960, 8(2):300.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Roth RM, LempelA. On MDS code via Caucy matrices[J]. IEEE Transformation Theory, 1989, 35(6):1314-1319.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Plank J, Luo J, Schuman C, et al. A performance evaluation and examination of open-source erasure codign library for storage[C]. Proc of the 7th USENIC Conf on File and Storage Technologies. Berkeley, CA: USENIX Association. 2009:253-266.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Plank J, Xu L. Optimizing Caucy Reed-Solomon codes for fault-tolerance network storage applications. Piscataway, NJ: IEEE, 2006:1<br><sup><a href="#fn_ 5" id="reffn_ 5"> 5</a></sup>:Plank J S , Ding Y . Note: Correction to the 1997 tutorial on Reed–Solomon coding[J]. Software Practice &amp; Experience, 2005, 35(2):189-194.<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>综述</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纠删码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计类问题如何解决</title>
    <link href="/2020/11/05/2020-11-04-designing-ds/"/>
    <url>/2020/11/05/2020-11-04-designing-ds/</url>
    
    <content type="html"><![CDATA[<h1 id="设计类题目如何解决"><a href="#设计类题目如何解决" class="headerlink" title="设计类题目如何解决"></a>设计类题目如何解决</h1><blockquote><p>设计类题目占比并不大，题目难度也不大。但是一旦碰到了，我们也要直到如何解决！</p><p>设计类问题会使我们对部分数据结构的内在实现由更深入的了解，类似于阅读java源码。</p></blockquote><h4 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h4><h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a><a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a></h4><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a> （※）</p><p><a href="https://leetcode-cn.com/problems/time-based-key-value-store/">981. 基于时间的键值存储 - 力扣（LeetCode）</a></p><p><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU缓存 - 力扣（LeetCode）</a></p><h4 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></h4><h4 id="385-迷你语法分析器"><a href="#385-迷你语法分析器" class="headerlink" title="385. 迷你语法分析器"></a><a href="https://leetcode-cn.com/problems/mini-parser/">385. 迷你语法分析器</a></h4><h4 id="1381-设计一个支持增量操作的栈"><a href="#1381-设计一个支持增量操作的栈" class="headerlink" title="1381. 设计一个支持增量操作的栈"></a><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/">1381. 设计一个支持增量操作的栈</a></h4><p><strong>Hard</strong> </p><p>或许你还没见过hard的设计类问题，嘿嘿</p><h4 id="1206-设计跳表"><a href="#1206-设计跳表" class="headerlink" title="1206. 设计跳表"></a><a href="https://leetcode-cn.com/problems/design-skiplist/">1206. 设计跳表</a></h4><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【参考】Ceph-Mon 详解</title>
    <link href="/2020/11/03/2020113-Ceph-Mon-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/11/03/2020113-Ceph-Mon-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Ceph-Monitor剖析"><a href="#Ceph-Monitor剖析" class="headerlink" title="Ceph Monitor剖析"></a>Ceph Monitor剖析</h1><blockquote><p>参考：<a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref/#data">http://docs.ceph.org.cn/rados/configuration/mon-config-ref/#data</a></p></blockquote><p>监视器们维护着集群运行图的“主副本”，就是说客户端连到一个监视器并获取当前运行图就能确定所有监视器、 OSD 和元数据服务器的位置。 Ceph 客户端读写 OSD 或元数据服务器前，必须先连到一个监视器，靠当前集群运行图的副本和 CRUSH 算法，客户端能计算出任何对象的位置，故此客户端有能力直接连到 OSD ，这对 Ceph 的高伸缩性、高性能来说非常重要。更多信息见<a href="http://docs.ceph.org.cn/architecture#scalability-and-high-availability">伸缩性和高可用性</a>。</p><p>监视器的主要角色是<strong>维护集群运行图的主副本，它也提供认证和日志记录服务</strong>。 Ceph 监视器们把监视器服务的所有更改写入一个单独的 Paxos 例程，然后 Paxos 以键/值方式存储所有变更以实现高度一致性。同步期间， Ceph 监视器能查询集群运行图的近期版本，它们通过操作键/值存储快照和迭代器（用 leveldb ）来进行存储级同步。</p><p><img src="\img\ceph-mon.jpg" alt="img"></p><h3 id="集群运行图"><a href="#集群运行图" class="headerlink" title="集群运行图"></a>集群运行图</h3><p>集群运行图是多个图的组合，包括监视器图、 OSD 图、归置组图和元数据服务器图。集群运行图追踪几个重要事件：哪些进程在集群里（ <code>in</code> ）；哪些进程在集群里（ <code>in</code> ）是 <code>up</code> 且在运行、或 <code>down</code> ；归置组状态是 <code>active</code> 或 <code>inactive</code> 、 <code>clean</code> 或其他状态；和其他反映当前集群状态的信息，像总存储容量、和使用量。</p><p>当集群状态有明显变更时，如一 OSD 挂了、一归置组降级了等等，集群运行图会被更新以反映集群当前状态。另外，监视器也维护着集群的主要状态历史。监视器图、 OSD 图、归置组图和元数据服务器图各自维护着它们的运行图版本。我们把各图的版本称为一个 epoch 。</p><p>运营集群时，跟踪这些状态是系统管理任务的重要部分。详情见<a href="http://docs.ceph.org.cn/rados/operations/monitoring">监控集群</a>和<a href="http://docs.ceph.org.cn/rados/operations/monitoring-osd-pg">监控 OSD 和归置组</a>。</p><h3 id="监视器法定人数"><a href="#监视器法定人数" class="headerlink" title="监视器法定人数"></a>监视器法定人数</h3><p>本文入门部分提供了一个简陋的 <a href="http://docs.ceph.org.cn/start/quick-start/#add-a-configuration-file">Ceph 配置文件</a>，它提供了一个监视器用于测试。只用一个监视器集群可以良好地运行，然而<strong>单监视器是一个单故障点</strong>，生产集群要实现高可用性的话得配置多个监视器，这样单个监视器的失效才<strong>不会</strong>影响整个集群。</p><p>集群用多个监视器实现高可用性时，多个监视器用 <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science">Paxos</a>) 算法对主集群运行图达成一致，这里的一致要求大多数监视器都在运行且够成法定人数（如 1 个、 3 之 2 在运行、 5 之 3 、 6 之 4 等等）。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>你把监视器加进 Ceph 配置文件时，得注意一些架构问题， Ceph 发现集群内的其他监视器时对其有着<strong>严格的一致性要求</strong>。尽管如此， Ceph 客户端和其他 Ceph 守护进程用配置文件发现监视器，监视器却用监视器图（ monmap ）相互发现而非配置文件。</p><p>一个监视器发现集群内的其他监视器时总是参考 monmap 的本地副本，用 monmap 而非 Ceph 配置文件避免了可能损坏集群的错误（如 <code>ceph.conf</code> 中指定地址或端口的拼写错误）。正因为监视器把 monmap 用于发现、并共享于客户端和其他 Ceph 守护进程间， <strong>monmap可严格地保证监视器的一致性是可靠的</strong>。</p><p>严格的一致性也适用于 monmap 的更新，因为关于监视器的任何更新、关于 monmap 的变更都是通过称为 <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science">Paxos</a>) 的分布式一致性算法传递的。监视器们必须就 monmap 的每次更新达成一致，以确保法定人数里的每个监视器 monmap 版本相同，如增加、删除一个监视器。 monmap 的更新是增量的，所以监视器们都有最新的一致版本，以及一系列之前版本。历史版本的存在允许一个落后的监视器跟上集群当前状态。</p><p>如果监视器通过配置文件而非 monmap 相互发现，这会引进其他风险，因为 Ceph 配置文件不是自动更新并分发的，监视器有可能不小心用了较老的配置文件，以致于不认识某监视器、放弃法定人数、或者产生一种 <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science">Paxos</a>) 不能确定当前系统状态的情形。</p><h3 id="初始化监视器"><a href="#初始化监视器" class="headerlink" title="初始化监视器"></a>初始化监视器</h3><p>在大多数配置和部署案例中，部署 Ceph 的工具可以帮你生成一个监视器图来初始化监视器（如 <code>ceph-deploy</code> 等），一个监视器需要 4 个选项：</p><ul><li><strong>文件系统标识符：</strong> <code>fsid</code> 是对象存储的唯一标识符。因为你可以在一套硬件上运行多个集群，所以在初始化监视器时必须指定对象存储的唯一标识符。部署工具通常可替你完成（如 <code>ceph-deploy</code> 会调用类似 <code>uuidgen</code> 的程序），但是你也可以手动指定 <code>fsid</code> 。</li><li><strong>监视器标识符：</strong> 监视器标识符是分配给集群内各监视器的唯一 ID ，它是一个字母数字组合，为方便起见，标识符通常以字母顺序结尾（如 <code>a</code> 、 <code>b</code> 等等），可以设置于 Ceph 配置文件（如 <code>[mon.a]</code> 、 <code>[mon.b]</code> 等等）、部署工具、或 <code>ceph</code> 命令行工具。</li><li><strong>密钥：</strong> 监视器必须有密钥。像 <code>ceph-deploy</code> 这样的部署工具通常会自动生成，也可以手动完成。见<a href="http://docs.ceph.org.cn/rados/operations/authentication#monitor-keyrings">监视器密钥环</a>。</li></ul><p>关于初始化的具体信息见<a href="http://docs.ceph.org.cn/dev/mon-bootstrap">初始化监视器</a>。</p><h2 id="监视器的配置"><a href="#监视器的配置" class="headerlink" title="监视器的配置"></a>监视器的配置</h2><p>要把配置应用到整个集群，把它们放到 <code>[global]</code> 下；要用于所有监视器，置于 <code>[mon]</code> 下；要用于某监视器，指定监视器例程，如 <code>[mon.a]</code> ）。按惯例，监视器例程用字母命名。</p><pre><code class="hljs json">[global][mon][mon.a][mon.b][mon.c]</code></pre><h3 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h3><p>Ceph 监视器的最简配置必须包括一主机名及其监视器地址，这些配置可置于 <code>[mon]</code> 下或某个监视器下。</p><pre><code class="hljs angelscript">[mon]        mon host = hostname1,hostname2,hostname3        mon addr = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span>:<span class="hljs-number">6789</span>,<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.11</span>:<span class="hljs-number">6789</span>,<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.12</span>:<span class="hljs-number">6789</span>[mon.a]        host = hostname1        mon addr = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span>:<span class="hljs-number">6789</span></code></pre><p>详情见<a href="http://docs.ceph.org.cn/rados/configuration/network-config-ref">网络配置参考</a>。</p><p>一旦部署了 Ceph 集群，监视器 IP 地址<strong>不应该</strong>更改。然而，如果你决意要改，必须严格按照<a href="http://docs.ceph.org.cn/rados/operations/add-or-rm-mons#changing-a-monitor-s-ip-address">更改监视器 IP 地址</a>来改。</p><h3 id="集群-ID"><a href="#集群-ID" class="headerlink" title="集群 ID"></a>集群 ID</h3><p>每个 Ceph 存储集群都有一个唯一标识符（ <code>fsid</code> ）。如果指定了，它应该出现在配置文件的 <code>[global]</code> 段下。部署工具通常会生成 <code>fsid</code> 并存于监视器图，所以不一定会写入配置文件， <code>fsid</code> 使得在一套硬件上运行多个集群成为可能。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">fsid</span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>集群 ID ，一集群一个。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>UUID</td></tr><tr><td style="text-align:left">是否必需:</td><td>Yes.</td></tr><tr><td style="text-align:left">默认值:</td><td>无。若未指定，部署工具会生成。</td></tr></tbody></table></div><h3 id="初始成员"><a href="#初始成员" class="headerlink" title="初始成员"></a>初始成员</h3><p>我们建议在生产环境下最少部署 3 个监视器，以确保高可用性。运行多个监视器时，你可以指定为形成法定人数成员所需的初始监视器，这能减小集群上线时间。</p><pre><code class="hljs properties"><span class="hljs-attr">[mon]</span>        <span class="hljs-attr">mon</span> <span class="hljs-string">initial members = a,b,c</span><span class="hljs-attr">mon</span> <span class="hljs-string">initial members</span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>集群启动时初始监视器的 ID ，若指定， Ceph 需要奇数个监视器来确定最初法定人数（如 3 ）。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>String</td></tr><tr><td style="text-align:left">默认值:</td><td>None</td></tr></tbody></table></div><div class="note note-priamry">            <p>集群内的<em>大多数</em>监视器必须能互通以建立法定人数，你可以用此选项减小初始监视器数量来形成。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构</tag>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 从入门到放弃</title>
    <link href="/2020/10/26/Shell/"/>
    <url>/2020/10/26/Shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-从入门到放弃"><a href="#Shell-从入门到放弃" class="headerlink" title="Shell 从入门到放弃"></a>Shell 从入门到放弃</h1><blockquote><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p></blockquote><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li><li>……</li></ul><p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <strong>#!/bin/sh</strong>，它同样也可以改为 <strong>#!/bin/bash</strong>。</p><p><strong>#!</strong> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h3 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h3><p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p><p>输入一些代码，第一行一般是这样：</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>echo &quot;Hello World !&quot;</code></pre><p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>echo 命令用于向窗口输出文本。</p><h3 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a>运行 Shell 脚本有两种方法：</h3><p><strong>1、作为可执行程序</strong></p><p>将上面的代码保存为 test.sh，并 cd 到相应目录：</p><pre><code class="hljs cmake">chmod +x ./<span class="hljs-keyword">test</span>.sh  <span class="hljs-comment">#使脚本具有执行权限</span>./<span class="hljs-keyword">test</span>.sh  <span class="hljs-comment">#执行脚本</span></code></pre><p>注意，一定要写成 <strong>./test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p><p><strong>2、作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>sh test.sh<span class="hljs-regexp">/bin/</span>php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><p>注意，<strong>变量名和等号之间不能有空格</strong>，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code class="hljs bash">your_name=<span class="hljs-string">&quot;qinjx&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$your_name</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;your_name&#125;</span></code></pre><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>下面的例子尝试更改只读变量，结果报错：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>myUrl=&quot;https://www.google.com&quot;readonly myUrlmyUrl=&quot;https://www.runoob.com&quot;</code></pre><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令可以删除变量。语法：</p><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> variable_name</code></pre><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><p><strong>实例</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span>myUrl=<span class="hljs-string">&quot;https://www.runoob.com&quot;</span><span class="hljs-built_in">unset</span> myUrl<span class="hljs-built_in">echo</span> <span class="hljs-variable">$myUrl</span></code></pre><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h1 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h1><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><pre><code class="hljs ini"><span class="hljs-attr">str</span>=<span class="hljs-string">&#x27;this is a string&#x27;</span></code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><pre><code class="hljs bash">your_name=<span class="hljs-string">&#x27;runoob&#x27;</span>str=<span class="hljs-string">&quot;Hello, I know you are \&quot;<span class="hljs-variable">$your_name</span>\&quot;! \n&quot;</span><span class="hljs-built_in">echo</span> -e <span class="hljs-variable">$str</span></code></pre><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><pre><code class="hljs bash">your_name=<span class="hljs-string">&quot;runoob&quot;</span><span class="hljs-comment"># 使用双引号拼接</span>greeting=<span class="hljs-string">&quot;hello, &quot;</span><span class="hljs-variable">$your_name</span><span class="hljs-string">&quot; !&quot;</span>greeting_1=<span class="hljs-string">&quot;hello, <span class="hljs-variable">$&#123;your_name&#125;</span> !&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$greeting</span>  <span class="hljs-variable">$greeting_1</span></code></pre><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><pre><code class="hljs bash">string=<span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#string&#125;</span> <span class="hljs-comment">#输出 4</span></code></pre><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><p>以下实例从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符：</p><pre><code class="hljs bash">string=<span class="hljs-string">&quot;runoob is a great site&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;string:1:4&#125;</span> <span class="hljs-comment"># 输出 unoo</span></code></pre><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p><pre><code class="hljs bash">string=<span class="hljs-string">&quot;runoob is a great site&quot;</span><span class="hljs-built_in">echo</span> `expr index <span class="hljs-string">&quot;<span class="hljs-variable">$string</span>&quot;</span> io`  <span class="hljs-comment"># 输出 4</span></code></pre><p><strong>注意：</strong> 以上脚本中 <strong>`</strong> 是反引号，而不是单引号 <strong>‘</strong>，不要看错了哦。</p><h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</p><pre><code class="hljs angelscript">数组名=(值<span class="hljs-number">1</span> 值<span class="hljs-number">2</span> ... 值n)</code></pre><p>例如：</p><pre><code class="hljs apache"><span class="hljs-attribute">array_name</span>=(value<span class="hljs-number">0</span> value<span class="hljs-number">1</span> value<span class="hljs-number">2</span> value<span class="hljs-number">3</span>)</code></pre><p>或者</p><pre><code class="hljs ceylon">array<span class="hljs-number">_n</span>ame=(<span class="hljs-keyword">value</span><span class="hljs-number">0</span><span class="hljs-keyword">value</span><span class="hljs-number">1</span><span class="hljs-keyword">value</span><span class="hljs-number">2</span><span class="hljs-keyword">value</span><span class="hljs-number">3</span>)</code></pre><p>还可以单独定义数组的各个分量：</p><pre><code class="hljs angelscript"><span class="hljs-built_in">array</span>_name[<span class="hljs-number">0</span>]=value0<span class="hljs-built_in">array</span>_name[<span class="hljs-number">1</span>]=value1<span class="hljs-built_in">array</span>_name[n]=valuen</code></pre><p>可以不使用连续的下标，而且下标的范围没有限制。</p><h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p>读取数组元素值的一般格式是：</p><pre><code class="hljs awk"><span class="hljs-variable">$&#123;数组名[下标]&#125;</span></code></pre><p>例如：</p><pre><code class="hljs ini"><span class="hljs-attr">valuen</span>=<span class="hljs-variable">$&#123;array_name[n]&#125;</span></code></pre><p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：</p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array_name[@]&#125;</span></code></pre><h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><pre><code class="hljs bash"><span class="hljs-comment"># 取得数组元素的个数</span>length=<span class="hljs-variable">$&#123;#array_name[@]&#125;</span><span class="hljs-comment"># 或者</span>length=<span class="hljs-variable">$&#123;#array_name[*]&#125;</span><span class="hljs-comment"># 取得数组单个元素的长度</span>lengthn=<span class="hljs-variable">$&#123;#array_name[n]&#125;</span></code></pre><p>单行注释 #</p><p>多行注释</p><pre><code class="hljs bash">:&lt;&lt;EOF sssEOF</code></pre><p>EOF也可以换成别的符号</p><h1 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h1><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>以下实例我们向脚本传递三个参数，并分别输出，其中 <strong>$0</strong> 为执行的文件名（包含文件路径）：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># author:菜鸟教程</span><span class="hljs-comment"># url:www.runoob.com</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Shell 传递参数实例！&quot;</span>;<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;执行的文件名：<span class="hljs-variable">$0</span>&quot;</span>;<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为：<span class="hljs-variable">$1</span>&quot;</span>;<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数为：<span class="hljs-variable">$2</span>&quot;</span>;<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数为：<span class="hljs-variable">$3</span>&quot;</span>;</code></pre><p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p><pre><code class="hljs sh">$ chmod +x test.sh $ ./test.sh 1 2 3Shell 传递参数实例！执行的文件名：./test.sh第一个参数为：1第二个参数为：2第三个参数为：3</code></pre><p>另外，还有几个特殊字符用来处理参数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数处理</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">$#</td><td style="text-align:left">传递到脚本的参数个数</td></tr><tr><td style="text-align:left">$*</td><td style="text-align:left">以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td style="text-align:left">$$</td><td style="text-align:left">脚本运行的当前进程ID号</td></tr><tr><td style="text-align:left">$!</td><td style="text-align:left">后台运行的最后一个进程的ID号</td></tr><tr><td style="text-align:left">$@</td><td style="text-align:left">与\$*相同，但是使用时加引号，并在引号中返回每个参数。 如”\$@”用「”」括起来的情况、以”\$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td style="text-align:left">$-</td><td style="text-align:left">显示Shell使用的当前选项，与<a href="https://www.runoob.com/linux/linux-comm-set.html">set命令</a>功能相同。</td></tr><tr><td style="text-align:left">$?</td><td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table></div><h1 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h1><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p><ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><p>例如，两个数相加(<strong>注意使用的是反引号 \</strong>`*<em> 而不是单引号 *<em>‘**</em></em>)：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p><em>#!/bin/bash</em></p><p>val=<strong>`**</strong>expr<strong> 2 + 2</strong>`<strong></strong>echo** “两数之和为 : $val”</p><p>两点注意：</p><ul><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被 <strong><code> </code></strong> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left"><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left"><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left"><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left"><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left"><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td style="text-align:left">=</td><td style="text-align:left">赋值</td><td style="text-align:left">a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">相等。用于比较两个数字，相同则返回 true。</td><td style="text-align:left">[ $a == $b ] 返回 false。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不相等。用于比较两个数字，不相同则返回 true。</td><td style="text-align:left">[ $a != $b ] 返回 true。</td></tr></tbody></table></div><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 <strong>[ $a == $b ]</strong>。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">-eq</td><td style="text-align:left">检测两个数是否相等，相等返回 true。</td><td style="text-align:left">[ $a -eq $b ] 返回 false。</td></tr><tr><td style="text-align:left">-ne</td><td style="text-align:left">检测两个数是否不相等，不相等返回 true。</td><td style="text-align:left">[ $a -ne $b ] 返回 true。</td></tr><tr><td style="text-align:left">-gt</td><td style="text-align:left">检测左边的数是否大于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -gt $b ] 返回 false。</td></tr><tr><td style="text-align:left">-lt</td><td style="text-align:left">检测左边的数是否小于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -lt $b ] 返回 true。</td></tr><tr><td style="text-align:left">-ge</td><td style="text-align:left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -ge $b ] 返回 false。</td></tr><tr><td style="text-align:left">-le</td><td style="text-align:left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -le $b ] 返回 true。</td></tr></tbody></table></div><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">!</td><td style="text-align:left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td style="text-align:left">[ ! false ] 返回 true。</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">或运算，有一个表达式为 true 则返回 true。</td><td style="text-align:left">[ \$a -lt  20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td style="text-align:left">-a</td><td style="text-align:left">与运算，两个表达式都为 true 才返回 true。</td><td style="text-align:left">[ \$a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table></div><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">逻辑的 AND</td><td style="text-align:left">[[\$a -lt 100 \&amp;\&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td><td style="text-align:left"></td><td>逻辑的 OR</td><td>[[ \$a -lt 100 \</td><td>\</td><td>$b -gt 100 ]] 返回 true</td></tr></tbody></table></div><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">检测两个字符串是否相等，相等返回 true。</td><td style="text-align:left">[ $a = $b ] 返回 false。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">检测两个字符串是否相等，不相等返回 true。</td><td style="text-align:left">[ $a != $b ] 返回 true。</td></tr><tr><td style="text-align:left">-z</td><td style="text-align:left">检测字符串长度是否为0，为0返回 true。</td><td style="text-align:left">[ -z $a ] 返回 false。</td></tr><tr><td style="text-align:left">-n</td><td style="text-align:left">检测字符串长度是否不为 0，不为 0 返回 true。</td><td style="text-align:left">[ -n “$a” ] 返回 true。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">检测字符串是否为空，不为空返回 true。</td><td style="text-align:left">[ $a ] 返回 true。</td></tr></tbody></table></div><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">-b file</td><td style="text-align:left">检测文件是否是块设备文件，如果是，则返回 true。</td><td style="text-align:left">[ -b $file ] 返回 false。</td></tr><tr><td style="text-align:left">-c file</td><td style="text-align:left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td style="text-align:left">[ -c $file ] 返回 false。</td></tr><tr><td style="text-align:left">-d file</td><td style="text-align:left">检测文件是否是目录，如果是，则返回 true。</td><td style="text-align:left">[ -d $file ] 返回 false。</td></tr><tr><td style="text-align:left">-f file</td><td style="text-align:left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td style="text-align:left">[ -f $file ] 返回 true。</td></tr><tr><td style="text-align:left">-g file</td><td style="text-align:left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td style="text-align:left">[ -g $file ] 返回 false。</td></tr><tr><td style="text-align:left">-k file</td><td style="text-align:left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td style="text-align:left">[ -k $file ] 返回 false。</td></tr><tr><td style="text-align:left">-p file</td><td style="text-align:left">检测文件是否是有名管道，如果是，则返回 true。</td><td style="text-align:left">[ -p $file ] 返回 false。</td></tr><tr><td style="text-align:left">-u file</td><td style="text-align:left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td style="text-align:left">[ -u $file ] 返回 false。</td></tr><tr><td style="text-align:left">-r file</td><td style="text-align:left">检测文件是否可读，如果是，则返回 true。</td><td style="text-align:left">[ -r $file ] 返回 true。</td></tr><tr><td style="text-align:left">-w file</td><td style="text-align:left">检测文件是否可写，如果是，则返回 true。</td><td style="text-align:left">[ -w $file ] 返回 true。</td></tr><tr><td style="text-align:left">-x file</td><td style="text-align:left">检测文件是否可执行，如果是，则返回 true。</td><td style="text-align:left">[ -x $file ] 返回 true。</td></tr><tr><td style="text-align:left">-s file</td><td style="text-align:left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td style="text-align:left">[ -s $file ] 返回 true。</td></tr><tr><td style="text-align:left">-e file</td><td style="text-align:left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td style="text-align:left">[ -e $file ] 返回 true。</td></tr></tbody></table></div><p>其他检查符：</p><ul><li><strong>-S</strong>: 判断某文件是否 socket。</li><li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li></ul><h1 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">&quot;q&quot;</span>])) &#123;    search(q);&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 不做任何事情</span>&#125;</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><hr><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if 语句语法格式：</p><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> conditionthen    <span class="hljs-keyword">command</span>1     <span class="hljs-keyword">command</span>2    <span class="hljs-string">...</span>    <span class="hljs-keyword">command</span>N fi</code></pre><p>写成一行（适用于终端命令提示符）：</p><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ $(ps -ef | grep -c <span class="hljs-string">&quot;ssh&quot;</span>) -gt 1 ]; <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;true&quot;</span>; <span class="hljs-keyword">fi</span></code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的。</p><h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><p>if else 语法格式：</p><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> conditionthen    <span class="hljs-keyword">command</span>1     <span class="hljs-keyword">command</span>2    <span class="hljs-string">...</span>    <span class="hljs-keyword">command</span>Nelse    <span class="hljs-keyword">command</span>fi</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><p>if else-if else 语法格式：</p><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition1<span class="hljs-keyword">then</span>    command1<span class="hljs-keyword">elif</span> condition2 <span class="hljs-keyword">then</span>     command2<span class="hljs-keyword">else</span>    commandN<span class="hljs-keyword">fi</span></code></pre><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<span class="hljs-keyword">do</span>    <span class="hljs-built_in">command</span><span class="hljs-keyword">done</span></code></pre><p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>int=1<span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))<span class="hljs-keyword">do</span>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span>    <span class="hljs-built_in">let</span> <span class="hljs-string">&quot;int++&quot;</span><span class="hljs-keyword">done</span></code></pre><p>运行脚本，输出：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span></code></pre><p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：<a href="https://www.runoob.com/linux/linux-comm-let.html">Bash let 命令</a></p><p>。</p><p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。</p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;按下 &lt;CTRL-D&gt; 退出&#x27;</span><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&#x27;输入你最喜欢的网站名: &#x27;</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> FILM<span class="hljs-keyword">do</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;是的！<span class="hljs-variable">$FILM</span> 是一个好网站&quot;</span><span class="hljs-keyword">done</span></code></pre><h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p><p>until 语法格式:</p><pre><code class="hljs livecodeserver"><span class="hljs-keyword">until</span> condition<span class="hljs-built_in">do</span>    <span class="hljs-keyword">command</span>done</code></pre><p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p><p>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：</p><h1 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h1><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p><p>shell中函数的定义格式如下：</p><pre><code class="hljs ada">[ <span class="hljs-keyword">function</span> <span class="hljs-title">]</span> funname [()]&#123;    action;    [<span class="hljs-keyword">return</span> <span class="hljs-type">int</span>;]&#125;</code></pre><p>说明：</p><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><p>下面的例子定义了一个函数并进行调用：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># author:菜鸟教程</span><span class="hljs-comment"># url:www.runoob.com</span><span class="hljs-function"><span class="hljs-title">demoFun</span></span>()&#123;    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这是我的第一个 shell 函数!&quot;</span>&#125;<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----函数开始执行-----&quot;</span>demoFun<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----函数执行完毕-----&quot;</span></code></pre><h1 id="Shell-输入-输出重定向"><a href="#Shell-输入-输出重定向" class="headerlink" title="Shell 输入/输出重定向"></a>Shell 输入/输出重定向</h1><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><p>重定向命令列表如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">command &gt; file</td><td style="text-align:left">将输出重定向到 file。</td></tr><tr><td style="text-align:left">command &lt; file</td><td style="text-align:left">将输入重定向到 file。</td></tr><tr><td style="text-align:left">command &gt;&gt; file</td><td style="text-align:left">将输出以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt; file</td><td style="text-align:left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&gt; file</td><td style="text-align:left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&amp; m</td><td style="text-align:left">将输出文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">n &lt;&amp; m</td><td style="text-align:left">将输入文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">&lt;&lt; tag</td><td style="text-align:left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table></div><blockquote><p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p></blockquote><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p><pre><code class="hljs apache"><span class="hljs-attribute">command1</span> &lt; file<span class="hljs-number">1</span></code></pre><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p><p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</p><pre><code class="hljs routeros">$ wc -l users       2 users</code></pre><p>也可以将输入重定向到 users 文件：</p><pre><code class="hljs routeros">$  wc -l &lt; users       2</code></pre><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p><pre><code class="hljs stata">command1 &lt; <span class="hljs-keyword">infile</span> &gt; <span class="hljs-keyword">outfile</span></code></pre><p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p><h3 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><pre><code class="hljs cmake">$ <span class="hljs-keyword">command</span> <span class="hljs-number">2</span> &gt; <span class="hljs-keyword">file</span></code></pre><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><pre><code class="hljs cmake">$ <span class="hljs-keyword">command</span> <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-keyword">file</span></code></pre><p><strong>2</strong> 表示标准错误文件(stderr)。</p><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><pre><code class="hljs angelscript">$ command &gt; file <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>或者$ command &gt;&gt; file <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span></code></pre><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><pre><code class="hljs livecodeserver">$ <span class="hljs-keyword">command</span> &lt; <span class="hljs-title">file1</span> &gt;<span class="hljs-title">file2</span></code></pre><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
      <category>CLI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake学习</title>
    <link href="/2020/10/24/CMake%20%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <url>/2020/10/24/CMake%20%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake-蹦迪指南"><a href="#CMake-蹦迪指南" class="headerlink" title="CMake 蹦迪指南"></a>CMake 蹦迪指南</h1><h6 id="CMake方式编译生成库文件"><a href="#CMake方式编译生成库文件" class="headerlink" title="CMake方式编译生成库文件"></a>CMake方式编译生成库文件</h6><p>以简单的例子来来看看CMake的语法,创建一个  test项目，项目结构如下<br> ├── test目录<br> │   ├── CMakeLists.txt<br> │   ├── include目录<br> │   │   ├── myprint.h<br> │   ├── src 目录<br> │   │   ├── myprint.cpp<br> │   ├── lib目录<br> │   ├── biuld目录</p><p>怎样利用CMake来将项目编译成动态库提供给其他项目使用。首先我们要创建CMakeLists.txt文件，简单的来说CMake就是我们把编译信息录入，cmake命令根据CMakeLists.txt生成编译需要的Makefile文件。看看CMakeLists.txt具体的编写/</p><hr><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><blockquote><p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html">http://www.ruanyifeng.com/blog/2015/02/make.html</a></p></blockquote><p>建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><blockquote><pre><code class="hljs bash">&lt;target&gt; : &lt;prerequisites&gt; [tab]  &lt;commands&gt;</code></pre></blockquote><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h3 id="2-2-目标（target）"><a href="#2-2-目标（target）" class="headerlink" title="2.2 目标（target）"></a>2.2 目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><blockquote><pre><code class="hljs bash">clean:      rm *.o</code></pre></blockquote><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><blockquote><pre><code class="hljs bash">$ make  clean</code></pre></blockquote><p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p><p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><blockquote><pre><code class="hljs bash">.PHONY: cleanclean:        rm *.o temp</code></pre></blockquote><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">手册</a>。</p><p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p><blockquote><pre><code class="hljs bash">$ make</code></pre></blockquote><p>上面代码执行Makefile文件的第一个目标。</p><h3 id="2-3-前置条件（prerequisites）"><a href="#2-3-前置条件（prerequisites）" class="headerlink" title="2.3 前置条件（prerequisites）"></a>2.3 前置条件（prerequisites）</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><blockquote><pre><code class="hljs bash">result.txt: source.txt    cp source.txt result.txt</code></pre></blockquote><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p><blockquote><pre><code class="hljs bash">source.txt:    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is the source&quot;</span> &gt; source.txt</code></pre></blockquote><p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p><blockquote><pre><code class="hljs bash">$ make result.txt$ make result.txt</code></pre></blockquote><p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><blockquote><pre><code class="hljs bash"><span class="hljs-built_in">source</span>: file1 file2 file3</code></pre></blockquote><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><blockquote><pre><code class="hljs bash">$ make <span class="hljs-built_in">source</span></code></pre></blockquote><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><blockquote><pre><code class="hljs bash">$ make file1$ make file2$ make file3</code></pre></blockquote><h3 id="命令（commands）"><a href="#命令（commands）" class="headerlink" title="命令（commands）"></a>命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p><blockquote><pre><code class="hljs bash">.RECIPEPREFIX = &gt;all:&gt; <span class="hljs-built_in">echo</span> Hello, world</code></pre></blockquote><p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p><p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p><blockquote><pre><code class="hljs bash">var-lost:    <span class="hljs-built_in">export</span> foo=bar    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;foo=[$<span class="hljs-variable">$foo</span>]&quot;</span></code></pre></blockquote><p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p><blockquote><pre><code class="hljs bash">var-kept:    <span class="hljs-built_in">export</span> foo=bar; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;foo=[$<span class="hljs-variable">$foo</span>]&quot;</span></code></pre></blockquote><p>另一个解决办法是在换行符前加反斜杠转义。</p><blockquote><pre><code class="hljs bash">var-kept:    <span class="hljs-built_in">export</span> foo=bar; \    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;foo=[$<span class="hljs-variable">$foo</span>]&quot;</span></code></pre></blockquote><p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p><blockquote><pre><code class="hljs bash">.ONESHELL:var-kept:    <span class="hljs-built_in">export</span> foo=bar;     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;foo=[$<span class="hljs-variable">$foo</span>]&quot;</span></code></pre></blockquote><p>makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br> makefile带来的好处就是—“自动化编译”,一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make,Visual C++的nmake,Linux下GNU的make.可见，makefile都成为了一种在工程方面的编译方法。<br> <strong>make</strong><br> 根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。<br> <strong>make clean</strong><br> 清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。<br> <strong>make install</strong><br> 将编译成功的可执行文件安装到系统目录中，一般为/usr/local/bin目录。<br> <strong>make dist</strong><br> 产生发布软件包文件（即distribution package）。这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。<br> 它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件。PACKAGE和VERSION,是我们在configure.in中定义的AM_INIT_AUTOMAKE（PACKAGE, VERSION）。<br> <strong>make distcheck</strong><br> 生成发布软件包并对其进行测试检查，以确定发布包的正确性。这个操作将自动把压缩包文件解开，然后执行configure命令，并且执行make,来确认编译不出现错误，最后提示你软件包已经准备好，可以发布了。<br> <strong>make distclean</strong><br> 类似make clean,但同时也将configure生成的文件全部删除掉，包括Makefile文件。</p>]]></content>
    
    
    <categories>
      
      <category>cmake</category>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「高级部署」Ceph手动配置集群部署&amp;编译源码</title>
    <link href="/2020/10/21/Ceph%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/10/21/Ceph%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>TODO: 最近一次更新 : 2020/11/26 21:11</p>          </div><h1 id="当前最流行的分布式存储系统——Ceph尝鲜"><a href="#当前最流行的分布式存储系统——Ceph尝鲜" class="headerlink" title="当前最流行的分布式存储系统——Ceph尝鲜"></a>当前最流行的分布式存储系统——Ceph尝鲜</h1><blockquote><p>首先介绍一些使用的网站备查，建议保存到chrome收藏夹！</p><p><a href="http://ceph.org.cn/">Ceph中国社区</a>：包括中文文档（非最新），以及新闻等。</p><p><a href="https://docs.ceph.com/en/latest/">最新的英文文档</a>：最新的英文文档，包括nautilus和Octopus版本，你一定不想错过！</p><p><a href="https://docs.ceph.com/en/latest/api/">API文档</a></p><p><a href="http://docs.ceph.org.cn/start/quick-start-preflight/#ntp">快速安装入门</a>：适合新手，包括基础的配置等。</p><p><a href="https://github.com/ceph/ceph">Ceph源码</a>：喜欢git的筒子可以看这儿，包括编译步骤。</p><p><a href="https://tracker.ceph.com/">官方的问题tracker</a>：</p><p><a href="https://tracker.ceph.com/projects/ceph/roadmap">官方的roadmap</a>（版本问题）</p></blockquote><p>你在寻找。。。</p><p>源码编译可以直接去 <a href="#here">这儿</a></p><p><img src="\img\ceph-logo.png" alt="Logo"></p><h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><ul><li>x.0.z - 开发版（给早期测试者和勇士们）</li><li>x.1.z - 候选版（用于测试集群、高手们）</li><li>x.2.z - 稳定、修正版（给用户们）</li></ul><div class="table-container"><table><thead><tr><th>版本名称</th><th>发行时间/EOL</th><th>建议的部署工具</th></tr></thead><tbody><tr><td>Argonaut 　0.48版本(LTS)</td><td>2012年6月3日</td><td></td></tr><tr><td>Bobtail 　　0.56版本(LTS)</td><td>2013年1月1日</td><td></td></tr><tr><td>Cuttlefish  0.61版本</td><td>2013年5月7日</td><td></td></tr><tr><td>Dumpling  0.67版本(LTS)</td><td>2013年8月14日</td><td></td></tr><tr><td>Emperor 　 0.72版本</td><td>2013年11月9日</td><td></td></tr><tr><td>Firefly 　　 0.80版本(LTS)</td><td>2014年5月</td><td></td></tr><tr><td>Giant 　 Stable</td><td>October 2014 - April 2015</td><td></td></tr><tr><td>Hammer   LTS</td><td>April 2015 - November 2016</td><td></td></tr><tr><td>Infernalis   Stable</td><td>November 2015 - June 2016</td><td></td></tr><tr><td>Jewel 10</td><td>2016年4月</td><td>ceph-deploy</td></tr><tr><td>Kraken 11</td><td>2017年10月</td><td>ceph-deploy</td></tr><tr><td>Luminous 12</td><td>2017年10月</td><td>ceph-deploy</td></tr><tr><td>mimic 13</td><td>2018年5月</td><td>ceph-deploy</td></tr><tr><td>Nautilus 14.2.12</td><td>2019年3月 /2021年6月</td><td><a href="https://rook.io/">Rook</a> (Kubernetes-preferred,fully integrated with new orchestration API,  docker-dependent)</td></tr><tr><td>Octopus 15.2.5</td><td>2020年3月 /2022年6月</td><td><a href="https://docs.ceph.com/en/latest/cephadm/#cephadm">Cephadm</a>（fully integrated with new orchestration API,  docker-dependent）</td></tr><tr><td>Pacific 16</td><td></td></tr></tbody></table></div><p>获取最新版本信息，详见</p><p><a href="https://docs.ceph.com/en/latest/releases/general/">https://docs.ceph.com/en/latest/releases/general/</a></p><p>如果你遇到问题，No problem,这儿有一个庞大的社区来协助你：</p><ul><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/community/">Ceph 社区</a></li><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/log-and-debug/">日志和调试</a></li><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/troubleshooting-mon/">Troubleshooting Monitors</a></li><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/troubleshooting-osd/">Troubleshooting OSDs</a></li><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/troubleshooting-pg/">Troubleshooting PGs</a></li><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/memory-profiling/">Memory Profiling</a></li><li><a href="https://docs.ceph.com/en/latest/rados/troubleshooting/cpu-profiling/">CPU Profiling</a></li></ul><hr><p>硬件支持问题</p><h3 id="Ceph硬件要求"><a href="#Ceph硬件要求" class="headerlink" title="Ceph硬件要求"></a>Ceph硬件要求</h3><p>Ceph 为普通硬件设计，这可使构建、维护 PB 级数据集群的费用相对低廉。规划集群硬件时，需要均衡几方面的因素，包括区域失效和潜在的性能问题。硬件规划要包含把使用 Ceph 集群的 Ceph 守护进程和其他进程恰当分布。通常，我们推荐在一台机器上只运行一种类型的守护进程。我们推荐把使用数据集群的进程（如 OpenStack 、 CloudStack 等）安装在别的机器上。</p><blockquote><p>关于 Ceph 的高品质博客文章也值得参考，比如 <a href="http://ceph.com/community/ceph-performance-part-1-disk-controller-write-throughput/">Ceph Write Throughput 1</a> 、 <a href="http://ceph.com/community/ceph-performance-part-2-write-throughput-without-ssd-journals/">Ceph Write Throughput 2</a> 、 <a href="http://ceph.com/uncategorized/argonaut-vs-bobtail-performance-preview/">Argonaut v. Bobtail Performance Preview</a> 、 <a href="http://ceph.com/community/ceph-bobtail-performance-io-scheduler-comparison/">Bobtail Performance - I/O Scheduler Comparison</a> 。</p></blockquote><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>Ceph 元数据服务器对 CPU 敏感，它会动态地重分布它们的负载，所以你的元数据服务器应该有足够的处理能力（如 4 核或更强悍的 CPU ）。 Ceph 的 OSD 运行着 <a href="http://docs.ceph.org.cn/glossary/#term-rados"><em>RADOS</em></a> 服务、用 <a href="http://docs.ceph.org.cn/glossary/#term-crush"><em>CRUSH</em></a> 计算数据存放位置、复制数据、维护它自己的集群运行图副本，因此 OSD 需要一定的处理能力（如双核 CPU ）。监视器只简单地维护着集群运行图的副本，因此对 CPU 不敏感；但必须考虑机器以后是否还会运行 Ceph 监视器以外的 CPU 密集型任务。例如，如果服务器以后要运行用于计算的虚拟机（如 OpenStack Nova ），你就要确保给 Ceph 进程保留了足够的处理能力，所以我们推荐在其他机器上运行 CPU 密集型任务。</p><h4 id="RAM内存"><a href="#RAM内存" class="headerlink" title="RAM内存"></a>RAM内存</h4><p>元数据服务器和监视器必须可以尽快地提供它们的数据，所以他们应该有足够的内存，至少每进程 1GB 。 OSD 的日常运行不需要那么多内存（如每进程 500MB ）差不多了；然而在恢复期间它们占用内存比较大（如每进程每 TB 数据需要约 1GB 内存）。通常内存越多越好。</p><p>元数据服务器和监视器必须可以尽快地提供它们的数据，所以他们应该有足够的内存，至少每进程 1GB 。 OSD 的日常运行不需要那么多内存（如每进程 500MB ）差不多了；然而在恢复期间它们占用内存比较大（如每进程每 TB 数据需要约 1GB 内存）。通常内存越多越好。</p><blockquote><p>因为 Ceph 发送 ACK 前必须把所有数据写入日志（至少对 xfs 和 ext4 来说是），因此均衡日志和 OSD 性能相当重要。</p></blockquote><h4 id="硬盘驱动器"><a href="#硬盘驱动器" class="headerlink" title="硬盘驱动器"></a>硬盘驱动器</h4><p>OSD 应该有足够的空间用于存储对象数据。考虑到大硬盘的每 GB 成本，我们建议用容量大于 1TB 的硬盘。</p><ul><li><p>不顾分区而在单个硬盘上运行多个OSD，这样<strong>不明智</strong>！</p></li><li><p>不顾分区而在运行了OSD的硬盘上同时运行监视器或元数据服务器也<strong>不明智</strong>！</p></li></ul><p>存储驱动器受限于寻道时间、访问时间、读写时间、还有总吞吐量，这些物理局限性影响着整体系统性能，尤其在系统恢复期间。因此我们推荐独立的驱动器用于安装操作系统和软件，另外每个 OSD 守护进程占用一个驱动器。大多数 “slow OSD”问题的起因都是在相同的硬盘上运行了操作系统、多个 OSD 、和/或多个日志文件。鉴于解决性能问题的成本差不多会超过另外增加磁盘驱动器，你应该在设计时就避免增加 OSD 存储驱动器的负担来提升性能。</p><p>Ceph 允许你在每块硬盘驱动器上运行多个 OSD ，但这会导致资源竞争并降低总体吞吐量； Ceph 也允许把日志和对象数据存储在相同驱动器上，但这会增加记录写日志并回应客户端的延时，因为 Ceph 必须先写入日志才会回应确认了写动作。 btrfs 文件系统能同时写入日志数据和对象数据， xfs 和 ext4 却不能。</p><p>SSD总体性能优于HDD</p><ul><li><strong>写密集语义：</strong> 记日志涉及写密集语义，所以你要确保选用的 SSD 写入性能和硬盘相当或好于硬盘。廉价 SSD 可能在加速访问的同时引入写延时，有时候高性能硬盘的写入速度可以和便宜 SSD 相媲美。</li><li><strong>顺序写入：</strong> 在一个 SSD 上为多个 OSD 存储多个日志时也必须考虑 SSD 的顺序写入极限，因为它们要同时处理多个 OSD 日志的写入请求。</li><li><strong>分区对齐：</strong> 采用了 SSD 的一个常见问题是人们喜欢分区，却常常忽略了分区对齐，这会导致 SSD 的数据传输速率慢很多，所以请确保分区对齐了。</li></ul><p>SSD 用于对象存储太昂贵了，但是把 OSD 的日志存到 SSD 、把对象数据存储到独立的硬盘可以明显提升性能。 <code>osd journal</code> 选项的默认值是 <code>/var/lib/ceph/osd/$cluster-$id/journal</code> ，你可以把它挂载到一个 SSD 或 SSD 分区，这样它就不再是和对象数据一样存储在同一个硬盘上的文件了。</p><p>提升 CephFS 文件系统性能的一种方法是从 CephFS 文件内容里分离出元数据。 Ceph 提供了默认的 <code>metadata</code> 存储池来存储 CephFS 元数据，所以你不需要给 CephFS 元数据创建存储池，但是可以给它创建一个仅指向某主机 SSD 的 CRUSH 运行图。详情见<a href="http://ceph.com/docs/master/rados/operations/crush-map/#placing-different-pools-on-different-osds">给存储池指定 OSD</a> 。</p><p>你可以在同一主机上运行多个 OSD ，但要确保 OSD 硬盘总吞吐量不超过为客户端提供读写服务所需的网络带宽；还要考虑集群在每台主机上所存储的数据占总体的百分比，如果一台主机所占百分比太大而它挂了，就可能导致诸如超过 <code>full ratio</code> 的问题，此问题会使 Ceph 中止运作以防数据丢失。</p><p>如果每台主机运行多个 OSD ，也得保证内核是最新的。参阅<a href="http://docs.ceph.org.cn/start/os-recommendations">操作系统推荐</a>里关于 <code>glibc</code> 和 <code>syncfs(2)</code> 的部分，确保硬件性能可达期望值。</p><p>OSD 数量较多（如 20 个以上）的主机会派生出大量线程，尤其是在恢复和重均衡期间。很多 Linux 内核默认的最大线程数较小（如 32k 个），如果您遇到了这类问题，可以把 <code>kernel.pid_max</code> 值调高些。理论最大值是 4194303 。例如把下列这行加入 <code>/etc/sysctl.conf</code> 文件：</p><pre><code class="hljs ini"><span class="hljs-attr">kernel.pid_max</span> = <span class="hljs-number">4194303</span></code></pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>​        建议每台机器最少两个千兆网卡，现在大多数机械硬盘都能达到大概 100MB/s 的吞吐量，网卡应该能处理所有 OSD 硬盘总吞吐量，所以推荐最少两个千兆网卡，分别用于公网（前端）和集群网络（后端）。集群网络（最好别连接到国际互联网）用于处理由数据复制产生的额外负载，而且可防止拒绝服务攻击，拒绝服务攻击会干扰数据归置组，使之在 OSD 数据复制时不能回到 <code>active + clean</code> 状态。请考虑部署万兆网卡。通过 1Gbps 网络复制 1TB 数据耗时 3 小时，而 3TB （典型配置）需要 9 小时，相比之下，如果使用 10Gbps 复制时间可分别缩减到 20 分钟和 1 小时。在一个 PB 级集群中， OSD 磁盘失败是常态，而非异常；在性价比合理的的前提下，系统管理员想让 PG 尽快从 <code>degraded</code> （降级）状态恢复到 <code>active + clean</code> 状态。另外，一些部署工具（如 Dell 的 Crowbar ）部署了 5 个不同的网络，但使用了 VLAN 以提高网络和硬件可管理性。 VLAN 使用 802.1q 协议，还需要采用支持 VLAN 功能的网卡和交换机，增加的硬件成本可用节省的运营（网络安装、维护）成本抵消。使用 VLAN 来处理集群和计算栈（如 OpenStack 、 CloudStack 等等）之间的 VM 流量时，采用 10G 网卡仍然值得。每个网络的机架路由器到核心路由器应该有更大的带宽，如 40Gbps 到 100Gbps 。</p><p>​        服务器应配置底板管理控制器（ Baseboard Management Controller, BMC ），管理和部署工具也应该大规模使用 BMC ，所以请考虑带外网络管理的成本/效益平衡，此程序管理着 SSH 访问、 VM 映像上传、操作系统安装、端口管理、等等，会徒增网络负载。运营 3 个网络有点过分，但是每条流量路径都指示了部署一个大型数据集群前要仔细考虑的潜能力、吞吐量、性能瓶颈。</p><p>Ceph 可以运行在廉价的普通硬件上，小型生产集群和开发集群可以在一般的硬件上。</p><p>如果在只有一块硬盘的机器上运行 OSD ，要把数据和操作系统分别放到不同分区；一般来说，我们推荐操作系统和数据分别使用不同的硬盘。</p><h4 id="最低硬件要求"><a href="#最低硬件要求" class="headerlink" title="最低硬件要求"></a>最低硬件要求</h4><div class="table-container"><table><thead><tr><th style="text-align:left">进程</th><th style="text-align:left">条件</th><th style="text-align:left">最低建议</th></tr></thead><tbody><tr><td style="text-align:left"><code>ceph-osd</code></td><td style="text-align:left">Processor</td><td style="text-align:left">1x 64-bit AMD-641x 32-bit ARM dual-core or better1x i386 dual-core</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">RAM</td><td style="text-align:left">~1GB for 1TB of storage per daemon</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Volume Storage</td><td style="text-align:left">1x storage drive per daemon</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Journal</td><td style="text-align:left">1x SSD partition per daemon (optional)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left"><code>ceph-mon</code></td><td style="text-align:left">Processor</td><td style="text-align:left">1x 64-bit AMD-64/i3861x 32-bit ARM dual-core or better1x i386 dual-core</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">RAM</td><td style="text-align:left">1 GB per daemon</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Disk Space</td><td style="text-align:left">10 GB per daemon</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left"><code>ceph-mds</code></td><td style="text-align:left">Processor</td><td style="text-align:left">1x 64-bit AMD-64 quad-core1x 32-bit ARM quad-core1x i386 quad-core</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">RAM</td><td style="text-align:left">1 GB minimum per daemon</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Disk Space</td><td style="text-align:left">1 MB per daemon</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr></tbody></table></div><h4 id="生产实例"><a href="#生产实例" class="headerlink" title="生产实例"></a>生产实例</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Configuration</th><th style="text-align:left">Criteria</th><th style="text-align:left">Minimum Recommended</th></tr></thead><tbody><tr><td style="text-align:left">Dell PE R510</td><td style="text-align:left">Processor</td><td style="text-align:left">2x 64-bit quad-core Xeon CPUs</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">RAM</td><td style="text-align:left">16 GB</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Volume Storage</td><td style="text-align:left">8x 2TB drives. 1 OS, 7 Storage</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Client Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">OSD Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Mgmt. Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left">Dell PE R515</td><td style="text-align:left">Processor</td><td style="text-align:left">1x hex-core Opteron CPU</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">RAM</td><td style="text-align:left">16 GB</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Volume Storage</td><td style="text-align:left">12x 3TB drives. Storage</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">OS Storage</td><td style="text-align:left">1x 500GB drive. Operating System.</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Client Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">OSD Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Mgmt. Network</td><td style="text-align:left">2x 1GB Ethernet NICs</td></tr></tbody></table></div><p>当然如果你想更加细致的开发ceph，建议进行<strong>手动部署</strong>！</p><h1 id="A-Manual-Deploymeny手动部署💪"><a href="#A-Manual-Deploymeny手动部署💪" class="headerlink" title="A. Manual Deploymeny手动部署💪"></a>A. <em>Manual Deploymeny</em>手动部署💪</h1><h2 id="1-部署ceph-mon"><a href="#1-部署ceph-mon" class="headerlink" title="1. 部署ceph-mon"></a>1. 部署ceph-mon</h2><p>安装完成之后在<code>/etc/ceph</code>目录下新建文件<code>ceph.conf</code>，内容大致如下，根据实际情况进行修改即可：</p><pre><code class="hljs routeros">[global]fsid = &#123;cluster-id&#125;mon initial members = &#123;hostname&#125;[, &#123;hostname&#125;]mon host = &#123;ip-address&#125;[, &#123;ip-address&#125;]public<span class="hljs-built_in"> network </span>= &#123;network&#125;[, &#123;network&#125;]cluster<span class="hljs-built_in"> network </span>= &#123;network&#125;[, &#123;network&#125;]auth cluster required = cephxauth<span class="hljs-built_in"> service </span>required = cephxauth<span class="hljs-built_in"> client </span>required = cephxosd journal size = &#123;n&#125;osd<span class="hljs-built_in"> pool default </span>size = &#123;n&#125;  # Write an object n times.osd<span class="hljs-built_in"> pool default </span>min size = &#123;n&#125; # Allow writing n copies <span class="hljs-keyword">in</span> a degraded state.osd<span class="hljs-built_in"> pool default </span>pg num = &#123;n&#125;osd<span class="hljs-built_in"> pool default </span>pgp num = &#123;n&#125;osd crush chooseleaf<span class="hljs-built_in"> type </span>= &#123;n&#125;</code></pre><p>为监控节点创建密钥：</p><pre><code class="hljs shell">ceph-authtool --create-keyring /etc/ceph/ceph.mon.keyring --gen-key -n mon. --cap mon &#x27;allow *&#x27;</code></pre><p>创建client.admin用户并创建密钥：</p><pre><code class="hljs shell">ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --cap mon &#x27;allow *&#x27; --cap osd &#x27;allow *&#x27; --cap mds &#x27;allow *&#x27; --cap mgr &#x27;allow *&#x27;</code></pre><p>创建client.bootstrap-osd用户并创建密钥：</p><pre><code class="hljs shell">ceph-authtool --create-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring --gen-key -n client.bootstrap-osd --cap mon &#x27;profile bootstrap-osd&#x27;</code></pre><p>将刚才生成的两个密钥加入ceph.mon.keyring中：</p><pre><code class="hljs shell">ceph-authtool /etc/ceph/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyringceph-authtool /etc/ceph/ceph.mon.keyring --import-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring</code></pre><p>此时ceph.mon.keyring中应有如下密钥：</p><pre><code class="hljs nix">[mon.]<span class="hljs-attr">key</span> = AQBWAa1f8zAHJBAAf0cyxMAZjsZeL7+x+<span class="hljs-attr">czsLw==</span>caps <span class="hljs-attr">mon</span> = <span class="hljs-string">&quot;allow *&quot;</span>[client.admin]<span class="hljs-attr">key</span> = AQDPAa1fxm0VMRAAXMJ+<span class="hljs-attr">QU7sA9knr5ZWsluLxg==</span>caps <span class="hljs-attr">mds</span> = <span class="hljs-string">&quot;allow *&quot;</span>caps <span class="hljs-attr">mgr</span> = <span class="hljs-string">&quot;allow *&quot;</span>caps <span class="hljs-attr">mon</span> = <span class="hljs-string">&quot;allow *&quot;</span>caps <span class="hljs-attr">osd</span> = <span class="hljs-string">&quot;allow *&quot;</span>[client.bootstrap-osd]<span class="hljs-attr">key</span> = AQAWAq1fATC1ChAAb2wMiO+k/<span class="hljs-attr">hwlMEmddDLAcg==</span>caps <span class="hljs-attr">mgr</span> = <span class="hljs-string">&quot;allow r&quot;</span>caps <span class="hljs-attr">mon</span> = <span class="hljs-string">&quot;profile bootstrap-osd&quot;</span></code></pre><p>生成监控映射：</p><pre><code class="hljs shell">monmaptool --create --add &#123;hostname&#125; &#123;ip-address&#125; --fsid &#123;uuid&#125; /etc/ceph/monmap</code></pre><p>创建默认的数据目录，其中目录名是{cluster-name}-{hostname}格式：</p><pre><code class="hljs shell">sudo mkdir /var/lib/ceph/mon/&#123;cluster-name&#125;-&#123;hostname&#125;</code></pre><p>创建守护进程：</p><pre><code class="hljs shell">sudo ceph-mon [--cluster &#123;cluster-name&#125;] --mkfs -i &#123;hostname&#125; --monmap /etc/ceph/monmap --keyring /etc/ceph/ceph.mon.keyring</code></pre><p>启动mon：</p><pre><code class="hljs shell">ceph-mon -i &#123;hostname&#125; -c /etc/ceph/ceph.conf --cluster ceph</code></pre><p>这儿不能根据官方推荐的systemctl。 </p><p>之后我们用 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph -s</span></code></pre><p>查看集群</p><p>这里笔者遇到问题：</p><pre><code class="hljs pgsql">[errno <span class="hljs-number">2</span>] RADOS <span class="hljs-keyword">object</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span> (error connecting <span class="hljs-keyword">to</span> the <span class="hljs-keyword">cluster</span>)</code></pre><p>提示RADOS对象没有找到，但是我还没有到那一步呢！</p><p>原来是没有加sudo</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo ceph -s</span></code></pre><pre><code class="hljs yaml"><span class="hljs-attr">cluster:</span>  <span class="hljs-attr">id:</span>     <span class="hljs-string">250a1431-6cf3-4d0b-a964-361cd8d10dad</span>  <span class="hljs-attr">health:</span> <span class="hljs-string">HEALTH_WARN</span>          <span class="hljs-number">1</span> <span class="hljs-string">monitors</span> <span class="hljs-string">have</span> <span class="hljs-string">not</span> <span class="hljs-string">enabled</span> <span class="hljs-string">msgr2</span> <span class="hljs-attr">services:</span>  <span class="hljs-attr">mon:</span> <span class="hljs-number">1</span> <span class="hljs-string">daemons,</span> <span class="hljs-string">quorum</span> <span class="hljs-string">ceph-master</span> <span class="hljs-string">(age</span> <span class="hljs-string">25m)</span>  <span class="hljs-attr">mgr:</span> <span class="hljs-literal">no</span> <span class="hljs-string">daemons</span> <span class="hljs-string">active</span>  <span class="hljs-attr">osd: 0 osds:</span> <span class="hljs-number">0</span> <span class="hljs-string">up,</span> <span class="hljs-number">0</span> <span class="hljs-string">in</span> <span class="hljs-attr">data:</span>  <span class="hljs-attr">pools:</span>   <span class="hljs-number">0</span> <span class="hljs-string">pools,</span> <span class="hljs-number">0</span> <span class="hljs-string">pgs</span>  <span class="hljs-attr">objects:</span> <span class="hljs-number">0</span> <span class="hljs-string">objects,</span> <span class="hljs-number">0</span> <span class="hljs-string">B</span>  <span class="hljs-attr">usage:</span>   <span class="hljs-number">0</span> <span class="hljs-string">B</span> <span class="hljs-string">used,</span> <span class="hljs-number">0</span> <span class="hljs-string">B</span> <span class="hljs-string">/</span> <span class="hljs-number">0</span> <span class="hljs-string">B</span> <span class="hljs-string">avail</span>  <span class="hljs-attr">pgs:</span></code></pre><p>这是最<strong>基本</strong>的集群，所以只有一个monitor，马上我们就进行必要的扩展！</p><p>这儿有一个 <code>HEALTH_WARN</code>大家应该注意到了，这是因为 msgr 没有enable。</p><pre><code class="hljs routeros">sudo ceph<span class="hljs-built_in"> health </span>detail #详细查看健康状况</code></pre><h2 id="2-部署ceph-mgr"><a href="#2-部署ceph-mgr" class="headerlink" title="2. 部署ceph-mgr"></a>2. 部署ceph-mgr</h2><p>前面我们说每一个mon节点最好加一个mgr守护进程。名字叫<code>open-stack</code></p><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>创建用户 openstack 用于 MGR 监控</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">auth </span><span class="hljs-built_in">get-or-create</span> <span class="hljs-string">mgr.</span><span class="hljs-string">openstack </span><span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-string">osd </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-string">mds </span><span class="hljs-string">&#x27;allow *&#x27;</span> [<span class="hljs-string">mgr.</span><span class="hljs-string">openstack]</span> <span class="hljs-string">key </span>= <span class="hljs-string">AQBqhxNaKcVpLhAA/</span><span class="hljs-string">P1GVlu3yRugvXkLfgauLA=</span>=</code></pre><h2 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h2><p>假如用户已经存在, 用过下面方法进行权限修改</p><pre><code class="hljs apache"><span class="hljs-attribute">ceph</span> auth caps mgr.openstack mon &#x27;<span class="hljs-literal">allow</span> *&#x27; osd &#x27;<span class="hljs-literal">allow</span> *&#x27; mds &#x27;<span class="hljs-literal">allow</span> *&#x27;[mgr.openstack]        <span class="hljs-attribute">key</span> = AQBqhxNaKcVpLhAA/P<span class="hljs-number">1</span>GVlu<span class="hljs-number">3</span>yRugvXkLfgauLA==</code></pre><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>提示一下删除用户方法</p><pre><code class="hljs css"><span class="hljs-selector-tag">ceph</span> <span class="hljs-selector-tag">auth</span> <span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">mgr</span><span class="hljs-selector-class">.openstack</span></code></pre><h2 id="导出密钥"><a href="#导出密钥" class="headerlink" title="导出密钥"></a>导出密钥</h2><p>需要吧之前创建的用户密码存放至对应位置</p><pre><code class="hljs crystal">mkdir /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mgr</span>/<span class="hljs-title">ceph</span>-<span class="hljs-title">openstack</span></span>ceph auth get mgr.openstack -o /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mgr</span>/<span class="hljs-title">ceph</span>-<span class="hljs-title">openstack</span>/<span class="hljs-title">keyring</span></span>exported keyring <span class="hljs-keyword">for</span> mgr.openstack</code></pre><h2 id="启动-mgr"><a href="#启动-mgr" class="headerlink" title="启动 mgr"></a>启动 mgr</h2><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph-mgr -i openstack</span></code></pre><p>然后部署完成之后状态如下：</p><h2 id="3-部署ceph-osd"><a href="#3-部署ceph-osd" class="headerlink" title="3.部署ceph-osd"></a>3.部署ceph-osd</h2><p>修改<code>/etc/ceph/ceph.conf</code></p><pre><code class="hljs awk">[osd]run_dir = <span class="hljs-regexp">/data0/</span><span class="hljs-variable">$name</span> osd data = <span class="hljs-regexp">/data0/</span><span class="hljs-variable">$name</span>osd journal = <span class="hljs-regexp">/data0/</span><span class="hljs-variable">$name</span>/journalosd max object name len = <span class="hljs-number">256</span>osd max object namespace len = <span class="hljs-number">64</span></code></pre><p>笔者这里未专门分配磁盘，<code>/data0/$name</code>写的是<code>/var/lib/ceph/osd/ceph-0</code>，为了确保体验，建议专门为osd和journal分区，最好是xfs系统。</p><p>官方给了short-form和long form两种方式，我们选择long form。我们先切换到root权限：</p><p>因为下面是脚本模式，$\$var$相当于环境变量。<strong>注意，bash的等号两端不能有空格！</strong></p><pre><code class="hljs crystal">sudo bash <span class="hljs-comment"># 运行运行bash脚本</span>UUID=$(uuidgen) <span class="hljs-comment">#和集群ID一样，OSD也要生成唯一ID </span>OSD_SECRET=$(ceph-authtool --gen-print-key) <span class="hljs-comment">#生成密匙</span>sudo cp /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">bootstrap</span>-<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>.<span class="hljs-title">keyring</span> /<span class="hljs-title">etc</span>/<span class="hljs-title">ceph</span>/</span>ID=$(echo <span class="hljs-string">&quot;&#123;\&quot;cephx_secret\&quot;: \&quot;$OSD_SECRET\&quot;&#125;&quot;</span> | \   ceph osd new $UUID -i - \   -n client.bootstrap-osd -k /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">bootstrap</span>-<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>.<span class="hljs-title">keyring</span>) <span class="hljs-comment">#生成OSD-ID，从0开始</span></span>    mkdir /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-$<span class="hljs-title">ID</span></span></code></pre><blockquote><p>sudo su , sudo su-, sudo bash 均可进入root，区别是 sudo bash更全面，可以运行脚本，开头的命令头是绿字，sudo su- 允许一定场合不用输入密码，而sudo su是进入一般的root模式。</p></blockquote><div class="note note-warning">            <p>挂载osd的路径应该与运行操作系统的路径分开。并建议采用xfs文件系统，而不是brtfs或者ext4.</p>          </div><p>我们建议额外分配一定空间专门用作osd存储，以及日志存储，并且将其挂载到<code>/var/lib/ceph/osd/ceph-&#123;osd_num&#125;</code></p><pre><code class="hljs crystal">sudo mkfs.xfs /dev/&#123;DEV&#125;sudo mount /dev/&#123;DEV&#125; /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-$<span class="hljs-title">ID</span></span></code></pre><p>如果你像笔者一样粗心，忘了将osd存储和os分开，那么只能进行如下操作</p><pre><code class="hljs crystal">sudo mount /dev/sda1 /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-0</span></code></pre><pre><code class="hljs crystal">ceph-authtool --create-keyring /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-$<span class="hljs-title">ID</span>/<span class="hljs-title">keyring</span> \</span>     --name osd.$ID --add-key $OSD_SECRET ceph-osd -i $ID --mkfs --osd-uuid $UUID <span class="hljs-comment">#初始化OSD初始目录</span>chown -R <span class="hljs-symbol">ceph:</span>ceph /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-$<span class="hljs-title">ID</span> <span class="hljs-comment">#目录拥有者，谨慎执行，否则sudo容易挂</span></span></code></pre><p>启动osd</p><pre><code class="hljs routeros">systemctl <span class="hljs-builtin-name">enable</span> ceph-osd@<span class="hljs-variable">$ID</span>systemctl start ceph-osd@<span class="hljs-variable">$ID</span></code></pre><p>​    检查osd是否启动 ceph -s</p><pre><code class="hljs yaml"><span class="hljs-attr">cluster:</span>  <span class="hljs-attr">id:</span>     <span class="hljs-string">250a1431-6cf3-4d0b-a964-361cd8d10dad</span>  <span class="hljs-attr">health:</span> <span class="hljs-string">HEALTH_WARN</span>          <span class="hljs-literal">no</span> <span class="hljs-string">active</span> <span class="hljs-string">mgr</span>          <span class="hljs-number">1</span> <span class="hljs-string">monitors</span> <span class="hljs-string">have</span> <span class="hljs-string">not</span> <span class="hljs-string">enabled</span> <span class="hljs-string">msgr2</span> <span class="hljs-attr">services:</span>  <span class="hljs-attr">mon:</span> <span class="hljs-number">1</span> <span class="hljs-string">daemons,</span> <span class="hljs-string">quorum</span> <span class="hljs-string">ceph-master</span> <span class="hljs-string">(age</span> <span class="hljs-string">72m)</span>  <span class="hljs-attr">mgr:</span> <span class="hljs-literal">no</span> <span class="hljs-string">daemons</span> <span class="hljs-string">active</span>  <span class="hljs-attr">osd: 1 osds:</span> <span class="hljs-number">0</span> <span class="hljs-string">up,</span> <span class="hljs-number">0</span> <span class="hljs-string">in</span> <span class="hljs-attr">data:</span>  <span class="hljs-attr">pools:</span>   <span class="hljs-number">0</span> <span class="hljs-string">pools,</span> <span class="hljs-number">0</span> <span class="hljs-string">pgs</span>  <span class="hljs-attr">objects:</span> <span class="hljs-number">0</span> <span class="hljs-string">objects,</span> <span class="hljs-number">0</span> <span class="hljs-string">B</span>  <span class="hljs-attr">usage:</span>   <span class="hljs-number">0</span> <span class="hljs-string">B</span> <span class="hljs-string">used,</span> <span class="hljs-number">0</span> <span class="hljs-string">B</span> <span class="hljs-string">/</span> <span class="hljs-number">0</span> <span class="hljs-string">B</span> <span class="hljs-string">avail</span>  <span class="hljs-attr">pgs:</span></code></pre><p>这就说明我们搭建了一个osd。</p><hr><h1 id="B-Build-amp-Make-编译源码"><a href="#B-Build-amp-Make-编译源码" class="headerlink" title="B. Build &amp;Make:编译源码"></a>B. <em>Build &amp;Make</em>:编译源码</h1><p><span id="here">您到站了！</span></p><p><del>版本14.2.12：Nautilus</del></p><p>版本15.2.5：Octopus √ （最新版）</p><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/xiaochina/p/12275313.html">Nautilus版本部署</a></p><p><a href="https://blog.csdn.net/qq_40071358/article/details/106924184">Octopus版本部署</a></p></blockquote><p>硬件配置</p><ul><li>Ubuntu18.04 LTS（Bionic Beaver） </li></ul><p>装完虚拟机，你应该1. <a href="https://blog.csdn.net/adullperson/article/details/105184861">设置共享文件夹</a> 2. 改变镜像为清华源并update 3. 下载中文输入法vim，chrome等 4. 快照保存 【由于从官网和github下载ceph源码和tarball很慢，我放在我的网盘上】</p><blockquote><p>如果你，发现硬盘分配小了，想扩容，又不想重新装系统，看<a href="https://blog.csdn.net/daemon_2017/article/details/80660372">这里</a>。以及磁盘清理<a href="https://blog.csdn.net/m0_37407756/article/details/79903837">技巧</a>。</p></blockquote><ul><li>运存16g+硬盘80g 四核（根据实际情况）</li></ul><p>（官网要求最少60g空间：A debug build of Ceph may take around 40 gigabytes. If you want to build Ceph in a virtual machine (VM) please make sure total disk space on the VM is at least 60 gigabytes.）</p><p>（初始4g+20g出现硬盘不足问题，一怒之下。。）</p><p>安装步骤：</p><p>下载源码有两种方式：</p><ol><li>GitHub </li></ol><pre><code class="hljs awk">git clone --recursive git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ceph/</span>ceph <span class="hljs-comment">#recursive是保证下载所有子模块，大小应该有100多M</span></code></pre><ol><li>tarball</li></ol><p>【Github下载太慢？baidu网盘】：链接：<a href="https://pan.baidu.com/s/1siz1Bag4Y4XduMLaqc21TQ">https://pan.baidu.com/s/1siz1Bag4Y4XduMLaqc21TQ</a><br>提取码：xahe </p><p>如果是虚拟机的话：需要支持共享文件夹。</p><pre><code class="hljs dts">tar -<span class="hljs-class">zxvf </span>&#123;文件名&#125; <span class="hljs-meta">#解压</span><span class="hljs-class">cd </span>&#123;文件名&#125;</code></pre><pre><code class="hljs sql">git submodule <span class="hljs-keyword">update</span> <span class="hljs-comment">--init --recursive #检查有没有模块缺失，试了一下没啥卵用</span>sudo ./<span class="hljs-keyword">install</span>-deps.sh <span class="hljs-comment">#安装所有依赖，需要大量时间，建议网好的时候进行</span>sudo ./do_cmake.sh -DCMAKE_BUILD_TYPE=RelWithDebInfo -DWITH_SEASTAR=<span class="hljs-keyword">ON</span> -DWITH_MGR_DASHBOARD_FRONTEND=<span class="hljs-keyword">OFF</span> -DWITH_PYTHON2=<span class="hljs-keyword">OFF</span> -DWITH_PYTHON3=<span class="hljs-keyword">ON</span> -DMGR_PYTHON_VERSION=<span class="hljs-number">3</span> <span class="hljs-comment">#这一步 如果这部报错就试试 sudo ./run-make-check.sh 只要最后build文件夹有makefile就可以了，我们不需要调试信息，需要seastar，不需要前端，采用python3</span>cd <span class="hljs-keyword">build</span>sudo make -j4 vstart<span class="hljs-comment"># 保证能运行test cluster就行，这里-j4是线程数，根据实际情况设定</span>sudo make -j4 <span class="hljs-keyword">all</span> <span class="hljs-comment">#编译所有组件，需要很多空间，根据需要进行</span>sudo make <span class="hljs-keyword">install</span> <span class="hljs-comment">#别忘了进行安装</span></code></pre><p>缺啥补啥 (lib+XX+-dev格式)</p><p>比如笔者装了以下库 </p><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> libhwloc-devsudo apt <span class="hljs-keyword">install</span> libsctp-devsudo apt <span class="hljs-keyword">install</span> libyaml-cpp-devsudo apt <span class="hljs-keyword">install</span> ragel</code></pre><p>编译可能要5-8小时。建议开个<code>top</code>窗口，看看<code>cc1plus</code>这个进程在不在，如果不在，而且内存没怎么占用，说明程序死了。<code>ctrl+c</code>终止再重新编译。</p><hr><p>按照官方的测试cluster只用编译到vstart就行了</p><p><code>sudo make -j4 vstart</code></p><p>如果你遇到问题，请对症下药！</p><h2 id="P1-未与github远程库建立联系"><a href="#P1-未与github远程库建立联系" class="headerlink" title="P1:未与github远程库建立联系"></a>P1:未与github远程库建立联系</h2><pre><code class="hljs gradle">CMake Error at src<span class="hljs-regexp">/CMakeFiles/gi</span>t-data/grabRef.cmake:<span class="hljs-number">48</span> (<span class="hljs-keyword">file</span>):  <span class="hljs-keyword">file</span> failed to open <span class="hljs-keyword">for</span> reading (No such <span class="hljs-keyword">file</span> or directory):    <span class="hljs-regexp">/home/</span>ceph<span class="hljs-regexp">/Sharing Hub/</span>ceph-master<span class="hljs-regexp">/src/</span>CMakeFiles<span class="hljs-regexp">/git-data/</span>head-ref<span class="hljs-keyword">Call</span> Stack (most recent <span class="hljs-keyword">call</span> first):  cmake<span class="hljs-regexp">/modules/G</span>etGitRevisionDescription.cmake:<span class="hljs-number">75</span> (<span class="hljs-keyword">include</span>)  src/CMakeLists.txt:<span class="hljs-number">216</span> (get_git_head_revision)CMake Error at src<span class="hljs-regexp">/CMakeFiles/gi</span>t-data/grabRef.cmake:<span class="hljs-number">48</span> (<span class="hljs-keyword">file</span>):  <span class="hljs-keyword">file</span> failed to open <span class="hljs-keyword">for</span> reading (No such <span class="hljs-keyword">file</span> or directory):    <span class="hljs-regexp">/home/</span>ceph<span class="hljs-regexp">/Sharing Hub/</span>ceph-master<span class="hljs-regexp">/src/</span>CMakeFiles<span class="hljs-regexp">/git-data/</span>head-ref<span class="hljs-keyword">Call</span> Stack (most recent <span class="hljs-keyword">call</span> first):  cmake<span class="hljs-regexp">/modules/G</span>etGitRevisionDescription.cmake:<span class="hljs-number">75</span> (<span class="hljs-keyword">include</span>)  cmake<span class="hljs-regexp">/modules/G</span>etGitRevisionDescription.cmake:<span class="hljs-number">85</span> (get_git_head_revision)  src/CMakeLists.txt:<span class="hljs-number">217</span> (git_describe)CMake Error at src/CMakeLists.txt:<span class="hljs-number">221</span> (<span class="hljs-keyword">if</span>):  <span class="hljs-keyword">if</span> given arguments:    <span class="hljs-string">&quot;STREQUAL&quot;</span> <span class="hljs-string">&quot;GITDIR-NOTFOUND&quot;</span>  Unknown arguments specified-- Configuring incomplete, errors occurred!See also <span class="hljs-string">&quot;/home/ceph/Sharing Hub/ceph-master/CMakeFiles/CMakeOutput.log&quot;</span>.See also <span class="hljs-string">&quot;/home/ceph/Sharing Hub/ceph-master/CMakeFiles/CMakeError.log&quot;</span>.</code></pre><p>注意：千万不要运行<code>make_deb.sh</code>否则所有文件都会被删除</p><p>原因：未与远程库建立联系：</p><p>解决：在主目录下依次执行</p><pre><code class="hljs awk">git initgit remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ceph/</span>ceph.gitgit add .git commit -m <span class="hljs-string">&quot;123&quot;</span></code></pre><h2 id="P2：-Python和Ceph使用了不同的OpenSSL库"><a href="#P2：-Python和Ceph使用了不同的OpenSSL库" class="headerlink" title="P2： Python和Ceph使用了不同的OpenSSL库"></a>P2： Python和Ceph使用了不同的OpenSSL库</h2><pre><code class="hljs apache"><span class="hljs-attribute">CMake</span> Error at src/pybind/CMakeLists.txt:<span class="hljs-number">67</span> (message):  <span class="hljs-attribute">Python</span> and Ceph link to different OpenSSL versions: <span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>   <span class="hljs-attribute">vs</span> <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>n</code></pre><p>字面意思。Python和Ceph使用了不同的OpenSSL库。</p><p>参考：<a href="https://github.com/ceph/ceph/pull/22659，https://tracker.ceph.com/issues/36425">https://github.com/ceph/ceph/pull/22659，https://tracker.ceph.com/issues/36425</a></p><p>问题：默认pyth2链接到openssl1.0.2n(早期版本)</p><p>现在的ceph是通过python3编译。python3直接连接到openssl1.1.1，所以我们通过以下参数强制用python3编译。</p><pre><code class="hljs routeros"><span class="hljs-attribute">-DWITH_PYTHON2</span>=OFF <span class="hljs-attribute">-DWITH_PYTHON3</span>=ON <span class="hljs-attribute">-DMGR_PYTHON_VERSION</span>=3</code></pre><p>只要开始编译就可以停下来了，因为这是单线程很慢，但是基本的makefile已经有了。</p><p><code>sudo make -j4</code></p><p>这里<code>-j4</code>表示使用4线程编译，会比单线程快很多。</p><p>技巧：build过程随时查看Makefile，检查编译进度。如果某个target有问题，我们只需要单独build这个target即可，比如</p><pre><code class="hljs puppet">sudo make -<span class="hljs-keyword">j4</span> &#123;挂掉的<span class="hljs-literal">target</span>，在makefile最后可以找到&#125;</code></pre><h2 id="p3-内存不足"><a href="#p3-内存不足" class="headerlink" title="p3:内存不足"></a>p3:内存不足</h2><pre><code class="hljs shell">c++: fatal error: Killed signal terminated program cc1plus</code></pre><p>这是因为内存不够了。这里有个方法：</p><pre><code class="hljs jboss-cli">sudo sh -c &#x27;<span class="hljs-keyword">echo</span> 1 &gt; <span class="hljs-string">/proc/sys/vm/drop_caches</span>&#x27;sudo sh -c &#x27;<span class="hljs-keyword">echo</span> 2 &gt; <span class="hljs-string">/proc/sys/vm/drop_caches</span>&#x27;sudo sh -c &#x27;<span class="hljs-keyword">echo</span> 3 &gt; <span class="hljs-string">/proc/sys/vm/drop_caches</span>&#x27;</code></pre><p>利用上述命令清理缓存区的内存。</p><h2 id="p4-npm问题，不build-MGR-DASHBOARD-FRONTEND就没有问题"><a href="#p4-npm问题，不build-MGR-DASHBOARD-FRONTEND就没有问题" class="headerlink" title="p4:npm问题，不build MGR_DASHBOARD_FRONTEND就没有问题"></a>p4:npm问题，不build MGR_DASHBOARD_FRONTEND就没有问题</h2><pre><code class="hljs gams">Environment <span class="hljs-keyword">variables</span> have <span class="hljs-comment">been set</span>sh: 1: ng: not <span class="hljs-comment">found</span>npm <span class="hljs-comment">ERR! file sh</span>npm <span class="hljs-comment">ERR! code ELIFECYCLE</span>npm <span class="hljs-comment">ERR! errno ENOENT</span>npm <span class="hljs-comment">ERR! syscall spawn</span>npm <span class="hljs-comment">ERR! ceph-dashboard@0.0.0 build:</span> `<span class="hljs-comment">npm run env_build &amp;&amp; ng build</span> <span class="hljs-comment">&quot;--progress=false&quot;</span>`npm <span class="hljs-comment">ERR! spawn ENOENT</span>npm <span class="hljs-comment">ERR!</span> npm <span class="hljs-comment">ERR! Failed at the ceph-dashboard@0.0.0 build script.</span>npm <span class="hljs-comment">ERR! This is probably not a problem with npm. There is likely additional logging output above.</span>npm <span class="hljs-comment">ERR! A complete log of this run can be found in:</span>npm <span class="hljs-comment">ERR!</span>     /home/<span class="hljs-comment">ceph</span>/.npm/<span class="hljs-comment">_logs</span>/<span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-24</span>T05_33_57_314Z-debug.<span class="hljs-built_in">log</span>src/<span class="hljs-comment">pybind</span>/mgr/<span class="hljs-comment">dashboard</span>/CMakeFiles/<span class="hljs-comment">mgr-dashboard-frontend-build.dir</span>/build.make:<span class="hljs-number">3072</span>: recipe <span class="hljs-keyword">for</span> target <span class="hljs-comment">&#x27;../src/pybind/mgr/dashboard/frontend/dist&#x27;</span> failedmake[<span class="hljs-number">2</span>]: *** [../<span class="hljs-comment">src</span>/pybind/<span class="hljs-comment">mgr</span>/dashboard/<span class="hljs-comment">frontend</span>/dist] Error <span class="hljs-number">1</span>CMakeFiles/<span class="hljs-comment">Makefile2:4897: recipe for target</span> <span class="hljs-comment">&#x27;src/pybind/mgr/dashboard/CMakeFiles/mgr-dashboard-frontend-build.dir/all&#x27;</span><span class="hljs-comment"> failed</span>make[1]: *** [src/pybind/mgr/dashboard/CMakeFiles/mgr-dashboard-frontend-build.dir/all] Error <span class="hljs-comment">2</span>make[1]: *** Waiting <span class="hljs-comment">for unfinished jobs....</span></code></pre><p><strong>注意：built target xxx表示这个任务已经成功编译完了。</strong> </p><p>进行到50%提示没有找到ng这个命令,查了一下，是因为没有下npm包的原因，解决办法，如果遇到找不到依赖情况可以根据提示找缺失依赖，逐级寻找：</p><p>In case others come here with this issue as I have, here is how I solved it system-wide on MacOS. Hope this helps.</p><p>Verify node is installed:</p><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">-v</span>v11.<span class="hljs-number">2.0</span></code></pre><p>Verify npm is installed:</p><pre><code class="hljs angelscript">$ npm -v<span class="hljs-number">6.4</span><span class="hljs-number">.1</span></code></pre><p>Verify your npm global install file path is configured (known as <a href="https://docs.npmjs.com/files/folders#prefix-configuration">prefix</a>). Mine is under ~/.npm-packages:</p><pre><code class="hljs routeros">$ npm<span class="hljs-built_in"> config </span>ls -l | grep prefixprefix = <span class="hljs-string">&quot;/Users/christiangroleau/.npm-packages&quot;</span></code></pre><p>If not, you can place it into your ~/.npmrc file:</p><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> prefix=~<span class="hljs-string">/.npm-packages</span> &gt;&gt; ~<span class="hljs-string">/.npmrc</span></code></pre><p>Verify that your prefix path is listed in your system PATH:</p><pre><code class="hljs awk">$ echo <span class="hljs-variable">$PATH</span><span class="hljs-regexp">/Users/</span>christiangroleau<span class="hljs-regexp">/.npm-packages/</span>bin:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin:/u</span>sr<span class="hljs-regexp">/bin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:/sbin</code></pre><p>If not, invoke the following:</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.npm-packages/bin:<span class="hljs-variable">$PATH</span>&quot;</span></code></pre><p>Finally, you can reinstall angular-cli (in my case I needed to install it globally):</p><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> install -g @angular/cli</code></pre><p>Verify installation:</p><pre><code class="hljs brainfuck"><span class="hljs-comment">$</span> <span class="hljs-comment">ng</span> <span class="hljs-literal">-</span><span class="hljs-comment">v</span><span class="hljs-comment">Mg</span>++ <span class="hljs-comment">version:</span><span class="hljs-comment">Mg</span>++ <span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">5beta1</span> <span class="hljs-comment">(formerly</span> <span class="hljs-comment">MicroGnuEmacs</span> <span class="hljs-comment">Adv</span><span class="hljs-string">.</span><span class="hljs-comment">)</span></code></pre><h2 id="p5-npm被锁"><a href="#p5-npm被锁" class="headerlink" title="p5: npm被锁"></a>p5: npm被锁</h2><pre><code class="hljs gams">Environment <span class="hljs-keyword">variables</span> have <span class="hljs-comment">been set</span>panic: aborting <span class="hljs-comment">due to terminal initialize failure</span>Aborted <span class="hljs-comment">(core dumped)</span>npm <span class="hljs-comment">ERR! code ELIFECYCLE</span>npm <span class="hljs-comment">ERR! errno 134</span>npm <span class="hljs-comment">ERR! ceph-dashboard@0.0.0 build:</span> `<span class="hljs-comment">npm run env_build &amp;&amp; ng build</span> <span class="hljs-comment">&quot;--progress=false&quot;</span>`npm <span class="hljs-comment">ERR! Exit status 134</span>npm <span class="hljs-comment">ERR!</span> npm <span class="hljs-comment">ERR! Failed at the ceph-dashboard@0.0.0 build script.</span>npm <span class="hljs-comment">ERR! This is probably not a problem with npm. There is likely additional logging output above.</span>npm <span class="hljs-comment">ERR! A complete log of this run can be found in:</span>npm <span class="hljs-comment">ERR!</span>     /home/<span class="hljs-comment">ceph</span>/.npm/<span class="hljs-comment">_logs</span>/<span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-24</span>T12_17_18_469Z-debug.<span class="hljs-built_in">log</span>src/<span class="hljs-comment">pybind</span>/mgr/<span class="hljs-comment">dashboard</span>/CMakeFiles/<span class="hljs-comment">mgr-dashboard-frontend-build.dir</span>/build.make:<span class="hljs-number">3072</span>: recipe <span class="hljs-keyword">for</span> target <span class="hljs-comment">&#x27;../src/pybind/mgr/dashboard/frontend/dist&#x27;</span> failedmake[<span class="hljs-number">2</span>]: *** [../<span class="hljs-comment">src</span>/pybind/<span class="hljs-comment">mgr</span>/dashboard/<span class="hljs-comment">frontend</span>/dist] Error <span class="hljs-number">134</span>CMakeFiles/<span class="hljs-comment">Makefile2:4897: recipe for target</span> <span class="hljs-comment">&#x27;src/pybind/mgr/dashboard/CMakeFiles/mgr-dashboard-frontend-build.dir/all&#x27;</span><span class="hljs-comment"> failed</span>make[1]: *** [src/pybind/mgr/dashboard/CMakeFiles/mgr-dashboard-frontend-build.dir/all] Error <span class="hljs-comment">2</span>make[1]: *** Waiting <span class="hljs-comment">for unfinished jobs....</span>[ 40%] Built <span class="hljs-comment">target os</span>[ 46%] Built <span class="hljs-comment">target rbd_internal</span>[ 51%] Built <span class="hljs-comment">target rgw_common</span>Makefile:140: recipe <span class="hljs-comment">for target</span> <span class="hljs-comment">&#x27;all&#x27;</span><span class="hljs-comment"> failed</span>make: *** [all] Error <span class="hljs-comment">2</span></code></pre><p>这个问题很恶心，花了我很久时间。</p><p>首先下载npm</p><p> <code>$sudo apt install npm</code></p><p>然后，找到<code>/ceph-14.2.4/build/src/pybind/mgr/dashboard/node-env/lib</code>下的<code>node-modules</code></p><ul><li><code>sudo npm cache clean --force</code></li><li>delete <code>node_modules</code> folder, use <code>rm -r</code></li><li>delete <code>package-lock.json</code> file </li><li><code>sudo npm install</code></li></ul><p><strong>注意注意注意！</strong>，慎用<code>rm -rf</code>，后果自负！</p><h2 id="p6-git文件没版本号"><a href="#p6-git文件没版本号" class="headerlink" title="p6: git文件没版本号"></a>p6: git文件没版本号</h2><pre><code class="hljs angelscript">/home/ceph/ceph<span class="hljs-number">-15.2</span><span class="hljs-number">.5</span>/build/src/include/ceph_ver.h:<span class="hljs-number">4</span>:<span class="hljs-number">26</span>: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ <span class="hljs-keyword">or</span> ‘__attribute__’ before ‘/’ token    <span class="hljs-number">4</span> | #define CEPH_GIT_VER <span class="hljs-built_in">ref</span>s/heads/master      |                          ^/home/ceph/ceph<span class="hljs-number">-15.2</span><span class="hljs-number">.5</span>/src/ceph_ver.c:<span class="hljs-number">6</span>:<span class="hljs-number">34</span>: note: <span class="hljs-keyword">in</span> expansion of macro ‘CONCAT_VER_SYMBOL’    <span class="hljs-number">6</span> | #define DEFINE_VER_SYMBOL(x) <span class="hljs-built_in">int</span> CONCAT_VER_SYMBOL(x)      |                                  ^~~~~~~~~~~~~~~~~/home/ceph/ceph<span class="hljs-number">-15.2</span><span class="hljs-number">.5</span>/src/ceph_ver.c:<span class="hljs-number">8</span>:<span class="hljs-number">1</span>: note: <span class="hljs-keyword">in</span> expansion of macro ‘DEFINE_VER_SYMBOL’    <span class="hljs-number">8</span> | DEFINE_VER_SYMBOL(CEPH_GIT_VER);      | ^~~~~~~~~~~~~~~~~/home/ceph/ceph<span class="hljs-number">-15.2</span><span class="hljs-number">.5</span>/src/ceph_ver.c:<span class="hljs-number">8</span>:<span class="hljs-number">19</span>: note: <span class="hljs-keyword">in</span> expansion of macro ‘CEPH_GIT_VER’    <span class="hljs-number">8</span> | DEFINE_VER_SYMBOL(CEPH_GIT_VER);      |                   ^~~~~~~~~~~~src/CMakeFiles/common-objs.dir/build.make:<span class="hljs-number">63</span>: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;src/CMakeFiles/common-objs.dir/ceph_ver.c.o&#x27;</span> failedmake[<span class="hljs-number">3</span>]: *** [src/CMakeFiles/common-objs.dir/ceph_ver.c.o] Error <span class="hljs-number">1</span>CMakeFiles/Makefile2:<span class="hljs-number">727</span>: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;src/CMakeFiles/common-objs.dir/all&#x27;</span> failedmake[<span class="hljs-number">2</span>]: *** [src/CMakeFiles/common-objs.dir/all] Error <span class="hljs-number">2</span>make[<span class="hljs-number">2</span>]: *** Waiting <span class="hljs-keyword">for</span> unfinished jobs....</code></pre><p>找到/home/ceph/ceph-15.2.5/build/src/include/ceph_ver.h文件</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CEPH_GIT_VER refs/heads/master</span></code></pre><p>改为</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CEPH_GIT_VER 150205</span></code></pre><p>这是不得已之举，必须改成整数版本号，可以解决就将就一下。</p><h2 id="p7-undefined-reference-to-HMAC-CTX-new’"><a href="#p7-undefined-reference-to-HMAC-CTX-new’" class="headerlink" title="p7: undefined reference to `HMAC_CTX_new’"></a>p7: undefined reference to `HMAC_CTX_new’</h2><pre><code class="hljs shell">running buildrunning build_ext<span class="hljs-meta">[100%</span><span class="bash">] Built target cython_rados</span>../lib/libcommon.a(Crypto.cc.o): In function `ceph::crypto::ssl::HMAC::HMAC(evp_md_st const*, unsigned char const*, unsigned long)&#x27;:/home/ceph/ceph-14.2.4/src/common/ceph_crypto.h:284: undefined reference to `HMAC_CTX_new&#x27;../lib/libcommon.a(Crypto.cc.o): In function `ceph::crypto::ssl::HMAC::~HMAC()&#x27;:/home/ceph/ceph-14.2.4/src/common/ceph_crypto.h:291: undefined reference to `HMAC_CTX_free&#x27;../lib/libcommon.a(ceph_crypto.cc.o): In function `ceph::crypto::ssl::OpenSSLDigest::OpenSSLDigest(evp_md_st const*)&#x27;:/home/ceph/ceph-14.2.4/src/common/ceph_crypto.cc:94: undefined reference to `EVP_MD_CTX_new&#x27;../lib/libcommon.a(ceph_crypto.cc.o): In function `ceph::crypto::ssl::OpenSSLDigest::~OpenSSLDigest()&#x27;:/home/ceph/ceph-14.2.4/src/common/ceph_crypto.cc:100: undefined reference to `EVP_MD_CTX_free&#x27;collect2: error: ld returned 1 exit statussrc/CMakeFiles/ceph-osd.dir/build.make:145: recipe for target &#x27;bin/ceph-osd&#x27; failedmake[3]: *** [bin/ceph-osd] Error 1CMakeFiles/Makefile2:1256: recipe for target &#x27;src/CMakeFiles/ceph-osd.dir/all&#x27; failedmake[2]: *** [src/CMakeFiles/ceph-osd.dir/all] Error 2CMakeFiles/Makefile2:804: recipe for target &#x27;src/CMakeFiles/vstart-base.dir/rule&#x27; failedmake[1]: *** [src/CMakeFiles/vstart-base.dir/rule] Error 2Makefile:318: recipe for target &#x27;vstart-base&#x27; failedmake: *** [vstart-base] Error 2</code></pre><p>解决方法</p><p><code>sudo apt-get install libssl-dev</code></p><h2 id="p8-缺失curl库"><a href="#p8-缺失curl库" class="headerlink" title="p8: 缺失curl库"></a>p8: 缺失curl库</h2><pre><code class="hljs shell">/home/ceph/ceph-14.2.4/src/rgw/rgw_http_client_curl.cc:7:10: fatal error: curl/curl.h: No such file or directory    7 | #include &lt;curl/curl.h&gt;      |          ^~~~~~~~~~~~~compilation terminated.</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> apt install libcurl<span class="hljs-number">4</span>-gnutls</code></pre><h2 id="p9-缺失yaml库"><a href="#p9-缺失yaml库" class="headerlink" title="p9: 缺失yaml库"></a>p9: 缺失yaml库</h2><pre><code class="hljs angelscript">Best match: PyYAML <span class="hljs-number">5.3</span><span class="hljs-number">.1</span>Processing PyYAML<span class="hljs-number">-5.3</span><span class="hljs-number">.1</span>.tar.gzWriting /tmp/easy_install-_fQ46U/PyYAML<span class="hljs-number">-5.3</span><span class="hljs-number">.1</span>/setup.cfgRunning PyYAML<span class="hljs-number">-5.3</span><span class="hljs-number">.1</span>/setup.py -q bdist_egg --dist-dir /tmp/easy_install-_fQ46U/PyYAML<span class="hljs-number">-5.3</span><span class="hljs-number">.1</span>/egg-dist-tmp-ZSDHMjIn file included <span class="hljs-keyword">from</span> ext/_yaml.c:<span class="hljs-number">596</span>:ext/_yaml.h:<span class="hljs-number">2</span>:<span class="hljs-number">10</span>: fatal error: yaml.h: No such file <span class="hljs-keyword">or</span> directory    <span class="hljs-number">2</span> | #include &lt;yaml.h&gt;      |          ^~~~~~~~</code></pre><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install libyaml-cpp-<span class="hljs-built_in">dev</span></code></pre><h2 id="p10-缺失sdt库"><a href="#p10-缺失sdt库" class="headerlink" title="p10. 缺失sdt库"></a>p10. 缺失sdt库</h2><pre><code class="hljs yaml"><span class="hljs-attr">sys/sdt.h:</span> <span class="hljs-literal">No</span> <span class="hljs-string">such</span> <span class="hljs-string">file</span> <span class="hljs-string">or</span> <span class="hljs-string">directory</span>   <span class="hljs-number">111</span> <span class="hljs-string">|</span> <span class="hljs-comment">#include &lt;sys/sdt.h&gt;</span></code></pre><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> systemtap-sdt-dev</code></pre><h2 id="p11-undefined-reference-to-symbol-‘HMAC-CTX-new-OPENSSL-1-1-0’，用python2编译会出现这个问题"><a href="#p11-undefined-reference-to-symbol-‘HMAC-CTX-new-OPENSSL-1-1-0’，用python2编译会出现这个问题" class="headerlink" title="p11:undefined reference to symbol ‘HMAC_CTX_new@@OPENSSL_1_1_0’，用python2编译会出现这个问题"></a>p11:undefined reference to symbol ‘HMAC_CTX_new@@OPENSSL_1_1_0’，用python2编译会出现这个问题</h2><pre><code class="hljs shell">/usr/bin/ld: warning: libcrypto.so.1.1, needed by /usr/lib/x86_64-linux-gnu/librabbitmq.so, may conflict with libcrypto.so.1.0.0/usr/bin/ld: ../../lib/librgw_a.a(rgw_common.cc.o): undefined reference to symbol &#x27;HMAC_CTX_new@@OPENSSL_1_1_0&#x27;//usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: error adding symbols: DSO missing from command linecollect2: error: ld returned 1 exit status</code></pre><p>OPENSSL有两个版本的库，1.1和1.0.0，很显然我系统安装的是<code>1.1.1</code> 导致冲突了，</p><blockquote><p>Makefile 选项 CFLAGS 、LDFLAGS 、LIBS<br>CFLAGS 表示用于C编译器的选项<br>CXXFLAGS 表示用于C++编译器的选项<br>这两个变量实际上涵盖了编译和汇编的两个步骤</p></blockquote><p>CFLAGS：指定头文件(.h)的路径，如：CFLAGS=-I/usr/include -I/path/include 。</p><p>相同地，安装一个包时会在安装路径下建立一个include文件夹，当安装过程中出现故障时，试着把曾经安装的包的include文件夹增加到该变量中来。</p><p>LDFLAGS：gcc 等编译器会用到的一些优化參数，也能够在里面指定库文件的位置。</p><p>使用方法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。每安装一个包都差点儿一定的会在安装文件夹里建立一个lib文件夹。假设明明安装了某个包，而安装还有一个包时，它愣是说找不到，能够抒那个包的lib路径增加的LDFALGS中试一下。</p><p>LIBS：告诉链接器要链接哪些库文件。如LIBS = -lpthread -liconv</p><p>简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。</p><p>有时候LDFLAGS指定-L尽管能让链接器找到库进行链接。可是运行时链接器却找不到这个库。假设要让软件运行时库文件的路径也得到扩展，那么我们须要增加这两个库给”-Wl,R”：</p><p>LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib<br>假设在运行./configure曾经环境变量设置export LDFLAGS=”-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib” ，注意环境变量设置等号两边不能够有空格，并且要加上引號（shell的使用方法）。那么运行configure以后。Makefile将会设置这个选项。链接时会有这个參数，编译出来的可运行程序的库文件搜索路径就得到扩展了。</p><p><a href="https://www.cnblogs.com/fqnb001/p/8778790.html">什么是软链接，硬链接</a></p><p><a href="https://blog.csdn.net/qq_37806908/article/details/97686753">linux .so .o .a文件区别</a></p><p>​     .o,是目标文件,相当于windows中的.obj文件 </p><p>　.so 为共享库,是shared object,用于动态连接的,相当于windows下的dll </p><p>　.a为静态库,是好多个.o合在一起,用于静态连接 </p><p><code>sudo ll &#123;文件名&#125;</code> 查看所有链接</p><p><code>$sudo unlink libcrypto.so</code>解链接, so表示</p><p><code>$sudo ln -s libcrypto.so.1.1 libcrypto.so</code> 添加链接</p><p>如何查看openssl版本?</p><p><code>openssl version -a</code></p><p>ubuntu默认安装1.1.1，没事别卸载，否则很多功能会失效，比如chrome</p><h2 id="p12-Make-all-出现ELF-section-name-out-of-range"><a href="#p12-Make-all-出现ELF-section-name-out-of-range" class="headerlink" title="p12. Make all 出现ELF section name out of range"></a>p12. Make all 出现ELF section name out of range</h2><pre><code class="hljs stata">/usr/bin/ld: warning: CMakeFiles/unittest_rbd_mirror.<span class="hljs-keyword">dir</span>/test_mock_ImageReplayer.<span class="hljs-keyword">cc</span>.o has a corrupt string <span class="hljs-keyword">table</span> index - ignoring/usr/bin/ld: <span class="hljs-keyword">error</span>: CMakeFiles/unittest_rbd_mirror.<span class="hljs-keyword">dir</span>/test_mock_ImageReplayer.<span class="hljs-keyword">cc</span>.o: ELF section name <span class="hljs-keyword">out</span> of <span class="hljs-keyword">range</span>collect2: <span class="hljs-keyword">error</span>: ld returned 1 <span class="hljs-keyword">exit</span> statussrc/<span class="hljs-keyword">test</span>/rbd_mirror/CMakeFiles/unittest_rbd_mirror.<span class="hljs-keyword">dir</span>/build.make:951: recipe <span class="hljs-keyword">for</span> target &#x27;bin/unittest_rbd_mirror&#x27; failedmake[2]: *** [bin/unittest_rbd_mirror] <span class="hljs-keyword">Error</span> 1CMakeFiles/Makefile2:26032: recipe <span class="hljs-keyword">for</span> target &#x27;src/<span class="hljs-keyword">test</span>/rbd_mirror/CMakeFiles/unittest_rbd_mirror.<span class="hljs-keyword">dir</span>/all&#x27; failedmake[1]: *** [src/<span class="hljs-keyword">test</span>/rbd_mirror/CMakeFiles/unittest_rbd_mirror.<span class="hljs-keyword">dir</span>/all] <span class="hljs-keyword">Error</span> 2</code></pre><p>直接重新make就好了，玄学问题</p><h2 id="P13-internal-compiler-error-Segmentation-fault"><a href="#P13-internal-compiler-error-Segmentation-fault" class="headerlink" title="P13:internal compiler error: Segmentation fault"></a>P13:internal compiler error: Segmentation fault</h2><pre><code class="hljs gradle"><span class="hljs-regexp">/home/</span>ceph-server<span class="hljs-regexp">/ceph-15.2.5/</span>src<span class="hljs-regexp">/osd/</span>ECBackend.cc: In member function ‘<span class="hljs-keyword">void</span> ECBackend::filter_read_op(const OSDMapRef&amp;, ECBackend::ReadOp&amp;)’:<span class="hljs-regexp">/home/</span>ceph-server<span class="hljs-regexp">/ceph-15.2.5/</span>src<span class="hljs-regexp">/osd/</span>ECBackend.cc:<span class="hljs-number">1398</span>:<span class="hljs-number">1</span>: internal compiler error: Segmentation fault <span class="hljs-number">1398</span> | &#125;      | ^Please submit a full bug report,with preprocessed <span class="hljs-keyword">source</span> <span class="hljs-keyword">if</span> appropriate.</code></pre><p>重新编译</p><hr><h1 id="C-Way-to-development…"><a href="#C-Way-to-development…" class="headerlink" title="C. Way to development…"></a>C. <em>Way to development…</em></h1><p>好的在这里假设你编译源码成功了！</p><p>先不要庆祝</p><p>好戏才刚刚开始！</p><h2 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h2><pre><code class="hljs shell">../src/vstart.sh --debug --new -x --localhost --bluestore # 启动本地集群 采用bluestore对象存储./bin/ceph -s #返回集群状态</code></pre><p>注：./bin文件，前面只有一个点，你所有能运行的脚本都在这，大部分都无法直接修改！</p><p>笔者运行没有遇到问题，有一些问题可以在<a href="https://blog.csdn.net/qq_40071358/article/details/106924184">这儿</a>找到答案。</p><p>如果没有问题，笔者得到的输出应该如下，你的也应该类似：</p><pre><code class="hljs angelscript">*** DEVELOPER MODE: setting PATH, PYTHONPATH <span class="hljs-keyword">and</span> LD_LIBRARY_PATH ***<span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span>T09:<span class="hljs-number">50</span>:<span class="hljs-number">54.832</span>+<span class="hljs-number">0800</span> <span class="hljs-number">7f</span>1160a3b700 <span class="hljs-number">-1</span> WARNING: all dangerous <span class="hljs-keyword">and</span> experimental features are enabled.<span class="hljs-number">2020</span><span class="hljs-number">-10</span><span class="hljs-number">-31</span>T09:<span class="hljs-number">50</span>:<span class="hljs-number">54.844</span>+<span class="hljs-number">0800</span> <span class="hljs-number">7f</span>1160a3b700 <span class="hljs-number">-1</span> WARNING: all dangerous <span class="hljs-keyword">and</span> experimental features are enabled.  cluster:    id:     <span class="hljs-number">773</span>a0719<span class="hljs-number">-3</span>ed0<span class="hljs-number">-49f</span>a-a168<span class="hljs-number">-88</span>bd2ddc2d00    health: HEALTH_OK   services:    mon: <span class="hljs-number">3</span> daemons, quorum a,b,c (age <span class="hljs-number">99</span>s)    mgr: x(active, since <span class="hljs-number">91</span>s)    mds: a:<span class="hljs-number">1</span> &#123;<span class="hljs-number">0</span>=c=up:active&#125; <span class="hljs-number">2</span> up:standby    osd: <span class="hljs-number">3</span> osds: <span class="hljs-number">3</span> up (since <span class="hljs-number">66</span>s), <span class="hljs-number">3</span> <span class="hljs-keyword">in</span> (since <span class="hljs-number">66</span>s)   task status:    scrub status:        mds.c: idle   data:    pools:   <span class="hljs-number">3</span> pools, <span class="hljs-number">65</span> pgs    objects: <span class="hljs-number">22</span> objects, <span class="hljs-number">2.2</span> KiB    usage:   <span class="hljs-number">6.0</span> GiB used, <span class="hljs-number">297</span> GiB / <span class="hljs-number">303</span> GiB avail    pgs:     <span class="hljs-number">65</span> active+clean</code></pre><p><img src="\img\ceph-s.png" alt="image-20201031225553280"></p><p>可以看到mds和osd和mon进程，说明ceph cluster已经运行起来了。</p><pre><code class="hljs gradle">.<span class="hljs-regexp">/bin/</span>rados -p rbd bench <span class="hljs-number">30</span> <span class="hljs-keyword">write</span>.<span class="hljs-regexp">/bin/</span>rbd create foo --<span class="hljs-keyword">size</span> <span class="hljs-number">1000</span></code></pre><p>关闭一个cluster用：</p><pre><code class="hljs awk">..<span class="hljs-regexp">/src/</span>stop.sh</code></pre><p>启动和停止单独的守护进程，<code>sysvinit</code>脚本可以这样用：</p><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/i</span>nit-ceph restart osd.<span class="hljs-number">0</span>.<span class="hljs-regexp">/bin/i</span>nit-ceph stop</code></pre><p>如果要build并且进行所有测试</p><p>需要全部build，这是极其耗费时间和磁盘的（保守估计要100G以上）。</p><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> make -j<span class="hljs-number">8</span> <span class="hljs-attribute">sudo</span> ctest -j<span class="hljs-number">8</span></code></pre><p>如果有错误，会在CLI打印出来：</p><pre><code class="hljs angelscript"><span class="hljs-number">95</span>% tests passed, <span class="hljs-number">9</span> tests failed <span class="hljs-keyword">out</span> of <span class="hljs-number">192</span>Total Test time (real) = <span class="hljs-number">579.44</span> secThe following tests FAILED:<span class="hljs-number">111</span> - readable.sh (Failed)<span class="hljs-number">177</span> - unittest_rgw_dmclock_scheduler (Failed)<span class="hljs-number">184</span> - unittest_rbd_mirror (Not Run)<span class="hljs-number">186</span> - unittest_seastar_denc (Not Run)<span class="hljs-number">187</span> - unittest_seastar_socket (Not Run)<span class="hljs-number">188</span> - unittest_seastar_messenger (Not Run)<span class="hljs-number">189</span> - unittest_seastar_thread_pool (Not Run)<span class="hljs-number">190</span> - unittest_seastar_perfcounters (Not Run)<span class="hljs-number">191</span> - unittest_seastar_lru (Not Run)Errors <span class="hljs-keyword">while</span> running CTest</code></pre><p>如果想进行单个测试，在/bin文件夹运行对应文件，比如：</p><pre><code class="hljs awk">sudo .<span class="hljs-regexp">/bin/u</span>nittest_rbd_mirror</code></pre><p>如果没有问题，应该是我这样的：</p><pre><code class="hljs angelscript"><span class="hljs-number">99</span>% tests passed, <span class="hljs-number">2</span> tests failed <span class="hljs-keyword">out</span> of <span class="hljs-number">192</span>Total Test time (real) = <span class="hljs-number">488.16</span> secThe following tests FAILED:<span class="hljs-number">111</span> - readable.sh (Failed)<span class="hljs-number">177</span> - unittest_rgw_dmclock_scheduler (Failed)Errors <span class="hljs-keyword">while</span> running CTest</code></pre><p>上面报错，是因为它们是trivial的，dmclock的api甚至还没开发出来。emoji~</p><hr><h2 id="调试集群，添加日志"><a href="#调试集群，添加日志" class="headerlink" title="调试集群，添加日志"></a>调试集群，添加日志</h2><p>我们可以在配置文件针对特定模块生成调试日志。但这可能产生超过1GB的日志文件。调试会影响集群的性能。</p><p>所以必须保证你磁盘有足够的空间。</p><h3 id="实时显示"><a href="#实时显示" class="headerlink" title="实时显示"></a>实时显示</h3><p>如果你希望看到实时调试信息，你必须登录到一台主机上执行：</p><pre><code class="hljs routeros">ceph daemon &#123;daemon-name&#125;<span class="hljs-built_in"> config </span>show | less</code></pre><p>例如</p><pre><code class="hljs routeros">ceph daemon osd.0<span class="hljs-built_in"> config </span>show | less</code></pre><p>为了激活调试输出，使用<code>ceph tell</code>:</p><pre><code class="hljs routeros">ceph tell &#123;daemon-type&#125;.&#123;daemon id <span class="hljs-keyword">or</span> *&#125;<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> &#123;name&#125; &#123;value&#125;</code></pre><p>daemon-type为mds,mon,osd之一。该命令通过监视器。如果您无法绑定到监视器，则仍然可以通过使用来登录要更改其配置的守护程序的主机，以进行更改。</p><p>例如</p><pre><code class="hljs routeros">ceph tell osd.0<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> debug_osd 0/5</code></pre><h3 id="启动时调试"><a href="#启动时调试" class="headerlink" title="启动时调试"></a>启动时调试</h3><p>可以在global设置设定</p><pre><code class="hljs routeros">[global]        <span class="hljs-builtin-name">debug</span> ms = 1/5[mon]        <span class="hljs-builtin-name">debug</span> mon = 20        <span class="hljs-builtin-name">debug</span> paxos = 1/5        <span class="hljs-builtin-name">debug</span> auth = 2[osd]        <span class="hljs-builtin-name">debug</span> osd = 1/5        <span class="hljs-builtin-name">debug</span> filestore = 1/5        <span class="hljs-builtin-name">debug</span> journal = 1        <span class="hljs-builtin-name">debug</span> monc = 5/20[mds]        <span class="hljs-builtin-name">debug</span> mds = 1        <span class="hljs-builtin-name">debug</span> mds balancer = 1</code></pre><h3 id="加速日志选择"><a href="#加速日志选择" class="headerlink" title="加速日志选择"></a>加速日志选择</h3><p>如果您的操作系统磁盘相对较满，则可以通过在处修改Ceph日志轮换文件来加速日志轮换<code>/etc/logrotate.d/ceph</code>。如果日志超过大小设置，请在旋转频率之后添加大小设置以加速日志旋转（通过cronjob）。例如，默认设置如下所示：</p><pre><code class="hljs stata"><span class="hljs-keyword">rotate</span> 7weekly<span class="hljs-keyword">compress</span>sharedscripts</code></pre><p>通过添加<code>size</code>设置进行修改。</p><pre><code class="hljs angelscript">rotate <span class="hljs-number">7</span>weeklysize <span class="hljs-number">500</span>Mcompresssharedscripts</code></pre><p>然后，为您的用户空间启动crontab编辑器。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">crontab -e</span></code></pre><p>最后，添加一个条目以检查<code>etc/logrotate.d/ceph</code>文件。</p><pre><code class="hljs basic"><span class="hljs-symbol">30 </span>* * * * /<span class="hljs-keyword">usr</span>/sbin/logrotate /etc/logrotate.d/ceph &gt;/dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span></code></pre><p>前面的示例<code>etc/logrotate.d/ceph</code>每30分钟检查一次文件。</p><h3 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h3><p>调试可能还需要您跟踪内存和线程问题。您可以使用Valgrind运行单个守护程序，一种守护程序或整个集群。您仅应在开发或调试Ceph时使用Valgrind。Valgrind在计算上很昂贵，否则会降低您的系统速度。Valgrind消息已记录到<code>stderr</code>。</p><h3 id="子系统，日志和调试设置"><a href="#子系统，日志和调试设置" class="headerlink" title="子系统，日志和调试设置"></a>子系统，日志和调试设置</h3><p>每个子系统都有其输出日志和内存中日志的日志记录级别。通过为调试日志记录设置日志文件级别和内存级别，可以为每个子系统设置不同的值。Ceph的日志记录级别以1到20，1最为简洁，20最为冗余。</p><p>调试日志记录设置可以为日志级别和内存级别采用单个值，这会将它们设置为相同的值。例如，如果您指定，则Ceph会将其视为日志级别和内存级别。您也可以单独指定它们。<strong>第一个设置是日志级别，第二个设置是内存级别</strong>。您必须使用正斜杠（/）分隔它们。例如，如果要将子系统的调试日志记录级别设置为，将其内存级别设置为，则可以将其指定为。例如：<code>debug ms = 1/5</code></p><pre><code class="hljs pgsql"><span class="hljs-keyword">debug</span> &#123;subsystem&#125; = &#123;<span class="hljs-keyword">log</span>-<span class="hljs-keyword">level</span>&#125;/&#123;memory-<span class="hljs-keyword">level</span>&#125;<span class="hljs-meta">#for example</span><span class="hljs-keyword">debug</span> mds balancer = <span class="hljs-number">1</span>/<span class="hljs-number">20</span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">Subsystem</th><th style="text-align:left">Log Level</th><th style="text-align:left">Memory Level</th></tr></thead><tbody><tr><td style="text-align:left"><code>default</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>lockdep</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>context</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>crush</code></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>mds</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mds balancer</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mds locker</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mds log</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mds log expire</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mds migrator</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>buffer</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>timer</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>filer</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>striper</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>objecter</code></td><td style="text-align:left">0</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>rados</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>rbd</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>rbd mirror</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>rbd replay</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>journaler</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>objectcacher</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>client</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>osd</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>optracker</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>objclass</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>filestore</code></td><td style="text-align:left">1</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><code>journal</code></td><td style="text-align:left">1</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><code>ms</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mon</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>monc</code></td><td style="text-align:left">0</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left"><code>paxos</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>tp</code></td><td style="text-align:left">0</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>auth</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>crypto</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>finisher</code></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>reserver</code></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>heartbeatmap</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>perfcounter</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>rgw</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>rgw sync</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>civetweb</code></td><td style="text-align:left">1</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left"><code>javaclient</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>asok</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>throttle</code></td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><code>refs</code></td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left"><code>compressor</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>bluestore</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>bluefs</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>bdev</code></td><td style="text-align:left">1</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><code>kstore</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>rocksdb</code></td><td style="text-align:left">4</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>leveldb</code></td><td style="text-align:left">4</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>memdb</code></td><td style="text-align:left">4</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>fuse</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mgr</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>mgrc</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>dpdk</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left"><code>eventtrace</code></td><td style="text-align:left">1</td><td style="text-align:left">5</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Parameters</th><th>Descrip.</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>log file</td><td>The location of the logging file for your cluster.</td><td>String</td><td>/var/log/ceph/\$cluster-\$name.log</td></tr><tr><td>log max new</td><td>The maximum number of recent events to include in a log file.</td><td>Integer</td><td>10000</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><h2 id="操作集群的三种方法"><a href="#操作集群的三种方法" class="headerlink" title="操作集群的三种方法"></a>操作集群的三种方法</h2><h2 id="1-Systemd-（推荐）"><a href="#1-Systemd-（推荐）" class="headerlink" title="1.Systemd.（推荐）"></a>1.Systemd.（推荐）</h2><p>Systemd 是 Linux 系统工具，用来启动<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">守护进程</a>，已成为大多数发行版的标准配置。包括启动，检查，列举systemd，以及停止。</p><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> systemctl start ceph.target       <span class="hljs-comment"># start all daemons</span>sudo systemctl status ceph-osd@<span class="hljs-number">12</span>      <span class="hljs-comment"># check status of osd.12</span>sudo systemctl status ceph\<span class="hljs-regexp">*.service</span> ceph\<span class="hljs-regexp">*.target</span> <span class="hljs-comment"># list the Ceph systemd units on a node</span>sudo systemctl stop ceph\<span class="hljs-regexp">*.service</span> ceph\<span class="hljs-regexp">*.target</span> <span class="hljs-comment">#stop all the daemons</span></code></pre><p>如果要启动一个节点上所有特定类型的守护进程。执行下面一个即可：</p><pre><code class="hljs aspectj">sudo systemctl start ceph-osd.<span class="hljs-keyword">target</span>sudo systemctl start ceph-mon.<span class="hljs-keyword">target</span>sudo systemctl start ceph-mds.<span class="hljs-keyword">target</span></code></pre><h2 id="2-Upstart"><a href="#2-Upstart" class="headerlink" title="2.Upstart"></a>2.Upstart</h2><h3 id="启动守护进程"><a href="#启动守护进程" class="headerlink" title="启动守护进程"></a>启动守护进程</h3><p>要在Ceph节点上启动特定的守护程序实例，请执行以下操作之一：</p><pre><code class="hljs sql">sudo <span class="hljs-keyword">start</span> ceph-<span class="hljs-keyword">all</span>sudo <span class="hljs-keyword">start</span> ceph-osd <span class="hljs-keyword">id</span>=&#123;<span class="hljs-keyword">id</span>&#125;sudo <span class="hljs-keyword">start</span> ceph-mon <span class="hljs-keyword">id</span>=&#123;hostname&#125;sudo <span class="hljs-keyword">start</span> ceph-mds <span class="hljs-keyword">id</span>=&#123;hostname&#125;sudo <span class="hljs-keyword">start</span> ceph-osd-<span class="hljs-keyword">all</span>sudo <span class="hljs-keyword">start</span> ceph-mon-<span class="hljs-keyword">all</span>sudo <span class="hljs-keyword">start</span> ceph-mds-<span class="hljs-keyword">all</span></code></pre><h3 id="停止守护程序"><a href="#停止守护程序" class="headerlink" title="停止守护程序"></a>停止守护程序</h3><p>要在Ceph节点上停止特定的守护程序实例，请执行以下操作之一：</p><pre><code class="hljs sql">sudo <span class="hljs-keyword">stop</span> ceph-<span class="hljs-keyword">all</span>sudo <span class="hljs-keyword">stop</span> ceph-osd <span class="hljs-keyword">id</span>=&#123;<span class="hljs-keyword">id</span>&#125;sudo <span class="hljs-keyword">stop</span> ceph-mon <span class="hljs-keyword">id</span>=&#123;hostname&#125;sudo <span class="hljs-keyword">stop</span> ceph-mds <span class="hljs-keyword">id</span>=&#123;hostname&#125;sudo <span class="hljs-keyword">stop</span> ceph-osd-<span class="hljs-keyword">all</span>sudo <span class="hljs-keyword">stop</span> ceph-mon-<span class="hljs-keyword">all</span>sudo <span class="hljs-keyword">stop</span> ceph-mds-<span class="hljs-keyword">all</span></code></pre><h2 id="3-Sysvinit"><a href="#3-Sysvinit" class="headerlink" title="3.Sysvinit"></a>3.Sysvinit</h2><p>每次<strong>启动</strong>，<strong>重新启动</strong>和 <strong>停止</strong>Ceph守护程序（或整个集群）时，都必须至少指定一个选项和一个命令。您也可以指定守护程序类型或守护程序实例。</p><pre><code class="hljs clojure">&#123;commandline&#125; [options] [commands] [daemons]</code></pre><p>该<code>ceph</code>选项包括：</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">捷径</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>--verbose</code></td><td style="text-align:left"><code>-v</code></td><td style="text-align:left">使用详细日志记录。</td></tr><tr><td style="text-align:left"><code>--valgrind</code></td><td style="text-align:left"><code>N/A</code></td><td style="text-align:left">（仅限Dev和QA）使用<a href="http://www.valgrind.org/">Valgrind</a>调试。</td></tr><tr><td style="text-align:left"><code>--allhosts</code></td><td style="text-align:left"><code>-a</code></td><td style="text-align:left">在<code>ceph.conf.</code> 否则的所有节点上执行，否则仅在上执行<code>localhost</code>。</td></tr><tr><td style="text-align:left"><code>--restart</code></td><td style="text-align:left"><code>N/A</code></td><td style="text-align:left">如果核心转储，则自动重新启动守护程序。</td></tr><tr><td style="text-align:left"><code>--norestart</code></td><td style="text-align:left"><code>N/A</code></td><td style="text-align:left">如果守护程序发生核心转储，请不要重新启动它。</td></tr><tr><td style="text-align:left"><code>--conf</code></td><td style="text-align:left"><code>-c</code></td><td style="text-align:left">使用备用配置文件。</td></tr></tbody></table></div><p>这些<code>ceph</code>命令包括：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>start</code></td><td style="text-align:left">启动守护程序。</td></tr><tr><td style="text-align:left"><code>stop</code></td><td style="text-align:left">停止守护程序。</td></tr><tr><td style="text-align:left"><code>forcestop</code></td><td style="text-align:left">强制守护程序停止。与…一样<code>kill -9</code></td></tr><tr><td style="text-align:left"><code>killall</code></td><td style="text-align:left">杀死所有特定类型的守护程序。</td></tr><tr><td style="text-align:left"><code>cleanlogs</code></td><td style="text-align:left">清除日志目录。</td></tr><tr><td style="text-align:left"><code>cleanalllogs</code></td><td style="text-align:left">清除日志目录中的<strong>所有内容</strong>。</td></tr></tbody></table></div><p>对于子系统操作，<code>ceph</code>服务可以通过为<code>[daemons]</code>选项添加特定的守护程序类型来定位特定的守护程序类型。守护程序类型包括：</p><ul><li><code>mon</code></li><li><code>osd</code></li><li><code>mds</code></li></ul><hr><h2 id="了解ceph的健康状况"><a href="#了解ceph的健康状况" class="headerlink" title="了解ceph的健康状况"></a>了解ceph的健康状况</h2><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><div class="table-container"><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">定义</th><th>建议</th></tr></thead><tbody><tr><td style="text-align:center">MON_DOWN</td><td style="text-align:center">当前有一个或多个监视守护程序已关闭。该群集需要大多数（超过1/2）的监视器才能正常运行。当一个或多个监视器关闭时，客户端可能很难与群集建立初始连接，因为它们可能需要尝试更多地址才能到达运行中的监视器。</td><td>通常，应该尽快重新启动关闭监视器的守护程序，以减少子监视器失败导致服务中断的风险。</td></tr><tr><td style="text-align:center">MON_CLOCK_SKEW</td><td style="text-align:center">运行ceph-mon监视器守护程序的主机上的时钟同步不够充分。如果群集检测到时钟偏差大于，则会发出此健康警报<code>mon_clock_drift_allowed</code>。</td><td>最好使用诸如<code>ntpd</code>或的工具同步时钟来解决 <code>chrony</code>。</td></tr><tr><td style="text-align:center">MON_MSGR2_NOT_ENABLED</td><td style="text-align:center">该<code>ms_bind_msgr2</code>选项已启用，但未将一个或多个监视器配置为绑定到群集monmap中的v2端口。这意味着特定于msgr2协议的功能（例如，加密）在某些或所有连接上不可用。</td><td><code>ceph mon enable-msgr2</code>该命令将更改为旧的默认端口6789配置的任何监视器，以继续侦听6789上的v1连接，并继续侦听新的默认3300端口上的v2连接。</td></tr><tr><td style="text-align:center">MON_DISK_LOW \MON_DISK_CRIT</td><td style="text-align:center">一台或多台监视器的磁盘空间不足。如果存储监视器数据库的文件系统上的可用空间（通常<code>/var/lib/ceph/mon</code>为百分比）降低至以下百分比<code>mon_data_avail_warn</code>（默认值：30％）， 则将触发此警报。</td><td>请通过诸如清理日志文件的方式来增加空间，或者进行扩容。</td></tr><tr><td style="text-align:center">MON_DISK_BIG</td><td style="text-align:center">如果监视器数据库的大小大于<code>mon_data_size_warn</code>（默认值：15 GiB），则会触发此警报 。</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><div class="table-container"><table><thead><tr><th>状态</th><th>定义</th><th>建议</th></tr></thead><tbody><tr><td>MGR_DOWN</td><td>当前所有管理器守护程序都已关闭。</td><td>应尽快重新启动停机管理器守护程序，以确保可以监视群集。</td></tr><tr><td>MGR_MODULE_DEPENDENCY</td><td>已启用的管理器模块未能通过依赖关系检查。此运行状况检查应随附来自模块的有关该问题的解释性消息</td><td></td></tr><tr><td>MGR_MODULE_ERROR</td><td>管理器模块遇到意外错误。</td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h3 id="OSD"><a href="#OSD" class="headerlink" title="OSD"></a>OSD</h3><div class="table-container"><table><thead><tr><th>状态</th><th>定义</th><th>解决</th></tr></thead><tbody><tr><td>OSD_DOWN</td><td>标记了一个或多个OSD。ceph-osd守护程序可能已停止，或者对等OSD可能无法通过网络访问OSD。</td><td></td></tr><tr><td>OSD_ <CRUSH_TYPE> _DOWN</td><td></td><td></td></tr><tr><td>OSD_ORPHAN</td><td>OSD在CRUSH映射层次结构中被引用，但不存在。</td><td>可以使用以下方法从CRUSH层次结构中删除OSD：ceph osd crush rm osd</td></tr><tr><td>OSD_OUT_OF_ORDER_FULL</td><td>Nearfull，backfillfull，full和/或failsafe_full的利用率阈值并非升序</td><td></td></tr><tr><td>OSD_FULL</td><td>一个或多个OSD超出了整个阈值，并正在阻止群集为写入提供服务。</td><td></td></tr><tr><td>OSD_BACKFILLFULL</td><td></td><td></td></tr><tr><td>OSD_NEARFULL</td><td></td><td></td></tr><tr><td>OSDMAP_FLAGS</td><td>已设置一个或多个感兴趣的群集标志。这些标志包括：</td><td></td></tr><tr><td>OSD_FLAGS</td><td>一个或多个OSD或CRUSH {nodes，device classes}已设置了关注标记</td><td></td></tr><tr><td>POOL_FULL</td><td>一个或多个池已达到其配额，并且不再允许写入。</td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h3 id="BlueStore"><a href="#BlueStore" class="headerlink" title="BlueStore"></a>BlueStore</h3><div class="table-container"><table><thead><tr><th>BLUEFS_SPILLOVER</th><th>已经为使用BlueStore后端的一个或多个OSD分配了 db分区（用于元数据的存储空间，通常在较快的设备上），但是该空间已满，因此元数据已“溢出”到正常的慢速设备上。</th><th></th></tr></thead><tbody><tr><td>BLUEFS_AVAILABLE_SPACE</td><td></td><td></td></tr><tr><td>BLUEFS_LOW_SPACE</td><td></td><td></td></tr><tr><td>BLUESTORE_FRAGMENTATION</td><td></td><td></td></tr><tr><td>BLUESTORE_LEGACY_STATFS</td><td></td><td></td></tr><tr><td>BLUESTORE_NO_PER_POOL_OMAP</td><td>从Octopus版本开始，BlueStore按池跟踪omap空间利用率，并且一个或多个OSD具有在Octopus之前创建的卷。</td><td></td></tr><tr><td>BLUESTORE_DISK_SIZE_MISMATCH</td><td>使用BlueStore的一个或多个OSD在物理设备的大小和跟踪其大小的元数据之间存在内部不一致。将来可能导致OSD崩溃</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><p>OSDMAP_FLAGS</p><ul><li><em>full</em>-群集被标记为已满，无法处理写入</li><li><em>pauserd</em>，<em>pausewr-</em>暂停的读取或写入</li><li><em>noup</em> -OSD不允许启动</li><li><em>nodown</em> -OSD故障报告被忽略，因此监视器不会将OSD标记为故障</li><li>noin-以前标记屏上显示出来，不会标示后面的，当他们开始</li><li><em>noout-</em>在配置的间隔后，不会自动将向下的OSD标记出来</li><li><em>nobackfill</em>，<em>norecover</em>，<em>norebalance-</em>恢复或数据重新平衡已暂停</li><li><em>noscrub</em>，<em>nodeep_scrub-</em>禁用清理</li><li><em>notieragent-</em>缓存分层活动已暂停</li></ul><p>除<em>full之外</em>，可以使用以下方式设置或清除这些标志：</p><pre><code class="hljs pf">ceph osd <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;flag&gt;</span>ceph osd unset <span class="hljs-variable">&lt;flag&gt;</span></code></pre><p>OSD_FLAGS</p><p>一个或多个OSD或CRUSH {nodes，device classes}已设置了关注标记。这些标志包括：</p><ul><li><em>noup</em>：这些OSD不允许启动</li><li><em>nodown</em>：这些OSD的故障报告将被忽略</li><li><em>noin</em>：如果以前在故障后自动将这些OSD标记出来，则它们在启动时将不会被标记</li><li><em>noout</em>：如果这些OSD处于关闭状态，则在配置的间隔后它们不会自动被标记 出来</li></ul><p>可以批量设置和清除这些标志：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-built_in">set-group</span> &lt;<span class="hljs-string">flags&gt;</span> &lt;<span class="hljs-string">who&gt;</span><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">unset-group </span>&lt;<span class="hljs-string">flags&gt;</span> &lt;<span class="hljs-string">who&gt;</span></code></pre><p>可以按以下方式检查池利用率：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph df</span></code></pre><p>当前定义的满比率可以通过以下方式看到：</p><pre><code class="hljs gradle">ceph osd <span class="hljs-keyword">dump</span> | <span class="hljs-keyword">grep</span> full_ratio</code></pre><p>可以通过以下方式查看池配额和利用率：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph df detail</span></code></pre><p>您可以使用以下方法提高池配额：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">pool </span><span class="hljs-built_in">set-quota</span> &lt;<span class="hljs-string">poolname&gt;</span> <span class="hljs-string">max_objects </span>&lt;<span class="hljs-string">num-objects&gt;</span><span class="hljs-string">ceph </span><span class="hljs-string">osd </span><span class="hljs-string">pool </span><span class="hljs-built_in">set-quota</span> &lt;<span class="hljs-string">poolname&gt;</span> <span class="hljs-string">max_bytes </span>&lt;<span class="hljs-string">num-bytes&gt;</span></code></pre><p>或删除一些现有数据以降低利用率。</p><p>要检查BlueFS有多少可用空间，请执行以下操作：</p><pre><code class="hljs mipsasm">ceph daemon osd.<span class="hljs-number">123</span> <span class="hljs-keyword">bluestore </span><span class="hljs-keyword">bluefs </span>available</code></pre><p>要模拟分配单位不同时的可用空间，请执行以下操作：</p><pre><code class="hljs arduino">ceph daemon osd<span class="hljs-number">.123</span> bluestore bluefs <span class="hljs-built_in">available</span> &lt;alloc-unit-<span class="hljs-built_in">size</span>&gt;</code></pre><p>要检查BlueStore碎片，可以执行以下操作：</p><pre><code class="hljs mipsasm">ceph daemon osd.<span class="hljs-number">123</span> <span class="hljs-keyword">bluestore </span>allocator <span class="hljs-keyword">score </span><span class="hljs-keyword">block</span></code></pre><p>如果需要详细的免费碎片报告，请执行以下操作：</p><pre><code class="hljs angelscript">ceph daemon osd<span class="hljs-number">.123</span> bluestore allocator dump block</code></pre><p>如果处理未运行的OSD进程时可以使用ceph-bluestore-tool检查碎片。获取碎片分数：</p><pre><code class="hljs crystal">ceph-bluestore-tool --path /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-123 --<span class="hljs-title">allocator</span> <span class="hljs-title">block</span> <span class="hljs-title">free</span>-<span class="hljs-title">score</span></span></code></pre><p>并转储详细的免费块：</p><pre><code class="hljs crystal">ceph-bluestore-tool --path /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-123 --<span class="hljs-title">allocator</span> <span class="hljs-title">block</span> <span class="hljs-title">free</span>-<span class="hljs-title">dump</span></span></code></pre><p>通过停止每个OSD，运行修复操作并重新启动它，可以将旧的OSD更新为按池跟踪。例如，如果<code>osd.123</code>需要更新，则 ：</p><pre><code class="hljs crystal">systemctl stop ceph-osd@<span class="hljs-number">123</span>ceph-bluestore-tool repair --path /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-123</span>systemctl start ceph-osd@<span class="hljs-number">123</span></code></pre><p>使用BlueStore的一个或多个OSD在物理设备的大小和跟踪其大小的元数据之间存在内部不一致。将来可能导致OSD崩溃。</p><p>相关的OSD应该销毁并重新配置。应当小心地一次执行一个OSD，并且这种方式不会使任何数据受到威胁。例如，如果osd<code>$N</code>出现错误，则：</p><pre><code class="hljs awk">ceph osd out osd.<span class="hljs-variable">$N</span><span class="hljs-keyword">while</span> ! ceph osd safe-to-destroy osd.<span class="hljs-variable">$N</span> ; <span class="hljs-keyword">do</span> sleep <span class="hljs-number">1</span>m ; doneceph osd destroy osd.<span class="hljs-variable">$N</span>ceph-volume lvm zap <span class="hljs-regexp">/path/</span>to/deviceceph-volume lvm create --osd-id <span class="hljs-variable">$N</span> --data <span class="hljs-regexp">/path/</span>to/device</code></pre><p>可以使用以下方法检查设备的运行状况：</p><pre><code class="hljs nginx"><span class="hljs-attribute">ceph</span> device <span class="hljs-literal">info</span> &lt;device-id&gt;</code></pre><p>设备预期寿命是由mgr或外部工具通过以下命令运行的预测模型设置的：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">device </span><span class="hljs-built_in">set-life-expectancy</span> &lt;<span class="hljs-string">device-id&gt;</span> &lt;<span class="hljs-string">from&gt;</span> &lt;<span class="hljs-string">to&gt;</span></code></pre><p>您可以手动更改存储的预期寿命，但这通常无法完成任何操作，因为最初设置的任何工具都可能会对其进行重新设置，并且更改存储的值不会影响硬件设备的实际运行状况。</p><hr><h2 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h2><p>所有 Ceph 集群都需要至少一个监视器、且 OSD 数量不小于副本数。自举引导初始监视器是部署 Ceph 存储集群的第一步，监视器的部署也为整个集群奠定了重要框架，如存储池副本数、每个 OSD 拥有的归置组数量（PG）、心跳周期、是否需认证等，其中大多数选项都有默认值，但是建设生产集群时仍需要您熟知它们。</p><p><img src="http://docs.ceph.org.cn/_images/ditaa-b67d58275cae03a5573d36907b437e36df685600.png" alt="img"></p><hr><h2 id="ceph-monitor配置"><a href="#ceph-monitor配置" class="headerlink" title="ceph monitor配置"></a>ceph monitor配置</h2><ol><li>登录到初始监视器节点：</li></ol><pre><code class="hljs puppet"><span class="hljs-keyword">ssh</span> &#123;<span class="hljs-built_in">hostname</span>&#125;</code></pre><p>如：</p><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> node<span class="hljs-number">1</span></code></pre><ol><li>确保保存 Ceph 配置文件的目录存在， Ceph 默认使用 <code>/etc/ceph</code> 。安装 <code>ceph</code> 软件时，安装器也会自动创建 <code>/etc/ceph/</code> 目录。</li></ol><pre><code class="hljs awk">ls <span class="hljs-regexp">/etc/</span>ceph</code></pre><ol><li>创建 Ceph 配置文件， Ceph 默认使用 <code>ceph.conf</code> ，其中的 <code>ceph</code> 是集群名字。</li></ol><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>ceph/ceph.conf</code></pre><ol><li>给集群分配惟一 ID （即 <code>fsid</code> ）。</li></ol><pre><code class="hljs ebnf"><span class="hljs-attribute">uuidgen</span></code></pre><ol><li>把此 ID 写入 Ceph 配置文件。</li></ol><pre><code class="hljs ini"><span class="hljs-attr">fsid</span> = &#123;UUID&#125;</code></pre><p>例如：</p><pre><code class="hljs apache"><span class="hljs-attribute">fsid</span> = a<span class="hljs-number">7</span>f<span class="hljs-number">64266</span>-<span class="hljs-number">0894</span>-<span class="hljs-number">4</span>f<span class="hljs-number">1</span>e-a<span class="hljs-number">635</span>-d<span class="hljs-number">0</span>aeaca<span class="hljs-number">0</span>e<span class="hljs-number">993</span></code></pre><ol><li>把初始监视器写入 Ceph 配置文件。</li></ol><pre><code class="hljs dust"><span class="xml">mon initial members = </span><span class="hljs-template-variable">&#123;hostname&#125;</span><span class="xml">[,</span><span class="hljs-template-variable">&#123;hostname&#125;</span><span class="xml">]</span></code></pre><p>例如：</p><pre><code class="hljs apache"><span class="hljs-attribute">mon</span> initial members = node<span class="hljs-number">1</span></code></pre><ol><li>把初始监视器的 IP 地址写入 Ceph 配置文件、并保存。</li></ol><pre><code class="hljs armasm"><span class="hljs-symbol">mon</span> host = &#123;<span class="hljs-built_in">ip</span>-address&#125;[,&#123;<span class="hljs-built_in">ip</span>-address&#125;]</code></pre><p>例如：</p><pre><code class="hljs angelscript">mon host = <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><p><strong>注意：</strong> 你也可以写 IPv6 地址，但是必须设置 <code>ms bind ipv6 = true</code> 。详情见<a href="http://docs.ceph.org.cn/rados/configuration/network-config-ref">网络配置参考</a>。</p><ol><li>为此集群创建密钥环、并生成监视器密钥。</li></ol><pre><code class="hljs dsconfig"><span class="hljs-string">ceph-authtool </span><span class="hljs-built_in">--create-keyring</span> /<span class="hljs-string">tmp/</span><span class="hljs-string">ceph.</span><span class="hljs-string">mon.</span><span class="hljs-string">keyring </span><span class="hljs-built_in">--gen-key</span> -n <span class="hljs-string">mon.</span> <span class="hljs-built_in">--cap</span> <span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow *&#x27;</span></code></pre><ol><li>生成管理员密钥环，生成 <code>client.admin</code> 用户并加入密钥环。</li></ol><pre><code class="hljs dsconfig"><span class="hljs-string">ceph-authtool </span><span class="hljs-built_in">--create-keyring</span> /<span class="hljs-string">etc/</span><span class="hljs-string">ceph/</span><span class="hljs-string">ceph.</span><span class="hljs-string">client.</span><span class="hljs-string">admin.</span><span class="hljs-string">keyring </span><span class="hljs-built_in">--gen-key</span> -n <span class="hljs-string">client.</span><span class="hljs-string">admin </span><span class="hljs-built_in">--set-uid=0</span> <span class="hljs-built_in">--cap</span> <span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-built_in">--cap</span> <span class="hljs-string">osd </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-built_in">--cap</span> <span class="hljs-string">mds </span><span class="hljs-string">&#x27;allow&#x27;</span></code></pre><p>10.把 <code>client.admin</code> 密钥加入 <code>ceph.mon.keyring</code> 。</p><pre><code class="hljs gradle">ceph-authtool <span class="hljs-regexp">/tmp/</span>ceph.mon.keyring --<span class="hljs-keyword">import</span>-keyring <span class="hljs-regexp">/etc/</span>ceph/ceph.client.admin.keyring</code></pre><ol><li><p>用规划好的主机名、对应 IP 地址、和 FSID 生成一个监视器图，并保存为 <code>/tmp/monmap</code> 。</p><pre><code class="hljs puppet">monmaptool --create --<span class="hljs-keyword">add</span> &#123;<span class="hljs-built_in">hostname</span>&#125; &#123;<span class="hljs-literal">ip</span>-address&#125; --<span class="hljs-keyword">fsid</span> &#123;<span class="hljs-built_in">uuid</span>&#125; /tmp/monmap</code></pre></li><li><p>在监视器主机上分别创建数据目录。</p></li></ol><p>详情见<a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref#data">监视器配置参考——数据</a>。</p><pre><code class="hljs crystal">sudo mkdir /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mon</span>/&#123;<span class="hljs-title">cluster</span>-<span class="hljs-title">name</span>&#125;-&#123;<span class="hljs-title">hostname</span>&#125;</span></code></pre><ol><li>用监视器图和密钥环组装守护进程所需的初始数据。</li></ol><pre><code class="hljs jboss-cli">ceph-mon [<span class="hljs-params">--cluster</span> &#123;cluster-name&#125;] <span class="hljs-params">--mkfs</span> -i &#123;hostname&#125; <span class="hljs-params">--monmap</span> <span class="hljs-string">/tmp/monmap</span> <span class="hljs-params">--keyring</span> <span class="hljs-string">/tmp/ceph.mon.keyring</span></code></pre><p>例如：</p><pre><code class="hljs jboss-cli">ceph-mon <span class="hljs-params">--mkfs</span> -i node1 <span class="hljs-params">--monmap</span> <span class="hljs-string">/tmp/monmap</span> <span class="hljs-params">--keyring</span> <span class="hljs-string">/tmp/ceph.mon.keyring</span></code></pre><ol><li>建一个空文件 <code>done</code> ，表示监视器已创建、可以启动了：</li></ol><pre><code class="hljs crystal">sudo touch /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mon</span>/<span class="hljs-title">ceph</span>-<span class="hljs-title">node1</span>/<span class="hljs-title">done</span></span></code></pre><p>15.启动监视器。</p><p>在 Ubuntu 上用 Upstart ：</p><pre><code class="hljs pgsql">sudo <span class="hljs-keyword">start</span> ceph-mon id=node1 [<span class="hljs-keyword">cluster</span>=&#123;<span class="hljs-keyword">cluster</span>-<span class="hljs-type">name</span>&#125;]</code></pre><ol><li>要使此守护进程开机自启，需要创建两个空文件，像这样：</li></ol><pre><code class="hljs crystal">sudo touch /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mon</span>/&#123;<span class="hljs-title">cluster</span>-<span class="hljs-title">name</span>&#125;-&#123;<span class="hljs-title">hostname</span>&#125;/<span class="hljs-title">upstart</span></span></code></pre><p>例如：</p><pre><code class="hljs crystal">sudo touch /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mon</span>/<span class="hljs-title">ceph</span>-<span class="hljs-title">node1</span>/<span class="hljs-title">upstart</span></span></code></pre><ol><li>验证下 Ceph 已经创建了默认存储池。</li></ol><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph osd lspools</span></code></pre><p>你应该会看到这样的输出：</p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-keyword">data</span>,<span class="hljs-number">1</span> metadata,<span class="hljs-number">2</span> rbd,</code></pre><ol><li>确认下集群在运行。</li></ol><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph -s</span></code></pre><p>你应该从输出里看到刚刚启动的监视器在正常运行，并且应该会看到一个健康错误：它表明归置组卡在了 <code>stuck inactive</code> 状态。输出大致如此：</p><pre><code class="hljs apache"><span class="hljs-attribute">cluster</span> a<span class="hljs-number">7</span>f<span class="hljs-number">64266</span>-<span class="hljs-number">0894</span>-<span class="hljs-number">4</span>f<span class="hljs-number">1</span>e-a<span class="hljs-number">635</span>-d<span class="hljs-number">0</span>aeaca<span class="hljs-number">0</span>e<span class="hljs-number">993</span>  <span class="hljs-attribute">health</span> HEALTH_ERR <span class="hljs-number">192</span> pgs stuck inactive; <span class="hljs-number">192</span> pgs stuck unclean; no osds  <span class="hljs-attribute">monmap</span> e<span class="hljs-number">1</span>: <span class="hljs-number">1</span> mons at &#123;node<span class="hljs-number">1</span>=<span class="hljs-number">192.168.0.1:6789</span>/<span class="hljs-number">0</span>&#125;, election epoch <span class="hljs-number">1</span>, quorum <span class="hljs-number">0</span> node<span class="hljs-number">1</span>  <span class="hljs-attribute">osdmap</span> e<span class="hljs-number">1</span>: <span class="hljs-number">0</span> osds: <span class="hljs-number">0</span> up, <span class="hljs-number">0</span> in  <span class="hljs-attribute">pgmap</span> v<span class="hljs-number">2</span>: <span class="hljs-number">192</span> pgs, <span class="hljs-number">3</span> pools, <span class="hljs-number">0</span> bytes data, <span class="hljs-number">0</span> objects     <span class="hljs-attribute">0</span> kB used, <span class="hljs-number">0</span> kB / <span class="hljs-number">0</span> kB avail     <span class="hljs-attribute">192</span> creating</code></pre><p>更详细的介绍可以参考<a href="#MONITOR">MONITOR</a></p><hr><h2 id="ceph-OSD配置"><a href="#ceph-OSD配置" class="headerlink" title="ceph OSD配置"></a>ceph OSD配置</h2><p>Ceph 配置文件添加 OSD</p><p>你的初始监视器可以正常运行后就可以添加 OSD 了。要想让集群达到 <code>active + clean</code> 状态，必须安装足够多的 OSD 来处理对象副本（如 <code>osd pool default size = 2</code> 需要至少 2 个 OSD ）。在完成监视器自举引导后，集群就有了默认的 CRUSH 图，但现在此图还是空的，里面没有任何 OSD 映射到 Ceph 节点。</p><h3 id="精简型"><a href="#精简型" class="headerlink" title="精简型"></a>精简型</h3><p>Ceph 软件包提供了 <code>ceph-disk</code> 工具，用于准备硬盘：可以是分区或用于 Ceph 的目录。 <code>ceph-disk</code> 可通过递增索引来创建 OSD ID ；还能把 OSD 加入 CRUSH 图。 <code>ceph-disk</code> 的详细用法可参考 <code>ceph-disk -h</code> ，此工具把后面将提到的<a href="http://docs.ceph.org.cn/install/manual-deployment/#id3">精简型</a>里面的步骤都自动化了。为按照精简型创建前两个 OSD ，在 <code>node2</code> 和 <code>node3</code> 上执行下列命令：</p><ol><li><p>准备OSD。</p><pre><code class="hljs n1ql">ssh &#123;node-name&#125;sudo ceph-disk <span class="hljs-keyword">prepare</span> --<span class="hljs-keyword">cluster</span> &#123;<span class="hljs-keyword">cluster</span>-name&#125; --<span class="hljs-keyword">cluster</span>-<span class="hljs-built_in">uuid</span> &#123;<span class="hljs-built_in">uuid</span>&#125; --fs-<span class="hljs-built_in">type</span> &#123;ext4|xfs|btrfs&#125; &#123;data-<span class="hljs-keyword">path</span>&#125; [&#123;journal-<span class="hljs-keyword">path</span>&#125;]</code></pre><p>例如：</p><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> node<span class="hljs-number">1</span><span class="hljs-attribute">sudo</span> ceph-disk prepare --cluster ceph --cluster-uuid a<span class="hljs-number">7</span>f<span class="hljs-number">64266</span>-<span class="hljs-number">0894</span>-<span class="hljs-number">4</span>f<span class="hljs-number">1</span>e-a<span class="hljs-number">635</span>-d<span class="hljs-number">0</span>aeaca<span class="hljs-number">0</span>e<span class="hljs-number">993</span> --fs-type ext<span class="hljs-number">4</span> /dev/hdd<span class="hljs-number">1</span></code></pre></li><li><p>激活 OSD：</p><pre><code class="hljs puppet">sudo ceph-disk <span class="hljs-keyword">activate</span> &#123;data-<span class="hljs-built_in">path</span>&#125; [--activate-<span class="hljs-keyword">key</span> &#123;<span class="hljs-built_in">path</span>&#125;]</code></pre><p>例如：</p><pre><code class="hljs awk">sudo ceph-disk activate <span class="hljs-regexp">/dev/</span>hdd1</code></pre><p><strong>注：</strong> 如果你的 Ceph 节点上没有 <code>/var/lib/ceph/bootstrap-osd/&#123;cluster&#125;.keyring</code> ，那么应该外加 <code>--activate-key</code> 参数。</p></li></ol><h3 id="细致型"><a href="#细致型" class="headerlink" title="细致型"></a>细致型</h3><p>要是不想借助任何辅助工具，可按下列步骤创建 OSD 、将之加入集群和 CRUSH 图。按下列详细步骤可在 <code>node2</code> 和 <code>node3</code> 上增加前 2 个 OSD ：</p><ol><li><p>登录到OSD主机。</p><pre><code class="hljs crmsh">ssh &#123;<span class="hljs-keyword">node</span><span class="hljs-title">-name</span>&#125;</code></pre></li><li><p>给 OSD 分配 UUID 。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">uuidgen</span></code></pre></li><li><p>创建 OSD 。如果没有指定 UUID ，将会在 OSD 首次启动时分配一个。下列命令执行完成后将输出 OSD 号，在后续步骤里还会用到这个号。</p><pre><code class="hljs sql">ceph osd <span class="hljs-keyword">create</span> [&#123;<span class="hljs-keyword">uuid</span>&#125; [&#123;<span class="hljs-keyword">id</span>&#125;]]</code></pre></li><li><p>在新 OSD 主机上创建默认目录。</p><pre><code class="hljs crystal">ssh &#123;new-osd-host&#125;sudo mkdir /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/&#123;<span class="hljs-title">cluster</span>-<span class="hljs-title">name</span>&#125;-&#123;<span class="hljs-title">osd</span>-<span class="hljs-title">number</span>&#125;</span></code></pre></li><li><p>如果要把 OSD 装到非系统盘的独立硬盘上，先创建文件系统、然后挂载到刚创建的目录下：</p><pre><code class="hljs crystal">ssh &#123;new-osd-host&#125;sudo mkfs -t &#123;fstype&#125; /dev/&#123;hdd&#125;sudo mount -o user_xattr /dev/&#123;hdd&#125; /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/&#123;<span class="hljs-title">cluster</span>-<span class="hljs-title">name</span>&#125;-&#123;<span class="hljs-title">osd</span>-<span class="hljs-title">number</span>&#125;</span></code></pre></li><li><p>初始化 OSD 数据目录：</p><pre><code class="hljs puppet"><span class="hljs-keyword">ssh</span> &#123;new-osd-host&#125;<span class="hljs-keyword">sudo</span> <span class="hljs-keyword">ceph</span>-osd -<span class="hljs-keyword">i</span> &#123;osd-num&#125; --mkfs --mkkey --osd-uuid [&#123;uuid&#125;]</code></pre><p>加 <code>--mkkey</code> 选项运行 <code>ceph-osd</code> 之前，此目录必须是空的；另外，如果集群名字不是默认值，还要给 <code>ceph-osd</code> 指定 <code>--cluster</code> 选项。</p></li><li><p>注册此 OSD 的密钥。路径内 <code>ceph-&#123;osd-num&#125;</code> 里的 <code>ceph</code> 其含义为 <code>$cluster-$id</code> ，如果你的集群名字不是 <code>ceph</code> ，请指定自己的集群名：</p><pre><code class="hljs crystal">sudo ceph auth add osd.&#123;osd-num&#125; osd <span class="hljs-string">&#x27;allow *&#x27;</span> mon <span class="hljs-string">&#x27;allow profile osd&#x27;</span> -i /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/&#123;<span class="hljs-title">cluster</span>-<span class="hljs-title">name</span>&#125;-&#123;<span class="hljs-title">osd</span>-<span class="hljs-title">num</span>&#125;/<span class="hljs-title">keyring</span></span></code></pre></li><li><p>把此节点加入 CRUSH 图。</p><pre><code class="hljs smali">ceph [--cluster &#123;cluster-name&#125;] osd crush<span class="hljs-built_in"> add-bucket </span>&#123;hostname&#125; host</code></pre><p>例如：</p><pre><code class="hljs smali">ceph osd crush<span class="hljs-built_in"> add-bucket </span>node1 host</code></pre></li><li><p>把此 Ceph 节点放入 <code>default</code> 根下。</p><pre><code class="hljs arduino">ceph osd crush <span class="hljs-built_in">move</span> node1 root=<span class="hljs-keyword">default</span></code></pre></li><li><p>把此 OSD 加入 CRUSH 图之后，它就能接收数据了。你也可以反编译 CRUSH 图、把此 OSD 加入设备列表、对应主机作为桶加入（如果它还不在 CRUSH 图里）、然后此设备作为主机的一个条目、分配权重、重新编译、注入集群。</p><pre><code class="hljs dust"><span class="xml">ceph [--cluster </span><span class="hljs-template-variable">&#123;cluster-name&#125;</span><span class="xml">] osd crush add </span><span class="hljs-template-variable">&#123;id-or-name&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;weight&#125;</span><span class="xml"> [</span><span class="hljs-template-variable">&#123;bucket-type&#125;</span><span class="xml">=</span><span class="hljs-template-variable">&#123;bucket-name&#125;</span><span class="xml"> ...]</span></code></pre><p>例如：</p><pre><code class="hljs apache"><span class="hljs-attribute">ceph</span> osd crush add osd.<span class="hljs-number">0</span> <span class="hljs-number">1</span>.<span class="hljs-number">0</span> host=node<span class="hljs-number">1</span></code></pre></li><li><p>把 OSD 加入 Ceph 后， OSD 已经在配置里了。但它还没开始运行，这时处于 <code>down</code> 且 <code>in</code> 状态，要启动进程才能收数据。</p><p>在 Ubuntu 系统上用 Upstart 启动：</p><pre><code class="hljs pgsql">sudo <span class="hljs-keyword">start</span> ceph-osd id=&#123;osd-num&#125; [<span class="hljs-keyword">cluster</span>=&#123;<span class="hljs-keyword">cluster</span>-<span class="hljs-type">name</span>&#125;]</code></pre><p>例如：</p><pre><code class="hljs routeros">sudo start ceph-osd <span class="hljs-attribute">id</span>=0sudo start ceph-osd <span class="hljs-attribute">id</span>=1</code></pre><p>在 Debian/CentOS/RHEL 上用 sysvinit 启动：</p><pre><code class="hljs sql">sudo /etc/init.d/ceph <span class="hljs-keyword">start</span> osd.&#123;osd-<span class="hljs-keyword">num</span>&#125; [<span class="hljs-comment">--cluster &#123;cluster-name&#125;]</span></code></pre><p>例如：</p><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/ceph start osd.<span class="hljs-number">0</span>sudo <span class="hljs-regexp">/etc/i</span>nit.d/ceph start osd.<span class="hljs-number">1</span></code></pre><p>要让守护进程开机自启，必须创建一个空文件：</p><pre><code class="hljs crystal">sudo touch /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/&#123;<span class="hljs-title">cluster</span>-<span class="hljs-title">name</span>&#125;-&#123;<span class="hljs-title">osd</span>-<span class="hljs-title">num</span>&#125;/<span class="hljs-title">sysvinit</span></span></code></pre><p>例如：</p><pre><code class="hljs crystal">sudo touch /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-0/<span class="hljs-title">sysvinit</span></span>sudo touch /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">osd</span>/<span class="hljs-title">ceph</span>-1/<span class="hljs-title">sysvinit</span></span></code></pre><p>OSD 启动后，它应该处于 <code>up</code> 且 <code>in</code> 状态。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>监视器和两个 OSD 开始正常运行后，你就可以通过下列命令观察归置组互联过程了：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">ceph -w</span></code></pre><p>执行下列命令查看 OSD树：</p><pre><code class="hljs dos">ceph osd <span class="hljs-built_in">tree</span></code></pre><p>你应该会看到类似如下的输出：</p><pre><code class="hljs lsl"># id    weight  type name       up/down reweight<span class="hljs-number">-1</span>      <span class="hljs-number">2</span>       root <span class="hljs-section">default</span><span class="hljs-number">-2</span>      <span class="hljs-number">2</span>               host node1<span class="hljs-number">0</span>       <span class="hljs-number">1</span>                       osd<span class="hljs-number">.0</span>   up      <span class="hljs-number">1</span><span class="hljs-number">-3</span>      <span class="hljs-number">1</span>               host node2<span class="hljs-number">1</span>       <span class="hljs-number">1</span>                       osd<span class="hljs-number">.1</span>   up      <span class="hljs-number">1</span></code></pre><p>要增加（或删除）额外监视器，参见<a href="http://docs.ceph.org.cn/rados/operations/add-or-rm-mons">增加/删除监视器</a>。要增加（或删除）额外 OSD ，参见<a href="http://docs.ceph.org.cn/rados/operations/add-or-rm-osds">增加/删除 OSD</a> 。可用于配置存储集群内的所有守护进程、或者某一类型的所有守护进程。要配置一系列守护进程，这些配置必须位于能收到配置的段落之下，比如：</p><pre><code class="hljs json">[global]</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th><code>[global]</code> 下的配置影响 Ceph 集群里的所有守护进程。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>auth supported = cephx</code></td></tr></tbody></table></div><pre><code class="hljs json">[osd]</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th><code>[osd]</code> 下的配置影响存储集群里的所有 <code>ceph-osd</code> 进程，并且会覆盖 <code>[global]</code> 下的同一选项。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>osd journal size = 1000</code></td></tr></tbody></table></div><pre><code class="hljs json">[mon]</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th><code>[mon]</code> 下的配置影响集群里的所有 <code>ceph-mon</code> 进程，并且会覆盖 <code>[global]</code> 下的同一选项。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>mon addr = 10.0.0.101:6789</code></td></tr></tbody></table></div><pre><code class="hljs json">[mds]</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th><code>[mds]</code> 下的配置影响集群里的所有 <code>ceph-mds</code> 进程，并且会覆盖 <code>[global]</code> 下的同一选项。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>host = myserver01</code></td></tr></tbody></table></div><pre><code class="hljs json">[client]</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th><code>[client]</code> 下的配置影响所有客户端（如挂载的 Ceph 文件系统、挂载的块设备等等）。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>log file = /var/log/ceph/radosgw.log</code></td></tr></tbody></table></div><p>全局设置影响集群内所有守护进程的例程，所以 <code>[global]</code> 可用于设置适用所有守护进程的选项。但可以用这些覆盖 <code>[global]</code> 设置：</p><ol><li>在 <code>[osd]</code> 、 <code>[mon]</code> 、 <code>[mds]</code> 下更改某一类进程的配置。</li><li>更改特定进程的设置，如 <code>[osd.1]</code> 。</li></ol><p>覆盖全局设置会影响所有子进程，明确剔除的例外。</p><p>典型的全局设置包括激活认证，例如：</p><pre><code class="hljs routeros">[global]<span class="hljs-comment">#Enable authentication between hosts within the cluster.</span><span class="hljs-comment">#v 0.54 and earlier</span>auth supported = cephx<span class="hljs-comment">#v 0.55 and after</span>auth cluster required = cephxauth<span class="hljs-built_in"> service </span>required = cephxauth<span class="hljs-built_in"> client </span>required = cephx</code></pre><p>你可以统一配置一类守护进程。配置写到 <code>[osd]</code> 、 <code>[mon]</code> 、 <code>[mds]</code> 下时，无须再指定某个特定例程，即可分别影响所有 OSD 、监视器、元数据进程。</p><p>典型的类范畴配置包括日志尺寸、 filestore 选项等，如：</p><pre><code class="hljs angelscript">[osd]osd journal size = <span class="hljs-number">1000</span></code></pre><p>你也可以配置某个特定例程。一个例程由类型和及其例程 ID 确定， OSD 的例程 ID 只能是数字，但监视器和元数据服务器的 ID 可包含字母和数字。</p><pre><code class="hljs ini"><span class="hljs-section">[osd.1]</span><span class="hljs-comment"># settings affect osd.1 only.</span><span class="hljs-section">[mon.a]</span><span class="hljs-comment"># settings affect mon.a only.</span><span class="hljs-section">[mds.b]</span><span class="hljs-comment"># settings affect mds.b only.</span></code></pre><p>如果你想配置某个 Ceph 网关客户端，可以用点（ . ）分隔的守护进程和例程来指定，例如：</p><pre><code class="hljs clean">[client.radosgw.<span class="hljs-keyword">instance</span>-name]# settings affect client.radosgw.<span class="hljs-keyword">instance</span>-name only.</code></pre><h2 id="元变量¶"><a href="#元变量¶" class="headerlink" title="元变量¶"></a>元变量<a href="http://docs.ceph.org.cn/rados/configuration/ceph-conf/#ceph-metavariables">¶</a></h2><p>元变量大大简化了集群配置。 Ceph 会把配置的元变量展开为具体值；元变量功能很强大，可以用在配置文件的 <code>[global]</code> 、 <code>[osd]</code> 、 <code>[mon]</code> 、 <code>[mds]</code> 段里，类似于 Bash 的 shell 扩展。</p><p>Ceph 支持下列元变量：</p><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$cluster</span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>展开为存储集群名字，在同一套硬件上运行多个集群时有用。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>/etc/ceph/$cluster.keyring</code></td></tr><tr><td style="text-align:left">默认值:</td><td><code>ceph</code></td></tr></tbody></table></div><pre><code class="hljs elm">$<span class="hljs-keyword">type</span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>可展开为 <code>mds</code> 、 <code>osd</code> 、 <code>mon</code> 中的一个，有赖于当前守护进程的类型。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>/var/lib/ceph/$type</code></td></tr></tbody></table></div><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$id</span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>展开为守护进程标识符； <code>osd.0</code> 应为 <code>0</code> ， <code>mds.a</code> 是 <code>a</code> 。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>/var/lib/ceph/$type/$cluster-$id</code></td></tr></tbody></table></div><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$host</span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>展开为当前守护进程的主机名。</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table></div><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$name</span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>展开为 <code>$type.$id</code> 。</th></tr></thead><tbody><tr><td style="text-align:left">实例:</td><td><code>/var/run/ceph/$cluster-$name.asok</code></td></tr></tbody></table></div><h2 id="共有选项"><a href="#共有选项" class="headerlink" title="共有选项"></a>共有选项</h2><p><a href="http://docs.ceph.org.cn/install/hardware-recommendations">硬件推荐</a>段提供了一些配置 Ceph 存储集群的硬件指导。一个 <a href="http://docs.ceph.org.cn/glossary/#term-13"><em>Ceph 节点</em></a>可以运行多个进程，例如一个节点有多个硬盘，可以为每个硬盘配置一个 <code>ceph-osd</code> 守护进程。理想情况下一台主机应该只运行一类进程，例如：一台主机运行着 <code>ceph-osd</code> 进程，另一台主机运行着 <code>ceph-mds</code> 进程， <code>ceph-mon</code> 进程又在另外一台主机上。</p><p>各节点都用 <code>host</code> 选项指定主机名字，监视器还需要用 <code>addr</code> 选项指定网络地址和端口（即域名或 IP 地址）。基本配置文件可以只指定最小配置。例如：</p><pre><code class="hljs ini"><span class="hljs-section">[global]</span><span class="hljs-attr">mon_initial_members</span> = ceph1<span class="hljs-attr">mon_host</span> = <span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span></code></pre><div class="note note-danger">            <p><code>host</code> 选项是此节点的短名字，不是全资域名（ FQDN ），也<strong>不是</strong> IP 地址；执行 <code>hostname -s</code> 即可得到短名字。不要给初始监视器之外的例程设置 <code>host</code> ，除非你想手动部署；<strong>一定不能</strong>用于 <code>chef</code> 或 <code>ceph-deploy</code> ，这些工具会自动获取正确结果。</p>          </div><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p><img src="\img\ceph-network.png" alt="img"></p><ol><li><strong>性能：</strong> OSD 为客户端处理数据复制，复制多份时 OSD 间的网络负载势必会影响到客户端和 Ceph 集群的通讯，包括延时增加、产生性能问题；恢复和重均衡也会显著增加公共网延时。关于 Ceph 如何复制参见<a href="http://docs.ceph.org.cn/architecture#scalability-and-high-availability">伸缩性和高可用性</a>；关于心跳流量参见<a href="http://docs.ceph.org.cn/rados/configuration/mon-osd-interaction">监视器与 OSD 的交互</a>。</li><li><strong>安全：</strong> 大多数人都是良民，很少的一撮人喜欢折腾拒绝服务攻击（ DoS ）。当 OSD 间的流量失控时，归置组再也不能达到 <code>active + clean</code> 状态，这样用户就不能读写数据了。挫败此类攻击的一种好方法是<u>维护一个完全独立的集群网，使之不能直连互联网</u>；另外，请考虑用<a href="http://docs.ceph.org.cn/rados/configuration/auth-config-ref#signatures">消息签名</a>防止欺骗攻击。</li></ol><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>守护进程默认会<a href="http://docs.ceph.org.cn/rados/configuration/network-config-ref/#id10">绑定</a>到 <code>6800:7300</code> 间的端口，你可以更改此范围。更改防火墙配置前先检查下 <code>iptables</code> 配置。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo iptables -L</span></code></pre><p>一些 Linux 发行版的规则拒绝除 SSH 之外的所有网卡的所有入栈连接，例如：</p><pre><code class="hljs vhdl"><span class="hljs-keyword">REJECT</span> <span class="hljs-keyword">all</span> <span class="hljs-comment">-- anywhere anywhere reject-with icmp-host-prohibited</span></code></pre><p>你得先删掉公共网和集群网对应的这些规则，然后再增加安全保护规则。</p><h3 id="监视器防火墙"><a href="#监视器防火墙" class="headerlink" title="监视器防火墙"></a>监视器防火墙</h3><p>监视器默认监听 <code>6789</code> 端口，而且监视器总是运行在公共网。按下例增加规则时，要把 <code>&#123;iface&#125;</code> 替换为公共网接口（如 <code>eth0</code> 、 <code>eth1</code> 等等）、 <code>&#123;ip-address&#125;</code> 替换为公共网 IP 、 <code>&#123;netmask&#125;</code> 替换为公共网掩码。</p><pre><code class="hljs dust"><span class="xml">sudo iptables -A INPUT -i </span><span class="hljs-template-variable">&#123;iface&#125;</span><span class="xml"> -p tcp -s </span><span class="hljs-template-variable">&#123;ip-address&#125;</span><span class="xml">/</span><span class="hljs-template-variable">&#123;netmask&#125;</span><span class="xml"> --dport 6789 -j ACCEPT</span></code></pre><h3 id="MDS-防火墙"><a href="#MDS-防火墙" class="headerlink" title="MDS 防火墙"></a>MDS 防火墙</h3><p><a href="http://docs.ceph.org.cn/glossary/#term-64"><em>元数据服务器</em></a>会监听公共网 6800 以上的第一个可用端口。需要注意的是，这种行为是不确定的，所以如果你在同一主机上运行多个 OSD 或 MDS 、或者在很短的时间内重启了多个守护进程，它们会绑定更高的端口号；所以说你应该预先打开整个 6800-7300 端口区间。按下例增加规则时，要把 <code>&#123;iface&#125;</code> 替换为公共网接口（如 <code>eth0</code> 、 <code>eth1</code> 等等）、 <code>&#123;ip-address&#125;</code> 替换为公共网 IP 、 <code>&#123;netmask&#125;</code> 替换为公共网掩码。</p><p>例如：</p><pre><code class="hljs dust"><span class="xml">sudo iptables -A INPUT -i </span><span class="hljs-template-variable">&#123;iface&#125;</span><span class="xml"> -m multiport -p tcp -s </span><span class="hljs-template-variable">&#123;ip-address&#125;</span><span class="xml">/</span><span class="hljs-template-variable">&#123;netmask&#125;</span><span class="xml"> --dports 6800:7300 -j ACCEPT</span></code></pre><h3 id="OSD-防火墙"><a href="#OSD-防火墙" class="headerlink" title="OSD 防火墙"></a>OSD 防火墙</h3><p>OSD 守护进程默认<a href="http://docs.ceph.org.cn/rados/configuration/network-config-ref/#id10">绑定</a> 从 6800 起的第一个可用端口，需要注意的是，这种行为是不确定的，所以如果你在同一主机上运行多个 OSD 或 MDS 、或者在很短的时间内重启了多个守护进程，它们会绑定更高的端口号。一主机上的各个 OSD 最多会用到 4 个端口：</p><ol><li>一个用于和客户端、监视器通讯；</li><li>一个用于发送数据到其他 OSD ；</li><li>两个用于各个网卡上的心跳；</li></ol><p><img src="\img\ceph-firewall.png" alt="img"></p><p>当某个守护进程失败并重启时没释放端口，重启后的进程就会监听新端口。你应该打开整个 6800-7300 端口区间，以应对这种可能性。</p><p>如果你分开了公共网和集群网，必须分别为之设置防火墙，因为客户端会通过公共网连接、而其他 OSD 会通过集群网连接。按下例增加规则时，要把 <code>&#123;iface&#125;</code> 替换为网口（如 <code>eth0</code> 、 <code>eth1</code> 等等）、 <code>&#123;ip-address&#125;</code> 替换为公共网或集群网 IP 、 <code>&#123;netmask&#125;</code> 替换为公共网或集群网掩码。例如：</p><pre><code class="hljs dust"><span class="xml">sudo iptables -A INPUT -i </span><span class="hljs-template-variable">&#123;iface&#125;</span><span class="xml">  -m multiport -p tcp -s </span><span class="hljs-template-variable">&#123;ip-address&#125;</span><span class="xml">/</span><span class="hljs-template-variable">&#123;netmask&#125;</span><span class="xml"> --dports 6800:7300 -j ACCEPT</span></code></pre><div class="note note-primary">            <p>如果你的元数据服务器和 OSD 在同一节点上，可以合并公共网配置。</p>          </div><h2 id="CEPH-网络"><a href="#CEPH-网络" class="headerlink" title="CEPH 网络"></a>CEPH 网络</h2><p>Ceph 的网络配置要放到 <code>[global]</code> 段下。前述的 5 分钟快速入门提供了一个简陋的 <a href="http://docs.ceph.org.cn/start/quick-ceph-deploy/#create-a-cluster">Ceph 配置文件</a>，它假设服务器和客户端都位于同一网段， Ceph 可以很好地适应这种情形。然而 Ceph 允许配置更精细的公共网，包括多 IP 和多掩码；也能用单独的集群网处理 OSD 心跳、对象复制、和恢复流量。不要混淆你配置的 IP 地址和客户端用来访问存储服务的公共网地址。典型的内网常常是 <code>192.168.0.0</code> 或 <code>10.0.0.0</code> 。</p> <div class="note note-primary">            <p>如果你给公共网或集群网配置了多个 IP 地址及子网掩码，这些子网必须能互通。另外要确保在防火墙上为各 IP 和子网开放了必要的端口。</p><p>Ceph 用 CIDR 法表示子网(IP地址/网络ID的位数)，如 <code>10.0.0.0/24</code> 。</p>          </div><p>配置完几个网络后，可以重启集群或挨个重启守护进程。 Ceph 守护进程动态地绑定端口，所以更改网络配置后无需重启整个集群。</p><h3 id="公共网"><a href="#公共网" class="headerlink" title="公共网"></a>公共网</h3><p>要配置一个公共网，把下列选项加到配置文件的 <code>[global]</code> 段下。</p><pre><code class="hljs routeros">[global]        <span class="hljs-built_in">..</span>.        public<span class="hljs-built_in"> network </span>= &#123;public-network/netmask&#125;</code></pre><h3 id="集群网"><a href="#集群网" class="headerlink" title="集群网"></a>集群网</h3><p>如果你声明了集群网， OSD 将把心跳、对象复制和恢复流量路由到集群网，与单个网络相比这会提升性能。要配置集群网，把下列选项加进配置文件的 <code>[global]</code> 段。</p><pre><code class="hljs routeros">[global]        <span class="hljs-built_in">..</span>.        cluster<span class="hljs-built_in"> network </span>= &#123;cluster-network/netmask&#125;</code></pre><p>为安全起见，从公共网或互联网到集群网应该是<strong>不可达</strong>的。</p><h2 id="CEPH-守护进程"><a href="#CEPH-守护进程" class="headerlink" title="CEPH 守护进程"></a>CEPH 守护进程</h2><p>有一个网络配置是所有守护进程都要配的：各个守护进程都<strong>必须</strong>指定 <code>host</code> ， Ceph 也要求指定监视器 IP 地址及端口。</p><div class="note note-danger">            <p>一些部署工具（如 <code>ceph-deploy</code> 、 Chef ）会给你创建配置文件，如果它能胜任那就<strong>别设置</strong>这些值。</p>          </div><div class="note note-primary">            <p><code>host</code> 选项是主机的短名，不是全资域名 FQDN ，也<strong>不是</strong> IP 地址。在命令行下输入 <code>hostname -s</code> 获取主机名。</p>          </div><pre><code class="hljs dust"><span class="xml">[mon.a]</span><span class="xml">        host = </span><span class="hljs-template-variable">&#123;hostname&#125;</span><span class="xml">        mon addr = </span><span class="hljs-template-variable">&#123;ip-address&#125;</span><span class="xml">:6789</span><span class="xml">[osd.0]</span><span class="xml">        host = </span><span class="hljs-template-variable">&#123;hostname&#125;</span></code></pre><p>并非一定要给守护进程设置 IP 地址。如果你有一个静态配置，且分离了公共网和集群网， Ceph 允许你在配置文件里指定主机的 IP 地址。要给守护进程设置静态 IP ，可把下列选项加到 <code>ceph.conf</code> 。</p><pre><code class="hljs armasm">[osd.<span class="hljs-number">0</span>]        public <span class="hljs-keyword">addr</span> = &#123;host-public-<span class="hljs-built_in">ip</span>-address&#125;        cluster <span class="hljs-keyword">addr</span> = &#123;host-cluster-<span class="hljs-built_in">ip</span>-address&#125;</code></pre><blockquote><p>单网卡OSD、双网络集群</p><p>一般来说，我们不建议用单网卡 OSD 主机部署两个网络。然而这事可以实现，把 <code>public addr</code> 选项配在 <code>[osd.n]</code> 段下即可强制 OSD 主机运行在公共网，其中 <code>n</code> 是其 OSD 号。另外，公共网和集群网必须互通，考虑到安全因素我们不建议这样做。</p></blockquote><h2 id="网络配置选项"><a href="#网络配置选项" class="headerlink" title="网络配置选项"></a>网络配置选项</h2><p>网络配置选项不是必需的， Ceph 假设所有主机都运行于公共网，除非你特意配置了一个集群网。</p><h3 id="公共网-1"><a href="#公共网-1" class="headerlink" title="公共网"></a>公共网</h3><p>公共网配置用于明确地为公共网定义 IP 地址和子网。你可以分配静态 IP 或用 <code>public addr</code> 覆盖 <code>public network</code> 选项。</p><p>public network</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>公共网（前端）的 IP 地址和掩码（如 <code>192.168.0.0/24</code> ），置于 <code>[global]</code> 下。多个子网用逗号分隔。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td><code>&#123;ip-address&#125;/&#123;netmask&#125; [, &#123;ip-address&#125;/&#123;netmask&#125;]</code></td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td>N/A</td></tr></tbody></table></div><p>public addr</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>用于公共网（前端）的 IP 地址。适用于各守护进程。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>IP 地址</td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td>N/A</td></tr></tbody></table></div><h3 id="集群网-1"><a href="#集群网-1" class="headerlink" title="集群网"></a>集群网</h3><p>集群网配置用来声明一个集群网，并明确地定义其 IP 地址和子网。你可以配置静态 IP 或为某 OSD 守护进程配置 <code>cluster addr</code> 以覆盖 <code>cluster network</code> 选项。</p><p>cluster network</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>集群网（后端）的 IP 地址及掩码（如 <code>10.0.0.0/24</code> ），置于 <code>[global]</code> 下。多个子网用逗号分隔。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td><code>&#123;ip-address&#125;/&#123;netmask&#125; [, &#123;ip-address&#125;/&#123;netmask&#125;]</code></td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td>N/A</td></tr></tbody></table></div><p>cluster addr</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>集群网（后端） IP 地址。置于各守护进程下。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>Address</td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td>N/A</td></tr></tbody></table></div><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>绑定选项用于设置 OSD 和 MDS 默认使用的端口范围，默认范围是 <code>6800:7300</code> 。确保<a href="http://docs.ceph.org.cn/rados/configuration/network-config-ref/#id2">防火墙</a>开放了对应端口范围。</p><p>你也可以让 Ceph 守护进程绑定到 IPv6 地址。</p><p>ms bind port min</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>OSD 或 MDS 可绑定的最小端口号。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>32-bit Integer</td></tr><tr><td style="text-align:left">默认值:</td><td><code>6800</code></td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr></tbody></table></div><p>ms bind port max</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>OSD 或 MDS 可绑定的最大端口号。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>32-bit Integer</td></tr><tr><td style="text-align:left">默认值:</td><td><code>7300</code></td></tr><tr><td style="text-align:left">是否必需:</td><td>No.</td></tr></tbody></table></div><p>ms bind ipv6</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>允许 Ceph 守护进程绑定 IPv6 地址。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>Boolean</td></tr><tr><td style="text-align:left">默认值:</td><td><code>false</code></td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr></tbody></table></div><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><p>Ceph 配置文件里至少要写一个监视器、且每个监视器下都要配置 <code>mon addr</code> 选项；每个监视器、元数据服务器和 OSD 下都要配 <code>host</code> 选项。</p><p>mon addr</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th><code>&#123;hostname&#125;:&#123;port&#125;</code> 条目列表，用以让客户端连接 Ceph 监视器。如果未设置， Ceph 查找 <code>[mon.*]</code> 段。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>String</td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td>N/A</td></tr></tbody></table></div><p>host</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>主机名。此选项用于特定守护进程，如 <code>[osd.0]</code> 。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>String</td></tr><tr><td style="text-align:left">是否必需:</td><td>Yes, for daemon instances.</td></tr><tr><td style="text-align:left">默认值:</td><td><code>localhost</code></td></tr></tbody></table></div><p>不要用 <code>localhost</code> 。在命令行下执行 <code>hostname -s</code> 获取主机名（到第一个点，不是全资域名），并用于配置文件。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>Ceph 默认禁用 TCP 缓冲。</p><p>ms tcp nodelay</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>Ceph 用 <code>ms tcp nodelay</code> 使系统尽快（不缓冲）发送每个请求。禁用 <a href="http://en.wikipedia.org/wiki/Nagle&#39;s_algorithm">Nagle 算法</a>可增加吞吐量，但会引进延时。如果你遇到大量小包，可以禁用 <code>ms tcp nodelay</code> 试试。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>Boolean</td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td><code>true</code></td></tr></tbody></table></div><p>ms tcp rcvbuf</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>网络套接字接收缓冲尺寸，默认禁用。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>32-bit Integer</td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td><code>0</code></td></tr></tbody></table></div><p>ms tcp read timeout</p><div class="table-container"><table><thead><tr><th style="text-align:left">描述:</th><th>如果一客户端或守护进程发送请求到另一个 Ceph 守护进程，且没有断开不再使用的连接，在 <code>ms tcp read timeout</code> 指定的秒数之后它将被标记为空闲。</th></tr></thead><tbody><tr><td style="text-align:left">类型:</td><td>Unsigned 64-bit Integer</td></tr><tr><td style="text-align:left">是否必需:</td><td>No</td></tr><tr><td style="text-align:left">默认值:</td><td><code>900</code> 15 minutes.</td></tr></tbody></table></div><h2 id="认证选项"><a href="#认证选项" class="headerlink" title="认证选项"></a>认证选项</h2><p><code>cephx</code> 协议已默认开启。加密认证要耗费一定计算资源，但通常很低。如果您的客户端和服务器网络环境相当安全，而且认证的负面效应更大，你可以关闭它，<strong>通常不推荐您这么做</strong>。</p><p>使用ceph-deploy会自动创建认证信息：</p><pre><code class="hljs ini"><span class="hljs-attr">auth_cluster_required</span> = cephx<span class="hljs-attr">auth_service_required</span> = cephx<span class="hljs-attr">auth_client_required</span> = cephx</code></pre><p>当执行<code>ceph-deploy mon create-initial</code>，ceph会引导初始监视器，返回一个<code>ceph.client.admin.keyring</code>文件。</p><p>当执行 <code>ceph-deploy admin &#123;node-name&#125;</code>，你相当于把<code>ceph.client.admin.keyring</code>文件放在节点的/etc/ceph目录下。</p><h3 id="启用-CEPHX"><a href="#启用-CEPHX" class="headerlink" title="启用 CEPHX"></a>启用 CEPHX</h3><p>启用 <code>cephx</code> 后， Ceph 将在默认搜索路径（包括 <code>/etc/ceph/ceph.$name.keyring</code> ）里查找密钥环。你可以在 <a href="http://docs.ceph.org.cn/rados/configuration/ceph-conf">Ceph 配置</a>文件的 <code>[global]</code> 段里添加 <code>keyring</code> 选项来修改，但不推荐。</p><p>在禁用了 <code>cephx</code> 的集群上执行下面的步骤来启用它，如果你（或者部署工具）已经生成了密钥，你可以跳过相关步骤。</p><ol><li><p>创建 <code>client.admin</code> 密钥，并为客户端保存此密钥的副本：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">auth </span><span class="hljs-built_in">get-or-create</span> <span class="hljs-string">client.</span><span class="hljs-string">admin </span><span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-string">mds </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-string">osd </span><span class="hljs-string">&#x27;allow *&#x27;</span> -o /<span class="hljs-string">etc/</span><span class="hljs-string">ceph/</span><span class="hljs-string">ceph.</span><span class="hljs-string">client.</span><span class="hljs-string">admin.</span><span class="hljs-string">keyring</span></code></pre><div class="note note-danger">            <p><strong>警告：</strong> 此命令会覆盖任何存在的 <code>/etc/ceph/client.admin.keyring</code> 文件，如果部署工具已经完成此步骤，千万别再执行此命令。多加小心！</p>          </div></li><li><p>创建监视器集群所需的密钥环、并给它们生成密钥。</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph-authtool </span><span class="hljs-built_in">--create-keyring</span> /<span class="hljs-string">tmp/</span><span class="hljs-string">ceph.</span><span class="hljs-string">mon.</span><span class="hljs-string">keyring </span><span class="hljs-built_in">--gen-key</span> -n <span class="hljs-string">mon.</span> <span class="hljs-built_in">--cap</span> <span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow *&#x27;</span></code></pre></li><li><p>把监视器密钥环复制到 <code>ceph.mon.keyring</code> 文件，再把此文件复制到各监视器的 <code>mon data</code> 目录下。比如要把它复制给名为 <code>ceph</code> 集群的 <code>mon.a</code> ，用此命令：</p><pre><code class="hljs crystal">cp /tmp/ceph.mon.keyring /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/<span class="hljs-title">mon</span>/<span class="hljs-title">ceph</span>-<span class="hljs-title">a</span>/<span class="hljs-title">keyring</span></span></code></pre></li><li><p>为每个 OSD 生成密钥， <code>&#123;$id&#125;</code> 是 OSD 编号：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">auth </span><span class="hljs-built_in">get-or-create</span> <span class="hljs-string">osd.</span>&#123;$<span class="hljs-string">id&#125;</span> <span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow rwx&#x27;</span> <span class="hljs-string">osd </span><span class="hljs-string">&#x27;allow *&#x27;</span> -o /<span class="hljs-string">var/</span><span class="hljs-string">lib/</span><span class="hljs-string">ceph/</span><span class="hljs-string">osd/</span><span class="hljs-string">ceph-</span>&#123;$<span class="hljs-string">id&#125;</span>/<span class="hljs-string">keyring</span></code></pre></li><li><p>为每个 MDS 生成密钥， <code>&#123;$id&#125;</code> 是 MDS 的标识字母：</p><pre><code class="hljs dsconfig"><span class="hljs-string">ceph </span><span class="hljs-string">auth </span><span class="hljs-built_in">get-or-create</span> <span class="hljs-string">mds.</span>&#123;$<span class="hljs-string">id&#125;</span> <span class="hljs-string">mon </span><span class="hljs-string">&#x27;allow rwx&#x27;</span> <span class="hljs-string">osd </span><span class="hljs-string">&#x27;allow *&#x27;</span> <span class="hljs-string">mds </span><span class="hljs-string">&#x27;allow *&#x27;</span> -o /<span class="hljs-string">var/</span><span class="hljs-string">lib/</span><span class="hljs-string">ceph/</span><span class="hljs-string">mds/</span><span class="hljs-string">ceph-</span>&#123;$<span class="hljs-string">id&#125;</span>/<span class="hljs-string">keyring</span></code></pre></li><li><p>把以下配置加入 <a href="http://docs.ceph.org.cn/rados/configuration/ceph-conf">Ceph 配置</a>文件的 <code>[global]</code> 段下以启用 <code>cephx</code> 认证：</p><pre><code class="hljs routeros">auth cluster required = cephxauth<span class="hljs-built_in"> service </span>required = cephxauth<span class="hljs-built_in"> client </span>required = cephx</code></pre></li><li><p>启动或重启 Ceph 集群，详情见<a href="http://docs.ceph.org.cn/rados/operations/operating">操纵集群</a>。</p></li></ol><h3 id="禁用-CEPHX"><a href="#禁用-CEPHX" class="headerlink" title="禁用 CEPHX"></a>禁用 CEPHX</h3><p>下述步骤描述了如何禁用 Cephx 。如果你的集群环境相对安全，你可以减免认证耗费的计算资源，然而<strong>我们不推荐</strong>。但是临时禁用认证会使安装、和/或排障更简单。</p><ol><li><p>把下列配置加入 <a href="http://docs.ceph.org.cn/rados/configuration/ceph-conf">Ceph 配置</a>文件的 <code>[global]</code> 段下即可禁用 <code>cephx</code> 认证：</p><pre><code class="hljs routeros">auth cluster required = noneauth<span class="hljs-built_in"> service </span>required = noneauth<span class="hljs-built_in"> client </span>required = none</code></pre></li><li><p>启动或重启 Ceph 集群，具体参考<a href="http://docs.ceph.org.cn/rados/operations/operating">操纵集群</a>。</p></li></ol><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>如果你的集群启用了认证， <code>ceph</code> 管理命令和客户端得有密钥才能访问集群。</p><p>给 <code>ceph</code> 管理命令和客户端提供密钥的最常用方法就是把密钥环放到 <code>/etc/ceph</code> ，通过 <code>ceph-deploy</code> 部署的 Cuttlefish 及更高版本，其文件名通常是 <code>ceph.client.admin.keyring</code> （或 <code>$cluster.client.admin.keyring</code> ）。如果你的密钥环位于 <code>/etc/ceph</code> 下，就不需要在 Ceph 配置文件里指定 <code>keyring</code> 选项了。</p><p>我们建议把集群的密钥环复制到你执行管理命令的节点，它包含 <code>client.admin</code> 密钥。</p><p>你可以用 <code>ceph-deploy admin</code> 命令做此事，详情见’部署管理主机’_，手动复制可执行此命令：</p><pre><code class="hljs roboconf">sudo scp &#123;<span class="hljs-attribute">user&#125;@&#123;ceph-cluster-host&#125;</span>:/etc/ceph/ceph<span class="hljs-variable">.client</span><span class="hljs-variable">.admin</span><span class="hljs-variable">.keyring</span> /etc/ceph/ceph<span class="hljs-variable">.client</span><span class="hljs-variable">.admin</span><span class="hljs-variable">.keyring</span></code></pre><div class="note note-primary">            <p>确保给客户端上的 <code>ceph.keyring</code> 设置合理的权限位（如 <code>chmod 644</code> ）</p>          </div><p>守护进程数据目录位置默认格式如下：</p><pre><code class="hljs crystal">/var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">ceph</span>/$<span class="hljs-title">type</span>/$<span class="hljs-title">cluster</span>-$<span class="hljs-title">id</span></span></code></pre><h2 id="MONITOR-配置"><a href="#MONITOR-配置" class="headerlink" title="MONITOR 配置"></a>MONITOR 配置</h2><p><span id ="MONITOR"> 这儿</span></p><p>监视器们维护着集群运行图的“主副本”，就是说<strong>客户端连到一个监视器并获取当前运行图就能确定所有监视器、 OSD 和元数据服务器的位置</strong>。 Ceph 客户端读写 OSD 或元数据服务器前，必须先连到一个监视器，靠当前集群运行图的副本和 CRUSH 算法，客户端能计算出任何对象的位置，故此客户端有能力直接连到 OSD ，这对 Ceph 的高伸缩性、高性能来说非常重要。更多信息见<a href="http://docs.ceph.org.cn/architecture#scalability-and-high-availability">伸缩性和高可用性</a>。</p><p>监视器的主要角色是维护集群运行图的主副本，它也提供<strong>认证</strong>和<strong>日志记录</strong>服务。 Ceph 监视器们把监视器服务的所有更改写入一个单独的 <strong>Paxos</strong> 例程，然后 Paxos 以键/值方式存储所有变更以实现高度一致性。同步期间， Ceph 监视器能查询集群运行图的近期版本，它们通过操作键/值存储快照和迭代器（用 leveldb ）来进行存储级同步。</p><p><img src="\img\ceph-mon.png" alt="img"></p><h3 id="集群运行图"><a href="#集群运行图" class="headerlink" title="集群运行图"></a>集群运行图</h3><p>集群运行图是多个图的组合，包括监视器图、 OSD 图、归置组图和元数据服务器图。集群运行图追踪几个重要事件：哪些进程在集群里（ <code>in</code> ）；哪些进程在集群里（ <code>in</code> ）是 <code>up</code> 且在运行、或 <code>down</code> ；归置组状态是 <code>active</code> 或 <code>inactive</code> 、 <code>clean</code> 或其他状态；和其他反映当前集群状态的信息，像总存储容量、和使用量。</p><p>当集群状态有明显变更时，如一 OSD 挂了、一归置组降级了等等，集群运行图会被更新以反映集群当前状态。另外，监视器也维护着集群的主要状态历史。监视器图、 OSD 图、归置组图和元数据服务器图各自维护着它们的运行图版本。我们把各图的版本称为一个 epoch 。</p><p>运营集群时，跟踪这些状态是系统管理任务的重要部分。详情见<a href="http://docs.ceph.org.cn/rados/operations/monitoring">监控集群</a>和<a href="http://docs.ceph.org.cn/rados/operations/monitoring-osd-pg">监控 OSD 和归置组</a>。</p><h3 id="监视器法定人数（Quorum）"><a href="#监视器法定人数（Quorum）" class="headerlink" title="监视器法定人数（Quorum）"></a>监视器法定人数（Quorum）</h3><p>简单的Ceph-deploy只会配置一台monitor，而这很容易造成单点故障。Ceph采用<strong>Paxos</strong>来保证集群运行一致性。这里的一致要求大多数监视器都在运行且够成法定人数（如 1 个、 3 之 2 在运行、 5 之 3 、 6 之 4 等等）。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>你把监视器加进 Ceph 配置文件时，得注意一些架构问题， Ceph 发现集群内的其他监视器时对其有着<strong>严格的一致性要求</strong>。尽管如此， Ceph 客户端和其他 Ceph 守护进程用配置文件发现监视器，监视器却用监视器图（ monmap ）相互发现而非配置文件。</p><p>一个监视器发现集群内的其他监视器时总是参考 <strong>monmap</strong> 的本地副本，用 monmap 而非 Ceph 配置文件避免了可能损坏集群的错误（如 <code>ceph.conf</code> 中指定地址或端口的拼写错误）。正因为监视器把 monmap 用于发现、并共享于客户端和其他 Ceph 守护进程间， <strong>monmap可严格地保证监视器的一致性是可靠的</strong>。</p><p>严格的一致性也适用于 monmap 的更新，因为关于监视器的任何更新、关于 monmap 的变更都是通过称为 <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science">Paxos</a>) 的分布式一致性算法传递的。监视器们必须就 monmap 的每次更新达成一致，以确保法定人数里的每个监视器 monmap 版本相同，如增加、删除一个监视器。 monmap 的更新是增量的，所以监视器们都有最新的一致版本，以及一系列之前版本。历史版本的存在允许一个落后的监视器跟上集群当前状态。</p><h3 id="初始化监视器"><a href="#初始化监视器" class="headerlink" title="初始化监视器"></a>初始化监视器</h3><p>在大多数配置和部署案例中，部署 Ceph 的工具可以帮你生成一个监视器图来初始化监视器（如 <code>ceph-deploy</code> 等），一个监视器需要 若干个选项：</p><p><strong>惟一标识符：</strong> <code>fsid</code> 是集群的惟一标识，它是 Ceph 作为文件系统时的文件系统标识符。现在， Ceph 还支持原生接口、块设备、和对象存储网关接口，所以 <code>fsid</code> 有点名不符实了。</p><p><strong>集群名称：</strong> 每个 Ceph 集群都有自己的名字，它是个不含空格的字符串。默认名字是 <code>ceph</code> 、但你可以更改；尤其是运营着多个集群时，需要用名字来区分要操作哪一个。比如，当你以<a href="http://docs.ceph.org.cn/radosgw/federated-config">联盟架构</a>运营多个集群时，集群名字（如 <code>us-west</code> 、 <code>us-east</code> ）将作为标识符出现在 CLI 界面上。<strong>注意：</strong>要在命令行下指定某个集群，可以指定以集群名为前缀的配置文件（如 <code>ceph.conf</code> 、 <code>us-west.conf</code> 、 <code>us-east.conf</code> 等）；也可以参考 CLI 用法（ <code>ceph --cluster &#123;cluster-name&#125;</code> ）。</p><p><strong>监视器名字：</strong> 同一集群内的各监视器例程都有惟一的名字，通常都用主机名作为监视器名字（我们建议每台主机只运行一个监视器、并且不要与 OSD 主机复用。短主机名可以用 <code>hostname -s</code> 获取。</p><p><strong>监视器图：</strong> 自举引导初始监视器需要生成监视器图，为此，需要有 <code>fsid</code> 、集群名（或用默认）、至少一个主机名及其 IP 。</p><p><strong>监视器密钥环：</strong> 监视器之间通过密钥通讯，所以你必须把监视器密钥加入密钥环，并在自举引导时提供。</p><p><strong>管理密钥环：</strong> 要使用 <code>ceph</code> 这个命令行工具，你必须有 <code>client.admin</code> 用户，所以你要创建此用户及其密钥，并把他们加入密钥环。</p><p>关于初始化的具体信息见<a href="http://docs.ceph.org.cn/dev/mon-bootstrap">初始化监视器</a>。</p><pre><code class="hljs angelscript">[mon]        mon host = hostname1,hostname2,hostname3        mon addr = <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span>:<span class="hljs-number">6789</span>,<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.11</span>:<span class="hljs-number">6789</span>,<span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.12</span>:<span class="hljs-number">6789</span></code></pre><h3 id="初始成员"><a href="#初始成员" class="headerlink" title="初始成员"></a>初始成员</h3><p>我们建议在生产环境下最少部署 3 个监视器，以确保高可用性。运行多个监视器时，你可以指定为形成法定人数成员所需的初始监视器，这能减小集群上线时间。</p><pre><code class="hljs csharp">[<span class="hljs-meta">mon</span>]        mon initial members = a,b,c</code></pre><div class="note note-primary">            <p>Ceph 需要奇数个监视器来确定最初法定人数（如 3 ）。</p>          </div><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Ceph 监视器有存储数据的默认路径，生产集群为实现更高性能可把监视器部署到非 OSD 节点的独立主机上。因为监视器会频繁 <code>fsync()</code> ，这可能影响 OSD 。</p><h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><p>Ceph 存储集群利用率接近最大容量时（即 <code>mon osd full ratio</code> ），作为防止数据丢失的安全措施，它会阻止你读写 OSD 。因此，让生产集群用满可不是好事，因为牺牲了高可用性。 full ratio 默认值是 <code>.95</code> 或容量的 95% 。对小型测试集群来说这是非常激进的设置。</p><div class="note note-primary">            <p>监控集群时，要警惕和 <code>nearfull</code> 相关的警告。这意味着一些 OSD 的失败会导致临时服务中断，应该增加一些 OSD 来扩展存储容量。</p>          </div><p>在测试集群时，一个常见场景是：系统管理员从集群删除一个 OSD 、接着观察重均衡；然后继续删除其他 OSD ，直到集群达到占满率并锁死。我们建议，即使在测试集群里也要规划一点空闲容量用于保证高可用性。理想情况下，要做好这样的预案：一系列 OSD 失败后，短时间内不更换它们仍能恢复到 <code>active + clean</code> 状态。你也可以在 <code>active + degraded</code> 状态运行集群，但对正常使用来说并不好。找出你集群的两个数字：</p><ol><li>OSD 数量。</li><li>集群总容量</li></ol><p>用集群里 OSD 总数除以集群总容量，就能得到 OSD 平均容量；如果按预计的 OSD 数乘以这个值所得的结果计算（偏小），实际应用时将出错；最后再用集群容量乘以占满率能得到最大运行容量，然后扣除预估的 OSD 失败率；用较高的失败率（如整机架的 OSD ）重复前述过程看是否接近占满率。</p><pre><code class="hljs jboss-cli">[global]<span class="hljs-comment"># 在OSDconsidered full之前的磁盘空间使用率</span>mon osd full ratio = <span class="hljs-string">.80</span>    <span class="hljs-comment"># OSD 硬盘使用率达到多少就认为它 full 。</span>        mon osd full ratio = <span class="hljs-string">.80</span>        <span class="hljs-comment">#OSD 硬盘使用率达到多少就认为它 nearfull 。</span>        mon osd nearfull ratio = <span class="hljs-string">.70</span></code></pre><div class="note note-primary">            <p>如果一些 OSD 快满了，但其他的仍有足够空间，你可能配错 CRUSH 权重了。</p>          </div><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>Ceph 监视器要求各 OSD 向它报告、并接收 OSD 们的邻居状态报告，以此来掌握集群。 Ceph 提供了监视器与 OSD 交互的合理默认值，然而你可以按需修改，详情见<a href="http://docs.ceph.org.cn/rados/configuration/mon-osd-interaction">监视器与 OSD 的交互</a>。</p><h3 id="监视器存储同步"><a href="#监视器存储同步" class="headerlink" title="监视器存储同步"></a>监视器存储同步</h3><p>当你用多个监视器支撑一个生产集群时，各监视器都要检查邻居是否有集群运行图的最新版本（如，邻居监视器的图有一或多个 epoch 版本高于当前监视器的最高版 epoch ），过一段时间，集群里的某个监视器可能落后于其它监视器太多而不得不离开法定人数，然后同步到集群当前状态，并重回法定人数。为了同步，监视器可能承担三种中的一种角色：</p><ol><li><strong>Leader</strong>: Leader 是实现最新 Paxos 版本的第一个监视器。</li><li><strong>Provider</strong>: Provider 有最新集群运行图的监视器，但不是第一个实现最新版。</li><li><strong>Requester:</strong> Requester 落后于 leader ，重回法定人数前，必须同步以获取关于集群的最新信息。</li></ol><p>有了这些角色区分， leader就 可以给 provider 委派同步任务，这会避免同步请求压垮 leader 、影响性能。在下面的图示中， requester 已经知道它落后于其它监视器，然后向 leader 请求同步， leader 让它去和 provider 同步。</p><hr><p><img src="\img\ceph-mon2.png" alt="img"></p><p>一旦同步完成， Ceph 需要修复整个集群，使归置组回到 <code>active + clean</code> 状态。</p><div class="table-container"><table><thead><tr><th>Parameters</th><th>Descrip.</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>mon sync timeout</td><td>Number of seconds the monitor will wait for the next update message from its sync provider before it gives up and bootstrap again.</td><td>Double</td><td>60.0</td></tr><tr><td>mon sync max payload size</td><td>The maximum size for a sync payload (in bytes).</td><td>32-bit Integer</td><td>1048576</td></tr><tr><td>paxos max join drift</td><td>The maximum Paxos iterations before we must first sync the monitor data stores. When a monitor finds that its peer is too far ahead of it, it will first sync with data stores before moving on.</td><td>Integer</td><td>10</td></tr><tr><td>paxos stash full interval</td><td>How often (in commits) to stash a full copy of the PaxosService state. Current this setting only affects <code>mds</code>, <code>mon</code>, <code>auth</code> and <code>mgr</code> PaxosServices.</td><td>Integer</td><td>25</td></tr><tr><td>paxos propose interval</td><td>Gather updates for this time interval before proposing a map update.</td><td>Double</td><td>1.0</td></tr><tr><td>paxos min</td><td>The minimum number of paxos states to keep around</td><td>Integer</td><td>500</td></tr><tr><td>paxos min wait</td><td>The minimum amount of time to gather updates after a period of inactivity.</td><td>Double</td><td>0.05</td></tr><tr><td>paxos trim min</td><td>Number of extra proposals tolerated before trimming</td><td>Integer</td><td>250</td></tr><tr><td>paxos trim max</td><td>The maximum number of extra proposals to trim at a time</td><td>Integer</td><td>500</td></tr><tr><td>paxos service trim min</td><td>The minimum amount of versions to trigger a trim (0 disables it)</td><td>Integer</td><td>250</td></tr><tr><td>paxos service trim max</td><td>The maximum amount of versions to trim during a single proposal (0 disables it)</td><td>Integer</td><td>500</td></tr><tr><td>mon mds force trim to</td><td>Force monitor to trim mdsmaps to this point (0 disables it. dangerous, use with care)</td><td>Integer</td><td>0</td></tr><tr><td>mon osd force trim to</td><td>Force monitor to trim osdmaps to this point, even if there is PGs not clean at the specified epoch (0 disables it. dangerous, use with care)</td><td>Integer</td><td>0</td></tr><tr><td>mon osd cache size</td><td>The size of osdmaps cache, not to rely on underlying store’s cache</td><td>Integer</td><td>500</td></tr><tr><td>mon election timeout</td><td>On election proposer, maximum waiting time for all ACKs in seconds.</td><td>Float</td><td>5.00</td></tr><tr><td>mon lease</td><td>The length (in seconds) of the lease on the monitor’s versions.</td><td>Float</td><td>5.00</td></tr><tr><td>mon lease renew interval factor</td><td><code>mon lease</code> * <code>mon lease renew interval factor</code> will be the interval for the Leader to renew the other monitor’s leases. The factor should be less than <code>1.0</code>.</td><td>Float</td><td>0.60</td></tr><tr><td>mon lease ack timeout factor</td><td>The Leader will wait <code>mon lease</code> * <code>mon lease ack timeout factor</code> for the Providers to acknowledge the lease extension.</td><td>Float</td><td>2.00</td></tr><tr><td>mon accept timeout factor</td><td>The Leader will wait <code>mon lease</code> * <code>mon accept timeout factor</code> for the Requester(s) to accept a Paxos update. It is also used during the Paxos recovery phase for similar purposes.</td><td>Float</td><td>2.00</td></tr><tr><td>mon min osdmap epochs</td><td>Minimum number of OSD map epochs to keep at all times.</td><td>32-bit Integer</td><td>500</td></tr><tr><td>mon max log epochs</td><td>Maximum number of Log epochs the monitor should keep.</td><td>32-bit Integer</td><td>500</td></tr></tbody></table></div><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>Ceph 的守护进程会相互传递关键消息，这些消息必须在达到超时阀值前处理掉。如果 Ceph 监视器时钟不同步，就可能出现多种异常情况。例如：</p><ul><li>守护进程忽略了收到的消息（如时间戳过时了）</li><li>消息未及时收到时，超时触发得太快或太晚。</li></ul><p>详情见<a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref/#id13">监视器存储同步</a>和 <a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref/#slurp">Slurp</a> 。</p><p>为了避免实际漂移建议安装<code>NTP</code></p><div class="table-container"><table><thead><tr><th>Parameters</th><th>Descrip.</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>mon tick interval</td><td>A monitor’s tick interval in seconds.</td><td>32-bit Integer</td><td>5</td></tr><tr><td>mon clock drift allowed</td><td>The clock drift in seconds allowed between monitors.</td><td>Float</td><td>0.05</td></tr><tr><td>mon clock drift warn backoff</td><td>Exponential backoff for clock drift warnings</td><td>Float</td><td>5.00</td></tr><tr><td>mon timecheck interval</td><td>The time check interval (clock drift check) in seconds for the Leader.</td><td>Float</td><td>300.0</td></tr><tr><td>mon timecheck skew interval</td><td>The time check interval (clock drift check) in seconds when in presence of a skew in seconds for the Leader.</td><td>Float</td><td>30.0</td></tr></tbody></table></div><ul><li><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2></li></ul><div class="table-container"><table><thead><tr><th>Parameters</th><th>Descrip.</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>mon client hunt interval</td><td>The client will try a new monitor every <code>N</code> seconds until it establishes a connection.</td><td>Double</td><td>3.00</td></tr><tr><td>mon client ping interval</td><td>The client will ping the monitor every <code>N</code> seconds.</td><td>Double</td><td>10.00</td></tr><tr><td>mon client max log entries per message</td><td>The maximum number of log entries a monitor will generate per client message.</td><td>Integer</td><td>1000</td></tr><tr><td>mon client bytes</td><td>The amount of client message data allowed in memory (in bytes).</td><td>64-bit Integer Unsigned</td><td>100ul &lt;&lt; 20</td></tr></tbody></table></div><h2 id="Pool-Settings"><a href="#Pool-Settings" class="headerlink" title="Pool Settings"></a>Pool Settings</h2><div class="table-container"><table><thead><tr><th>Parameters</th><th>Descrip.</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>mon allow pool delete</td><td>If the monitors should allow pools to be removed. Regardless of what the pool flags say.</td><td>Boolean</td><td>false</td></tr><tr><td>osd pool default ec fast read</td><td>Whether to turn on fast read on the pool or not. It will be used as the default setting of newly created erasure coded pools if <code>fast_read</code> is not specified at create time.</td><td>Boolean</td><td>false</td></tr><tr><td>osd pool default flag hashpspool</td><td>Set the hashpspool flag on new pools</td><td>Boolean</td><td>true</td></tr><tr><td>osd pool default flag nodelete</td><td>Set the nodelete flag on new pools. Prevents allow pool removal with this flag in any way.</td><td>Boolean</td><td>false</td></tr><tr><td>osd pool default flag nopgchange</td><td>Set the nopgchange flag on new pools. Does not allow the number of PGs to be changed for a pool.</td><td>Boolean</td><td>false</td></tr><tr><td>osd pool default flag nosizechange</td><td>Set the nosizechange flag on new pools. Does not allow the size to be changed of pool.</td><td>Boolean</td><td>false</td></tr></tbody></table></div><p>For more information about the pool flags see <a href="https://docs.ceph.com/en/latest/rados/operations/pools/#set-pool-values">Pool values</a>.</p><hr><h2 id="Miscellaneous¶"><a href="#Miscellaneous¶" class="headerlink" title="Miscellaneous¶"></a>Miscellaneous<a href="https://docs.ceph.com/en/latest/rados/configuration/mon-config-ref/#miscellaneous">¶</a></h2><p>Please click… the link icon.</p><h2 id="文档编译"><a href="#文档编译" class="headerlink" title="文档编译"></a>文档编译</h2><p>安装和使用</p><pre><code class="hljs sql">sudo apt-get <span class="hljs-keyword">install</span> cat doc_deps.deb.txt<span class="hljs-keyword">admin</span>/<span class="hljs-keyword">build</span>-doc</code></pre><hr><h2 id="加速本地编译"><a href="#加速本地编译" class="headerlink" title="加速本地编译"></a>加速本地编译</h2><p><a href="https://docs.ceph.com/en/latest/dev/developer_guide/essentials/#using-ccache-to-speed-up-local-builds">https://docs.ceph.com/en/latest/dev/developer_guide/essentials/#using-ccache-to-speed-up-local-builds</a></p><h1 id="为ceph社区做出自己的贡献"><a href="#为ceph社区做出自己的贡献" class="headerlink" title="为ceph社区做出自己的贡献"></a>为ceph社区做出自己的贡献</h1><p>Mailing list</p><p>The <code>dev@ceph.io</code> list is for discussion about the development of Ceph, its interoperability with other technology, and the operations of the project itself. Subscribe by sending a message to <code>dev-request@ceph.io</code> with the line:</p><pre><code class="hljs ebnf"><span class="hljs-attribute">subscribe ceph-devel</span></code></pre><p>in the body of the message.</p><p>The <a href="mailto:ceph-devel%40vger.kernel.org">ceph-devel@vger.kernel.org</a> list is for discussion and patch review for the Linux kernel Ceph client component. Subscribe by sending a message to <code>majordomo@vger.kernel.org</code> with the line:</p><pre><code class="hljs ebnf"><span class="hljs-attribute">subscribe ceph-devel</span></code></pre><p>in the body of the message.</p><hr><h1 id="Trouble-Shooting-Runtime"><a href="#Trouble-Shooting-Runtime" class="headerlink" title="Trouble Shooting: Runtime"></a>Trouble Shooting: Runtime</h1><ol><li><pre><code class="hljs apache"><span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">47</span>.<span class="hljs-number">856064</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> accepter.accepter.bind unable to bind to <span class="hljs-number">101.67.163.20:6789</span>: (<span class="hljs-number">99</span>) Cannot assign requested address<span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">47</span>.<span class="hljs-number">856085</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> accepter.accepter.bind was unable to bind. Trying again in <span class="hljs-number">5</span> seconds<span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">52</span>.<span class="hljs-number">856281</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> accepter.accepter.bind unable to bind to <span class="hljs-number">101.67.163.20:6789</span>: (<span class="hljs-number">99</span>) Cannot assign requested address<span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">52</span>.<span class="hljs-number">856319</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> accepter.accepter.bind was unable to bind. Trying again in <span class="hljs-number">5</span> seconds<span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">57</span>.<span class="hljs-number">856622</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> accepter.accepter.bind unable to bind to <span class="hljs-number">101.67.163.20:6789</span>: (<span class="hljs-number">99</span>) Cannot assign requested address<span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">57</span>.<span class="hljs-number">856657</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> accepter.accepter.bind was unable to bind after <span class="hljs-number">3</span> attempts: (<span class="hljs-number">99</span>) Cannot assign requested address<span class="hljs-attribute">2015</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">57</span>.<span class="hljs-number">856670</span> <span class="hljs-number">7</span>f<span class="hljs-number">4</span>a<span class="hljs-number">5</span>a<span class="hljs-number">36</span>a<span class="hljs-number">7</span>a<span class="hljs-number">0</span> -<span class="hljs-number">1</span> unable to bind monitor to <span class="hljs-number">101.67.163.20:6789</span>/<span class="hljs-number">0</span><span class="hljs-attribute">failed</span>: &#x27;ssh ceph-<span class="hljs-number">10</span> ulimit -n <span class="hljs-number">32768</span>;  /usr/bin/ceph-mon -i a --pid-file /var/run/ceph/mon.a.pid -c /etc/ceph/ceph.conf --cluster ceph &#x27;</code></pre></li></ol><p>这是由于ip地址更换的原因，检查一下。</p><p>2.</p><p>sudo 执行很慢，可以改/etc/hosts </p><p><a href="https://www.cnblogs.com/mouseleo/p/9302301.html">https://www.cnblogs.com/mouseleo/p/9302301.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ceph</category>
      
      <category>分布式存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构</tag>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM命令查询</title>
    <link href="/2020/10/18/VIMdict/"/>
    <url>/2020/10/18/VIMdict/</url>
    
    <content type="html"><![CDATA[<h1 id="VIM命令查询本"><a href="#VIM命令查询本" class="headerlink" title="VIM命令查询本"></a>VIM命令查询本</h1><h1 id="1-1-Vim的几种模式"><a href="#1-1-Vim的几种模式" class="headerlink" title="1.1 Vim的几种模式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60">1.1 Vim的几种模式</a></h1><ul><li>正常模式：可以使用快捷键命令，或按:输入命令行。</li><li>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。</li><li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</li><li>替换模式：正常模式下，按R进入。</li></ul><h1 id="2-启动Vim"><a href="#2-启动Vim" class="headerlink" title="2. 启动Vim"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61">2. 启动Vim</a></h1><ul><li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li><li>vim -r file: 恢复上次异常退出的文件；</li><li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li><li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li><li>vim -y num file: 将编辑窗口的大小设为num行；</li><li>vim + file: 从文件的末尾开始；</li><li>vim +num file: 从第num行开始；</li><li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li><li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li></ul><h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62">3. 文档操作</a></h1><ul><li>:e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</li><li>:e! file –放弃对当前文件的修改，编辑新的文件。</li><li>:e+file – 开始新的文件，并从文件尾开始编辑。</li><li>:e+n file – 开始新的文件，并从第n行开始编辑。</li><li>:enew –编译一个未命名的新文档。(CTRL-W n)</li><li>:e – 重新加载当前文档。</li><li>:e! – 重新加载当前文档，并丢弃已做的改动。</li><li>:e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li><li>:f或ctrl+g – 显示文档名，是否修改，和光标位置。</li><li>:f filename – 改变编辑的文件名，这时再保存相当于另存为。</li><li>gf – 打开以光标所在字符串为文件名的文件。</li><li>:w – 保存修改。</li><li>:n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li><li>:wq – 保存并退出。</li><li>ZZ – 保存并退出。</li><li>:x – 保存并退出。</li><li>:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li><li>:saveas newfilename – 另存为</li><li>:browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：<ul><li>:set browsedir=last – 用上次访问过的目录（默认）；</li><li>:set browsedir=buffer – 用当前文件所在目录；</li><li>:set browsedir=current – 用当前工作目录；</li></ul></li><li>:Sex – 水平分割一个窗口，浏览文件系统；</li><li>:Vex – 垂直分割一个窗口，浏览文件系统；</li></ul><h1 id="4-光标的移动"><a href="#4-光标的移动" class="headerlink" title="4. 光标的移动"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63">4. 光标的移动</a></h1><h2 id="4-1-基本移动"><a href="#4-1-基本移动" class="headerlink" title="4.1 基本移动"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64">4.1 基本移动</a></h2><p>以下移动都是在normal模式下。</p><ul><li>h或退格: 左移一个字符；</li><li>l或空格: 右移一个字符；</li><li>j: 下移一行；</li><li>k: 上移一行；</li><li>gj: 移动到一段内的下一行；</li><li>gk: 移动到一段内的上一行；</li><li>+或Enter: 把光标移至下一行第一个非空白字符。</li><li>-: 把光标移至上一行第一个非空白字符。</li><li>w: 前移一个单词，光标停在下一个单词开头；</li><li>W: 移动下一个单词开头，但忽略一些标点；</li><li>e: 前移一个单词，光标停在下一个单词末尾；</li><li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li><li>b: 后移一个单词，光标停在上一个单词开头；</li><li>B: 移动到上一个单词开头，忽略一些标点；</li><li>ge: 后移一个单词，光标停在上一个单词末尾；</li><li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li><li>(: 前移1句。</li><li>): 后移1句。</li><li>{: 前移1段。</li><li>}: 后移1段。</li><li>fc: 把光标移到同一行的下一个c字符处</li><li>Fc: 把光标移到同一行的上一个c字符处</li><li>tc: 把光标移到同一行的下一个c字符前</li><li>Tc: 把光标移到同一行的上一个c字符后</li><li>;: 配合f &amp; t使用，重复一次</li><li>,: 配合f &amp; t使用，反向重复一次</li></ul><p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p><ul><li>0: 移动到行首。</li><li>g0: 移到光标所在屏幕行行首。</li><li>^: 移动到本行第一个非空白字符。</li><li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li><li>: 移动光标所在屏幕行行尾。</li><li>n|: 把光标移到递n列上。</li><li>nG: 到文件第n行。</li><li>:n<cr> 移动到第n行。</li><li>:$<cr> 移动到最后一行。</li><li>H: 把光标移到屏幕最顶端一行。</li><li>M: 把光标移到屏幕中间一行。</li><li>L: 把光标移到屏幕最底端一行。</li><li>gg: 到文件头部。</li><li>G: 到文件尾部。</li></ul><h2 id="4-2-翻屏"><a href="#4-2-翻屏" class="headerlink" title="4.2 翻屏"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65">4.2 翻屏</a></h2><ul><li>ctrl+f: 下翻一屏。</li><li>ctrl+b: 上翻一屏。</li><li>ctrl+d: 下翻半屏。</li><li>ctrl+u: 上翻半屏。</li><li>ctrl+e: 向下滚动一行。</li><li>ctrl+y: 向上滚动一行。</li><li>n%: 到文件n%的位置。</li><li>zz: 将当前行移动到屏幕中央。</li><li>zt: 将当前行移动到屏幕顶端。</li><li>zb: 将当前行移动到屏幕底端。</li></ul><h2 id="4-3-标记"><a href="#4-3-标记" class="headerlink" title="4.3 标记"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66">4.3 标记</a></h2><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。</p><ul><li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li><li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>`{a-z}: 移动到标记位置。</li><li>‘{a-z}: 移动到标记行的行首。</li><li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li><li>“: 移动到上次编辑的位置。”也可以，不过“精确到列，而”精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li><li>`”: 移动到上次离开的地方。</li><li>`.: 移动到最后改动的地方。</li><li>:marks 显示所有标记。</li><li>:delmarks a b – 删除标记a和b。</li><li>:delmarks a-c – 删除标记a、b和c。</li><li>:delmarks a c-f – 删除标记a、c、d、e、f。</li><li>:delmarks! – 删除当前缓冲区的所有标记。</li><li>:help mark-motions 查看更多关于mark的知识。</li></ul><h1 id="5-插入文本"><a href="#5-插入文本" class="headerlink" title="5. 插入文本"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67">5. 插入文本</a></h1><h2 id="5-1-基本插入"><a href="#5-1-基本插入" class="headerlink" title="5.1 基本插入"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68">5.1 基本插入</a></h2><ul><li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</li><li>I: 在当前行第一个非空字符前插入；</li><li>gI: 在当前行第一列插入；</li><li>a: 在光标后插入；</li><li>A: 在当前行最后插入；</li><li>o: 在下面新建一行插入；</li><li>O: 在上面新建一行插入；</li><li>:r filename在当前位置插入另一个文件的内容。</li><li>:[n]r filename在第n行插入另一个文件的内容。</li><li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li></ul><h2 id="5-2-改写插入"><a href="#5-2-改写插入" class="headerlink" title="5.2 改写插入"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69">5.2 改写插入</a></h2><ul><li>c[n]w: 改写光标后1(n)个词。</li><li>c[n]l: 改写光标后n个字母。</li><li>c[n]h: 改写光标前n个字母。</li><li>[n]cc: 修改当前[n]行。</li><li>[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</li><li>[n]S: 删除指定数目的行，并以所输入文本代替之。</li></ul><p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p><h1 id="6-剪切复制和寄存器"><a href="#6-剪切复制和寄存器" class="headerlink" title="6. 剪切复制和寄存器"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70">6. 剪切复制和寄存器</a></h1><h2 id="6-1-剪切和复制、粘贴"><a href="#6-1-剪切和复制、粘贴" class="headerlink" title="6.1 剪切和复制、粘贴"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71">6.1 剪切和复制、粘贴</a></h2><ul><li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li><li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li><li>y: 复制在可视模式下选中的文本。</li><li>yy or Y: 复制整行文本。</li><li>y[n]w: 复制一(n)个词。</li><li>y[n]l: 复制光标右边1(n)个字符。</li><li>y[n]h: 复制光标左边1(n)个字符。</li><li>yor D: 删除（剪切）当前位置到行尾的内容。</li><li>d[n]w: 删除（剪切）1(n)个单词</li><li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li><li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li><li>d0: 删除（剪切）当前位置到行首的内容</li><li>[n] dd: 删除（剪切）1(n)行。</li><li>:m,nd<cr> 剪切m行到n行的内容。</li><li>d1G或dgg: 剪切光标以上的所有行。</li><li>dG: 剪切光标以下的所有行。</li><li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li>d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</li><li>p: 在光标之后粘贴。</li><li>P: 在光标之前粘贴。</li></ul><h2 id="6-2-文本对象"><a href="#6-2-文本对象" class="headerlink" title="6.2 文本对象"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72">6.2 文本对象</a></h2><ul><li>aw：一个词</li><li>as：一句。</li><li>ap：一段。</li><li>ab：一块（包含在圆括号中的）。</li></ul><p>y, d, c, v都可以跟文本对象。</p><h2 id="6-3-寄存器"><a href="#6-3-寄存器" class="headerlink" title="6.3 寄存器"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73">6.3 寄存器</a></h2><ul><li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li><li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。</li><li>:reg 显示所有寄存器的内容。</li><li>“”：不加寄存器索引时，默认使用的寄存器。</li><li>“<em>：当前选择缓冲区，”</em>yy把当前行的内容放入当前选择缓冲区。</li><li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li></ul><h1 id="7-查找与替换"><a href="#7-查找与替换" class="headerlink" title="7. 查找与替换"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74">7. 查找与替换</a></h1><h2 id="7-1-查找"><a href="#7-1-查找" class="headerlink" title="7.1 查找"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75">7.1 查找</a></h2><ul><li>/something: 在后面的文本中查找something。</li><li>?something: 在前面的文本中查找something。</li><li>/pattern/+number: 将光标停在包含pattern的行后面第number行上。</li><li>/pattern/-number: 将光标停在包含pattern的行前面第number行上。</li><li>n: 向后查找下一个。</li><li>N: 向前查找下一个。</li></ul><p>可以用grep或vimgrep查找一个模式都在哪些地方出现过，</p><p>其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。</p><p>用法为： :vim[grep]/pattern/[g] [j] files</p><p>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p><p>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</p><p>vimgrep前面可以加数字限定搜索结果的上限，如</p><p>:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。</p><p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。</p><p>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：</p><p>:vim/^d{1,}./ %</p><p>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，</p><p>就更像个目录了。</p><h2 id="7-2-替换"><a href="#7-2-替换" class="headerlink" title="7.2 替换"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76">7.2 替换</a></h2><ul><li>:s/old/new - 用new替换当前行第一个old。</li><li>:s/old/new/g - 用new替换当前行所有的old。</li><li>:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。</li><li>:%s/old/new/g - 用new替换文件中所有的old。</li><li>:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。</li><li>:%s/表示行尾。</li><li>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</li></ul><p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p><p>语法为 :[range]g/pattern/command</p><p>例如 :%g/^ xyz/normal dd。</p><p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p><p>关于range的规定为：</p><ul><li>如果不指定range，则表示当前行。</li><li>m,n: 从m行到n行。</li><li>0: 最开始一行（可能是这样）。</li><li>$: 最后一行</li><li>.: 当前行</li><li>%: 所有行</li></ul><h2 id="7-3-正则表达式"><a href="#7-3-正则表达式" class="headerlink" title="7.3 正则表达式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77">7.3 正则表达式</a></h2><p>高级的查找替换就要用到正则表达式。</p><ul><li>\d: 表示十进制数（我猜的）</li><li>\s: 表示空格</li><li>\S: 非空字符</li><li>\a: 英文字母</li><li>|: 表示 或</li><li>.: 表示.</li><li>{m,n}: 表示m到n个字符。这要和 \s与\a等连用，如 \a\{m,n} 表示m 到n个英文字母。</li><li>{m,}: 表示m到无限多个字符。</li><li>**: 当前目录下的所有子目录。</li></ul><p>:help pattern得到更多帮助。</p><hr><h1 id="8-排版"><a href="#8-排版" class="headerlink" title="8. 排版"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78">8. 排版</a></h1><h2 id="8-1-基本排版"><a href="#8-1-基本排版" class="headerlink" title="8.1 基本排版"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79">8.1 基本排版</a></h2><ul><li>&lt;&lt; 向左缩进一个shiftwidth</li><li>>&gt; 向右缩进一个shiftwidth</li><li>:ce(nter) 本行文字居中</li><li>:le(ft) 本行文字靠左</li><li>:ri(ght) 本行文字靠右</li><li>gq 对选中的文字重排，即对过长的文字进行断行</li><li>gqq 重排当前行</li><li>gqnq 重排n行</li><li>gqap 重排当前段</li><li>gqnap 重排n段</li><li>gqnj 重排当前行和下面n行</li><li>gqQ 重排当前段对文章末尾</li><li>J 拼接当前行和下一行</li><li>gJ 同 J ，不过合并后不留空格。</li></ul><h2 id="8-2-拼写检查"><a href="#8-2-拼写检查" class="headerlink" title="8.2 拼写检查"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80">8.2 拼写检查</a></h2><ul><li>:set spell－开启拼写检查功能</li><li>:set nospell－关闭拼写检查功能</li><li>]s－移到下一个拼写错误的单词</li><li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li><li>z=－显示一个有关拼写错误单词的列表，可从中选择</li><li>zg－告诉拼写检查器该单词是拼写正确的</li><li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li></ul><h2 id="8-3-统计字数"><a href="#8-3-统计字数" class="headerlink" title="8.3 统计字数"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81">8.3 统计字数</a></h2><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p><hr><h1 id="9-编辑多个文件"><a href="#9-编辑多个文件" class="headerlink" title="9. 编辑多个文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82">9. 编辑多个文件</a></h1><h2 id="9-1-一次编辑多个文件"><a href="#9-1-一次编辑多个文件" class="headerlink" title="9.1 一次编辑多个文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83">9.1 一次编辑多个文件</a></h2><p>我们可以一次打开多个文件，如</p><blockquote><pre><code class="hljs stylus">vi <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.txt</span> c.txt</code></pre></blockquote><ul><li>使用:next(:n)编辑下一个文件。</li><li>:2n 编辑下2个文件。</li><li>使用:previous或:N编辑上一个文件。</li><li>使用:wnext，保存当前文件，并编辑下一个文件。</li><li>使用:wprevious，保存当前文件，并编辑上一个文件。</li><li>使用:args 显示文件列表。</li><li>:n filenames或:args filenames 指定新的文件列表。</li><li>vi -o filenames 在水平分割的多个窗口中编辑多个文件。</li><li>vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</li></ul><h2 id="9-2-多标签编辑"><a href="#9-2-多标签编辑" class="headerlink" title="9.2 多标签编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84">9.2 多标签编辑</a></h2><ul><li>vim -p files: 打开多个文件，每个文件占用一个标签页。</li><li>:tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li><li>^w gf – 在新的标签页里打开光标下路径指定的文件。</li><li>:tabn – 切换到下一个标签。Control + PageDown，也可以。</li><li>:tabp – 切换到上一个标签。Control + PageUp，也可以。</li><li>[n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</li><li>:tab split – 将当前缓冲区的内容在新页签中打开。</li><li>:tabc[lose] – 关闭当前的标签页。</li><li>:tabo[nly] – 关闭其它的标签页。</li><li>:tabs – 列出所有的标签页和它们包含的窗口。</li><li>:tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li></ul><h2 id="9-3-缓冲区"><a href="#9-3-缓冲区" class="headerlink" title="9.3 缓冲区"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85">9.3 缓冲区</a></h2><ul><li>:buffers或:ls或:files 显示缓冲区列表。</li><li>ctrl+^：在最近两个缓冲区间切换。</li><li>:bn – 下一个缓冲区。</li><li>:bp – 上一个缓冲区。</li><li>:bl – 最后一个缓冲区。</li><li>:b[n]或:[n]b – 切换到第n个缓冲区。</li><li>:nbw(ipeout) – 彻底删除第n个缓冲区。</li><li>:nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</li><li>:ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li></ul><h1 id="10-分屏编辑"><a href="#10-分屏编辑" class="headerlink" title="10. 分屏编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86">10. 分屏编辑</a></h1><ul><li>vim -o file1 file2:水平分割窗口，同时打开file1和file2</li><li>vim -O file1 file2:垂直分割窗口，同时打开file1和file2</li></ul><h2 id="10-1-水平分割"><a href="#10-1-水平分割" class="headerlink" title="10.1 水平分割"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87">10.1 水平分割</a></h2><ul><li>:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</li><li>:split filename – 水平分割窗口，并在新窗口中显示另一个文件。</li><li>:nsplit(:nsp) – 水平分割出一个n行高的窗口。</li><li>:[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</li><li>ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li><li>C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</li></ul><h2 id="10-2-垂直分割"><a href="#10-2-垂直分割" class="headerlink" title="10.2 垂直分割"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88">10.2 垂直分割</a></h2><ul><li>:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</li><li>:[N]vne[w] – 垂直分割出一个新窗口。</li><li>:vertical 水平分割的命令： 相应的垂直分割。</li></ul><h2 id="10-3-关闭子窗口"><a href="#10-3-关闭子窗口" class="headerlink" title="10.3 关闭子窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89">10.3 关闭子窗口</a></h2><ul><li>:qall – 关闭所有窗口，退出vim。</li><li>:wall – 保存所有修改过的窗口。</li><li>:only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)</li><li>:close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</li></ul><h2 id="10-4-调整窗口大小"><a href="#10-4-调整窗口大小" class="headerlink" title="10.4 调整窗口大小"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90">10.4 调整窗口大小</a></h2><ul><li>ctrl+w + –当前窗口增高一行。也可以用n增高n行。</li><li>ctrl+w - –当前窗口减小一行。也可以用n减小n行。</li><li>ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。</li><li>:resize n – 当前窗口n行高。</li><li>ctrl+w = – 所有窗口同样高度。</li><li>n ctrl+w _ – 当前窗口的高度设定为n行。</li><li>ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。</li><li>ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。</li><li>ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</li></ul><h2 id="10-5-切换和移动窗口"><a href="#10-5-切换和移动窗口" class="headerlink" title="10.5 切换和移动窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91">10.5 切换和移动窗口</a></h2><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><ul><li>ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</li><li>ctrl+w p: 切换到前一个窗口。</li><li>ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</li><li>ctrl+w t(b):切换到最上（下）面的窗口。<BR></li><li>ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</li><li>ctrl+w r：旋转窗口的位置。</li><li>ctrl+w T: 将当前的窗口移动到新的标签页上。</li></ul><h1 id="11-快速编辑"><a href="#11-快速编辑" class="headerlink" title="11. 快速编辑"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92">11. 快速编辑</a></h1><h2 id="11-1-改变大小写"><a href="#11-1-改变大小写" class="headerlink" title="11.1 改变大小写"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93">11.1 改变大小写</a></h2><ul><li>~: 反转光标所在字符的大小写。</li><li>可视模式下的U或u：把选中的文本变为大写或小写。</li><li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</li></ul><h2 id="11-2-替换（normal模式）"><a href="#11-2-替换（normal模式）" class="headerlink" title="11.2 替换（normal模式）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94">11.2 替换（normal模式）</a></h2><ul><li>r: 替换光标处的字符，同样支持汉字。</li><li>R: 进入替换模式，按esc回到正常模式。</li></ul><h2 id="11-3-撤消与重做（normal模式）"><a href="#11-3-撤消与重做（normal模式）" class="headerlink" title="11.3 撤消与重做（normal模式）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95">11.3 撤消与重做（normal模式）</a></h2><ul><li>[n] u: 取消一(n)个改动。</li><li>:undo 5 – 撤销5个改变。</li><li>:undolist – 你的撤销历史。</li><li>ctrl + r: 重做最后的改动。</li><li>U: 取消当前行中所有的改动。</li><li>:earlier 4m – 回到4分钟前</li><li>:later 55s – 前进55秒</li></ul><h2 id="11-4-宏"><a href="#11-4-宏" class="headerlink" title="11.4 宏"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96">11.4 宏</a></h2><ul><li>. –重复上一个编辑动作</li><li>qa：开始录制宏a（键盘操作记录）</li><li>q：停止录制</li><li>@a：播放宏a</li></ul><h1 id="12-编辑特殊文件"><a href="#12-编辑特殊文件" class="headerlink" title="12. 编辑特殊文件"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97">12. 编辑特殊文件</a></h1><h2 id="12-1-文件加解密"><a href="#12-1-文件加解密" class="headerlink" title="12.1 文件加解密"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98">12.1 文件加解密</a></h2><ul><li>vim -x file: 开始编辑一个加密的文件。</li><li>:X – 为当前文件设置密码。</li><li>:set key= – 去除文件的密码。</li></ul><p><a href="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html">这里是</a> 滇狐总结的比较高级的vi技巧。</p><h2 id="12-2-文件的编码"><a href="#12-2-文件的编码" class="headerlink" title="12.2 文件的编码"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99">12.2 文件的编码</a></h2><ul><li>:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。</li><li>:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。</li><li>:set fenc或:set fileencoding，查看当前文件的编码。</li><li>在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li></ul><p>让vim 正确处理文件格式和文件编码，有赖于 <a href="http://www.cnblogs.com/jiqingwu/admin/vimrc.html">~/.vimrc的正确配置</a></p><h2 id="12-3-文件格式"><a href="#12-3-文件格式" class="headerlink" title="12.3 文件格式"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100">12.3 文件格式</a></h2><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><ul><li>:e ++ff=dos filename, 让vim用dos格式打开这个文件。</li><li>:w ++ff=mac filename, 以mac格式存储这个文件。</li><li>:set ff，显示当前文件的格式。</li><li>在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</li></ul><h1 id="13-编程辅助"><a href="#13-编程辅助" class="headerlink" title="13. 编程辅助"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101">13. 编程辅助</a></h1><h2 id="13-1-一些按键"><a href="#13-1-一些按键" class="headerlink" title="13.1 一些按键"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102">13.1 一些按键</a></h2><ul><li>gd: 跳转到局部变量的定义处；</li><li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li>g;: 上一个修改过的地方；</li><li>g,: 下一个修改过的地方；</li><li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li><li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li><li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li><li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li><li>[{: 跳转到当前块开始处；</li><li>]}: 跳转到当前块结束处；</li><li>[/: 跳转到当前注释块开始处；</li><li>]/: 跳转到当前注释块结束处；</li><li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li></ul><p>下面的括号匹配对编程很实用的。</p><ul><li>ci’, di’, yi’：修改、剪切或复制’之间的内容。</li><li>ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。</li><li>ci”, di”, yi”：修改、剪切或复制”之间的内容。</li><li>ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。</li><li>ci(, di(, yi(：修改、剪切或复制()之间的内容。</li><li>ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</li><li>ci[, di[, yi[：修改、剪切或复制[]之间的内容。</li><li>ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</li><li>ci{, di{, yi{：修改、剪切或复制{}之间的内容。</li><li>ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。</li><li>ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</li><li>ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</li></ul><h2 id="13-2-ctags"><a href="#13-2-ctags" class="headerlink" title="13.2 ctags"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103">13.2 ctags</a></h2><ul><li>ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</li><li>:set tags=path/tags – 告诉ctags使用哪个tag文件</li><li>:tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</li><li>:stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</li><li>:ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。</li><li>:pclose – 关闭预览窗口。热键是C-w z。</li><li>:pedit abc.h – 在预览窗口中编辑abc.h</li><li>:psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</li></ul><p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><ul><li>:[n]tnext – 下一[n]个匹配。</li><li>:[n]tprev – 上一[n]个匹配。</li><li>:tfirst – 第一个匹配</li><li>:tlast – 最后一个匹配</li><li>:tselect tagname – 打开选择列表</li></ul><p>tab键补齐</p><ul><li>:tag xyz<tab> – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</li><li>:tag /xyz<tab> – 会用名字中含有xyz的tag名补全。</li></ul><h2 id="13-3-cscope"><a href="#13-3-cscope" class="headerlink" title="13.3 cscope"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104">13.3 cscope</a></h2><ul><li>cscope -Rbq: 生成cscope.out文件</li><li>:cs add /path/to/cscope.out /your/work/dir</li><li>:cs find c func – 查找func在哪些地方被调用</li><li>:cw – 打开quickfix窗口查看结果</li></ul><h2 id="13-4-gtags"><a href="#13-4-gtags" class="headerlink" title="13.4 gtags"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105">13.4 gtags</a></h2><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p><ul><li>:Gtags funcname 定位到 funcname 的定义处。</li><li>:Gtags -r funcname 查询 funcname被引用的地方。</li><li>:Gtags -s symbol 定位 symbol 出现的地方。</li><li>:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</li><li>:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</li><li>:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。</li></ul><h2 id="13-5-编译"><a href="#13-5-编译" class="headerlink" title="13.5 编译"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106">13.5 编译</a></h2><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p><p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.<a href="http://lib.csdn.net/base/java">Java</a>文件，你可以这样设置：</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">makeprg</span>=javac\ abc.java</code></pre><p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p><pre><code class="hljs asciidoc"><span class="hljs-meta">:setl efm=%A%f:%l:\</span> %m,%-Z%p^,%-C%.%#</code></pre><p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p><h2 id="13-6-快速修改窗口"><a href="#13-6-快速修改窗口" class="headerlink" title="13.6 快速修改窗口"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107">13.6 快速修改窗口</a></h2><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p><ul><li>:copen – 打开快速修改窗口。</li><li>:cclose – 关闭快速修改窗口。</li></ul><p>快速修改窗口在make程序时非常有用，当make之后：</p><ul><li>:cl – 在快速修改窗口中列出错误。</li><li>:cn – 定位到下一个错误。</li><li>:cp – 定位到上一个错误。</li><li>:cr – 定位到第一个错误。</li></ul><h2 id="13-7-自动补全"><a href="#13-7-自动补全" class="headerlink" title="13.7 自动补全"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108">13.7 自动补全</a></h2><ul><li>C-x C-s – 拼写建议。</li><li>C-x C-v – 补全vim选项和命令。</li><li>C-x C-l – 整行补全。</li><li>C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</li><li>C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</li><li>C-x C-o – 编程时可以补全关键字和函数名啊。</li><li>C-x C-i – 根据头文件内关键字补全。</li><li>C-x C-d – 补全宏定义。</li><li>C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</li></ul><p>当弹出补全菜单后：</p><ul><li>C-p 向前切换成员；</li><li>C-n 向后切换成员；</li><li>C-e 退出下拉菜单，并退回到原来录入的文字；</li><li>C-y 退出下拉菜单，并接受当前选项。</li></ul><h2 id="13-8-多行缩进缩出"><a href="#13-8-多行缩进缩出" class="headerlink" title="13.8 多行缩进缩出"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109">13.8 多行缩进缩出</a></h2><ul><li>正常模式下，按两下&gt;;光标所在行会缩进。</li><li>如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</li><li>对应的，按两下&lt;;，光标所在行会缩出。</li><li>如果在编辑代码文件，可以用=进行调整。</li><li>在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。</li><li>或者n =，调整n行代码的缩排。</li></ul><h2 id="13-9-折叠"><a href="#13-9-折叠" class="headerlink" title="13.9 折叠"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110">13.9 折叠</a></h2><ul><li>zf – 创建折叠的命令，可以在一个可视区域上使用该命令；</li><li>zd – 删除当前行的折叠；</li><li>zD – 删除当前行的折叠；</li><li>zfap – 折叠光标所在的段；</li><li>zo – 打开折叠的文本；</li><li>zc – 收起折叠；</li><li>za – 打开/关闭当前折叠；</li><li>zr – 打开嵌套的折行；</li><li>zm – 收起嵌套的折行；</li><li>zR (zO) – 打开所有折行；</li><li>zM (zC) – 收起所有折行；</li><li>zj – 跳到下一个折叠处；</li><li>zk – 跳到上一个折叠处；</li><li>zi – enable/disable fold;</li></ul><h1 id="14-命令行"><a href="#14-命令行" class="headerlink" title="14. 命令行"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111">14. 命令行</a></h1><p>normal模式下按:进入命令行模式</p><h2 id="14-1-命令行模式下的快捷键："><a href="#14-1-命令行模式下的快捷键：" class="headerlink" title="14.1 命令行模式下的快捷键："></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112">14.1 命令行模式下的快捷键：</a></h2><ul><li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li><li>左右方向键：左/右移一个字符。</li><li>C-w： 向前删除一个单词。</li><li>C-h： 向前删除一个字符，等同于Backspace。</li><li>C-u： 从当前位置移动到命令行开头。</li><li>C-b： 移动到命令行开头。</li><li>C-e： 移动到命令行末尾。</li><li>Shift-Left： 左移一个单词。</li><li>Shift-Right： 右移一个单词。</li><li>@： 重复上一次的冒号命令。</li><li>q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li><li>q/和q? 可以打开查找历史记录。</li></ul><h2 id="14-2-执行外部命令"><a href="#14-2-执行外部命令" class="headerlink" title="14.2 执行外部命令"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113">14.2 执行外部命令</a></h2><ul><li>:! cmd 执行外部命令。</li><li>:!! 执行上一次的外部命令。</li><li>:sh 调用shell，用exit返回vim。</li><li>:r !cmd 将命令的返回结果插入文件当前位置。</li><li>:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</li></ul><h1 id="15-其它"><a href="#15-其它" class="headerlink" title="15. 其它"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114">15. 其它</a></h1><h2 id="15-1-工作目录"><a href="#15-1-工作目录" class="headerlink" title="15.1 工作目录"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115">15.1 工作目录</a></h2><ul><li>:pwd 显示vim的工作目录。</li><li>:cd path 改变vim的工作目录。</li><li>:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</li></ul><h2 id="15-2-一些快捷键（收集中）"><a href="#15-2-一些快捷键（收集中）" class="headerlink" title="15.2 一些快捷键（收集中）"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116">15.2 一些快捷键（收集中）</a></h2><ul><li>K: 打开光标所在词的manpage。</li><li>*: 向下搜索光标所在词。</li><li>g*: 同上，但部分符合即可。</li><li>#: 向上搜索光标所在词。</li><li>g#: 同上，但部分符合即可。</li><li>g C-g: 统计全文或统计部分的字数。</li></ul><h2 id="15-3-在线帮助"><a href="#15-3-在线帮助" class="headerlink" title="15.3 在线帮助"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117">15.3 在线帮助</a></h2><ul><li>:h(elp)或F1 打开总的帮助。</li><li>:help user-manual 打开用户手册。</li><li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li><li>:helptags somepath 为somepath中的文档生成索引。</li><li>:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</li><li>Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</li><li>:ver 显示版本信息。</li></ul><h2 id="15-4-一些小功能"><a href="#15-4-一些小功能" class="headerlink" title="15.4 一些小功能"></a><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118">15.4 一些小功能</a></h2><ul><li>简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux实用技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组和字符串的🆒skr操作——前缀和&amp;差分数组</title>
    <link href="/2020/10/16/2020-10-16-prefix_sum/"/>
    <url>/2020/10/16/2020-10-16-prefix_sum/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前缀和，很容易让人想到高等数学中的积分操作；对称的，差分数组对应着微分操作，表示作差。让人不禁感叹大自然和计算机之间的神奇联系。</p></blockquote><h1 id="I-前缀和"><a href="#I-前缀和" class="headerlink" title="I 前缀和"></a>I 前缀和</h1><ul><li><ol><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为k的子数组</a>(Medium)</li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含最长的子字符串</a>(Medium)</li></ol></li><li><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></li><li>LCP 19：<a href="https://leetcode-cn.com/problems/UlBDOe/">秋叶收藏集</a></li></ul><blockquote><p>什么是前缀和？前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。 </p><p>设$p[]$为前缀和数组，$a[]$为原数组，根据这句话可以得到前缀和的定义式和递推式:</p><div class="table-container"><table><thead><tr><th></th><th>定义式</th><th>递推式</th></tr></thead><tbody><tr><td><strong>一维前缀和</strong></td><td>$p[i]=\sum\limits_{i}^{n}a[i]$</td><td>$p[i]-p[i-1]=a[i]$</td></tr><tr><td><strong>二维前缀和</strong></td><td>$p[i]=\sum\limits_{i}^{n}\sum\limits_{j}^{m}a[i][j]$</td><td>$p[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+a[i][j]$</td></tr></tbody></table></div></blockquote><hr><h2 id="560-和为k的子数组-Medium"><a href="#560-和为k的子数组-Medium" class="headerlink" title="560.和为k的子数组(Medium)"></a><strong><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560.和为k的子数组</a>(Medium)</strong></h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p><p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p><hr><p>定义$pre[i]$表示$[0…i]$所有数之和,那么范围$[j-i]$可以表示为: $pre[i]-pre[j-1]$,  且$pre[i] = pre[i-1] + nums[i]$ , 问题转化为,</p><p>找到有多少个区间,满足$pre[i]-pre[j-1]==k$. 所以我们考虑以 $i$ 结尾的和为 $k$ 的连续子数组个数时只要统计有多少个前缀和为 $\textit{pre}[i]-k$的 $\textit{pre}[j]$ 即可。我们建立哈希表 $\textit{mp}$，以和为键，出现次数为对应的值，记录 $\textit{pre}[i]$ 出现的次数，从左往右边更新 $\textit{mp}$边计算答案，那么以 $i$ 结尾的答案 $\textit{mp}[\textit{pre}[i]-k]$ 即可在 $O(1)$ 时间内得到。最后的答案即为所有下标结尾的和为 $k$ 的子数组个数之和。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> res;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//数组长度和k都非常大，因此要尽量在线性时间复杂度解决</span>        <span class="hljs-comment">//我们尝试动态规划解决,</span>        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]==k;        res = <span class="hljs-number">0</span>;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; memo;<span class="hljs-comment">//记录和的个数</span>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;        memo[<span class="hljs-number">0</span>]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)        &#123;            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;pre&lt;&lt;endl;</span>            pre = pre + nums[i];                        <span class="hljs-keyword">if</span>(memo.count(pre-k))            res += memo[pre-k];            memo[pre]++;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><hr><h2 id="1371-每个元音包含最长的子字符串-Medium"><a href="#1371-每个元音包含最长的子字符串-Medium" class="headerlink" title="1371,每个元音包含最长的子字符串(Medium)"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371,每个元音包含最长的子字符串</a>(Medium)</h2><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p>示例 1：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;eleetminicoworoep&quot;</span>输出：<span class="hljs-number">13</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetminicowor&quot;</span> ，它包含 e，i，o 各 <span class="hljs-number">2</span> 个，以及 <span class="hljs-number">0</span> 个 a，u 。</code></pre><p>示例 2：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;leetcodeisgreat&quot;</span>输出：<span class="hljs-number">5</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetc&quot;</span> ，其中包含 <span class="hljs-number">2</span> 个 e 。</code></pre><p>示例 3：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;bcbcbc&quot;</span>输出：<span class="hljs-number">6</span>解释：这个示例中，字符串 <span class="hljs-string">&quot;bcbcbc&quot;</span> 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 <span class="hljs-number">0</span> 次。</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 5 x 10^5s 只包含小写英文字母。</code></p><p>定义$pre[i][k]$表示前$i$个字母，第$k$个元音字母总出现的次数。那么在$[i-1,j-1]$区间内，元音字母出现次数为$pre[j][k]-pre[i][k]$，在$O(1)$时间内得到第$k$个元音字母出现的次数。</p><p>同时我们要考虑避免枚举所有的$i$，计算以它结尾的满足条件的最长子字符串长度，我们要找到最小$i$使得$pre[j][k]-pre[i][k]$均为偶数。 我们需要利用【所有元音出现偶数次】这个条件，对于满足条件的子串而言，$pre[i][k]$和$pre[j][k]$的奇偶性一定相同，因为偶数一定是奇数+奇数，或者偶数+偶数组成。所以我们可以把$pre[i][k]$改为表示$[0,i-1]$的<strong>元音奇偶性</strong>。</p><p>此外我们还需要进行「状态压缩」：</p><pre><code class="hljs dts">&#123;<span class="hljs-symbol">  a:</span> cnta, <span class="hljs-comment">// a 出现次数的奇偶性</span><span class="hljs-symbol">  e:</span> cnte, <span class="hljs-comment">// e 出现次数的奇偶性</span><span class="hljs-symbol">  i:</span> cnti, <span class="hljs-comment">// i 出现次数的奇偶性</span><span class="hljs-symbol">  o:</span> cnto, <span class="hljs-comment">// o 出现次数的奇偶性</span><span class="hljs-symbol">  u:</span> cntu  <span class="hljs-comment">// u 出现次数的奇偶性</span>&#125;</code></pre><p>我们可以用二进制表示这些奇偶。</p><p>举一个例子，假如到第 $i $个位置，<code>u o i e a</code>出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 $(11001)_2=(25)_{10}$ 作为它的状态。</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = s.size(), res = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; vowel&#123;            &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>&#125;        &#125;;        <span class="hljs-comment">// 我们用pre[status]表示status状态对应的位置i，不断更新</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>,<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">//初始均为偶</span>        pre[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态，所有元音为偶数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)        &#123;            <span class="hljs-keyword">if</span>(vowel.count(s[i<span class="hljs-number">-1</span>]))            status ^= vowel[s[i<span class="hljs-number">-1</span>]];                        <span class="hljs-keyword">if</span>(~pre[status]) res = max(res,i - pre[status]); <span class="hljs-comment">//pre[status]!=-1</span>            <span class="hljs-keyword">else</span>             &#123;                pre[status] = i ;            &#125;                &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><blockquote><p>注意 18行的 ~pre[status]表示<strong>按位取反</strong>，包含了符号位，所以只有pre[status]不为-1，才为True。</p><p>$ \text{~} 0 = -1$， </p></blockquote><p>时间复杂度: $O(N)$. $N$为字符串长度。</p><p>空间复杂度: $O(1)$.</p><hr><h2 id="LCP-19-秋叶收藏集"><a href="#LCP-19-秋叶收藏集" class="headerlink" title="LCP 19. 秋叶收藏集"></a><a href="https://leetcode-cn.com/problems/UlBDOe/">LCP 19. 秋叶收藏集</a></h2><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 <code>leaves</code>， 字符串 <code>leaves</code> 仅包含小写字符 <code>r</code> 和 <code>y</code>， 其中字符 <code>r</code> 表示一片红叶，字符 <code>y</code> 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>leaves = &quot;rrryyyrryyyrr&quot;</code></p><p>输出：<code>2</code></p><p>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>leaves = &quot;ryr&quot;</code></p><p>输出：<code>0</code></p><p>解释：已符合要求，不需要额外操作</p></blockquote><p><strong>提示：</strong></p><ul><li><code>3 &lt;= leaves.length &lt;= 10^5</code></li><li><code>leaves</code> 中只包含字符 <code>&#39;r&#39;</code> 和字符 <code>&#39;y&#39;</code></li></ul><hr><p>【待更新】</p><h2 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327. 区间和的个数"></a><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></h2><p>给定一个整数数组 <code>nums</code>，返回区间和在 <code>[lower, upper]</code> 之间的个数，包含 <code>lower</code> 和 <code>upper</code>。<br>区间和 <code>S(i, j)</code> 表示在 <code>nums</code> 中，位置从 <code>i</code> 到 <code>j</code> 的元素之和，包含 <code>i</code> 和 <code>j</code> (<code>i</code> ≤ <code>j</code>)。</p><p><strong>说明:</strong><br>最直观的算法复杂度是 <em>O</em>(<em>n</em>2) ，请在此基础上优化你的算法。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: nums = [<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-1</span>], lower = <span class="hljs-number">-2</span>, upper = <span class="hljs-number">2</span>,输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">3</span>个区间分别是: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]，它们表示的和分别为: <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>。</code></pre><hr><p>该题的方法奇多，可谓是百家争鸣。不论是传统的归并排序还是线段树，树状数组，都值得好好研究，举一反三，刷题不累！</p><p>方法一：前缀和+归并排序，虽然归并操作是$O(nlogn)$。</p><p>思路与算法</p><p>设前缀和数组为 $\textit{preSum}$，则问题等价于求所有的下标对$ (i,j)$，满足</p><p>$preSum[j]−preSum[i]∈[lower,upper]$</p><p>我们先考虑如下的问题：给定两个升序排列的数组 $n_1, n_2$ ，试找出所有的下标对 $(i,j)$，满足</p><p>$n_2[j] - n_1[i] \in [\textit{lower}, \textit{upper}]$</p><p>在已知两个数组均为升序的情况下，这一问题是相对简单的：我们在 $n_2$中维护两个指针$ l,r$。起初，它们都指向 $n_2$<br>的起始位置。随后，我们考察 $n_1$ 的第一个元素。首先，不断地将指针 l 向右移动，直到$ n_2[l] \ge n_1[0] + \textit{lower}$为止，此时， l 及其右边的元素均大于或等于$ n_1[0] + \textit{lower}$；随后，再不断地将指针 rr 向右移动，直到$ n_2[r] &gt; n_1[0] + \textit{upper}$为止，则 rr 左边的元素均小于或等于 $n_1[0] + \textit{upper}$。故区间 $[l,r)$ 中的所有下标 j，都满足$n_2[j] - n_1[0] \in [\textit{lower}, \textit{upper}]<br>$</p><p>在解决这一问题后，原问题就迎刃而解了：我们采用归并排序的方式，能够得到左右两个数组排序后的形式，以及对应的下标对数量。对于原数组而言，若要找出全部的下标对数量，只需要再额外找出左端点在左侧数组，同时右端点在右侧数组的下标对数量，而这正是我们此前讨论的问题。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSumRecursive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt;&amp; sum, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span> (left == right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> n1 = countRangeSumRecursive(sum, lower, upper, left, mid);            <span class="hljs-keyword">int</span> n2 = countRangeSumRecursive(sum, lower, upper, mid + <span class="hljs-number">1</span>, right);            <span class="hljs-keyword">int</span> ret = n1 + n2;            <span class="hljs-comment">// 首先统计下标对的数量</span>            <span class="hljs-keyword">int</span> i = left;            <span class="hljs-keyword">int</span> l = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> r = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;                <span class="hljs-keyword">while</span> (l &lt;= right &amp;&amp; sum[l] - sum[i] &lt; lower) l++;                <span class="hljs-keyword">while</span> (r &lt;= right &amp;&amp; sum[r] - sum[i] &lt;= upper) r++;                ret += (r - l);                i++;            &#125;            <span class="hljs-comment">// 随后合并两个排序数组</span>            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;            <span class="hljs-keyword">int</span> p1 = left, p2 = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (p1 &lt;= mid || p2 &lt;= right) &#123;                <span class="hljs-keyword">if</span> (p1 &gt; mid) &#123;                    sorted[p++] = sum[p2++];                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 &gt; right) &#123;                    sorted[p++] = sum[p1++];                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (sum[p1] &lt; sum[p2]) &#123;                        sorted[p++] = sum[p1++];                    &#125; <span class="hljs-keyword">else</span> &#123;                        sorted[p++] = sum[p2++];                    &#125;                &#125;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sorted.size(); i++) &#123;                sum[left + i] = sorted[i];            &#125;            <span class="hljs-keyword">return</span> ret;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;        <span class="hljs-keyword">long</span> s = <span class="hljs-number">0</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt; sum&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v: nums) &#123;            s += v;            sum.push_back(s);        &#125;        <span class="hljs-keyword">return</span> countRangeSumRecursive(sum, lower, upper, <span class="hljs-number">0</span>, sum.size() - <span class="hljs-number">1</span>);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N\log N)$，其中 N 为数组的长度。设执行时间为 $T(N)$，则两次递归调用的时间均为 $T(N/2)$，最后需要 $O(N)$的时间求出下标对数量以及合并数组，故有$<br>T(N)=2⋅T(N/2)+O(N)$</p><p>根据主定理，有$ T(N) = O(N\log N)$。</p><p>空间复杂度：$O(N)4。设空间占用为$ M(N)4，递归调用所需空间为 $M(N/2)4，而合并数组所需空间为 $O(N)$，故</p><p>$<br>M(N)=max{M(N/2),O(N)}=M(N/2)+O(N)$</p><p>根据主定理，有 $M(N) = O(N)$。</p><blockquote><p>前缀和数组先加入0，可以简化我们很多代码！</p></blockquote><h1 id="II-差分数组"><a href="#II-差分数组" class="headerlink" title="II 差分数组"></a>II 差分数组</h1><blockquote><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">1674. 使数组互补的最少操作次数</a></p></blockquote><p>设数组为$a[0…n-1]$第$i-1$项为$a[i]$</p><p>那么定义差分数组$diff[i] = a[i]-a[i-1]$。</p><p>它的性质是前i项和是$a[i]$。</p><hr><h2 id="1674-使数组互补的最少操作次数"><a href="#1674-使数组互补的最少操作次数" class="headerlink" title="1674. 使数组互补的最少操作次数"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">1674. 使数组互补的最少操作次数</a></h2><p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>limit</code> 。每一次操作，你可以将 <code>nums</code> 中的任何整数替换为 <code>1</code> 到 <code>limit</code> 之间的另一个整数。</p><p>如果对于所有下标 <code>i</code>（<strong>下标从</strong> <code>0</code> <strong>开始</strong>），<code>nums[i] + nums[n - 1 - i]</code> 都等于同一个数，则数组 <code>nums</code> 是 <strong>互补的</strong> 。例如，数组 <code>[1,2,3,4]</code> 是互补的，因为对于所有下标 <code>i</code> ，<code>nums[i] + nums[n - 1 - i] = 5</code> 。</p><p>返回使数组 <strong>互补</strong> 的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], limit = <span class="hljs-number">4</span>输出：<span class="hljs-number">1</span>解释：经过 <span class="hljs-number">1</span> 次操作，你可以将数组 nums 变成 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]（加粗元素是变更的数字）：nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4.</span>nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4.</span>nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4.</span>nums[<span class="hljs-number">3</span>] + nums[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span> + <span class="hljs-number">1</span> = <span class="hljs-number">4.</span>对于每个 i ，nums[i] + nums[n<span class="hljs-number">-1</span>-i] = <span class="hljs-number">4</span> ，所以 nums 是互补的。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], limit = <span class="hljs-number">2</span>输出：<span class="hljs-number">2</span>解释：经过 <span class="hljs-number">2</span> 次操作，你可以将数组 nums 变成 [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。你不能将任何数字变更为 <span class="hljs-number">3</span> ，因为 <span class="hljs-number">3</span> &gt; limit 。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], limit = <span class="hljs-number">2</span>输出：<span class="hljs-number">0</span>解释：nums 已经是互补的。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= limit &lt;= 105</code></li><li><code>n</code> 是偶数。</li></ul><hr><p>这一题不考虑dp，因为相邻两项之间唯一联系是它和对称项的和相等。在确定的和下，总操作数是确定的。</p><p>$nums[i]+nums[i-1] = K$我们考虑操作有三种：</p><ul><li>当和为K，此时不需要操作</li><li>当和小于K，且$max(nums[i],nums[i-1])+limit&lt;K$，那么此时也必须修改两位</li><li>当和大于K，且$min(nums[i],nums[i-1])+1&gt;K$，那么此时也必须修改两位</li><li>其余情况，均只需操作一位</li></ul><p>总结以下，对于每一个$i$，其范围为$[a,b]=[min(nums[i],nums[i-1])+1,max(nums[i],nums[i-1])+limit]$，</p><p>并且对于修改两位的情况，最极限的情况为$[2,2*limit]$</p><p>对于差分数组$diff[i]$，区间$[l,r]$对应$diff[l]$和$diff[r+1]$。其最大大小为$2*limit+2$</p><p>我们先用一个哈希表$freq$存储每个和的可能情况，并且更新差分数组，因为是互补的，所以</p><p>$diff[a]++$且$diff[b]—;$</p><p>然后遍历$i\in [2,2*limit]$</p><p>如果哈希表内有该元素，对应操作数为0 ，得到其总数量为$op_0=freq[i]$</p><p>然后求操作数为1的数量$op_1=diff[i]-freq[i]$</p><p>最后的操作数为2直接取补集，$op_2=n/2-op_0-op_1$</p><p>更新答案 $res = min(res, op_1+2*op_2)$</p><p>代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-keyword">int</span> res = INT_MAX;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; sum;<span class="hljs-comment">//计算和的频次</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(<span class="hljs-number">2</span>*limit+<span class="hljs-number">2</span>)</span></span>;         <span class="hljs-comment">//引入差分数组</span>        <span class="hljs-comment">// cout&lt;&lt;(2*limit+2)&lt;&lt;endl;</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n/<span class="hljs-number">2</span>;i++)        &#123;            sum[nums[i]+nums[n-i<span class="hljs-number">-1</span>]]++;            <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>+min(nums[i],nums[n<span class="hljs-number">-1</span>-i]);            <span class="hljs-keyword">int</span> b = limit+max(nums[i],nums[n<span class="hljs-number">-1</span>-i])+<span class="hljs-number">1</span>;            diff[a]++;            diff[b]--;        &#125;        <span class="hljs-keyword">int</span> op_1 = <span class="hljs-number">0</span>, op_2 = <span class="hljs-number">0</span>, op_0 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> op01 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= limit*<span class="hljs-number">2</span>; i++)        &#123;            <span class="hljs-comment">//我们需要统计各操作的贡献</span>            op01 += diff[i];            op_0 = sum.count(i)?sum[i]:<span class="hljs-number">0</span>;            op_1 = op01 - op_0;<span class="hljs-comment">//需要一次操作</span>            op_2 = n/<span class="hljs-number">2</span> - op01;             <span class="hljs-comment">// printf(&quot;%d,%d,%d\n&quot;,op_0,op_1,op_2);</span>            res = min(res, op_1+op_2*<span class="hljs-number">2</span>);        &#125;        <span class="hljs-keyword">return</span> (res==INT_MAX)?<span class="hljs-number">0</span>:res;    &#125;&#125;;</code></pre><p>时间复杂度$O(n/2+limit)$</p><p>空间复杂度基本相同。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop环境配置</title>
    <link href="/2020/10/08/Hadoop%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/10/08/Hadoop%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Hadoop环境配置"><a href="#Hadoop环境配置" class="headerlink" title="Hadoop环境配置"></a>Hadoop环境配置</h1><h2 id="单机模式的操作方法"><a href="#单机模式的操作方法" class="headerlink" title="单机模式的操作方法"></a>单机模式的操作方法</h2><p>默认情况下，Hadoop被配置成以非分布式模式运行的一个独立Java进程。这对调试非常有帮助。</p><p>下面的实例将已解压的 conf 目录拷贝作为输入，查找并显示匹配给定正则表达式的条目。输出写入到指定的output目录。</p><pre><code class="hljs bash">$ mkdir input$ cp conf/*.xml input$ bin/hadoop jar hadoop-*-examples.jar grep input output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span>$ cat output/*</code></pre><h2 id="伪分布式模式的操作方法"><a href="#伪分布式模式的操作方法" class="headerlink" title="伪分布式模式的操作方法"></a>伪分布式模式的操作方法</h2><p>Hadoop可以在单节点上以所谓的伪分布式模式运行，此时每一个Hadoop守护进程都作为一个独立的Java进程运行。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用如下的 conf/hadoop-site.xml:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.default.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>localhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapred.job.tracker<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>localhost:9001<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式存储架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出学MapReduce</title>
    <link href="/2020/10/02/2020-10-5-mapreduce/"/>
    <url>/2020/10/02/2020-10-5-mapreduce/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出学MapReduce"><a href="#深入浅出学MapReduce" class="headerlink" title="深入浅出学MapReduce"></a>深入浅出学MapReduce</h1><blockquote><p>参考：<a href="https://www.cnblogs.com/boothsun/p/7714609.html">https://www.cnblogs.com/boothsun/p/7714609.html</a></p><p>谷歌在2004年发表了可以分析大量数据的MapReduce算法. 每当你听到”大数据”这个词时，它指的是因为太大而让仅仅一台机器难以有效存储或分析的问题。MapReduce通过把计算量分配给不同的计算机群，能够解决大部分和大数据有关的分析问题。Hadoop提供了最受欢迎的利用MapReduce算法来管理大数据的开源方式。先进MapReduce是主流，题外话：Hadoop是其发明者(Prof. Doug Cutting)的孩子画的大象的名字。</p><p>Hadoop的优势：PB级数据处理，经济，高效，可靠。</p><p>所以通常来说，每当你听到“大数据”，那也许意味着Hadoop被用来存储数据，也通常意味着数据的抽取和检索是用的MapReduce。</p></blockquote><p>你想数出一摞扑克牌中有多少黑桃。直观方式是一张一张检查并且数出有多少张是黑桃。</p><p><img src="../img/hadoop.png" alt="image-20201011211938355" style="zoom:67%;" /></p><p><img src="../img/mapreduce_2.jpg" alt="image-20201011212059132" style="zoom:67%;" /><img src="2020-10-5-mapreduce/image-20201011214146689.png" alt="image-20201011214146689"></p><p><img src="../img/mapreduce_2.jpg" alt="image-20201011212059132" style="zoom:67%;" /><img src="2020-10-5-mapreduce/image-20201011214146689.png" alt="image-20201011214146689"></p><p>MapReduce方法规则是:</p><ol><li>给在座的所有玩家中分配这摞牌</li><li>让每个玩家数自己手中有几张是黑桃,然后把这个数目汇报给你</li><li>你把所有玩家告诉你的数字加起来,得到最后的结论</li></ol><hr><p>MapReduce融合了两种经典函数：</p><ul><li><p><strong>映射</strong>（Mapping）：对集合里每一个目标应用同一个操作。</p></li><li><p><strong>化简</strong>（Reducing）：遍历集合中的元素来返回一个综合的结果。</p></li></ul><p>Mapreduce关注</p><p>1）如何分割输入数据</p><p>2）大集群上的调度</p><p>3）计算机错误处理</p><p>4）管理集群中计算机必要的通信</p><hr><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>Hadoop Distributed File System</p><p>HDFS架构：</p><p>主节点namenode：只有一个。</p><ul><li>接受用户请求。</li><li></li></ul><p>从节点datanodes：有多个。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce - Hadoop</tag>
      
      <tag>存储</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法II 神经网络</title>
    <link href="/2020/10/02/20201002-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95II-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/10/02/20201002-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95II-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>按照[Kohone,1988]的说法，神经网络是具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实物体所做出反应。</p></blockquote><p>我们从M-P神经元开始了解：</p><p><img src="\img\mp_neuron.jpg" alt=""></p><p><img src="E:\blog\myblog\source\img\mp_neuron.jpg" alt="image-20201004215837939" style="zoom:60%;" /></p><p>用公式描述就是$y=f(\sum\limits_{i=1}^nw_ix_i-\theta)$</p><p>其中$f$函数被称为激活函数，通常采用平滑的sigmoid函数，$1/(1+e^{-x})$。把多个这样的神经元按照一定层次串联起来就构成了神经网络。其有一个很好的性质$f’(x)=f(x)(1-f(x))$</p><p>感知机由两层神经元组成，</p><p><img src="\img\perceptron.png" alt="一个感知器"></p><p><img src="E:\blog\myblog\source\img\perceptron.png" alt="image-20201004215837939" style="zoom:100%;" /></p><p>感知机可以非常容易的实现与、或、非运算。更一般地，给定数据集，权重$w_i(i=1,2,3,…n)$以及阈值$\theta$可以通过学习得到。阈值$\theta$可以看作是固定输入为-1.0的哑节点所对应的连接权重$w_{n+1}$。学习方式</p><script type="math/tex; mode=display">w_i\leftarrow w_i + \triangle w_i\\\triangle w_i=\eta(y-\hat{y})x_i</script><p>其中$\eta\in (0,1)$被称为学习率（learning rate）。这是最简单的情况，不能解决实际问题。一般地，会加入隐藏层。</p><hr><h2 id="误差逆向传递BP算法"><a href="#误差逆向传递BP算法" class="headerlink" title="误差逆向传递BP算法"></a>误差逆向传递BP算法</h2><p>这是迄今最为成功的神经网络算法。如下图所示：</p><p><img src="\img\bp.png" alt=""></p><p><img src="E:\blog\myblog\source\img\bp.png" alt="image-20201004215837939" style="zoom:50%;" /></p><p>输入神经元数目d，中间为q，输出为l，那么总参数数量为$(d+l+1)*q+l$</p><p>第j个神经元的输入为 $\beta_j = \sum\limits_{h=1}^q = w_{kj}b_h$，第h个隐藏层输入为$\alpha_h=\sum\limits_{i=1}^dv_{ih}x_i$</p><p>神经元的输出</p><script type="math/tex; mode=display">\hat{y_j}=f(\beta_j-\theta_j)</script><p>网络在$(x_k,y_k)$上的均方误差</p><script type="math/tex; mode=display">E_k=\frac{1}{2}\sum\limits_{j=1}^{l}(\hat{y_j}-y_j^k)^2</script><p>BP算法基于梯度下降策略（$gradient  descent$）,对 给定学习率$\eta$：</p><script type="math/tex; mode=display">\triangle w_{hj}=-\eta\frac{\partial E_k}{\partial w_{hj}}</script><p>BP算法：</p><ul><li><p>在（0，1）范围内随机初始化网络中所有连接权和阈值</p></li><li><p>对于训练集所有数据，不断进行如下循环：</p><ul><li><p>根据 (2) 计算出当前样本输出；</p></li><li><p>根据 $ g_i = -\frac{\partial E_k}{\partial y_j}.\frac{\partial y_j}{\partial \beta_j}\     = y_j(1-y_j)(Y_j-y_j)$, 为方便表示为$y_j = \hat{y_j}, Y_j = y_j$</p><p>计算出输出层梯度项；</p></li><li><p>根据$e_h=  -\frac{\partial E_k}{\partial b_h}. \frac{\partial b_h}{\partial \alpha_h}\ \quad = -\sum\limits_{j=1}^l\frac{\partial E_k}{\partial \beta_j}\frac{\partial \beta_j}{\partial b_h}f’(\alpha_h-γ_h) \ \quad= b_h(1-b_h)\sum\limits_{j=1}^lw_{hj}g_j$</p><p>计算隐藏层神经元的梯度项。</p></li><li><p>根据$\triangle \theta_j = -\eta g_i \ \triangle v_{ih}=\eta e_h x_i \ \triangle γ_h = -\eta e_h$</p><p>更新连接权和阈值</p></li></ul></li><li><p>如果误差小于某一个值，则停止。</p></li></ul><p>BP的目标是最小化训练集上的累积误差，即$E=\frac{1}{m}\sum\limits_{k=1}^mE_k$.</p><p>由于BP神经元强大的表示能力，其经常遇到过拟合问题，有两种解决途径：1. 早停，若训练误差下降而验证集误差上升就停止。2. 正则化，基本思想是在误差目标函数中增加一个用于描述网络复杂度的部分。</p><script type="math/tex; mode=display">E=\lambda\frac{1}{m}\sum\limits_{k=1}^mE_k + (1-\lambda)\sum w_i^2</script><p>其中$\lambda \in(0,1)$</p><h3 id="全局最小与局部最小"><a href="#全局最小与局部最小" class="headerlink" title="全局最小与局部最小"></a>全局最小与局部最小</h3><p>通常有以下策略：</p><ul><li>以多组不同参数初始化多个神经网络，取其中最小误差的解作为最终参数。</li><li>使用“模拟退火”，“遗传算法”</li><li>使用随机梯度下降，（Stochastic Gradient Descent）。</li></ul><h3 id="其它常见的神经网络"><a href="#其它常见的神经网络" class="headerlink" title="其它常见的神经网络"></a>其它常见的神经网络</h3><ol><li>RBF 径向基网络</li></ol><script type="math/tex; mode=display">\phi(x)=\sum\limits_{i=1}^qw_i\rho(x,c_i)</script><p>其中q为隐层神经元个数，$c_i$和$w_i$分别为第i个隐层神经元所对应的中心和权重，$\rho$为径向基函数，某种沿径向对称的标量函数。</p><ol><li>竞争学习网络</li></ol><p>网络中输出神经元相互抑制，只有表现最优者胜出。典型的是ART网络。</p><ol><li><p>SOM网络</p></li><li><p>级联相关网络</p></li><li><p><strong>Boltzmann机</strong></p><p>神经网络有一类模型是定义“能量”，当能量达最小时达到理想状态。其神经元分为两层：显示层和隐藏层。显示层用于表示输入输出，而隐藏层表示书表达，神经元的状态只有两种，用0，1表示，1表示激活，0表示抑制。</p><p>设$s_i$为第i个神经元状态，$w_{ij}$表示神经元i和j的连接权，$\theta_i$表示神经元i的阈值，Boltzman能量为：</p><script type="math/tex; mode=display">E(s) = -\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}w_{ij}s_is_j-\sum\limits_{i=1}^{n}\theta_is_i</script><p>训练后的网络将服从boltzman分布：</p><script type="math/tex; mode=display">P(s)=\frac{e^{-E(s)}}{\sum e^{-E(t)}}</script><p>标准的Boltzman是一个全连接图，复杂度很高，实际采用受限boltzmann（Restricted Boltzmann Machine），如下图，通常采用对比散度算法来训练（Contrast Divergence）。假定网络有d个显示层神经元和q个隐藏层神经元。则由于同一层内不存在连接：</p><script type="math/tex; mode=display">P(v|h)=\prod\limits_{i=1}^dP(v_i|h)</script><script type="math/tex; mode=display">P(h|v)=\prod\limits_{j=1}^dP(h_j|v)</script><p>先根据（10）得到隐藏层概率分布求出h，再根据（9）得到v‘，产生h’，连接权更新公式为：</p><script type="math/tex; mode=display">\triangle w=\eta(vh^T-v'h'^T)</script></li></ol><p>   <img src="\img\rbm.jpg" alt=""></p><p>   <img src="E:\blog\myblog\source\img\rbm.jpg" alt="img" style="zoom:50%;" /></p><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a><strong>RNN</strong></h2><p> RNN是一种特殊的神经网络结构, 它是根据”人的认知是基于过往的经验和记忆”这一观点提出的. 它与DNN,CNN不同的是: 它不仅考虑前一时刻的输入,而且赋予了网络对前面的内容的一种<strong>‘记忆’功能</strong>.</p><p>  RNN之所以称为<strong>循环神经网路</strong>，即一个序列当前的输出与前面的输出也有关。具体的表现形式为网络会对前面的信息进行记忆并应用于当前输出的计算中，即隐藏层之间的节点不再无连接而是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。</p><p>  ① <strong><em>\</em>自然语言处理(NLP)**</strong>: 主要有<strong>视频处理</strong>, <strong>文本生成*</strong>,<em> <strong>语言模型</strong></em>, 图像处理*</p><p>  ② <strong>机器翻译</strong>, 机器写小说</p><p>  ③ <strong>语音识别</strong></p><p>  ④ <strong>图像描述生成</strong></p><p>  ⑤ 文本相似度计算</p><p>  ⑥ <strong>音乐推荐</strong>、<strong>网易考拉商品推荐</strong>、<strong>Youtube视频推荐</strong>等新的应用领域</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法I 决策树</title>
    <link href="/2020/09/27/ML4_DecisionTree/"/>
    <url>/2020/09/27/ML4_DecisionTree/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习算法I-决策树"><a href="#机器学习算法I-决策树" class="headerlink" title="机器学习算法I: 决策树"></a>机器学习算法I: 决策树</h1><p>决策树的基本算法是「<strong>分而治之</strong>」。</p><p>设有训练集$D$以及属性集$A$. 函数<code>TreeGenerate(D,A)</code>算法如下：</p><ul><li><p>我们生成树节点node，若D中样本全部属于同一类别C.就将node标记为C类叶节点。</p></li><li><p>如果A为空集或者D中样本在A上取值相同，那么将node标记为叶节点，其类别标记为D中样本数最多的类。然后返回。</p></li><li><p>从A中选择最优划分属性$a^*$.</p></li><li><p>对最优划分属性的每个子属性$a_i$:</p><ul><li>为node生成一个分支，令$D_v$表示$D$在$a^*$上取值为$a_i$的样本子集；<ul><li>如果$D_v$为空，那么将分支节点标记为叶节点，其类别标记为$D$中样本最多的类。并返回。</li><li>以$TreeGenrate(D_v,A/(a_*))为分支节点$</li></ul></li></ul><p>最后输出一棵以node为根节点的决策树。</p></li></ul><h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><p>如何选择最优划分属性？我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即纯度（purity）越来越高。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k=1,2,..n)$，则$D$的信息熵定义为</p><script type="math/tex; mode=display">Entropy(D)=-\sum_\limits{k=1}^{n}p_k\log_2 p_k</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>决策树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双胞胎DFS与BFS</title>
    <link href="/2020/09/27/2020-8-12-dfs-bfs/"/>
    <url>/2020/09/27/2020-8-12-dfs-bfs/</url>
    
    <content type="html"><![CDATA[<h1 id="专题-DFS-amp-BFS"><a href="#专题-DFS-amp-BFS" class="headerlink" title="专题:DFS&amp;BFS"></a>专题:DFS&amp;BFS</h1><blockquote><p> DFS:深度优先搜索，BFS：广度优先搜索，是最频繁被考察的算法知识点之一。我们来找一些例题专门研究一下。</p></blockquote><p>二叉树里面的三种遍历既可以用DFS（递归写法），也可以用BFS（迭代+栈），而层序遍历对应的就是BFS。</p><p>在图论中，DFS是万金油算法，其衍生的如Dijisktra(优先队列)，SPFA算法是<strong>最短路</strong>的主流算法。</p><p>下面介绍一类二维矩阵中典型的「岛屿问题」，来加深理解，在整体DFS框架中又隐藏一些彩蛋，加以利用的话可以极大的优化算法。</p><ul><li><a href="https://leetcode-cn.com/problems/number-of-islands/">L200. 岛屿数量</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/surrounded-regions/">L130.被围绕的区域 (Medium)</a></li><li><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> （Medium）</li><li><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a> （Hard）</li><li><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙I</a>（Medium）</li><li><a href="https://leetcode-cn.com/problems/word-ladder-ii/">单词接龙II</a> (Hard)</li><li>双向bfs。</li></ul><hr><h2 id="1-被围绕的区域"><a href="#1-被围绕的区域" class="headerlink" title="1.被围绕的区域"></a>1.被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span></code></pre><p>运行你的函数后，矩阵变为：</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span></code></pre><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><hr><p><strong>思路</strong>：常规的想法是在矩阵中找到所有湖然后判断其是否与边界0相连，显然，这不是一个很好的注意，有可能一开碰到边界，也有可能最后找到边界，也有可能中间碰到边界。</p><p>所以此时需要换一种思路，我们找到一个「DFS触发条件」，以减少任务量，一种思路是从四个边界出发，如果为<code>&#39;O&#39;</code>，则进入DFS，将所有的<code>&#39;O&#39;</code>改为<code>&#39;A&#39;</code>，之后遍历完之后，将所有剩余的<code>&#39;O&#39;</code>改为<code>&#39;X&#39;</code>即可。</p><h2 id="2-岛屿的数量"><a href="#2-岛屿的数量" class="headerlink" title="2. 岛屿的数量"></a>2. 岛屿的数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:</p><pre><code class="hljs prolog">[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]]输出: <span class="hljs-number">1</span></code></pre><p>示例 2:</p><pre><code class="hljs prolog">输入:[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>]]输出: <span class="hljs-number">3</span></code></pre><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><hr><p><strong>思路：</strong>同样地，我们判断一个岛屿与哪些1相连是很困难的，因此需要转换思路，我们把「DFS触发条件」设定为<code>grid[x][y]==&#39;1&#39;</code>，此时岛屿数量加1，把遍历过的点改为0.即可。</p><p><strong>时间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。</p><p><strong>空间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 $M×N$。</p><h2 id="3-最大人工岛（Hard）"><a href="#3-最大人工岛（Hard）" class="headerlink" title="3. 最大人工岛（Hard）"></a>3. 最大人工岛（Hard）</h2><p>在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。</p><p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]输出: <span class="hljs-number">3</span>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，最终连通两个小岛得到面积为 <span class="hljs-number">3</span> 的岛屿。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]输出: <span class="hljs-number">4</span>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。</code></pre><p>示例 3:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]输出: <span class="hljs-number">4</span>解释: 没有<span class="hljs-number">0</span>可以让我们变成<span class="hljs-number">1</span>，面积依然为 <span class="hljs-number">4</span>。</code></pre><p>说明:</p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= grid.length = grid[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">50</span><span class="hljs-symbol">0 </span>&lt;= grid[i][j] &lt;= <span class="hljs-number">1</span></code></pre><hr><p>在解这道题之前，我们需要想到一些边界情况;</p><ol><li>全为陆地，则无法填海，<code>maxArea = m*n</code>,m,n分别为地图横纵尺寸。</li><li>全为海洋，则仍可以填岛，<code>maxArea = 1</code>.</li><li>只有一座连通岛，那么此时填充的作用仅仅是扩大面积而不是连通相邻的岛，<code>maxArea = maxArea+1</code>.</li></ol><p>那么如何填充使得面积最大，这个通过题目的简单例子是无法感受到的，比如下面这种情况</p><script type="math/tex; mode=display">[[0,0,1,0,0,0,0,1,0,0,0,0,0],\\ [0,0,0,0,0,0,0,1,1,1,0,0,0],\\ [0,1,1,0,1,0,0,0,0,0,0,0,0],\\ [0,1,0,0,1,1,0,0,1,0,1,0,0],\\ [0,1,0,0,1,1,0,0,1,1,1,0,0],\\ [0,0,0,0,0,0,0,0,0,@,*,0,0],\\ [0,0,0,0,0,0,0,1,1,1,0,0,0],\\ [0,0,0,0,0,0,0,1,1,0,0,0,0]]\\</script><p>（1）<code>@=0,*=0</code>,此时可以把@变为1，最大面积为<code>5+5+1=11</code>。</p><p>（2）<code>@=0,*=1</code>,此时可以把@变为1或者*下方的0变为1，最大面积为<code>6+5+1=12</code>。</p><p><strong>思路</strong>：把连通岛编号<code>index(&gt;=2)</code>。统计每个人工岛的最大面积（通过dfs）。然后再遍历地图，把所有为<code>0</code>的地方，<u>研究其是否连接<em>至少</em>两个岛，即上下左右方向链接不同<code>index</code>的岛屿。</u></p><p>这样的话，我们就能兼顾所有情况。C++代码如下。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m,n,maxArea,index;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; base_area;<span class="hljs-comment">//基础面积哈希表</span>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; d = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">outRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> (x&gt;=m||y&gt;=n||x&lt;<span class="hljs-number">0</span>||y&lt;<span class="hljs-number">0</span>) ;<span class="hljs-comment">//越界检查</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> &amp;area)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//找到至少两个index不相等的岛屿，并统计它们的面积</span>        <span class="hljs-keyword">int</span> base_index = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(!outRange(x+d[i][<span class="hljs-number">0</span>],y+d[i][<span class="hljs-number">1</span>])&amp;&amp;grid[x+d[i][<span class="hljs-number">0</span>]][y+d[i][<span class="hljs-number">1</span>]])             &#123;                base_index = grid[x+d[i][<span class="hljs-number">0</span>]][y+d[i][<span class="hljs-number">1</span>]];                <span class="hljs-keyword">if</span>(!count(temp.begin(),temp.end(),base_index))area += base_area[base_index];                temp[i] = base_index;            &#125;        &#125;                            &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> &amp;area)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">// cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot;,y:&quot;&lt;&lt;y&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(outRange(x,y)|| grid[x][y]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;        grid[x][y] = index;<span class="hljs-comment">//已经走过的陆地标记为index</span>        area+=<span class="hljs-number">1</span>;        dfs(x+<span class="hljs-number">1</span>,y,grid,area);         dfs(x<span class="hljs-number">-1</span>,y,grid,area);         dfs(x,y+<span class="hljs-number">1</span>,grid,area);         dfs(x,y<span class="hljs-number">-1</span>,grid,area);             &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!grid.size()||!grid[<span class="hljs-number">0</span>].size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = grid.size();        n = grid[<span class="hljs-number">0</span>].size();        maxArea = <span class="hljs-number">0</span>;        index = <span class="hljs-number">2</span>;        <span class="hljs-comment">//1.研究基础未填岛情况，把各个岛屿的面积保存再哈希表中</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;            dfs(i,j,grid,area);            base_area[index] = area;            <span class="hljs-built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,area:&quot;</span>&lt;&lt;base_area[index]&lt;&lt;<span class="hljs-built_in">endl</span>;            index++;               maxArea = max(maxArea,area);        &#125;        <span class="hljs-comment">//2.研究填岛情况，遍历所有的0</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)        &#123;<span class="hljs-comment">//如果&lt;u&gt;研究其是否连接*至少*两个岛，即上下左右方向链接不同`index`的岛屿</span>            <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;            connect(i,j,grid,area);            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,area:&quot;</span>&lt;&lt;area&lt;&lt;<span class="hljs-built_in">endl</span>;            maxArea = max(area,maxArea);        &#125;        <span class="hljs-comment">//研究几种需要填岛的特殊情况</span>        <span class="hljs-comment">//1.没有陆地 maxArea==0</span>        <span class="hljs-comment">//2.最大面积岛屿旁边没有相邻岛maxArea!=0, max_fillArea==0</span>        <span class="hljs-keyword">if</span>(maxArea==(m*n)) <span class="hljs-keyword">return</span> m*n;        <span class="hljs-keyword">return</span> maxArea+<span class="hljs-number">1</span>;<span class="hljs-comment">//没有海洋或没有岛</span>    &#125;&#125;;</code></pre><p>时间和空间可以根据代码进行分析。</p><h1 id="剪枝技巧"><a href="#剪枝技巧" class="headerlink" title="剪枝技巧"></a>剪枝技巧</h1><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="一种常见的技巧是让生成子序列是单增顺序的，如-216-组合总和III。"><a href="#一种常见的技巧是让生成子序列是单增顺序的，如-216-组合总和III。" class="headerlink" title="一种常见的技巧是让生成子序列是单增顺序的，如 216. 组合总和III。"></a>一种常见的技巧是让生成子序列是单增顺序的，如 216. 组合总和III。</h3><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> target,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sub)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>&amp;&amp;target==<span class="hljs-number">0</span>) &#123;res.push_back(sub);<span class="hljs-keyword">return</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= min(<span class="hljs-number">9</span>,target);i++)        <span class="hljs-keyword">if</span>(!sub.size()||i &gt; sub.back())        &#123;            sub.emplace_back(i);            dfs(k<span class="hljs-number">-1</span>,target-i,sub);            sub.pop_back();        &#125;    &#125;</code></pre><ul><li>当题目不能出现重复项时，有两种方法。如40.组合总和II</li><li><ol><li>使用哈希表天然去重功能，但是需要编码。</li><li>先对<code>candidates</code>进行排序，然后每次dfs取下一项，遇到<code>candidates</code>重复项就跳过。这里我们分<code>candidates</code>能否被选无限次进行讨论。</li></ol></li></ul><p>A. Candidates只能选取一次【40题】</p><pre><code class="hljs Cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; candidates;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;        res.push_back(path);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= <span class="hljs-number">0</span>; i++) &#123;        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])            <span class="hljs-keyword">continue</span>;        path.push_back(candidates[i]);        <span class="hljs-comment">// 元素不可重复利用，使用下一个即i+1</span>        DFS(i + <span class="hljs-number">1</span>, target - candidates[i]);        path.pop_back();    &#125;&#125;</code></pre><p>B. Candidates选取无限次【39题】</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;            res.push_back(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start;             i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= <span class="hljs-number">0</span>; i++) &#123;            path.push_back(candidates[i]);            DFS(i, target - candidates[i]);            path.pop_back();        &#125;    &#125;</code></pre><p>区别在于<code>dfs(i)</code>还是<code>dfs(i+1)</code>.</p><h3 id="二分法剪枝"><a href="#二分法剪枝" class="headerlink" title="二分法剪枝"></a>二分法剪枝</h3><p>二分法在特定情况下也可以进行剪枝。 请看下例。</p><h4 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h4><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="\img\1631-ex1.png" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]]输出：<span class="hljs-number">2</span>解释：路径 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 连续格子的差值绝对值最大为 <span class="hljs-number">2</span> 。这条路径比路径 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] 更优，因为另一条路劲差值最大值为 <span class="hljs-number">3</span> 。</code></pre><p><strong>示例 2：</strong></p><p><img src="\img\1631-ex2.png" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]]输出：<span class="hljs-number">1</span>解释：路径 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 的相邻格子差值绝对值最大为 <span class="hljs-number">1</span> ，比路径 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 更优。</code></pre><p><strong>示例 3：</strong></p><p><img src="\img\1631-ex3.png" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]输出：<span class="hljs-number">0</span>解释：上图所示路径不需要消耗任何体力。</code></pre><p><strong>提示：</strong></p><ul><li><code>rows == heights.length</code></li><li><code>columns == heights[i].length</code></li><li><code>1 &lt;= rows, columns &lt;= 100</code></li><li><code>1 &lt;= heights[i][j] &lt;= 106</code></li></ul><hr><p>「二分法」</p><p>我们对所有可能的高度差绝对值（介于0和999999）进行二分，设某次范围为$[start,end],mid = (start+end)/2$,当我们枚举到$mid$，只保留对应的相邻高度差绝对值小于等于$mid$的“枝叶”。从而达到剪枝目的。</p><p>只需要判断x下，能否到达终点。</p><ul><li>若能到达，则更新$end = mid-1,ans = mid$</li><li>否则更新$start = mid+1$</li></ul><p>最后的ans即为答案。</p><p>DFS版本</p><pre><code class="hljs cpp"><span class="hljs-comment">//DFS解法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m,n,res;    <span class="hljs-keyword">int</span> move[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">outRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> (x &lt; <span class="hljs-number">0</span>)||(y &lt; <span class="hljs-number">0</span>)||(x &gt;= m)||(y &gt;= n);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heights,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&amp; vis,<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> mid)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(vis[x*n+y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span>(x == m<span class="hljs-number">-1</span> &amp;&amp; y == n<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        vis[x*n+y] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">bool</span> ret = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;p : move)        &#123;            <span class="hljs-keyword">if</span>(outRange(x+p[<span class="hljs-number">0</span>],y+p[<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(heights[x][y]-heights[x+p[<span class="hljs-number">0</span>]][y+p[<span class="hljs-number">1</span>]])&lt;=mid&amp;&amp;dfs(heights,vis,x+p[<span class="hljs-number">0</span>],y+p[<span class="hljs-number">1</span>],mid))                 ret = <span class="hljs-literal">true</span>;                    &#125;                <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;        m = heights.size(), n = heights[<span class="hljs-number">0</span>].size();        res = INT32_MAX;        <span class="hljs-comment">//采用二分法+dfs</span>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">999999</span>, mid = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(start &lt;= end)        &#123;            mid = (start + end)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(m*n, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//状态压缩</span>            <span class="hljs-comment">// vis[0] = true;</span>            <span class="hljs-keyword">auto</span> arrivable = dfs(heights,vis,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,mid);            <span class="hljs-comment">//如果能到，那么最大体力消耗还可以缩小</span>            <span class="hljs-keyword">if</span>(arrivable) &#123;                end = mid - <span class="hljs-number">1</span>;                res = mid;                <span class="hljs-comment">// cout&lt;&lt;res&lt;&lt;endl;</span>            &#125;            <span class="hljs-keyword">else</span> start = mid + <span class="hljs-number">1</span>;             <span class="hljs-comment">// printf(&quot;[%d,%d]:res:%d\n&quot;,start,end,res);</span>                    &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p>时间复杂度：$O(log(M*N))$</p><p>空间复杂度:$O(M*N)$</p><p>BFS版本</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m,n,res;    <span class="hljs-keyword">int</span> move[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">outRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> (x &lt; <span class="hljs-number">0</span>)||(y &lt; <span class="hljs-number">0</span>)||(x &gt;= m)||(y &gt;= n);    &#125;    <span class="hljs-comment">//采用二分法进行5</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;        m = heights.size(), n = heights[<span class="hljs-number">0</span>].size();        res = INT32_MAX;        <span class="hljs-comment">//采用二分法+dfs</span>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">999999</span>, mid = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(start &lt;= end)        &#123;            mid = (start + end)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(m*n, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//状态压缩</span>            <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; reco;            <span class="hljs-keyword">bool</span> available = <span class="hljs-literal">false</span>;            reco.emplace(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);             <span class="hljs-keyword">while</span>(!reco.empty())            &#123;                <span class="hljs-keyword">auto</span> [x,y] = reco.front();reco.pop();                <span class="hljs-keyword">if</span>(vis[x*n+y]) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(x == m<span class="hljs-number">-1</span> &amp;&amp; y == n<span class="hljs-number">-1</span>)&#123;available = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>;&#125;                vis[x*n+y] = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;p : move)                &#123;                    <span class="hljs-keyword">if</span>(!outRange(x+p[<span class="hljs-number">0</span>],y+p[<span class="hljs-number">1</span>])&amp;&amp;<span class="hljs-built_in">abs</span>(heights[x][y]-heights[x+p[<span class="hljs-number">0</span>]][y+p[<span class="hljs-number">1</span>]])&lt;=mid)                     &#123;                        reco.emplace(x+p[<span class="hljs-number">0</span>],y+p[<span class="hljs-number">1</span>]);                    &#125;                &#125;            &#125;            <span class="hljs-comment">//如果能到，那么最大体力消耗还可以缩小</span>            <span class="hljs-keyword">if</span>(available) &#123;                end = mid - <span class="hljs-number">1</span>;                res = mid;            &#125;            <span class="hljs-keyword">else</span> start = mid + <span class="hljs-number">1</span>;         &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p>时间复杂度：$O(M*N)$,$M,N$分别为高度数组的长和宽。</p><p>空间复杂度：$O(M<em>N+M+N-1)=O(M</em>N)$</p><p>一般用dfs，在时间和空间上表现更好。</p><p>「并查集」：我们可以将所有边按照长度进行排序并依次添加进并查集，直到左上角和右下角连通为止。</p><p>「最短路」：我们可以使用任一单源最短路径的算法（例如 Dijkstra 算法），只需要在维护当前路径长度时，将其修改为题目中的定义即可。</p><hr><h2 id="DFS与BFS结合"><a href="#DFS与BFS结合" class="headerlink" title="DFS与BFS结合"></a>DFS与BFS结合</h2><h4 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II</a></h4><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换后得到的单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>beginWord = <span class="hljs-string">&quot;hit&quot;</span>,endWord = <span class="hljs-string">&quot;cog&quot;</span>,wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<span class="hljs-section">输出:</span>[  [<span class="hljs-string">&quot;hit&quot;</span>,<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>],  [<span class="hljs-string">&quot;hit&quot;</span>,<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]]</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>beginWord = <span class="hljs-string">&quot;hit&quot;</span>endWord = <span class="hljs-string">&quot;cog&quot;</span>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<span class="hljs-section">输出: []</span><span class="hljs-section">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span></code></pre><hr><p>这题与 <a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙I</a>不同之处在于，要求的是所有最短路径，这是一个比较棘手的问题，不过即便碰到我们也要知道怎么做。在构建完图之后（注意我们不需要再添加“*”过渡节点），我们进行广义优先搜索。</p><p>我们采用$cost$数组，其中第i个元素表示 beginWord对应的点到达第i个点的转换次数，初始状态为无穷大。开始将beginWord对应的路径压入队列。</p><p>我们设当前节点为$curr_list$，它保存的是<strong><em>路径</em></strong>，周围与之相邻的节点为$neigh$，记$end $为$curr_list$ 最后一个元素。</p><p>若队列不为空则，更新当前路径，若</p><ul><li>$curr == end,$则将当前路径加入到答案之中</li><li>否则， 遍历邻近节点，检查$cost[neigh]&gt;=cost[curr]+1$， 如果满足，我们就将$neigh$加入到队列中，并且更新$cost[neigh] = cost[curr] +1$.  否则这个节点已经被访问过，不需要考虑。</li></ul><p>C++代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; word2num;<span class="hljs-comment">//词梯对应的id</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges; <span class="hljs-comment">//图的所有变</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dis;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;            <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isClose</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;a, <span class="hljs-built_in">string</span> &amp;b)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//判断两单词是不是只有一个字母不同，只能用引用传参</span>        <span class="hljs-keyword">int</span> n = a.size();        <span class="hljs-keyword">int</span> diff = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">if</span>(a[i]!=b[i])&#123;             diff++;            <span class="hljs-keyword">if</span>(diff &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> diff == <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">findLadders</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;        <span class="hljs-comment">//建立图</span>        wordList.push_back(beginWord);        <span class="hljs-keyword">int</span> n = wordList.size();        edges.resize(n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            word2num[wordList[i]] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++)            <span class="hljs-keyword">if</span>(isClose(wordList[i],wordList[j]))            &#123;                                edges[i].insert(j);                edges[j].insert(i);            &#125;        &#125;        dis.resize(n,INT_MAX);                <span class="hljs-keyword">if</span>(!word2num.count(endWord)) <span class="hljs-keyword">return</span> &#123;&#125;;                <span class="hljs-keyword">int</span> start = word2num[beginWord], end = word2num[endWord];         dis[start] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// dfs会超时，我们采用广搜算法</span>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; bfs; <span class="hljs-comment">//元素为数组的列队</span>        bfs.push(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&#123;start&#125;);         <span class="hljs-keyword">while</span>(!bfs.empty())        &#123;            <span class="hljs-keyword">auto</span> curr_list = bfs.front(); bfs.pop();            <span class="hljs-keyword">int</span> curr = curr_list.back(); <span class="hljs-comment">//当前节点</span>            <span class="hljs-keyword">if</span>(curr == end)            &#123;                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tmp;                <span class="hljs-comment">//转化为string加入到答案</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ss: curr_list) tmp.push_back(wordList[ss]);                res.push_back(tmp);                 <span class="hljs-comment">// min_dis = min(min_dis,(int)curr_list.size());</span>                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;neigh:edges[curr])            &#123;                <span class="hljs-keyword">if</span>(dis[neigh] &gt;= dis[curr] + <span class="hljs-number">1</span>)                &#123;<span class="hljs-comment">//避免重复访问</span>                    dis[neigh] = dis[curr] + <span class="hljs-number">1</span>;                    curr_list.push_back(neigh);                    bfs.push(curr_list); <span class="hljs-comment">//当前列表添加到队尾</span>                    curr_list.pop_back();<span class="hljs-comment">//注意及时pop_back，否则会重复添加邻近节点</span>                &#125;            &#125;        &#125;        <span class="hljs-comment">//将序号变为string输出</span>        <span class="hljs-keyword">return</span> res;        &#125;&#125;;</code></pre><p>这样做并不需要比较各路径的长度，tmp一定最短路径， 为什么？</p><p>提示：$dis[neigh] &gt;= dis[curr] + 1$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DFS</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必须掌握数据结构-树</title>
    <link href="/2020/09/23/2020-9-23-binary_tree/"/>
    <url>/2020/09/23/2020-9-23-binary_tree/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>树，按照子节点最大数目分为二叉树和多叉树，按照方向分为单向树和双向树。</p>          </div><h1 id="树相关算法"><a href="#树相关算法" class="headerlink" title="树相关算法"></a>树相关算法</h1><blockquote><p>一看到树，基本上可以确定是DFS或者BFS了，比较单调，但是也有一些很复杂的题目。二叉树，根据实际需要，演变为二叉搜索树，2-3-4树，平衡树（红黑树、AVL树），在计算机系统中占据重要地位。</p></blockquote><p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 $n(n&gt;0)$ 个有限节点组成一个具有层次关系的集合。</p><p><img src="\img\binary_1.png" alt=""></p><p>把它叫做「树」是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>它具有以下的特点：</p><ul><li>每个节点都只有有限个子节点或无子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li><li>树里面没有环路。</li></ul><p>我们将介绍</p><ul><li><p>二叉树的表示</p></li><li><p>二叉树的遍历</p></li><li><p>二叉树序列化以及反序列化</p></li><li><p>树形dp</p></li><li><p>线索二叉树</p></li><li><p>最近公共祖先（LCA）</p></li><li><p>二叉平衡树</p></li><li><p>二叉树路径求和</p></li></ul><hr><p><strong>部分题目</strong></p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">968.二叉树监控（Hard）</a></li><li>834.树中距离之和（Hard）</li><li>124.二叉树最大路径（Hard）</li><li>99.恢复二叉搜索树（Hard）（*）</li><li>297.二叉树序列化与反序列化</li></ul><p><strong>二叉树遍历</strong></p><ul><li><ol><li>从中序遍历和前序遍历构造二叉树</li></ol></li><li><ol><li>从中序遍历和后序遍历构造二叉树</li></ol></li><li><p>889.根据前序遍历和后序遍历构造二叉树</p></li><li><ol><li>二叉树最近公共祖先</li></ol></li><li><ol><li>从先序遍历还原二叉树（Hard）（*）</li></ol></li><li><p>1617.<a href="https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/">统计子树中城市最大距离（Hard）</a></p></li></ul><hr><h2 id="二叉树的表示"><a href="#二叉树的表示" class="headerlink" title="二叉树的表示"></a>二叉树的表示</h2><p>我们一般采用结构体或者类来表示树节点。一棵树由其根节点<strong>唯一</strong>的表示。</p><p>C++</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;    TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;</code></pre><p>Java</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> TreeNode left;    <span class="hljs-keyword">public</span> TreeNode right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">this</span>(x, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, TreeNode _left, TreeNode _right)</span></span>&#123;        val = x;        left = _left;        right = _right;    &#125;&#125;</code></pre><p>python</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span></code></pre><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>由许多方法可以帮我们完成遍历：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）、层序遍历。</p><p>采用递归是非常trivial的。我们思考<strong>迭代</strong>的方式。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><strong>前序遍历</strong></h3><ol><li>首先申请一个新的栈，记为stack；</li><li>声明一个结点treeNode，让其指向node结点；</li><li>如果treeNode的不为空，将treeNode的值打印，并将treeNode入栈，然后让treeNode指向treeNode的右结点，</li><li>重复步骤3，直到treenode为空；</li><li>然后出栈，让treeNode指向treeNode的右孩子</li><li>重复步骤3，直到stack为空.</li></ol><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;            <span class="hljs-comment">//迭代访问节点的左孩子，并入栈</span>            <span class="hljs-keyword">while</span>(treeNode != <span class="hljs-keyword">null</span>)&#123;                System.out.print(treeNode.data+<span class="hljs-string">&quot; &quot;</span>);                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-comment">//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                treeNode = stack.pop();                treeNode = treeNode.rightChild;            &#125;        &#125;    &#125;</code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><strong>中序遍历</strong></h3><p><em>*对于一棵二叉搜索树而言，其中序遍历是非递减的。</em>，这可以成为许多题目的key。</p><p>例如：<code>[5,3,7,2,4,6,8]</code>，其中序遍历（根左右）为<code>[2,3,4,5,6,7,8]</code>，前序遍历（左根右）<code>[5,3,2,4,7,6,8]</code>，后序（左右根）遍历<code>[2,4,3,6,8,7,5]</code></p><ul><li>算法</li></ul><ol><li>申请一个新栈，记为stack，申请一个变量cur，初始时令treeNode为头节点；</li><li>先把treeNode节点压入栈中，对以treeNode节点为头的整棵子树来说，依次把整棵树的左子树压入栈中，即不断令treeNode=treeNode.leftChild，然后重复步骤2；</li><li>不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点记为treeNode，打印node的值，并让treeNode= treeNode.right，然后继续重复步骤2；</li><li>当stack为空并且cur为空时结束。</li></ol><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;            <span class="hljs-keyword">while</span>(treeNode != <span class="hljs-keyword">null</span>)&#123;                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                treeNode = stack.pop();                System.out.print(treeNode.data+<span class="hljs-string">&quot; &quot;</span>);                treeNode = treeNode.rightChild;            &#125;        &#125;    &#125;</code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><strong>后序遍历</strong></h3><p>我们需要一个标记位来记忆我们此时节点上一个节点，具体看代码注释</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        TreeNode lastVisit = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//标记每次遍历最后一次访问的节点</span>        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<span class="hljs-comment">//节点不为空，结点入栈，并且指向下一个左孩子</span>            <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span>)&#123;                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-comment">//栈不为空</span>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                <span class="hljs-comment">//出栈</span>                treeNode = stack.pop();                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 这块就是判断treeNode是否有右孩子，</span><span class="hljs-comment">                 * 如果没有输出treeNode.data，让lastVisit指向treeNode，并让treeNode为空</span><span class="hljs-comment">                 * 如果有右孩子，将当前节点继续入栈，treeNode指向它的右孩子,继续重复循环</span><span class="hljs-comment">                 */</span>                <span class="hljs-keyword">if</span>(treeNode.rightChild == <span class="hljs-keyword">null</span> || treeNode.rightChild == lastVisit) &#123;                    System.out.print(treeNode.data + <span class="hljs-string">&quot; &quot;</span>);                    lastVisit = treeNode;                    treeNode  = <span class="hljs-keyword">null</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    stack.push(treeNode);                    treeNode = treeNode.rightChild;                &#125;            &#125;        &#125;    &#125;</code></pre><p><strong>层序遍历</strong></p><p>层序遍历比较简单</p><ol><li>首先申请一个新的队列，记为queue；</li><li>将头结点head压入queue中；</li><li>每次从queue中出队，记为node，然后打印node值，如果node左孩子不为空，则将左孩子入队；如果node的右孩子不为空，则将右孩子入队；</li><li>重复步骤3，直到queue为空。</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelorder</span><span class="hljs-params">(TreeNode *root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; postorder;    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;    q.push(root);    TreeNode *node;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> num_node = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> q_size = q.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; q_size;i++)        &#123;            node = q.front();            postorder.emplace_back(node-&gt;val);            <span class="hljs-keyword">if</span>(node-&gt;left) q.push(node-&gt;left);            <span class="hljs-keyword">if</span>(node-&gt;right) q.push(node-&gt;right);            <span class="hljs-keyword">delete</span> node;            q.pop();         &#125;    &#125;    <span class="hljs-keyword">return</span> postorder;&#125;</code></pre><h3 id="练习-举一反三"><a href="#练习-举一反三" class="headerlink" title="练习(举一反三)"></a>练习(举一反三)</h3><ol><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序遍历和中序遍历构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从后序遍历和中序遍历构造二叉树</a></li></ol><p>889.<a href="889.根据前序遍历和后序遍历构造二叉树">根据前序遍历和后序遍历构造二叉树</a></p><p>我们要知道，中序遍历作用是确定左右子树与根节点的相对位置。我们建立一个哈希表记录中序遍历所有节点的位置，然后在前序遍历寻找，直到遇到叶子节点。</p><hr><h2 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h2><p>236.<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树最近公共祖先</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树:<code>root = [3,5,1,6,2,0,8,null,null,7,4]</code></p><p><img src="\img\binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-string">root</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>]<span class="hljs-string">,</span> <span class="hljs-string">p</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-string">q</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">输出:</span> <span class="hljs-number">3</span><span class="hljs-string">解释:</span> <span class="hljs-string">节点</span> <span class="hljs-number">5</span> <span class="hljs-string">和节点</span> <span class="hljs-number">1</span> <span class="hljs-string">的最近公共祖先是节点</span> <span class="hljs-number">3</span><span class="hljs-string">。</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-string">root</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>]<span class="hljs-string">,</span> <span class="hljs-string">p</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-string">q</span> <span class="hljs-string">=</span> <span class="hljs-number">4</span><span class="hljs-string">输出:</span> <span class="hljs-number">5</span><span class="hljs-string">解释:</span> <span class="hljs-string">节点</span> <span class="hljs-number">5</span> <span class="hljs-string">和节点</span> <span class="hljs-number">4</span> <span class="hljs-string">的最近公共祖先是节点</span> <span class="hljs-number">5</span><span class="hljs-string">。因为根据定义最近公共祖先节点可以为节点本身。</span></code></pre><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><hr><ul><li><p>思路和算法</p><p>我们递归遍历整棵二叉树，定义 $f_x$表示 $x$ 节点的子树中是否包含 p 节点或 q节点，如果包含为 true，否则为 false。那么符合条件的最近公共祖先 x 一定满足如下条件：</p><script type="math/tex; mode=display">(f_{\text{lson}}\ \&\&\ f_{\text{rson}})\ ||\ ((x\ =\ p\ ||\ x\ =\ q)\ \&\&\ (f_{\text{lson}}\ ||\ f_{\text{rson}}))</script><p>其中 $\text{lson}$ 和 $\text{rson}$ 分别代表 $x$ 节点的左孩子和右孩子。初看可能会感觉条件判断有点复杂，我们来一条条看，$f_{\text{lson}} \&amp;\&amp; f_{\text{rson}}$ 说明左子树和右子树均包含 p 节点或 q 节点，如果左子树包含的是 p 节点，那么右子树只能包含 q 节点，反之亦然，因为 p 节点和 q 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 xx 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 x 恰好是 p 节点或 q 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 x就是我们要找的最近公共祖先。</p><p>你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到，且由于 $f_x$本身的定义很巧妙，在找到最近公共祖先 x 以后，$f_x$    按定义被设置为 true ，即假定了这个子树中只有一个 p 节点或 q 节点，因此其他公共祖先不会再被判断为符合条件。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    TreeNode* ans;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> lson = dfs(root-&gt;left, p, q);        <span class="hljs-keyword">bool</span> rson = dfs(root-&gt;right, p, q);        <span class="hljs-keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         <span class="hljs-keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        dfs(root, p, q);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><p>复杂度分析</p><p>时间复杂度：$O(N)$，其中 $N$ 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 $O(N)$。</p><p>空间复杂度：$O(N) $，其中 $N$ 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 $N$，因此空间复杂度为 $O(N)$。</p></li></ul><hr><h2 id="二叉树序列化和反序列化"><a href="#二叉树序列化和反序列化" class="headerlink" title="二叉树序列化和反序列化"></a>二叉树序列化和反序列化</h2><blockquote><p>我们需要将字符串转化为树或者反过来就需要序列化和反序列化。</p></blockquote><h4 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h4><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>示例:</strong> </p><pre><code class="hljs lsl">你可以将以下二叉树：    <span class="hljs-number">1</span>   / \  <span class="hljs-number">2</span>   <span class="hljs-number">3</span>     / \    <span class="hljs-number">4</span>   <span class="hljs-number">5</span>序列化为 <span class="hljs-string">&quot;[1,2,3,null,null,4,5]&quot;</span></code></pre><p><strong>提示:</strong> 这与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://leetcode-cn.com/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>说明:</strong> 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><hr><p>补题解。。。</p><p><strong>C++代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; res&#123;root&#125;;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_Q;<span class="hljs-comment">//用于从树中解析出数字到res数组中</span>        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;[&quot;</span>;        node_Q.push(root);        <span class="hljs-keyword">while</span> (!node_Q.empty())        &#123;            TreeNode *node = node_Q.front();node_Q.pop();            <span class="hljs-keyword">if</span> (node-&gt;left)            &#123;                node_Q.push(node-&gt;left);                res.push_back(node-&gt;left);            &#125;<span class="hljs-keyword">else</span>                res.push_back(<span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">if</span> (node-&gt;right)            &#123;                node_Q.push(node-&gt;right);                res.push_back(node-&gt;right);            &#125;<span class="hljs-keyword">else</span>                res.push_back(<span class="hljs-literal">NULL</span>);        &#125;        <span class="hljs-keyword">while</span>(!res.back()) res.pop_back();<span class="hljs-comment">//去掉多余的NULL</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c:res)             <span class="hljs-keyword">if</span>(c) &#123;s += to_string(c-&gt;val);s+=<span class="hljs-string">&quot;,&quot;</span>;&#125;            <span class="hljs-keyword">else</span>  s += <span class="hljs-string">&quot;null,&quot;</span>;        s.pop_back();        s+=<span class="hljs-string">&quot;]&quot;</span>;        <span class="hljs-keyword">return</span> s;    &#125;        <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;        <span class="hljs-comment">//data forms like &quot;[72,1,4,6,null,5,3,null,null,null,null,null,2]&quot;</span>        <span class="hljs-comment">//时间复杂度：O(n),空间复杂度O(3n)</span>        <span class="hljs-keyword">if</span>(!data.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; data_list;        <span class="hljs-built_in">string</span> num;        <span class="hljs-keyword">bool</span> num_flag = <span class="hljs-literal">false</span>;        <span class="hljs-comment">//将字符串转换为只含有数字和Null的数组,考虑负号和多位数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.size();i++)        &#123;            <span class="hljs-keyword">if</span>((data[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;data[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)||data[i]==<span class="hljs-string">&#x27;-&#x27;</span>)            &#123;                num += data[i];                num_flag = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i] == <span class="hljs-string">&#x27;n&#x27;</span>)            &#123;                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;                data_list.push_back(<span class="hljs-string">&quot;null&quot;</span>);                i += <span class="hljs-number">3</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num_flag) &#123;data_list.push_back(num);num = <span class="hljs-string">&quot;&quot;</span>;num_flag = <span class="hljs-literal">false</span>;&#125;        &#125;        TreeNode *root = <span class="hljs-keyword">new</span> TreeNode(stoi(data_list[<span class="hljs-number">0</span>]));        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_Q; <span class="hljs-comment">//用于装载所有不为null的节点</span>        data_list.erase(data_list.begin());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c: data_list)             <span class="hljs-keyword">if</span> (c!=<span class="hljs-string">&quot;null&quot;</span>) node_Q.push(<span class="hljs-keyword">new</span> TreeNode(stoi(c)));            <span class="hljs-keyword">else</span> node_Q.push(<span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_stack; <span class="hljs-comment">//用于构建树结构</span>        node_stack.push(root);        <span class="hljs-keyword">while</span> (!node_stack.empty())        &#123;            TreeNode * node = node_stack.front();node_stack.pop();            <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (!node_Q.empty())             &#123;                node-&gt;left = node_Q.front();node_Q.pop();                node_stack.push(node-&gt;left);            &#125;            <span class="hljs-keyword">else</span> node-&gt;left = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">if</span> (!node_Q.empty())             &#123;                    node-&gt;right = node_Q.front();node_Q.pop();                node_stack.push(node-&gt;right);            &#125;            <span class="hljs-keyword">else</span> node-&gt;right = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p><strong>Java代码</strong></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNodeHelper</span></span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root The root node of a binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The level traversal serialization of this binary tree. For the syntax of serialization,</span><span class="hljs-comment">     * check https://suport.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation</span><span class="hljs-comment">     * or https://suport.leetcode-cn.com/hc/kb/article/1194353/.</span><span class="hljs-comment">     * If the root node contains any circle, it will return &quot;Error! Cycle found in the binary tree!&quot;.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">treeNodeToString</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;        &#125;        StringBuilder SB = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);        Deque&lt;TreeNode&gt; BFS = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        HashSet&lt;TreeNode&gt; memo = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        BFS.offer(root);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        TreeNode cur;        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span>)&#123;            cur = BFS.poll();            <span class="hljs-keyword">if</span> (memo.contains(cur))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error! Cycle found in the binary tree!&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (cur != <span class="hljs-keyword">null</span>)&#123;                --cnt;                SB.apend(Integer.toString(cur.val));                SB.apend(<span class="hljs-string">&#x27;,&#x27;</span>);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)&#123;                    ++cnt;                &#125;                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)&#123;                    ++cnt;                &#125;                BFS.offer(cur.left);                BFS.offer(cur.right);                memo.add(cur);            &#125;            <span class="hljs-keyword">else</span>&#123;                SB.apend(<span class="hljs-string">&quot;null,&quot;</span>);            &#125;        &#125;        SB.setCharAt(SB.length()-<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;]&#x27;</span>);        <span class="hljs-keyword">return</span> SB.toString();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input a level traversal serialization of a VALID binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The root node of the deserialized binary tree. if the input is not valid,</span><span class="hljs-comment">     * the result is undefined. To check the validity, you need these codes:</span><span class="hljs-comment">     * input = input.trim(); input = input.substring(1, input.length()-1)</span><span class="hljs-comment">     * if (input.charAt(0) == &#x27;[&#x27;) Then it may be a valid serialization.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">stringToTreeNode</span><span class="hljs-params">(String input)</span></span>&#123;        input = input.trim();        input = input.substring(<span class="hljs-number">1</span>, input.length()-<span class="hljs-number">1</span>);        String[] nodes = input.split(<span class="hljs-string">&quot;,&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length = nodes.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i)&#123;            nodes[i] = nodes[i].trim();        &#125;        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">true</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[<span class="hljs-number">0</span>]));            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            TreeNode ret = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[<span class="hljs-number">0</span>]));            Deque&lt;TreeNode&gt; BFS = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            BFS.offer(ret);            <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;            TreeNode cur;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                cur = BFS.poll();                <span class="hljs-keyword">if</span> (++idx &gt;= length)&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">false</span>)&#123;                    cur.left = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[idx]));                    BFS.offer(cur.left);                &#125;                <span class="hljs-keyword">if</span> (++idx &gt;= length)&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">false</span>)&#123;                    cur.right = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[idx]));                    BFS.offer(cur.right);                &#125;            &#125;            <span class="hljs-keyword">return</span> ret;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input the treeNode you want to implement deep copy of a binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> If the input treeNode represents a valid binary tree, return a deep copy;</span><span class="hljs-comment">     * if the input treeNode is null or it doesn&#x27;t represent a valid binary tree, return null;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">TreeNodeDeepCopy</span><span class="hljs-params">(TreeNode input)</span></span>&#123;        <span class="hljs-keyword">if</span> (input == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        String copyStr = TreeNodeHelper.treeNodeToString(input);        <span class="hljs-keyword">if</span> (copyStr.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;[&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//It means the input TreeNode is not valid, so return a null pointer;</span>        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> TreeNodeHelper.stringToTreeNode(copyStr);        &#125;    &#125;&#125;</code></pre><p><strong>Python代码</strong>（附带绘图）</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> turtleprintTree_switch = <span class="hljs-literal">True</span><span class="hljs-keyword">if</span> printTree_switch:    t = turtle.Turtle()    t.penup()    t.speed(<span class="hljs-string">&#x27;fast&#x27;</span>)<span class="hljs-comment">#&#x27;fastest&#x27; &#x27;fast&#x27; &#x27;normal&#x27; &#x27;slow&#x27; &#x27;slowest&#x27;</span>    t.shape(<span class="hljs-string">&#x27;turtle&#x27;</span>)<span class="hljs-comment">#arrow&quot;, &quot;turtle&quot;, &quot;circle&quot;, &quot;square&quot;, &quot;triangle&quot;, &quot;classic&quot;</span><span class="hljs-comment"># Definition for a binary tree node.</span>null = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>         self.val = x         self.left = <span class="hljs-literal">None</span>         self.right = <span class="hljs-literal">None</span><span class="hljs-comment">#___________________________Visualize a tree___________________________________</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">printTree</span>():</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,tree</span>):</span>        self.radius = <span class="hljs-number">50</span>        self.level = <span class="hljs-number">0</span>        self.branch_length = <span class="hljs-number">4</span>*self.radius        self.node_memo = &#123;&#125;        self.draw_binary_tree(tree,(<span class="hljs-number">0</span>,<span class="hljs-number">300</span>),self.level)            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_node</span>(<span class="hljs-params">self,data,start_pos</span>):</span>        <span class="hljs-comment"># draw the node</span>        (x,y) = start_pos        length = len(str(data))        t.setx(x);t.sety(y)        t.pendown()        t.setheading(<span class="hljs-number">0</span>)        t.circle(self.radius)        t.penup();t.goto(x-length/<span class="hljs-number">2</span>*<span class="hljs-number">16</span>,y+self.radius<span class="hljs-number">-8</span>);t.pendown()        t.write(data, font=(<span class="hljs-string">&quot;Arial&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;normal&quot;</span>))        t.penup()        t.setx(x)        t.sety(y)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_branch</span>(<span class="hljs-params">self,start_pos,orient,level</span>):</span>        <span class="hljs-comment">#draw the branch</span>        (x,y) = start_pos        t.setx(x);t.sety(y)        t.pendown()        t.setheading(<span class="hljs-number">180</span>)        <span class="hljs-keyword">if</span> orient == <span class="hljs-string">&#x27;left&#x27;</span>:            t.left(<span class="hljs-number">15</span>+<span class="hljs-number">20</span>*level)            t.forward(self.branch_length-level*<span class="hljs-number">20</span>)        <span class="hljs-keyword">elif</span> orient == <span class="hljs-string">&#x27;right&#x27;</span>:            t.left(<span class="hljs-number">180</span>-(<span class="hljs-number">15</span>+<span class="hljs-number">20</span>*level))            t.forward(self.branch_length-level*<span class="hljs-number">20</span>)        t.penup()        <span class="hljs-keyword">return</span> t.pos()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_binary_tree</span>(<span class="hljs-params">self,p,start_pos,level</span>):</span>        (x,y) = start_pos        self.node_memo[p] = (x,y+self.radius)        <span class="hljs-keyword">if</span> p!=<span class="hljs-literal">None</span>:            level+=<span class="hljs-number">1</span>            print(<span class="hljs-string">&quot;level:&quot;</span>,level)            self.draw_node(p.val,(x,y))            <span class="hljs-keyword">if</span> p.left!=<span class="hljs-literal">None</span>:                (x1,y1) = self.draw_branch((x,y),<span class="hljs-string">&#x27;left&#x27;</span>,level)                self.draw_binary_tree(p.left,(x1,y1<span class="hljs-number">-2</span>*self.radius),level)                        <span class="hljs-keyword">if</span> p.right!=<span class="hljs-literal">None</span>:                (x2,y2)=self.draw_branch((x,y),<span class="hljs-string">&#x27;right&#x27;</span>,level)                self.draw_binary_tree(p.right,(x2,y2<span class="hljs-number">-2</span>*self.radius),level)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_coord</span>(<span class="hljs-params">self,node</span>)-&gt;tuple:</span>        <span class="hljs-comment">#return the coord of the node circle centre</span>        <span class="hljs-keyword">return</span> self.node_memo[node]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_line</span>(<span class="hljs-params">self,coord1, coord2,pensize=<span class="hljs-number">5</span>,pen_color=<span class="hljs-string">&#x27;red&#x27;</span></span>):</span> <span class="hljs-comment">#from 1 to 2</span>        (x,y) = coord1          t.penup()        t.pensize(pensize)        t.pencolor(pen_color)        t.setx(x);t.sety(y)        t.pendown()        t.goto(coord2[<span class="hljs-number">0</span>],coord2[<span class="hljs-number">1</span>])        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">thank_turtle</span>():</span><span class="hljs-comment"># used when tree drawing ends</span>    turtle.done()<span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><span class="hljs-string">        </span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>        res = [(root.val, root)]        node_Q = deque()        node_Q.apendleft((root.val, root))        node = root        <span class="hljs-keyword">while</span> node_Q:            tup = node_Q.popleft()            a = tup[<span class="hljs-number">0</span>]; node = tup[<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> node.left:                node_Q.apend((node.left.val, node.left))                res.apend((node.left.val, node.left))            <span class="hljs-keyword">else</span>:                res.apend((<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">None</span>))            <span class="hljs-keyword">if</span> node.right:                node_Q.apend((node.right.val, node.right))                res.apend((node.right.val, node.right))            <span class="hljs-keyword">else</span>:                res.apend((<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">None</span>))        <span class="hljs-comment"># remove redundant nones and stringify it</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:             node = res[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: res.pop()            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span>        ret = []        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:             <span class="hljs-keyword">if</span> r != <span class="hljs-string">&#x27;null&#x27;</span>:                ret.apend(str(r[<span class="hljs-number">0</span>]))            <span class="hljs-keyword">else</span>:                ret.apend(r[<span class="hljs-number">0</span>])         <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>+<span class="hljs-string">&#x27;,&#x27;</span>.join(ret)+<span class="hljs-string">&#x27;]&#x27;</span>                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><span class="hljs-string">        </span><span class="hljs-string">        :type data: str</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment"># first we have to transform the string to a list </span>        <span class="hljs-comment"># and suplement the missing none</span>        <span class="hljs-comment"># it&#x27;s totally a reversal process of serialization</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        deserial =  data[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)        root = TreeNode(deserial[<span class="hljs-number">0</span>])        node_Q = deque()        <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> deserial[<span class="hljs-number">1</span>:]:             <span class="hljs-keyword">if</span> i!=<span class="hljs-string">&#x27;null&#x27;</span>: node_Q.apend(TreeNode(int(i)))            <span class="hljs-keyword">else</span>: node_Q.apend(<span class="hljs-literal">None</span>)        node_stack = deque()        node_stack.apend(root)        <span class="hljs-keyword">while</span> node_stack:            node = node_stack.popleft()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> node_Q:                 node.left = node_Q.popleft()                node_stack.apend(node.left)            <span class="hljs-keyword">else</span>: node.left = <span class="hljs-literal">None</span>            <span class="hljs-keyword">if</span> node_Q:                 node.right = node_Q.popleft()                node_stack.apend(node.right)            <span class="hljs-keyword">else</span>: node.right = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> root</code></pre><hr><h2 id="树形dp（Hard）"><a href="#树形dp（Hard）" class="headerlink" title="树形dp（Hard）"></a>树形dp（Hard）</h2><p> 一般来说树形dp在设状态转移方程时都可以用$dp[i][j]$表示i这颗子树怎么怎么样的最优解，实现时一般都是用子树更新父亲（即从下向上更新），那么首先应该考虑的是一个一个子树的更新父亲还是把所有子树都算完了在更新父亲？这就要因题而异了，一般来说有两种情况：    </p><p>​    1. <strong>需要把所有子树的信息都掌握之后再更新子树的就需要把所有子树都算再了在更新父亲</strong>。</p><ol><li><strong>而像树上背包这样的问题就需要一个一个的更新，每次都用一个子树更新已经更新完的子树+父亲，最后就可以将这一部分的子树更新完了，再继续往上更新，最后根节点就是答案。</strong></li></ol><p>其实上面的两种情况可以总结成一种情况就是一个个子树更新父亲，一般来说第一种情况应用更多，也能解决第二情况的问题，只不过如果符合第二种情况的时候用第二种可以速度更快一点，毕竟你省了一遍循环嘛。</p><ul><li>有依赖的背包问题（见相应专题）</li><li><ol><li>监控二叉树</li></ol></li><li>834.树中距离之和</li><li>1617.统计子树中城市最大距离</li></ul><hr><h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h4><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="\img\bst_cameras_01.png" alt="img"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">1</span>解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="\img\bst_cameras_02.png" alt="img"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">2</span>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><hr><p>假设根节点为$root$,其左右子节点分别为$left$,$right$。</p><ul><li>如果根节点处放摄像头，那么左右子节点不需要放摄像头。</li><li>如果根节点处不放摄像头，则左右节点之一必须要放摄像头。</li></ul><p>通过以上的分析，二叉树节点主要有三种状态：</p><ol><li>根节点处必须放摄像头的条件下，覆盖整棵树需要的摄像头数目。</li><li>覆盖整颗树需要的摄像头数目，无论$root$是否放摄像头。</li><li>覆盖两颗子树需要的摄像头数目，无论$root$是否被覆盖到。</li></ol><p>设三种状态下需要的摄像头数量分别为$a,b,c$。那么一定有$a\ge b\ge c$。</p><p>设左子树的对应上述状态变量分别为$l_a,l_b,l_c$,右子树的对应上述状态变量分别为$r_a,r_b,r_c$,那么有：</p><ul><li>$a = l_c+r_c+1$</li><li>$b=min(a,min(l_a+r_b,l_b+r_a))$，左子树和右子树肯定有一个根节点有摄像头，另一个没有，如果两个都有，则说明产生冗余，不是最优解。</li><li>$c=min(a,l_b+r_b)$,对c而言，要保证两颗子树均被覆盖，要么root放摄像头,那么等于$a$，要么不放，即为$l_b+r_b$。</li></ul><p>对于边界条件的判断。</p><p>如果该节点为<code>null</code>那么相当于无论用多少个摄像头都无法覆盖$a=INT_MAX,b=0,c=0$</p><hr><p><strong>JAVA代码</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_MAX = <span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">int</span> res;    <span class="hljs-keyword">int</span>[] dfs(TreeNode root)    &#123;<span class="hljs-comment">//返回a,b,c</span>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;INT_MAX,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span>[]l = dfs(root.left);        <span class="hljs-keyword">int</span>[]r = dfs(root.right);        <span class="hljs-keyword">int</span> l_a = l[<span class="hljs-number">0</span>], r_a = r[<span class="hljs-number">0</span>], l_b = l[<span class="hljs-number">1</span>], r_b = r[<span class="hljs-number">1</span>], l_c = l[<span class="hljs-number">2</span>], r_c = r[<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span> a = l_c + r_c + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = Math.min(a,Math.min(l_a+r_b,l_b+r_a));        <span class="hljs-keyword">int</span> c = Math.min(a,l_b + r_b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b,c&#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> dfs(root)[<span class="hljs-number">1</span>];    &#125;    &#125;</code></pre><hr><h4 id="834-树中距离之和"><a href="#834-树中距离之和" class="headerlink" title="834. 树中距离之和"></a>834. 树中距离之和</h4><p>给定一个无向、连通的树。树中有 <code>N</code> 个标记为 <code>0...N-1</code> 的节点以及 <code>N-1</code> 条边 。</p><p>第 <code>i</code> 条边连接节点 <code>edges[i][0]</code> 和 <code>edges[i][1]</code> 。</p><p>返回一个表示节点 <code>i</code> 与其他所有节点距离之和的列表 <code>ans</code>。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: N = <span class="hljs-number">6</span>, edges = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]]输出: [<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]解释: 如下为给定的树的示意图：  <span class="hljs-number">0</span> / \<span class="hljs-number">1</span>   <span class="hljs-number">2</span>   /|\  <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>我们可以计算出 dist(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + dist(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) + dist(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) + dist(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) + dist(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) 也就是 <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">8</span>。 因此，answer[<span class="hljs-number">0</span>] = <span class="hljs-number">8</span>，以此类推。</code></pre><p><strong>说明:</strong> <code>1 &lt;= N &lt;= 10000</code></p><hr><p>Hard难度的二叉树，然后节点数量很大，猜测多半是树形dp。首先不要害怕，把题目好好读一遍，然后看一下时间，想想晚上吃啥，开个玩笑（逃）。</p><p>本题需要想到的是：定义 $dp[u]$ 表示以 $u$ 为根的子树，它的所有子节点到它的距离之和，同时定义 $cnt[u]$ 表示以 $u$ 为根的所有节点数量（包括根节点），得到基本的转移方程：</p><script type="math/tex; mode=display">dp[u] = \sum\limits_{v\in son[u]} (dp[v]+cnt[v])</script><p>然后 就很trivial，把每个节点都这样dp一下，得到时间复杂度$O(n^2)$的TLE，n为节点数目。</p><p>所以我们考虑如何优化时间复杂度到$O(n)$。官方给的一种方法是“翻转”，非常tricky。链表题目也有几道是这样的。</p><p>​    设当前根为$u$，子节点为$v$，让 $v$ 换到根的位置，$u$ 变为其孩子节点，同时维护原有的 dp 信息。在这一次的转变中，我们观察到除了 $u$ 和 $v$ 的$dp$ 值，其他节点的 $dp$ 值都不会改变，因此只要更新 $dp[u]$ 和 $dp[v] $的值即可。</p><p>​    那么我们来看 $v$ 换到根的位置的时候怎么利用已有信息求出 $dp[u]$ 和 $dp[v]$ 的值。重新回顾第一次树形动态规划的转移方程，我们可以知道当 $u$ 变为 $v$ 的孩子的时候 $v$ 不在 $u$ 的后代集合 $son[u]$ 中了，因此此时 $dp[u]$ 需要减去 $v$ 的贡献，即</p><script type="math/tex; mode=display">dp[u]=dp[u]−(dp[v]+cnt[v])</script><p>同时 $cnt[u] = cnt[u]-cnt[v]$，$cnt[v] = cnt_{pre}[u]$，可以想u原来是老大，v逆袭了继承了老大所有财产，而老大失去了原来v的那部分财产。</p><p>而 $v$ 的后代节点集合中多出了 $u$，因此$dp[v]$ 的值要由 $u$ 更新上来，即</p><script type="math/tex; mode=display">dp[v]=dp[v]+(dp[u]+sz[u])</script><p>同时 更新ans数组。</p><p>至此我们完成了一次「换根」操作，在 $O(1)$ 的时间内维护了 $dp$ 的信息，且此时的树结构以 $v$ 为根。那么接下来我们不断地进行换根的操作，即能在 $O(N)$ 的时间内求出每个节点为根的答案，实现了时间复杂度的优化。</p><p><strong>cpp代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> N;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp,cnt,res;<span class="hljs-comment">//保存节点的深度</span>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; tree;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(tree[u].empty()) <span class="hljs-keyword">return</span>;        cnt[u] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:tree[u])        &#123;            <span class="hljs-keyword">if</span>(t == f) <span class="hljs-keyword">continue</span>;            dfs1(t,u);            cnt[u] += cnt[t];            dp[u] += (dp[t]+cnt[t]);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> f)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//f的作用避免 u-&gt;v-&gt;u无限循环</span>        <span class="hljs-keyword">if</span>(tree[u].empty()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> dpu = dp[u], cntu = cnt[u];                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:tree[u])        &#123;            <span class="hljs-keyword">if</span>(t == f) <span class="hljs-keyword">continue</span>;            dp[u] -= (dp[t] + cnt[t]);            cnt[u] -= cnt[t];            cnt[t] = cntu;            dp[t] += (dp[u] + cnt[u]);            res[t] = dp[t];            dfs2(t,u);             dp[u] = dpu;            cnt[u] = cntu;        &#125;        res[u] = dp[u];    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sumOfDistancesInTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!edges.size()) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">//有节点但没有边一定要考虑！</span>        <span class="hljs-keyword">this</span>-&gt;N = N;        dp.resize(N,<span class="hljs-number">0</span>);        cnt.resize(N,<span class="hljs-number">0</span>);        res.resize(N,<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)        &#123;<span class="hljs-comment">//题目说了双向图了</span>            tree[e[<span class="hljs-number">0</span>]].emplace_back(e[<span class="hljs-number">1</span>]);            tree[e[<span class="hljs-number">1</span>]].emplace_back(e[<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-comment">//得到不考虑上层节点的树形dp</span>        dfs1(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);        <span class="hljs-comment">//进行“倒根”操作</span>        dfs2(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p>这里有个细节，就是0不一定是根节点，但是题目说了是双向图，无论是从哪个子节点均可以遍历整个树，牢记！</p><hr><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ol><li>完全二叉树节点个数</li></ol><p>完全二叉树除了底层不满以外，其它层均满节点，且底层的第一个节点一定是最左边的节点。设完全二叉树的层数为$h$,那么二叉树的节点数$N\in[2^h,2^{h+1}-1]$. 红黑树和AVL树均属于完全二叉树。</p><p>因为节点数的最大最小值知道，完全二叉树经常可以和二分查找和位运算结合起来。</p><p>如何判断第k个节点是否存在？</p><p>具体做法是，根据节点个数范围的上下界得到当前需要判断的节点个数k，如果第 k 个节点存在，则节点个数一定大于或等于 k，如果第 k 个节点不存在，则节点个数一定小于 k，由此可以将查找的范围缩小一半，直到得到节点个数。</p><p>如何判断第 k 个节点是否存在呢？如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。通过位运算得到第 k 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 k 个节点是否存在。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;     <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//完全二叉树最后一层的第一个节点一定是最左边的节点，其余层均为满二叉树</span>     <span class="hljs-comment">//1.首先计算二叉树的层数</span>     <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;     TreeNode* node = root;     <span class="hljs-keyword">while</span>(node-&gt;left)     &#123;        node = node-&gt;left;        level++;              &#125;     <span class="hljs-built_in">cout</span>&lt;&lt;level&lt;&lt;<span class="hljs-built_in">endl</span>;     <span class="hljs-comment">//2.进行二分法搜索，设h = level，那么树的节点范围为[2^h, 2^(h+1)-1]</span>     <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>&lt;&lt;level, high =( <span class="hljs-number">1</span>&lt;&lt;(level+<span class="hljs-number">1</span>))<span class="hljs-number">-1</span>;     <span class="hljs-keyword">while</span>(low &lt; high)     &#123;         <span class="hljs-keyword">int</span> mid = low + ((high-low+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>);        <span class="hljs-comment">// printf(&quot;low:%d,high:%d,mid:%d\n&quot;,low,high,mid);</span>        <span class="hljs-keyword">if</span>(exists(root, level, mid))        &#123;<span class="hljs-comment">//如果存在这个节点，那么总节点数一定大于mid</span>            low = mid;        &#125;        <span class="hljs-keyword">else</span>        &#123;            high = mid<span class="hljs-number">-1</span>;        &#125;             &#125;     <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//low == high</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exists</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> level, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//核心函数：判断节点是否存在，采用位运算</span>        <span class="hljs-keyword">int</span> bits = <span class="hljs-number">1</span>&lt;&lt;(level<span class="hljs-number">-1</span>);        TreeNode *node = root;        <span class="hljs-keyword">while</span>(node &amp;&amp; bits &gt;<span class="hljs-number">0</span> )        &#123;            <span class="hljs-keyword">if</span>(!(bits &amp; k))            &#123;                node = node-&gt;left;            &#125;            <span class="hljs-keyword">else</span>            &#123;                node = node-&gt;right;            &#125;            bits&gt;&gt;=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> node!=<span class="hljs-literal">nullptr</span>;    &#125;&#125;;</code></pre><hr><h2 id="二叉树的线索化-（待完善）"><a href="#二叉树的线索化-（待完善）" class="headerlink" title="二叉树的线索化*（待完善）"></a>二叉树的线索化*（待完善）</h2><blockquote><p>二叉树转换为链表的方式，了解就行,参考<a href="https://blog.csdn.net/u014492609/article/details/40477795#">https://blog.csdn.net/u014492609/article/details/40477795#</a></p></blockquote><p>二叉树是一种非线性结构，遍历二叉树几乎都是通过递归或者用栈辅助实现非递归的遍历。二叉树作为存储结构时，一个节点只能获取节点的左孩子和右孩子，不能直接得到节点的<strong>任一</strong>遍历序列的前驱或者后继。为了保存这种在遍历中需要的信息，我们利用二叉树中指向左右子树的空指针来存放节点的前驱或后继信息。</p><p>也就是说，线索二叉树就是充分利用二叉树节点中的空指针，让它们分别指向本节点的前驱或者后继。既充分利用了资源，又方便我们遍历这颗二叉树。</p><p><strong>概念</strong></p><p>$n$个节点的二叉树中含有$n+1$个空指针域。利用二叉树中的空指针域 来存放在某种遍历次序下的前驱和后继 ，这种指针叫“线索”。这种加上了线索的二叉树称为线索二叉树（Threaded BinaryTree）。根据遍历次序的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。</p><p><strong>结构定义</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">// 线索二叉树</span><span class="hljs-keyword">enum</span> Flag&#123;    LINK,    CLUE,&#125;;<span class="hljs-comment">//设置标志位，是正常二叉树还是线索</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadTree</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> val;    ThreadTree *left, *right;    Flag left_flag, right_flag;    ThreadTree(<span class="hljs-keyword">int</span> x):val(x),left(<span class="hljs-literal">nullptr</span>),right(<span class="hljs-literal">nullptr</span>),left_flag(LINK),right_flag(LINK)&#123;&#125;    &#125;;</code></pre><p>与遍历一样，线索二叉树也有三种构造方式,我们主要讲中序构建，其它的可以类比。</p><p>建立一个全局节点$pre$，用于记录上一个节点。中序遍历一棵二叉树</p><ul><li>若节点没有左子树，那么节点的$left_flag$设为$CLUE$. 同时左子树指向$pre$</li><li>若节点没有右子树，那么节点的$right_flag$设为$CLUE$. 同时左子树指向当前节点$root$</li><li>当前节点赋给$pre$。</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inThreading</span><span class="hljs-params">(ThreadTree* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;    inThreading(root-&gt;left);<span class="hljs-comment">//对左子树递归构建</span>    <span class="hljs-keyword">if</span>(!root-&gt;left)    &#123;        root-&gt;left_flag = CLUE;        root-&gt;left = pre;    &#125;    <span class="hljs-keyword">if</span>(!root-&gt;right)    &#123;        root-&gt;right_flag = CLUE;        root-&gt;right = root;    &#125;    pre = root;    inThreading(root-&gt;right);&#125;</code></pre><p>然后我们思考如何找到这个双向链表的头节点。没有头节点是访问不了的哈。</p><p><img src="\img\threadtree1.jpg" alt="img"></p><p><img src="\img\threadtree2.jpg" alt="img"></p><p><img src="\img\threadtree3.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析最小生成树</title>
    <link href="/2020/09/18/2020-9-12-minimal-Spanning-tree/"/>
    <url>/2020/09/18/2020-9-12-minimal-Spanning-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树的两种方法（Kruskal算法和Prim算法）"><a href="#最小生成树的两种方法（Kruskal算法和Prim算法）" class="headerlink" title="最小生成树的两种方法（Kruskal算法和Prim算法）"></a>最小生成树的两种方法（Kruskal算法和Prim算法）</h1><hr><ul><li><ol><li><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点最小费用</a></li></ol></li></ul><blockquote><p>最小生成树（$Minimal  Spanning  Tree,MST$）：有 n 个结点的<a href="https://baike.baidu.com/item/连通图/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。比较常用的有两种算法：$Kruskal$算法和$Prim$算法。</p></blockquote><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>被称为“加边法”，初始最小生成树的边数是0，每迭代一次就寻找满足条件的最小代价边，加入到最小生成树集合中去。</p><ol><li>把图中所有边按照<strong>从小到大</strong>的顺序排序。</li><li>把图中$n$个顶点看成独立的$n$棵树组成的森林。</li><li>按权值从小到大选择边，所选的边连接的两个顶点$u_i,v_i$应该属于两个不同的树（否则会形成环），则称为最小生成树的一条边，并将这两棵树作为一棵树。</li><li>重复<code>3.</code>。直到所有的顶点都在一棵树内，或者有$n-1$条边为止。</li></ol><p><img src="\img\kruskal.jpg" alt="MST示意图"></p><p>和并查集的概念非常相似。Kruskal算法可以看成是基于并查集的贪心算法。    </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> res,n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;<span class="hljs-keyword">public</span>:    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">int</span> e1, e2;<span class="hljs-comment">//两个端点的编号</span>        <span class="hljs-keyword">int</span> Mahattan_dis;<span class="hljs-comment">//曼哈顿距离</span>        edge(<span class="hljs-keyword">int</span> e1,<span class="hljs-keyword">int</span> e2, <span class="hljs-keyword">int</span> m):e1(e1),e2(e2),Mahattan_dis(m)&#123;&#125;        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> edge&amp; other) <span class="hljs-keyword">const</span>        &#123;            <span class="hljs-keyword">return</span> Mahattan_dis &lt; other.Mahattan_dis;        &#125;    &#125;;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mahattan</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);    &#125;            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = points.size();    init(n);    <span class="hljs-built_in">vector</span>&lt;edge&gt; edges;    res  = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n;j++)    &#123;        edges.emplace_back(i,j,Mahattan(points,i,j));     &#125;       sort(edges.begin(),edges.end());<span class="hljs-comment">//按从小到大排序</span>    <span class="hljs-keyword">int</span> num = n;<span class="hljs-comment">//独立的子树的个数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)    &#123;        <span class="hljs-keyword">if</span>(merge(e.e1,e.e2))        &#123;            res += e.Mahattan_dis;            num--;        &#125;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//最后只有一个连通图则返回</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)             fa.emplace_back(i);     &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(fa[x] == x)             <span class="hljs-keyword">return</span> x;        fa[x] = find(fa[x]);         <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//合并的两条边必须是不同子树</span>        <span class="hljs-keyword">int</span> x = find(i),y = find(j);        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        fa[x] = y;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre><blockquote><p>细节：为了使得自定义结构体edge能够进行排序操作，我们不能把数组edges写成<code>vector&lt;edge*&gt; edges</code>这样的话是对指针指向的地址进行排序，而不是对曼哈顿距离排序。</p></blockquote><p>时间复杂度：$O(V^2)$,$V$为边的个数，等于$N-1$。</p><p>空间复杂度：$O(N)$, 包括并查集用的父数组和自定义数据结构edge。</p><hr><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>此算法又被称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树之中，算法从某一个顶点开始，逐渐扩散覆盖整个网络。比较适合<strong>稠密网络</strong>。</p><ol><li>图的所有顶点集合为V；初始令集合$u=s,v=V-u$.</li><li>在两个集合$u,v$所构成的边中，选择一条代价最小的边。</li><li>重复上述步骤，直到最小生成树有$n-1$条边，或者只有一棵树为止。</li></ol><p><img src="\img\prim.jpg" alt="这里写图片描述"></p><p>我们注意到我们每次添加的都是最小边，因此可以用小顶堆来存储。 Prim算法更像是Dijkstra算法。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> res,n;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mahattan</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; data;    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;left, T <span class="hljs-keyword">const</span> &amp;right)</span></span><span class="hljs-function">        </span>&#123;        <span class="hljs-comment">// 以y比较。输出结果为y较大的在前y相同时，先进入队列的元素在前。</span>            <span class="hljs-keyword">return</span> (left.second &gt; right.second); <span class="hljs-comment">// left.first在后面，顶部元素first最大</span>        &#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;    <span class="hljs-comment">//Prim 算法又被称为加点法</span>    <span class="hljs-keyword">int</span> n = points.size();    res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//任选一个点作为起始点，没有必要构建边，</span>    <span class="hljs-comment">//遍历小顶堆，每次从中取出代价最小的边，（需判断点是否已经取过，需要标记列表）</span>    <span class="hljs-comment">//若最后只有一个树，或者 小顶堆为空，说明已构建完MST</span>    <span class="hljs-built_in">priority_queue</span>&lt;data,<span class="hljs-built_in">vector</span>&lt;data&gt;,cmp&lt;data&gt;&gt; lheap;<span class="hljs-comment">//p1:点序号，p2:Mahattan距离，</span>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, edge = <span class="hljs-number">0</span>;    lheap.push(data(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span>(!lheap.empty() )    &#123;        <span class="hljs-keyword">int</span> next = lheap.top().first;        <span class="hljs-keyword">if</span>(vis[next]) &#123;lheap.pop();<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//如果访问过则直接跳过</span>        vis[next] = <span class="hljs-literal">true</span>; edge+=<span class="hljs-number">1</span>;        res += lheap.top().second;        lheap.pop();        <span class="hljs-keyword">if</span>(edge == n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果边的数量达到n则break</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            lheap.push(data(i,Mahattan(points,i,next)));        &#125;              &#125;    <span class="hljs-keyword">return</span> res;      &#125;   &#125;;</code></pre><p>时间复杂度：$O(N^2)$, N为点的个数。</p><p>空间复杂度：$O(N)$,需要一个优先队列来存储所有的可能边。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>MST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂内存中堆和栈的区别</title>
    <link href="/2020/09/18/CS_heap_stack/"/>
    <url>/2020/09/18/CS_heap_stack/</url>
    
    <content type="html"><![CDATA[<h1 id="弄懂内存中堆和栈的区别"><a href="#弄懂内存中堆和栈的区别" class="headerlink" title="弄懂内存中堆和栈的区别"></a>弄懂内存中堆和栈的区别</h1><blockquote><p>知识的<a href="https://blog.csdn.net/myqq1418/article/details/81584761">传送门</a></p></blockquote><p><strong>栈区</strong>($stack$)：由编译器自动分配释放，存放函数的参数值，以及局部变量的值，其操作方式类似数据结构的栈。</p><p><strong>堆区</strong>($heap$)：一般由程序员分配释放，若程序不释放，会被操作系统回收。其操作方式类似于数据结构的链表。</p><p><strong>全局区</strong>($static$)：全局变量和静态变量的存储在一起，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><p><strong>文字常量区</strong>：常量和字符串等。</p><p><strong>程序代码区</strong>：程序的二进制代码。</p><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p><img src="\img\heap_1.png" alt="image-20200918200847502"></p><p><img src="\img\heap_2.png" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局初始化区</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局初始化区</span><span class="hljs-keyword">char</span> *p1; <span class="hljs-comment">//全局未初始化区</span>main() &#123;    <span class="hljs-keyword">int</span> b; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> *p2; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> *p3 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//123456\0在常量区，p3在栈上。</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局（静态）初始化区</span>    p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//堆区，程序员自己申请，new也是的</span>    p2 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    <span class="hljs-comment">//分配得来得10和20字节的区域就在堆区。</span>    <span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre><p><img src="../img/image-dynamic_linking.png" alt="image-20201018162705557"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存 - 堆</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java八大数据类型以及封装类</title>
    <link href="/2020/09/18/Java_notes/"/>
    <url>/2020/09/18/Java_notes/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>Java基础学习</p>          </div><span class="label label-java">text</span><h1 id="Java八大数据类型以及封装类"><a href="#Java八大数据类型以及封装类" class="headerlink" title="Java八大数据类型以及封装类"></a>Java八大数据类型以及封装类</h1><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者<a href="http://lib.csdn.net/base/operatingsystem">操作系统</a>的改变而改变。</p><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>short：16位，最<a href="http://lib.csdn.net/base/hadoop">大数据</a>存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>boolean：只有true和false两个取值。</p><p>char：16位，存储Unicode码，用单引号赋值。</p><div class="table-container"><table><thead><tr><th>单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th><th>void</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td><td>—</td></tr><tr><td>封装器类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Void</td></tr></tbody></table></div><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>$(byte，short，char)—int—long—float—double$</p><h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><p>X转字符串</p><ul><li>调用类转换方法：<code>X.toString()</code></li><li>自动类型转换：<code>X+&quot;&quot;</code></li><li>使用String方法，<code>String.ValueOf(X)</code></li></ul><p>转字符</p><ul><li>调用类转换方法：<code>X.toCharArray()</code></li></ul><p>字符串转X</p><p>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p><p>例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue()</p><p>②静态parseXXX方法</p><pre><code class="hljs Java">String s = <span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-keyword">byte</span> b = Byte.parseByte( s );<span class="hljs-keyword">short</span> t = Short.parseShort( s );<span class="hljs-keyword">int</span> i = Integer.parseInt( s );<span class="hljs-keyword">long</span> l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );</code></pre><h1 id="Java引用类型"><a href="#Java引用类型" class="headerlink" title="Java引用类型"></a>Java引用类型</h1><p>Java有 5种引用类型（对象类型）：类 (Class) 接口(Interface) 数组 (List/ArrayList)枚举(enum) 标注</p><p>引用类型：底层结构和基本类型差别较大</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码优化系列</title>
    <link href="/2020/09/18/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    <url>/2020/09/18/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>结合不同语言特效，对代码的时间和空间复杂度进行优化。</p></blockquote><h1 id="代码优化系列（奇巧淫技）"><a href="#代码优化系列（奇巧淫技）" class="headerlink" title="代码优化系列（奇巧淫技）"></a>代码优化系列（奇巧淫技）</h1><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>C++ 尽量使用<code>a.lower_bound(index)</code>而不是<code>auto it = lower_bound(a.begin(),a.end(),index)</code>否则很容易超时。</p><p><code>lower_bound</code>: 进行的比较次数与 <code>first</code> 和 <code>last</code> 间的距离成对数（至多 <em>log<br>2(last - first) + O(1)</em> 次比较）。然而，对于非<a href="https://zh.cppreference.com/w/cpp/named_req/RandomAccessIterator"><em>遗留随机访问迭代器</em> <em>(LegacyRandomAccessIterator)</em> </a>，迭代次自增次数为线性。</p><p><code>set.lower_bound</code>与容器大小成对数。</p><h3 id="宏优化"><a href="#宏优化" class="headerlink" title="宏优化"></a>宏优化</h3><p>O3 优化<code>#progma GCC optimize(3)</code></p><h3 id="cout优化"><a href="#cout优化" class="headerlink" title="cout优化"></a>cout优化</h3><pre><code class="hljs angelscript">ios::sync_with_stdio(<span class="hljs-number">0</span>);</code></pre><h3 id="自定义比较，以sort为例"><a href="#自定义比较，以sort为例" class="headerlink" title="自定义比较，以sort为例"></a>自定义比较，以sort为例</h3><pre><code class="hljs lisp">sort(<span class="hljs-name">a</span>.begin(),a.end(),[](<span class="hljs-name">auto</span> <span class="hljs-symbol">&amp;left</span>, auto <span class="hljs-symbol">&amp;right</span>)&#123;...//左前右后&#125;)<span class="hljs-comment">;</span></code></pre><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>+号优先级比&lt;&lt;高， 这样写是错误的 <code>(1&lt;&lt;0+1&lt;&lt;1 == 3) -&gt; False</code>得到的结果是4. 时刻需要注意用括号</p><p>( a&amp;b &amp;&amp;  c) = a&amp;(b&amp;&amp;c) 而不是 (a&amp;b)&amp;&amp;c，注意！！！！</p><p><img src="/img/code_optimized.jpg" alt="img"></p><p>a||b&amp;&amp;c  = (a||b)&amp;&amp;c而不是a||(b&amp;&amp;c)</p><p>~-1 = 0;  if(~a)表示 a!=-1</p><h3 id="C-string-也可作为栈使用，"><a href="#C-string-也可作为栈使用，" class="headerlink" title="C++ string 也可作为栈使用，"></a>C++ string 也可作为栈使用，</h3><pre><code class="hljs less"><span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">s</span>;<span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-selector-tag">s</span><span class="hljs-selector-class">.pop_back</span>();<span class="hljs-comment">//如果是数字字符可以直接操作</span><span class="hljs-selector-tag">s</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-tag">--</span>;</code></pre><p>字典序比较 </p><pre><code class="hljs apache"><span class="hljs-attribute">s1</span>.compare(s<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> // s<span class="hljs-number">1</span>字典序比s<span class="hljs-number">2</span>大<span class="hljs-attribute">s1</span>&gt;s<span class="hljs-number">2</span></code></pre><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">typeid</span>(d).name()&lt;&lt;<span class="hljs-built_in">endl</span>;</code></pre><h3 id="巧用map-，pair作为键值"><a href="#巧用map-，pair作为键值" class="headerlink" title="巧用map ，pair作为键值"></a>巧用map ，pair作为键值</h3><p>此外map还自带<strong>字典序</strong>排序功能，</p><pre><code class="hljs cpp"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; mymap;mymap[<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)]=<span class="hljs-number">3</span>;</code></pre><h3 id="vector直接初始化大小按下标赋值而不是push-back更快"><a href="#vector直接初始化大小按下标赋值而不是push-back更快" class="headerlink" title="vector直接初始化大小按下标赋值而不是push_back更快"></a>vector<int>直接初始化大小按下标赋值而不是push_back更快</h3><p>stoi有大小限制，若超过INT_MAX会报 out_of_range错误</p><p>如果出现非<code>0-9</code>字符也会报这个错。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>当你准备设计一个新链表，那么千万不要将头节点设为原链表头节点的引用，而应该新建一个节点。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设原链表为head<span class="hljs-regexp">//</span>错误的写法ListNode *root1 = head;</code></pre><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设原链表为head<span class="hljs-regexp">//</span>正确的写法ListNode *root1 = new ListNode(<span class="hljs-number">0</span>);...return root1-&gt;<span class="hljs-keyword">next</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>代码优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ - Java</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪婪却巧妙的贪心算法</title>
    <link href="/2020/09/02/2020-8-25-greedy/"/>
    <url>/2020/09/02/2020-8-25-greedy/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法及其应用"><a href="#贪心算法及其应用" class="headerlink" title="贪心算法及其应用"></a>贪心算法及其应用</h1><ul><li><h4 id="976-三角形的最大周长-排序-贪心-（简单）"><a href="#976-三角形的最大周长-排序-贪心-（简单）" class="headerlink" title="976. 三角形的最大周长(排序+贪心)（简单）"></a><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a>(排序+贪心)（简单）</h4></li><li><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a> (贪心+排序)</p></li><li><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a>（贪心+额外数组）</p></li><li><p><a href="https://leetcode-cn.com/problems/jump-game-$i$/">45.跳跃游戏I</a>（贪心算法+双指针）</p></li><li><p><a href="https://leetcode-cn.com/problems/jump-game/">55.跳跃游戏II</a>（贪心算法+双指针）</p></li><li><p><a href="https://leetcode-cn.com/problems/find-valid-matrix-given-row-and-column-sums/">1607.给定行列和求可行矩阵</a> （贪心+线性代数）</p></li><li><h4 id="763-划分字母区间-贪心算法-双指针）"><a href="#763-划分字母区间-贪心算法-双指针）" class="headerlink" title="763. 划分字母区间 (贪心算法+双指针）"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a> (贪心算法+双指针）</h4></li><li><h4 id="1024-视频拼接（贪心-额外数组）"><a href="#1024-视频拼接（贪心-额外数组）" class="headerlink" title="1024. 视频拼接（贪心+额外数组）"></a><a href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a>（贪心+额外数组）</h4></li><li><p><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">1642.可以到达的最远建筑</a>（贪心算法+优先队列）</p></li></ul><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </p><p>贪心算法经常和<strong>其它策略</strong>一起考，比如双指针，特殊数组以及优先队列，单调栈等。需要特别注意！</p></blockquote><hr><p>首先我们感受以下贪心可以到什么程度</p><h4 id="976-三角形的最大周长"><a href="#976-三角形的最大周长" class="headerlink" title="976. 三角形的最大周长"></a><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a></h4><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]输出：<span class="hljs-number">5</span></code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">0</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：<span class="hljs-number">10</span></code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">8</span></code></pre><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 10^6</code></li></ol><hr><p>思路，排序+贪心，将A倒序排序，遍历$i\in [0,n-1]$如果开始的三个元素$A[i],A[i+1],A[i+2]$不能组成三角形($A[i]&lt;A[i+1]+A[i+2]$)，那么后面的也肯定无法组成；如果可以组成，那么一定是最大值。</p><p>注：该题只能以O(N)通过。</p><hr><h2 id="贪心-指针"><a href="#贪心-指针" class="headerlink" title="贪心+指针"></a>贪心+指针</h2><h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><p>难度中等</p><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><pre><code class="hljs lsl">输入：S = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]解释：划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>, <span class="hljs-string">&quot;defegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span>。每个字母最多出现在一个片段中。像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</code></pre><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><hr><p>这题我开始想的是并查集，后来看了官方题解，发现贪心+指针也可以做。</p><p>而且思路和<strong>跳跃游戏</strong>出奇一致。</p><p>我们用两个指针$start$和$end$分别表示某个区间左端点和右端点。同时用数组$last$记录每个字母最后一次出现的位置。</p><p>我们遍历整个字符串，更新右端点$end = max(i,last[(int)(S[i]-‘a’)])$</p><p>若遍历到右端点了，也就是$end == i$，说明这个时候已经将一个完整区间遍历完了，更新res,$res.push_back(end-start+1)$，同时将start赋值为下一个区间的开头，$start = end+1$</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<span class="hljs-keyword">int</span> last[<span class="hljs-number">26</span>];    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;    <span class="hljs-keyword">int</span> n = S.size();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)    &#123;        last[(<span class="hljs-keyword">int</span>)(S[i]-<span class="hljs-string">&#x27;a&#x27;</span>)] = i;&#125;     <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; n;i++)     &#123;         end = max(i,last[(<span class="hljs-keyword">int</span>)(S[i]-<span class="hljs-string">&#x27;a&#x27;</span>)]);         <span class="hljs-keyword">if</span>(i == end)         &#123;             res.push_back(end-start+<span class="hljs-number">1</span>);             end = start+<span class="hljs-number">1</span>;&#125;&#125;       <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><hr><h4 id="300-最长上升序列"><a href="#300-最长上升序列" class="headerlink" title="300.最长上升序列"></a>300.最长上升序列</h4><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]输出: <span class="hljs-number">4</span> 解释: 最长的上升子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 $O(n^2)$ 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p><hr><p>考虑一个简单的贪心，如果我们要求上升子序列尽可能长，那么要求序列上升的尽可能慢，因此要求每次最后加的数尽可能小。</p><p>基于以上思路，我们维护一个数组$d[i]$，表示长度为$i$的上升子序列末尾元素的最小值，用$len$记录目前最长上升长度。起始$d[1]=nums[0]$。</p><p>同时我们可以注意到，$d[i]$是关于$i$单调递增的。因为如果$d[j]\ge d[i]$且$j&lt;i$,我们考虑从长度为$i$的最长上升序列的末尾删除$i-j$个元素，那么这个序列的长度变为$j$，且第$j$个元素必然小于$d[i]$，也就小于$d[j]$.那么我们就找到一个长度为$j$的最长上升序列。且末尾元素比$d[j]$小，从而产生矛盾，单调性得证。</p><p>我们遍历数组，并更新$d[]$和$len$的值。如果$nums[i]&gt;d[len]$则更新$len+=1$，否则在$d[1…len]$中找到满足$d[i-1]&lt;nums[j]&lt;d[i]$的下标，并更新$d[i]=nums[j]$。</p><p>由于$d[]$单调，我们可以采用二分查找的方法，优化算法时间复杂度至$O(N\log N)$。</p><ul><li>设当前已求得最长上升子序列长度为$len$，初始为1，从前往后遍历数组$nums$，在遍历到$nums[i]$时：<ul><li>若$nums[i]&gt;d[len]$，直接加入到d数组末尾，$len+=1$.</li><li>否则，在d数组二分查找，找到第一个比$nums[i]$小的数$d[k]$，并更新$d[k+1] = nums[i]。$</li></ul></li></ul><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//最长子序列长度，可以通过dp</span>        <span class="hljs-comment">//同时利用哈希表，搜索过的空间就不搜索了</span>        <span class="hljs-comment">//注意，下一个较大元素可能不选，反而总长度会更长</span>        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//包含nums[i-1]，且以之为结束的最大子串长度</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;        d[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)        &#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; d[len]) d[++len]=nums[i];            <span class="hljs-keyword">else</span> <span class="hljs-comment">//在d进行二分查找,找到第一个比nums[i]小的数nums[k]</span>            &#123;                <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>,l = <span class="hljs-number">0</span>,r = len;                <span class="hljs-keyword">while</span>(l&lt;=r)                &#123;                    <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(nums[i] &gt; d[mid])                    &#123;                        k = mid;                        l = mid+<span class="hljs-number">1</span>;                    &#125;                     <span class="hljs-keyword">else</span> r = mid<span class="hljs-number">-1</span>;                &#125;                 d[k+<span class="hljs-number">1</span>] = nums[i];                         &#125;        &#125;        <span class="hljs-keyword">return</span> len;                &#125;&#125;;</code></pre><hr><h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a></h4><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p><p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]], T = <span class="hljs-number">10</span>输出：<span class="hljs-number">3</span>解释：我们选中 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>] 这三个片段。然后，按下面的方案重制比赛片段：将 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>] 再剪辑为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>] + [<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] 。现在我们手上有 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] + [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>] + [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]，而这些涵盖了整场比赛 [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]], T = <span class="hljs-number">5</span>输出：<span class="hljs-number">-1</span>解释：我们无法只用 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 覆盖 [<span class="hljs-number">0</span>,<span class="hljs-number">5</span>] 的整个过程。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]], T = <span class="hljs-number">9</span>输出：<span class="hljs-number">3</span>解释： 我们选取片段 [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">7</span>] 和 [<span class="hljs-number">6</span>,<span class="hljs-number">9</span>] 。</code></pre><p><strong>示例 4：</strong></p><pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">8</span>]], T = <span class="hljs-number">5</span>输出：<span class="hljs-number">2</span>解释：注意，你可能录制超过比赛结束时间的视频。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= clips.length &lt;= 100</code></li><li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li><li><code>0 &lt;= T &lt;= 100</code></li></ul><hr><p>这道题动态规划时间复杂度是$O(TN)$</p><p>但是贪心算法往往能做到$O(N)$， 人类的本质是贪婪，所以我们选择贪心算法。</p><p>注意到对于所有左端点相同的子区间，其右端点越远越有利。且最佳方案中不可能出现两个左端点相同的子区间。于是我们预处理所有的子区间，对于每一个位置 $i$，我们记录以其为左端点的子区间中最远的右端点，记为 $maxn[i]$。</p><p>我们枚举每一个位置，假设当枚举到位置 $i$ 时，记左端点不大于 $i$ 的所有子区间的最远右端点为 $last$。这样 $last$ 就代表了当前能覆盖到的最远的右端点。</p><p>每次我们枚举到一个新位置，我们都用$maxn[i]$ 来更新 $last$。如果更新后 $last==i$，那么说明下一个位置无法被覆盖，我们无法完成目标。</p><p>同时我们还需要记录上一个被使用的子区间的结束位置为 $pre$，每次我们越过一个被使用的子区间，就说明我们要启用一个新子区间，这个新子区间的结束位置即为当前的 $last$。也就是说，每次我们遇到 $i==pre$，则说明我们用完了一个被使用的子区间。这种情况下我们让答案加 1，并更新 $pre$ 即可。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; clips, <span class="hljs-keyword">int</span> T)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxn</span><span class="hljs-params">(T)</span></span>;        <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; it : clips) &#123;            <span class="hljs-keyword">if</span> (it[<span class="hljs-number">0</span>] &lt; T) &#123;                maxn[it[<span class="hljs-number">0</span>]] = max(maxn[it[<span class="hljs-number">0</span>]], it[<span class="hljs-number">1</span>]);<span class="hljs-comment">//更新maxn为保证左端点被覆盖的最远的端点，</span>            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;            last = max(last, maxn[i]); <span class="hljs-comment">//获取最远右端点</span>            <span class="hljs-keyword">if</span> (i == last) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//i到达最远，无法完成</span>            &#125;            <span class="hljs-keyword">if</span> (i == pre) &#123;                ret++;                pre = last;            &#125;        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;;</code></pre><p>复杂度分析</p><p>时间复杂度：$O(T+N)$，其中 $T $是区间的长度，$N$ 是子区间的数量。我们需要枚举每一个位置，时间复杂度 $O(T)$，同时我们还需要预处理所有的子区间，时间复杂度 $O(N)$。总时间复杂度为 $O(T) + O(N) = O(T + N)$。</p><p>空间复杂度：$O(T)$，其中 T 是区间的长度。对于每一个位置，我们需要记录以其为左端点的子区间的最右端点。</p><hr><h2 id="贪心算法-优先队列"><a href="#贪心算法-优先队列" class="headerlink" title="贪心算法+优先队列"></a>贪心算法+优先队列</h2><h4 id="1642-可以到达的最远建筑"><a href="#1642-可以到达的最远建筑" class="headerlink" title="1642.可以到达的最远建筑"></a><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">1642.可以到达的最远建筑</a></h4><p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p><p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p><p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标 <strong>从 0 开始</strong> ）时：</p><ul><li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li><li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 <strong><code>(h[i+1] - h[i])</code> 个砖块</strong></li></ul><p>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 <strong>从 0 开始</strong> ）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>], bricks = <span class="hljs-number">5</span>, ladders = <span class="hljs-number">1</span>输出：<span class="hljs-number">4</span>解释：从建筑物 <span class="hljs-number">0</span> 出发，你可以按此方案完成旅程：- 不使用砖块或梯子到达建筑物 <span class="hljs-number">1</span> ，因为 <span class="hljs-number">4</span> &gt;= <span class="hljs-number">2</span>- 使用 <span class="hljs-number">5</span> 个砖块到达建筑物 <span class="hljs-number">2</span> 。你必须使用砖块或梯子，因为 <span class="hljs-number">2</span> &lt; <span class="hljs-number">7</span>- 不使用砖块或梯子到达建筑物 <span class="hljs-number">3</span> ，因为 <span class="hljs-number">7</span> &gt;= <span class="hljs-number">6</span>- 使用唯一的梯子到达建筑物 <span class="hljs-number">4</span> 。你必须使用砖块或梯子，因为 <span class="hljs-number">6</span> &lt; <span class="hljs-number">9</span>无法越过建筑物 <span class="hljs-number">4</span> ，因为没有更多砖块或梯子。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>], bricks = <span class="hljs-number">10</span>, ladders = <span class="hljs-number">2</span>输出：<span class="hljs-number">7</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">14</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>,<span class="hljs-number">3</span>], bricks = <span class="hljs-number">17</span>, ladders = <span class="hljs-number">0</span>输出：<span class="hljs-number">3</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>1 &lt;= heights[i] &lt;= 106</code></li><li><code>0 &lt;= bricks &lt;= 109</code></li><li><code>0 &lt;= ladders &lt;= heights.length</code></li><li></li></ul><hr><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights, <span class="hljs-keyword">int</span> bricks, <span class="hljs-keyword">int</span> ladders)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = heights.size();    <span class="hljs-comment">//我们实时维护一个优先队列，保存从大到小排列的高度差</span>    <span class="hljs-comment">//前面的l个最大高度可以用绳子解决，后面的高度差之和就是消耗砖块的数量，若在i位置，高度差之和大于砖块位置，且没有绳子可以用，这就是我们能到达的最远位置。</span>   <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq;   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>;<span class="hljs-comment">//    cout&lt;&lt;endl;</span>   <span class="hljs-keyword">for</span>(;i &lt; len<span class="hljs-number">-1</span>;i++)   &#123;       <span class="hljs-keyword">if</span>(heights[i+<span class="hljs-number">1</span>] &lt;= heights[i]) <span class="hljs-keyword">continue</span>;       pq.push(heights[i+<span class="hljs-number">1</span>] - heights[i]);       sum += heights[i+<span class="hljs-number">1</span>] - heights[i];    <span class="hljs-comment">//    printf(&quot;sum:%d\n&quot;,sum);</span>       <span class="hljs-keyword">if</span>(sum &gt; bricks)       &#123;<span class="hljs-comment">//如果消耗的砖块超了就改用绳子</span>            <span class="hljs-keyword">if</span>(ladders == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            ladders --;            sum -= pq.top();            <span class="hljs-comment">// printf(&quot;-=:%d\n&quot;,sum);     </span>            pq.pop();       &#125;          &#125;    <span class="hljs-keyword">return</span> i;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学和线性代数应用于解题</title>
    <link href="/2020/09/02/2020-8-25-math/"/>
    <url>/2020/09/02/2020-8-25-math/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hi这里数学仅仅指数论和几何以及离散数学，没有谁用高等数学出题的，不过你也可以试试，让面试官刮目相看。我们重点研究一些很经典的数学问题。</p></blockquote><h1 id="利用数学、线性代数解题"><a href="#利用数学、线性代数解题" class="headerlink" title="利用数学、线性代数解题"></a>利用数学、线性代数解题</h1><blockquote><p>包括但不限于数论，几何，排列组合等。。。</p><p>LC上有很多题目是和数学相关的，如果我们有一定的数学基础，那么解起题来事半功倍！下面是一些例题和典型方法。</p><p>数学包括数论，几何，离散数学等，线性代数就是矩阵那一块，应试者需要具备基本的本科线性代数知识。</p></blockquote><ul><li><ol><li><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/">圆和矩形是否有重叠</a></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">可见点的最大数目</a>（配合滑动窗口和atan2）</li></ol></li><li><h4 id="1632-矩阵转换后的秩-Hard"><a href="#1632-矩阵转换后的秩-Hard" class="headerlink" title="1632. 矩阵转换后的秩(Hard)"></a><a href="https://leetcode-cn.com/problems/rank-transform-of-a-matrix/">1632. 矩阵转换后的秩</a>(Hard)</h4></li></ul><hr><ul><li><p>求质因数</p></li><li><p>最大公因数（GCD）</p></li><li><p>最小公倍数（LCM）</p></li><li><p>快速幂算法</p></li><li><p>Gauss消元法</p></li><li><p>几何</p></li><li><p>矩阵论</p></li></ul><h2 id="质因数求解"><a href="#质因数求解" class="headerlink" title="质因数求解"></a>质因数求解</h2><p>设$ R = \sqrt{A}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+1$个不同的质因数。质因数为本身的只有一个，非本身的质因数一定比$R$小，最多$R$个。</p><p><strong>策略</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)<span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>) &#123;...&#125;</code></pre><h2 id="最大公因数（Greatest-Common-Divisor）"><a href="#最大公因数（Greatest-Common-Divisor）" class="headerlink" title="最大公因数（Greatest Common Divisor）"></a>最大公因数（Greatest Common Divisor）</h2><p>交替递归，可以有效减小迭代次数。$(a,b)\rightarrow ( b,a\%b)$直到有一个数为0.</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">return</span> gcd(b, a % b);&#125;</code></pre><p>上述代码也可以用一行搞定：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> (!b)?a:gcd(b,a%b);&#125;</code></pre><h2 id="最小公倍数（LCM，Least-Common-Multiple）"><a href="#最小公倍数（LCM，Least-Common-Multiple）" class="headerlink" title="最小公倍数（LCM，Least Common Multiple）"></a>最小公倍数（LCM，Least Common Multiple）</h2><p>比如 $(2,3) - 6, (3,6) - 6, (6,15) - 30$，找到$a,b$的最大公因数$k$，结果就是$a/k*b$</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a/gcd(a,b)*b;&#125;</code></pre><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote><p>参考：<a href="https://blog.csdn.net/qq_19782019/article/details/85621386">https://blog.csdn.net/qq_19782019/article/details/85621386</a></p></blockquote><p>我们思考一个问题，求$2^{10E9}$的最后三位数。</p><blockquote><ol><li>(a + b) % p = (a % p + b % p) % p （1）</li><li>(a - b) % p = (a % p - b % p ) % p （2）</li><li><strong>(a * b) % p = (a % p * b % p) % p （3）</strong></li></ol><p>数学上可以证明只要我们每一步都取后三位，那么最后的结果就是答案。</p></blockquote><p>快速幂的核心算法是【分治】，即把每一次幂都分为两半。</p><ul><li>如果幂为偶数则，将幂除2，将基乘2，并且取余数。</li><li>如果幂为奇数，将幂减1除2，多出的一次幂乘到结果中，并且取余数。</li></ul><p>如果最后幂为0，表示计算完毕。</p><p>我们可以适当进行优化</p><ul><li><code>a&amp;1==true</code>表示a为奇数，因为偶数二进制最后一位一定是0.</li><li>幂减1除2，可以直接省略，因为<code>/2</code>运算会忽略小数点。同时<code>&gt;&gt;1</code>也表示除2.</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fastPower</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power, <span class="hljs-keyword">int</span> digits)</span> </span>&#123;    <span class="hljs-comment">//digits表示取最后几位</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % digits;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % digits;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="Gauss消元法"><a href="#Gauss消元法" class="headerlink" title="Gauss消元法"></a>Gauss消元法</h2><blockquote><p>高斯消元法主要用于求解线性方程组，也可以求矩阵的秩、矩阵的逆等，是一个重要的数学方法。其时间复杂度主要与方程组个数、方程组未知数个数有关，一般来说，时间复杂度为 $O(n^3)$</p><p>参考：<a href="https://blog.csdn.net/u011815404/article/details/88890702">https://blog.csdn.net/u011815404/article/details/88890702</a></p></blockquote><p>高斯消元法的基本思想是：通过一系列加减消元运算，直到得到类似$Ax=b$形式，然后再解方程。</p><p>解以下几种可能性：</p><ol><li>无解，表现为某一行系数全为0，但解不为0. </li><li>无穷多解，$det(A)=0$，增广矩阵的行列式为0，矩阵有至少一行全部为0。</li></ol><p>思路：遍历整个上三角区域，想办法初等变换得到上三角矩阵。设增广矩阵为$matrix$，大小为$m×n$。当前行为$row$，当前列为$col$。</p><ul><li>找出当前列绝对值最大的行$maxRow$。</li><li>采用冒泡法思想，将绝对值最大的行替换到最上面，方便后面进行消元。</li><li>若$col$列第$row$行下全为0，则对$row—$，直接处理下一列。</li><li>枚举要删去的行，采取的办法是求最小公倍数，以$maxRow$行为基准，消去$matrix[row][col],row!=maxRow$。</li></ul><p>下面代码不保证鲁棒性，仅作理解用。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Gauss</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;matrix)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @description: 利用Gauss消元法解方程</span><span class="hljs-comment"> * @param matrix为增广矩阵，包括非齐次项</span><span class="hljs-comment"> * @return &#123;type&#125; None</span><span class="hljs-comment"> * @author: Durant Thorvals</span><span class="hljs-comment"> * @complexity: Time:O(1),Space:O(1)</span><span class="hljs-comment"> */</span>      <span class="hljs-keyword">if</span>(!matrix.size()||!matrix[<span class="hljs-number">0</span>].size()) <span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-keyword">int</span> m = matrix.size(), n = matrix[<span class="hljs-number">0</span>].size();    <span class="hljs-keyword">if</span>(m!=n<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>);    <span class="hljs-comment">//转换为上三角形阶梯阵</span>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(row = <span class="hljs-number">0</span>; row &lt; m &amp;&amp; col &lt; n;row++,col++)    &#123;        <span class="hljs-keyword">int</span> maxrow = row;        <span class="hljs-comment">//找出当前列绝对值最大的行</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row+<span class="hljs-number">1</span>;i &lt; m;i++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(matrix[i][col]) &gt; <span class="hljs-built_in">abs</span>(matrix[maxrow][col]))                maxrow = i;        &#125;        <span class="hljs-comment">//将所有绝对值小于它的行进行交换</span>        <span class="hljs-keyword">if</span>(maxrow != row)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = col;j &lt; n;j++)            &#123;                swap(matrix[row][j],matrix[maxrow][j]);            &#125;        &#125;                <span class="hljs-comment">//若col列第row行一下全为0，则处理下一列</span>        <span class="hljs-keyword">if</span>(!matrix[row][col])        &#123;            row -- ;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">//枚举要删去的行</span>        <span class="hljs-comment">//通过寻找最小公倍数方式进行初等变换</span>        <span class="hljs-keyword">int</span> lcm, t_a, t_b;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row+<span class="hljs-number">1</span>;i &lt; m;i++)        &#123;                lcm = LCM(matrix[row][col],matrix[i][col]);            <span class="hljs-comment">//采用同乘方式消元</span>            <span class="hljs-keyword">if</span>(!lcm) &#123;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;The equations have infinite solution&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> &#123;&#125;;&#125;            t_a = lcm/ matrix[row][col];            t_b = lcm/ matrix[i][col];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = col;j &lt; n;j++)            &#123;<span class="hljs-comment">//这儿就可以看出是O(n^3)时间复杂度</span>                matrix[i][j] = matrix[i][j]*t_b - matrix[row][j]*t_a;            &#125;        &#125;    &#125;        <span class="hljs-comment">//讨论解的可能形式</span>    <span class="hljs-comment">//1.无解, 有一行是 0 ....0 b的形式</span>    <span class="hljs-keyword">int</span> i ;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">if</span>(matrix[m<span class="hljs-number">-1</span>][i]) <span class="hljs-keyword">break</span>;     <span class="hljs-keyword">if</span>(i == n<span class="hljs-number">-1</span>)    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;The equations seem insolvable...&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> &#123;&#125;;    &#125;    <span class="hljs-comment">//2.有无穷多解</span>    <span class="hljs-keyword">if</span>(i == n)    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;The equations have infinite solution&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> &#123;&#125;;    &#125;    <span class="hljs-comment">//3.有唯一一组解</span>    <span class="hljs-comment">//系数矩阵变为对角型，可以直接求解</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)    &#123;        <span class="hljs-keyword">int</span> temp = matrix[i][n<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n<span class="hljs-number">-1</span>;j++)            temp -= res[j]*matrix[i][j];        <span class="hljs-keyword">if</span>(temp%matrix[i][i]!=<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;solution needs tranform to floating unit...&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">return</span> &#123;&#125;;        &#125;        res[i] = temp/matrix[i][i];    &#125;    <span class="hljs-keyword">return</span> res;    &#125;</code></pre><p>可以清楚的看到算法时间复杂度$O(n^3)$，设矩阵大小为$n$。</p><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><p>几何问题很广泛，有些看似几何的问题其实可以归结为图问题。这里我们介绍纯数学几何。可能会涉及浮点数，我们需要了解一些常见工具。</p><p>有一些常用的库：</p><p><strong>C++</strong></p><blockquote><p><code>include&lt;cmath&gt;</code> </p></blockquote><p>基础: <code>cos</code>,<code>sin</code>,<code>tan</code>,<code>atan</code>,<code>sqrt</code>,<code>exp</code>,<code>pow</code>,<code>log</code>(lnx),<code>log10()</code>,<code>ceil</code>（向上取整）,<code>floor</code>（向下取整）。    </p><p><code>fabs</code>浮点数绝对值,</p><p><code>double modf (double, double*)</code>; 将参数的整数部分通过指针回传, 返回小数部分<br><code>double fmod (double, double)</code>; 返回两参数相除的余数</p><p><code>double atan2(double y, double x)</code>：返回的是方位角。范围$[-\pi,\pi]$</p><p><img src="\img\atan2.jpg" alt="atan2的公式"></p><hr><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><h4 id="1621-大小为-K-的不重叠线段的数目"><a href="#1621-大小为-K-的不重叠线段的数目" class="headerlink" title="1621. 大小为 K 的不重叠线段的数目"></a><a href="https://leetcode-cn.com/problems/number-of-sets-of-k-non-overlapping-line-segments/">1621. 大小为 K 的不重叠线段的数目</a></h4><p>python内置<code>math.comb</code>以计算组合数</p><p>C++需要自己编写</p><hr><p>题目赏析</p><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">12</span>输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4.</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">13</span>输出: <span class="hljs-number">2</span>解释: <span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9.</span></code></pre><hr><p>1770年，<a href="[https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem](https://en.wikipedia.org/wiki/Lagrange&#39;s_four-square_theorem">Lagrange</a>)证明了一个定理，被称为四平方数定理，它指出每个自然数都能表示为四个平方整数之和：</p><script type="math/tex; mode=display">p=a_0^2+a_1^2+a_2^2+a_3^2</script><p>这就规定了问题的上限，即最大的平方数个数是4.</p><p>注意，这里0也被当成完全平方数。</p><p>后来1797年，<a href="https://en.wikipedia.org/wiki/Adrien-Marie_Legendre">Legendre</a>用他的三平方定理完成了四平方定理，正整数可以表示为三个平方和的一个特殊条件：</p><script type="math/tex; mode=display">n\ne 4^k(8m+7) \Leftrightarrow p=a_0^2+a_1^2+a_2^2</script><p>在我们分解为（底部情况）三平方数之前，还有两种特例需要检查：</p><ol><li><p>该数本身是一个完全平方数 即<code>n=(int)(sqrt(n)*sqrt(n))</code></p></li><li><p>如果一个数可以分解为两个平方数之和，不幸的是，我们只能通过枚举来找到这样的数。</p></li></ol><p><strong>算法：</strong></p><ol><li><p>检查该数是否为完全平方数</p></li><li><p>如果该数可以表示为$n == 4^k(8m+7)$，那么可以确切的说，答案肯定为4；</p></li></ol><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) n /= <span class="hljs-number">4</span>;<span class="hljs-keyword">if</span>((n<span class="hljs-number">-7</span>)%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>) res = <span class="hljs-number">4</span>;</code></pre><ol><li>我们看该数，是否能由更少的完全平方数组成。</li></ol><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n<span class="hljs-number">-1</span>;k &gt;= <span class="hljs-number">1</span>;k--)&#123;    <span class="hljs-keyword">if</span>(isPerfectSquare(n*n-k*k)) res = <span class="hljs-number">2</span>;&#125;</code></pre><p><strong>代码：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> n == ((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n))*((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//一些很特殊的情况12 = 2^2+2^2+2^2; 18 = 3^2+3^2;1000= 30^2+10^2;61=5^2+6^2</span>    <span class="hljs-keyword">if</span>(isPerfectSquare(n)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> nn = n;    <span class="hljs-comment">//判断是否为四平方数</span>    <span class="hljs-keyword">while</span>(nn%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) nn/=<span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span>((nn<span class="hljs-number">-7</span>)%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n<span class="hljs-number">-1</span>;k &gt;= <span class="hljs-number">1</span>;k--)    <span class="hljs-keyword">if</span>(isPerfectSquare(k))    &#123;        <span class="hljs-comment">// printf(&quot;%d:\n&quot;,k);</span>        <span class="hljs-keyword">if</span>(isPerfectSquare(n-k)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>： 最好的情况下是$O(1)$，比如$n$是完全平方数, 最坏$O(N)$，即该数有两个平方数组成。</li><li><strong>空间复杂度</strong>:   $O(1)$，常数级别空间占用。</li></ul><hr><h4 id="10-可见点的最大数目"><a href="#10-可见点的最大数目" class="headerlink" title="10. 可见点的最大数目"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">10. 可见点的最大数目</a></h4><p>给你一个点数组 <code>points</code> 和一个表示角度的整数 <code>angle</code> ，你的位置是 <code>location</code> ，其中 <code>location = [posx, posy]</code> 且 <code>points[i] = [xi, yi]</code> 都表示 X-Y 平面上的整数坐标。</p><p>最开始，你面向东方进行观测。你 <strong>不能</strong> 进行移动改变位置，但可以通过 <strong>自转</strong> 调整观测角度。换句话说，<code>posx</code> 和 <code>posy</code> 不能改变。你的视野范围的角度用 <code>angle</code> 表示， 这决定了你观测任意方向时可以多宽。设 <code>d</code> 为你逆时针自转旋转的度数，那么你的视野就是角度范围 <code>[d - angle/2, d + angle/2]</code> 所指示的那片区域。</p><p>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。</p><p>返回你能看到的点的最大数目。</p><p><strong>示例 1：</strong></p><p><img src="\img\lc1610_1.jpg" alt="img"></p><pre><code class="hljs angelscript">输入：points = [[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]], angle = <span class="hljs-number">90</span>, location = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">3</span>解释：阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 和 [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]在同一条直线上，你仍然可以看到 [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：points = [[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]], angle = <span class="hljs-number">90</span>, location = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">4</span>解释：在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。</code></pre><p><strong>示例 3：</strong></p><p><img src="/img/lc1610_2.jpg" alt="img"></p><pre><code class="hljs angelscript">输入：points = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]], angle = <span class="hljs-number">13</span>, location = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">1</span>解释：如图所示，你只能看到两点之一。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 105</code></li><li><code>points[i].length == 2</code></li><li><code>location.length == 2</code></li><li><code>0 &lt;= angle &lt; 360</code></li><li><code>0 &lt;= posx, posy, xi, yi &lt;= 109</code></li></ul><hr><p>题解：<a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/solution/ji-zuo-biao-hua-dong-chuang-kou-zui-da-chang-du-zh/">https://leetcode-cn.com/problems/maximum-number-of-visible-points/solution/ji-zuo-biao-hua-dong-chuang-kou-zui-da-chang-du-zh/</a></p><p>需要额外定义2pi，是为了两角之差大于180时取补角考虑。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>几何</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>貌似很难懂的DSA是什么？</title>
    <link href="/2020/09/02/2020-9-2-fsm/"/>
    <url>/2020/09/02/2020-9-2-fsm/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是确定有限状态自动机（Deterministic-State-Automata）？"><a href="#什么是确定有限状态自动机（Deterministic-State-Automata）？" class="headerlink" title="什么是确定有限状态自动机（Deterministic State Automata）？"></a>什么是确定有限状态自动机（Deterministic State Automata）？</h1><p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p><ul><li>有一个特殊的状态，被称作「初始状态」。</li><li>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</li></ul><p>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p><p>一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。</p><p>自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。</p><p>自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。</p><hr><p><strong>例题：</strong></p><ul><li><ol><li><a href="">有效的数字</a>(Hard)</li></ol></li><li>剑指Offer 20. <a href="">表示数值的字符串</a>(Medium)</li></ul><hr><p>以 剑指Offer 20. <a href="">表示数值的字符串</a>(Medium) 为例。</p><blockquote><p> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p></blockquote><hr><p><strong>思路与算法</strong></p><p>根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p><ol><li>起始的空格</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点</li><li>小数部分</li><li>字符$E$</li><li>指数部分的符号位</li><li>指数的整数部分</li><li>结束的空格</li></ol><p>下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。</p><p>最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：</p><p><img src="\img\image-fsa.png" alt="image-20200902111512582"></p><p>在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 \text{e}e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。</p><hr><p><strong>代码</strong>：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">enum</span> state    &#123;        STATE_INIT,        <span class="hljs-comment">// STATE_SPACE,</span>        STATE_SIGN,        STATE_INTEGER,        STATE_POINT_INT,        STATE_POINT_NOT_INT,        STATE_DECIMAL,        STATE_EXP,        STATE_EXP_SIGN,        STATE_EXP_INT,        STATE_END,    &#125;;    <span class="hljs-keyword">enum</span> charType    &#123;        CHAR_NUM,        CHAR_SPACE,        CHAR_POINT,        CHAR_EXP,        CHAR_SIGN,        CHAR_INVALID,    &#125;;    <span class="hljs-function">charType <span class="hljs-title">getCharType</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_NUM;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span> CHAR_SPACE;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_POINT;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;E&#x27;</span>||ch == <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_EXP;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;+&#x27;</span>||ch==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_SIGN;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CHAR_INVALID;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">int</span> len = s.length();        state sta = STATE_INIT;        <span class="hljs-comment">//用哈希表存储状态转移方程</span>        <span class="hljs-built_in">unordered_map</span>&lt;state,<span class="hljs-built_in">unordered_map</span>&lt;charType,state&gt;&gt; transfer&#123;            &#123;                STATE_INIT, &#123;&#123;CHAR_SPACE,STATE_INIT&#125;,                            &#123;CHAR_SIGN, STATE_SIGN&#125;,                            &#123;CHAR_NUM, STATE_INTEGER&#125;,                            &#123;CHAR_POINT,STATE_POINT_NOT_INT&#125;            &#125;&#125;,            &#123;                STATE_SIGN,&#123;&#123;CHAR_NUM, STATE_INTEGER&#125;,                           &#123;CHAR_POINT, STATE_POINT_NOT_INT&#125;,            &#125;&#125;,            &#123;                STATE_DECIMAL,  &#123;&#123;CHAR_NUM, STATE_DECIMAL&#125;,                                &#123;CHAR_EXP, STATE_EXP&#125;,                                &#123;CHAR_SPACE, STATE_END&#125;            &#125;&#125;,            &#123;                STATE_INTEGER,  &#123;&#123;CHAR_NUM, STATE_INTEGER&#125;,                                &#123;CHAR_EXP,STATE_EXP&#125;,                                &#123;CHAR_POINT,STATE_POINT_INT&#125;,                                &#123;CHAR_SPACE,STATE_END&#125;            &#125;&#125;,            &#123;                STATE_POINT_NOT_INT,&#123;&#123;CHAR_NUM, STATE_DECIMAL&#125;            &#125;&#125;,            &#123;                STATE_POINT_INT,&#123;&#123;CHAR_SPACE,STATE_END&#125;,                                &#123;CHAR_NUM,STATE_DECIMAL&#125;,                                &#123;CHAR_EXP,STATE_EXP&#125;            &#125;&#125;,            &#123;                STATE_EXP,  &#123;&#123;CHAR_SIGN, STATE_EXP_SIGN&#125;,                            &#123;CHAR_NUM, STATE_EXP_INT&#125;            &#125;&#125;,            &#123;                STATE_EXP_SIGN,&#123;&#123;CHAR_NUM, STATE_EXP_INT&#125;            &#125;&#125;,            &#123;                STATE_EXP_INT,&#123;&#123;CHAR_NUM,STATE_EXP_INT&#125;,                                &#123;CHAR_SPACE,STATE_END&#125;&#125;            &#125;,            &#123;                STATE_END,&#123;&#123;CHAR_SPACE,STATE_END&#125;,&#125;            &#125;        &#125;;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)        &#123;            charType ct = getCharType(s[i]);            <span class="hljs-comment">//如果是非法状态，直接返回false</span>                    <span class="hljs-keyword">if</span>(!transfer[sta].count(ct)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            sta = transfer[sta][ct];                    &#125;         <span class="hljs-keyword">return</span> sta == STATE_END || sta == STATE_INTEGER || sta == STATE_POINT_INT || sta == STATE_DECIMAL|| sta == STATE_EXP_INT;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>有限自动状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索vs动态规划</title>
    <link href="/2020/08/28/2020-8-28-memorized-search/"/>
    <url>/2020/08/28/2020-8-28-memorized-search/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索vs动态规划"><a href="#记忆化搜索vs动态规划" class="headerlink" title="记忆化搜索vs动态规划"></a>记忆化搜索vs动态规划</h1><ul><li><blockquote><p>记忆化搜索实际上是递归来实现的，但是递归的过程中有许多的结果是被反复计算的，这样会大大降低算法的执行效率。　而记忆化搜索是在递归的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，因此极大的提高了算法的效率。</p></blockquote></li></ul><blockquote><p>记忆化搜索与动态规划区别：记忆化搜索：「<strong>自顶向下</strong>」，动态规划：「<strong>自底向上</strong>」。所有动态规划能解决的问题，记忆化搜索也能解决，唯一要注意的是动态规划不容易超时，但空间占用大，而记忆化搜索因为递归较多，容易TLE。    </p></blockquote><ul><li><a href="">546.移除盒子</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/">312.戳气球</a>(Hard)</li><li><a href="">1575.可行路径数</a>(hard)</li><li><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a>(Medium)（结合状态压缩）</li></ul><hr><h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h2><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code>，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>]输出: <span class="hljs-number">167</span> 解释: nums = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>] --&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>] --&gt;   [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>]   --&gt;  [<span class="hljs-number">8</span>]  --&gt; []     coins =  <span class="hljs-number">3</span>*<span class="hljs-number">1</span>*<span class="hljs-number">5</span>      +  <span class="hljs-number">3</span>*<span class="hljs-number">5</span>*<span class="hljs-number">8</span>    +  <span class="hljs-number">1</span>*<span class="hljs-number">3</span>*<span class="hljs-number">8</span>      + <span class="hljs-number">1</span>*<span class="hljs-number">8</span>*<span class="hljs-number">1</span>   = <span class="hljs-number">167</span></code></pre><hr><p>总的戳破气球操作数一定为<code>n</code>。我们可以倒过来看这些操作，每一次添加一个气球。</p><p>我们定义方法$solve(i,j)$表示将区间$(i,j)$全部填满所能得到的最多的硬币数。这里是一个开区间。当</p><ul><li><p>$i\ge j-1$，$solve(i,j)=0$</p></li><li><p>否则，我们枚举开区间$(i,j)$内的全部位置$mid$，令$mid$为当前区间第一个添加的气球，该操作所能得到的硬币数为  </p></li><li><script type="math/tex; mode=display">nums[mid-1]*nums[mid]*nums[mid+1] ​</script></li><li><p>同时我们递归的计算出分割的两区间对$solve(i,j)$的贡献，这三项最大值，即为$solve(i,j)$的值。这样问题可以转换为求$solve(i,mid)$与$solve(mid,j)$之和。</p></li></ul><p>状态转移方程：</p><script type="math/tex; mode=display">solve(i,j)= \left\{\begin{array}{rrr}0,i \ge j-1\\solve(i,mid)+\\ \max \limits_{i\lt mid \lt j}(nums[mid-1]*nums[mid]*nums[mid+1])+\\ solve(mid,j), otherwise\\\end{array}\right.</script><p>然后我们再看边界条件：</p><blockquote><p>$solve(0,0)=0$</p></blockquote><p>为了避免重复计算，我们存储<code>solve</code>的中间结果。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> n;     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; memo;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//开区间(i,j)内积分最大值,先加mid，再计算最大值</span>                <span class="hljs-keyword">if</span>(i &gt;= j<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span>(memo[i][j]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> memo[i][j];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mid = i+<span class="hljs-number">1</span>; mid &lt; j; mid++)        &#123;            memo[i][j] = max(memo[i][j], nums[i]*nums[mid]*nums[j]+solve(i,mid)+solve(mid,j) );        &#125;        <span class="hljs-keyword">return</span> memo[i][j];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//这一题和移除盒子是同类型题，要靠JOJO奇妙的动态规划来解决</span>        <span class="hljs-comment">//我们要让尽可能大的气球相邻</span>        n = nums.size();        nums.insert(nums.begin(),<span class="hljs-number">1</span>);        nums.emplace_back(<span class="hljs-number">1</span>);        <span class="hljs-keyword">this</span>-&gt;nums = nums;        memo.resize(n+<span class="hljs-number">2</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>));        <span class="hljs-keyword">return</span> solve(<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(n^3)$，其中 $n$ 是气球数量。区间数为 $n^2$，区间迭代复杂度为 O(n)O(n)，最终复杂度为 $O(n^2 \times n) = O(n^3)$</p></li><li><p>空间复杂度：$O(n^2)$，其中 $n$ 是气球数量。缓存大小为区间的个数。</p></li></ul><p><strong>动态规划代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">rec</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>))</span></span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            val[i] = nums[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;                    <span class="hljs-keyword">int</span> sum = val[i] * val[k] * val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = max(rec[i][j], sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];    &#125;&#125;;</code></pre><h2 id="546-移除盒子"><a href="#546-移除盒子" class="headerlink" title="546. 移除盒子"></a>546. 移除盒子</h2><p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。<br>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。<br>当你将所有盒子都去掉之后，求你能获得的最大积分和。</p><p>示例：</p><pre><code class="hljs angelscript">输入：boxes = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">23</span>解释：[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span> 分) ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">1</span>*<span class="hljs-number">1</span>=<span class="hljs-number">1</span> 分) ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span> 分) ----&gt; [] (<span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">4</span> 分)</code></pre><p>提示：</p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= boxes.length &lt;= <span class="hljs-number">100</span><span class="hljs-symbol">1 </span>&lt;= boxes[i] &lt;= <span class="hljs-number">100</span></code></pre><hr><p>这一题的规模比较小，按照官方的尿性，官解的时间复杂度会很大。很神奇的是，这种题目也可以通过动态规划解决。</p><p>用$f(l,r,k)$表示移除区间$[l,r]$加上该区间右边等于$a_r$的$k$个元素组成的序列的最大积分。</p><h2 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h2><hr><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p> <pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]输出：False解释：一开始，玩家<span class="hljs-number">1</span>可以从<span class="hljs-number">1</span>和<span class="hljs-number">2</span>中进行选择。如果他选择 <span class="hljs-number">2</span>（或者 <span class="hljs-number">1</span> ），那么玩家 <span class="hljs-number">2</span> 可以从 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）和 <span class="hljs-number">5</span> 中进行选择。如果玩家 <span class="hljs-number">2</span> 选择了 <span class="hljs-number">5</span> ，那么玩家 <span class="hljs-number">1</span> 则只剩下 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）可选。所以，玩家 <span class="hljs-number">1</span> 的最终分数为 <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>，而玩家 <span class="hljs-number">2</span> 为 <span class="hljs-number">5</span> 。因此，玩家 <span class="hljs-number">1</span> 永远不会成为赢家，返回 False 。</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">233</span>, <span class="hljs-number">7</span>]输出：True解释：玩家 <span class="hljs-number">1</span> 一开始选择 <span class="hljs-number">1</span> 。然后玩家 <span class="hljs-number">2</span> 必须从 <span class="hljs-number">5</span> 和 <span class="hljs-number">7</span> 中进行选择。无论玩家 <span class="hljs-number">2</span> 选择了哪个，玩家 <span class="hljs-number">1</span> 都可以选择 <span class="hljs-number">233</span> 。     最终，玩家 <span class="hljs-number">1</span>（<span class="hljs-number">234</span> 分）比玩家 <span class="hljs-number">2</span>（<span class="hljs-number">12</span> 分）获得更多的分数，所以返回 True，表示玩家 <span class="hljs-number">1</span> 可以成为赢家。</code></pre><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><hr><p>我们用$dp[l][r]$表示闭区间$[l,r]$内，自己「先手」能获得的分数最大值。那么函数<code>dfs(l,r)</code>返回<code>dp[l][r]</code>。并进行记录。</p><p><strong>记忆化搜索</strong> </p><p>$dp[l][r] = sum(l,r) - min(dp[l+1][r],dp[l][r-1])$</p><blockquote><p> 边界条件 $dp[l][l] = nums[l]$; 返回值：$dfs(nums,0,n-1)*2 &gt;= sum(nums,0,n-1)$</p></blockquote><p>时间复杂度：$O(2^n)$</p><p>空间复杂度: $O(n)$，递归的空间复杂度取决于使用了多少栈空间。</p><p><strong>动态规划</strong>    </p><p>$dp[l][r] = max(-dp[l+1][r] + nums[l],-dp[l][r-1]+nums[r])$</p><p>我们先在$nums[l],nums[r]$中进行选择，同时保证对手的$dp[l+1][r]或者dp[l][r-1]$最小。 </p><blockquote><p>边界条件 $dp[l][l] = nums[l]$, 返回值：$dp[0][n-1]&gt;=0$</p></blockquote><p>使用递归存在大量重复计算，时间复杂度很高，因而采用动态规划是更好的选择。<strong>注意</strong>：$i$的遍历要从$n$开始，即反过来。</p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度: $O(n)$，使用滚动数组优化。</p><p><strong>代码（DFS+记忆化搜索）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allsum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//对下标l-r进行求和</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r;i++) sum += nums[i];        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//记忆化搜索，返回l,r使得先手优势最大的值</span>        <span class="hljs-keyword">if</span>(dp[l][r]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[l][r];        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l==r) &#123;dp[l][r]=nums[l];<span class="hljs-keyword">return</span> nums[l];&#125;        dp[l][r] = allsum(nums,l,r) - min(dfs(nums,l+<span class="hljs-number">1</span>,r),dfs(nums,l,r<span class="hljs-number">-1</span>));        <span class="hljs-comment">// printf(&quot;dp[%d][%d]=%d\n&quot;,lr,dp[l][r]);</span>        <span class="hljs-keyword">return</span> dp[l][r];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>&gt;=allsum(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p><strong>代码（DFS+动态规划）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-comment">//表示[i,j]区间的最大值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) dp[i][i] = nums[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n;i &gt;= <span class="hljs-number">0</span>;i--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++)    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n &amp;&amp; j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)    &#123;        dp[i][j] = max(-dp[i+<span class="hljs-number">1</span>][j]+nums[i], -dp[i][j<span class="hljs-number">-1</span>]+nums[j]);        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;    </span>            &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><hr><h4 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a></h4><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到或超过 100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p><p>给定一个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和另一个整数 <code>desiredTotal</code>（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p><p>你可以假设 <code>maxChoosableInteger</code> 不会大于 20， <code>desiredTotal</code> 不会大于 300。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入：</span><span class="hljs-string">maxChoosableInteger</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">desiredTotal</span> <span class="hljs-string">=</span> <span class="hljs-number">11</span><span class="hljs-string">输出：</span><span class="hljs-literal">false</span><span class="hljs-string">解释：</span><span class="hljs-string">无论第一个玩家选择哪个整数，他都会失败。</span><span class="hljs-string">第一个玩家可以选择从</span> <span class="hljs-number">1</span> <span class="hljs-string">到</span> <span class="hljs-number">10</span> <span class="hljs-string">的整数。</span><span class="hljs-string">如果第一个玩家选择</span> <span class="hljs-number">1</span><span class="hljs-string">，那么第二个玩家只能选择从</span> <span class="hljs-number">2</span> <span class="hljs-string">到</span> <span class="hljs-number">10</span> <span class="hljs-string">的整数。</span><span class="hljs-string">第二个玩家可以通过选择整数</span> <span class="hljs-number">10</span><span class="hljs-string">（那么累积和为</span> <span class="hljs-number">11</span> <span class="hljs-string">&gt;=</span> <span class="hljs-string">desiredTotal），从而取得胜利.</span><span class="hljs-string">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span></code></pre><hr><blockquote><p>首先我们弄清稳赢的含义，也就是说在某一个回合，A走完一步后，B发现他无论下哪一步都会输，或者A发现自己无论下哪一步都会赢。这两者都表示A会赢。</p></blockquote><p>这道题目，是和博弈论相关的「先手」，很容易想到的做法是动态规划，但是因为回合数不确定，很难直接写出状态转移方程，这个时候我们可以，另辟蹊径，采用「<strong>记忆化搜索</strong>」，定义一个<code>helper</code>函数，参数分别为记忆化搜索范围<code>int maxChoosableIntegerx</code>，目标<code>int target</code>,状态转移方程组<code>boolean[] dp</code>, 还有状态<code>int state</code>，框架在两分钟内就可以搭好。</p><pre><code class="hljs cpp">state|(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>));<span class="hljs-comment">//表示对state第i位置1</span>state &amp; <span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>);<span class="hljs-comment">//判断state第i位是否为1</span></code></pre><p>我们思考状态压缩，因为最大整数不超过20，这就提示我们可以采用「<strong>状态压缩</strong>」。用$N$位二进制来表示状态，1表示选择，0表示未选，例如<code>1000_010</code>表示选择2和7。这里dp作用是<u>记忆状态</u>，如果在递归时，我们发现<code>dp[state]!=null</code>就可以直接返回<code>dp[state]</code>。</p><p><strong>算法</strong></p><p>我们实际考虑每个回合，先手能否稳赢，这里先手指各个回合。设<code>i</code>为选择的数，如果这个回合<code>target - i &lt;= 0</code>或者下一个回合 <code>helper(N, target - i, dp, state|cur) == false</code> 则表明先手获胜<code>dp[state] = true</code>并返回。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Boolean[] b;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canIWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxChoosableInteger, <span class="hljs-keyword">int</span> desiredTotal)</span> </span>&#123;        <span class="hljs-comment">//这个题属于经典零和博弈问题，要判断先手的玩家能否赢</span>        <span class="hljs-comment">//如果最大整数小于等于目标整数，那么先手玩家一定会赢</span>        <span class="hljs-comment">//记忆化搜索+状态压缩</span>        <span class="hljs-keyword">if</span>(maxChoosableInteger &gt;= desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>+maxChoosableInteger)*maxChoosableInteger &lt; <span class="hljs-number">2</span>*desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        b = <span class="hljs-keyword">new</span> Boolean[<span class="hljs-number">1</span> &lt;&lt; maxChoosableInteger];        <span class="hljs-keyword">return</span> helper(desiredTotal, <span class="hljs-number">0</span>, b , maxChoosableInteger);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> state, Boolean[] dp,<span class="hljs-keyword">int</span> N)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//dp[i]表示选择第i位后的状态</span>        <span class="hljs-keyword">if</span>(dp[state] != <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> dp[state];<span class="hljs-comment">//用类类型代替封装</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = N;i &gt;= <span class="hljs-number">1</span>;i--)        &#123;            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>&lt;&lt;(i-<span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) <span class="hljs-comment">//说明第i位还没用过</span>            &#123;                <span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>&lt;&lt;(i-<span class="hljs-number">1</span>);<span class="hljs-comment">//将第i位置1</span>                <span class="hljs-keyword">if</span>( target &lt;= i || (helper(target - i, state|cur, dp, N) == <span class="hljs-keyword">false</span>)) &#123;                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N!)$</p><p>空间复杂度：$ O(1&lt;&lt;m)$，$m$为最大可选择整数。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论之求解欧拉通路</title>
    <link href="/2020/08/27/2020-8-27-some_tricks/"/>
    <url>/2020/08/27/2020-8-27-some_tricks/</url>
    
    <content type="html"><![CDATA[<h1 id="图论：求解欧拉通路问题"><a href="#图论：求解欧拉通路问题" class="headerlink" title="图论：求解欧拉通路问题"></a>图论：求解欧拉通路问题</h1><ul><li>753.<a href="https://leetcode-cn.com/problems/cracking-the-safe/">破解保险箱</a>(Hard)</li><li>332.<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a>(Medium)</li></ul><p>这类问题在实际生活中经常出现，大致可以抽象为：</p><blockquote><p>给定一个 <em>n</em> 个点 <em>m</em> 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。</p></blockquote><p>这种「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系，下面给出定义：</p><ul><li><p>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</p></li><li><p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</p></li><li><p>具有欧拉回路的无向图称为欧拉图。</p></li></ul><p>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</p><hr><h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a></h3><p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p><p>说明:</p><p>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前<br>所有的机场都用三个大写字母表示（机场代码）。<br>假定所有机票至少存在一种合理的行程。<br>示例 1:</p><pre><code class="hljs prolog">输入: [[<span class="hljs-string">&quot;MUC&quot;</span>, <span class="hljs-string">&quot;LHR&quot;</span>], [<span class="hljs-string">&quot;JFK&quot;</span>, <span class="hljs-string">&quot;MUC&quot;</span>], [<span class="hljs-string">&quot;SFO&quot;</span>, <span class="hljs-string">&quot;SJC&quot;</span>], [<span class="hljs-string">&quot;LHR&quot;</span>, <span class="hljs-string">&quot;SFO&quot;</span>]]输出: [<span class="hljs-string">&quot;JFK&quot;</span>, <span class="hljs-string">&quot;MUC&quot;</span>, <span class="hljs-string">&quot;LHR&quot;</span>, <span class="hljs-string">&quot;SFO&quot;</span>, <span class="hljs-string">&quot;SJC&quot;</span>]</code></pre><p>示例 2:</p><pre><code class="hljs prolog">输入: [[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>],[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>],[<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>],[<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>],[<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]]输出: [<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]解释: 另一种有效的行程是 [<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]。但是它自然排序更大更靠后。</code></pre><hr><p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。</p><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><p>对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p><p>对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</p><p>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p><p>对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且</p><ul><li>恰有一个顶点的出度与入度差为 1；</li><li>恰有一个顶点的入度与出度差为 1；</li><li>所有其他顶点的入度和出度相同。</li></ul><p>让我们考虑下面的这张图：</p><p><img src="https://assets.leetcode-cn.com/solution-static/332/332_fig1.png" alt="Graph1" style="zoom:50%;" /></p><p>我们从起点 \text{JFK}JFK 出发，合法路径有两条：</p><script type="math/tex; mode=display">JFK→AAA→JFK→BBB→JFK\\JFK→BBB→JFK→AAA→JFK</script><p>既然要求字典序最小，那么我们每次应该贪心地选择当前节点所连的节点中字典序最小的那一个，并将其入栈。最后栈中就保存了我们遍历的顺序。</p><p>为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点，每次我们 $O(1) $地找到最小字典序的节点，并 $O(\log m)$ 地删除它。</p><p>然后我们考虑一种特殊情况：</p><p><img src="https://assets.leetcode-cn.com/solution-static/332/332_fig2.png" alt="Graph2"></p><p>当我们先访问 $AAA$时，我们无法回到 $JFK$，这样我们就无法访问剩余的边了。</p><p>也就是说，当我们贪心地选择字典序最小的节点前进时，我们可能先走入「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。</p><hr><h2 id="方法一：-Hierholzer-算法"><a href="#方法一：-Hierholzer-算法" class="headerlink" title="方法一：$Hierholzer$算法"></a>方法一：$Hierholzer$算法</h2><p>寻找欧拉路径的流程:</p><ol><li><p>从起点出发，进行深度优先搜索。</p></li><li><p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</p></li><li><p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p></li></ol><p>当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。</p><p>不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</p><p>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</p><p>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;,<span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-built_in">string</span>&gt;&gt;&gt; node;<span class="hljs-comment">//出发地，目的地</span>    <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> cur)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//先遍历完一个节点，再将节点入栈</span>        <span class="hljs-keyword">while</span>(node.count(cur)&amp;&amp;node[cur].size()&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">string</span> next = node[cur].top();            node[cur].pop();            dfs(next);        &#125;        res.emplace_back(cur);    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!tickets.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-comment">//问题可以变为：遍历一个图所有节点，返回自然排序最小的遍历方式</span>        <span class="hljs-comment">//这意味着我们必须找到所有的组合，并且逐个进行比较</span>        <span class="hljs-comment">//遍历方式，DFS</span>        n = tickets.size();        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:tickets ) node[t[<span class="hljs-number">0</span>]].emplace(t[<span class="hljs-number">1</span>]);                dfs(<span class="hljs-string">&quot;JFK&quot;</span>);        reverse(res.begin(),res.end());        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：$O(m \log m)$，其中 $m$ 是边的数量。对于每一条边我们需要 $O(\log m)$ 地删除它，最终的答案序列长度为 $m+1$，而与 $n$ 无关。</p></li><li><p><strong>空间复杂度</strong>：$O(m)$，其中 $m$ 是边的数量。我们需要存储每一条边</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>求解欧拉通路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买股票问题</title>
    <link href="/2020/08/26/2020-8-26-lotus/"/>
    <url>/2020/08/26/2020-8-26-lotus/</url>
    
    <content type="html"><![CDATA[<h1 id="股票系列问题"><a href="#股票系列问题" class="headerlink" title="股票系列问题"></a>股票系列问题</h1><ol><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>(Easy)（最多只能进行一次交易）</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a>(Easy) （你可以尽可能地完成更多的交易（多次买卖一支股票）。）</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a>(Hard) （你最多可以完成 <em>两笔</em> 交易。）</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a>(Hard) （设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。）</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">最佳买卖股票时机含冷冻期</a>(Medium) (卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天))</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a>(Medium) (你可以无限次地完成交易，但是你每笔交易都需要付手续费。)</p></li></ol><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a>(Medium) </p><p>一种常用的方法是将「买入」和「卖出」分开进行考虑：「买入」为负收益，而「卖出」为正收益。在初入股市时，你只有「买入」的权利，只能获得负收益。而当你「买入」之后，你就有了「卖出」的权利，可以获得正收益。显然，我们需要尽可能地降低负收益而提高正收益，因此我们的目标总是将收益值最大化。因此，我们可以使用动态规划的方法，维护在股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。<strong>这些题目共同点你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</strong></p><blockquote><p>此外也可以采用单调栈和DFA（有限自动状态机）进行求解！</p></blockquote><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><hr><h3 id="入门-买卖股票的最佳时机含手续费"><a href="#入门-买卖股票的最佳时机含手续费" class="headerlink" title="入门. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">入门. 买卖股票的最佳时机含手续费</a></h3><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: prices = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>], fee = <span class="hljs-number">2</span>输出: <span class="hljs-number">8</span>解释: 能够达到的最大利润:  在此处买入 prices[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>在此处卖出 prices[<span class="hljs-number">3</span>] = <span class="hljs-number">8</span>在此处买入 prices[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>在此处卖出 prices[<span class="hljs-number">5</span>] = <span class="hljs-number">9</span>总利润: ((<span class="hljs-number">8</span> - <span class="hljs-number">1</span>) - <span class="hljs-number">2</span>) + ((<span class="hljs-number">9</span> - <span class="hljs-number">4</span>) - <span class="hljs-number">2</span>) = <span class="hljs-number">8.</span></code></pre><p><strong>注意:</strong></p><ul><li><code>0 &lt; prices.length &lt;= 50000</code>.</li><li><code>0 &lt; prices[i] &lt; 50000</code>.</li><li><code>0 &lt;= fee &lt; 50000</code>.</li></ul><hr><p>我们将这道题作为入门，这道题要求时间复杂度为$O(N)$，否则无法AC。</p><p>这样的话我们只能定义常数状态来进行转移。</p><ul><li><p>当我们手头有没有卖出的股票，我们可以选择卖出，当然这样需要手续费。记录此时最大利润为cash</p></li><li><p>当我们手头没有股票，我们可以选择买入。记录此时最大利润为hold</p></li></ul><p>自然就有状态方程：</p><script type="math/tex; mode=display">cash = max(cash, hold + prices[i]-fee)\\hold = max(hold, cash - prices[i])</script><p>因为$hold[0]$是非法的，定义一个它无法取到的数，比如$-prices[0]$</p><hr><p>下面一题代表了多种状态的情况，这是股票问题最有趣的地方，很多状态！</p><h3 id="进阶-最佳买卖股票时机含冷冻期-Medium"><a href="#进阶-最佳买卖股票时机含冷冻期-Medium" class="headerlink" title="进阶.最佳买卖股票时机含冷冻期(Medium)"></a><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">进阶.最佳买卖股票时机含冷冻期</a>(Medium)</strong></h3><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</li></ul><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><hr><ol><li><strong>动态规划</strong></li></ol><p>由于题目规定不能同时进行多笔交易，那么我们便能通过动态规划进行求解：</p><p>我们用$f[i]$表示<strong>第$i$天结束后的「累计最大收益」</strong>，我们会有三种可能的状态：</p><ol><li>第$i$天，处于可以买入状态的最大收益， 记为$f[i][0]$</li><li>买入了一只股票，记为$f[i][1]$</li><li>卖出了一只股票，处于冷冻期，记为$f[i][2]$</li></ol><blockquote><p><strong>这里的「处于冷冻期」指的是在第 i天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</strong></p></blockquote><p>我们分别对三种状态进行分析</p><p><img src="\img\lotus.png" alt="image-20200827124158917"></p><p>状态转移方程为</p><script type="math/tex; mode=display">dp[i][0]=\max(dp[i-1][0],dp[i-1][2])\\dp[i][1]=\max(dp[i-1][0]-price[i-1],dp[i-1][1])\\dp[i][2]=dp[i-1][1]+price[i-1]</script><p>这里需要理解的是，在卖出一只股票后，一定处于冷冻状态，这时候最大利润一定是前一个卖出的状态加上卖出的价格。</p><blockquote><p>边界条件，千万要思考清楚，第二种状态初始值应该为INT_MIN。因为这种状态在逻辑上是不存在的！</p></blockquote><script type="math/tex; mode=display">\begin{array}{lcc}dp[0][0] = 0;\\dp[0][1] = INT\_MIN;\\dp[0][2] = 0;\end{array}</script><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!prices.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//要获得最大利润，利润=\sum（卖出价格-买入价格）</span>        <span class="hljs-keyword">int</span> n = prices.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>,INT_MIN))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = INT_MIN;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ;i++)        &#123;            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);            dp[i][<span class="hljs-number">2</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i<span class="hljs-number">-1</span>];                    <span class="hljs-comment">//printf(&quot;%d,%d,%d,%d\n&quot;,i,dp[i][0],dp[i][1],dp[i][2]);</span>        &#125;        <span class="hljs-keyword">return</span> max(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">2</span>]);    &#125;&#125;;</code></pre><p><strong>优化</strong></p><p>滚动数组【略】</p><hr><h3 id="实战-买卖股票的最佳时机-IV"><a href="#实战-买卖股票的最佳时机-IV" class="headerlink" title="实战.买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">实战.买卖股票的最佳时机 IV</a></h3><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：k = <span class="hljs-number">2</span>, prices = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">2</span>解释：在第 <span class="hljs-number">1</span> 天 (股票价格 = <span class="hljs-number">2</span>) 的时候买入，在第 <span class="hljs-number">2</span> 天 (股票价格 = <span class="hljs-number">4</span>) 的时候卖出，这笔交易所能获得利润 = <span class="hljs-number">4</span><span class="hljs-number">-2</span> = <span class="hljs-number">2</span> 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：k = <span class="hljs-number">2</span>, prices = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">7</span>解释：在第 <span class="hljs-number">2</span> 天 (股票价格 = <span class="hljs-number">2</span>) 的时候买入，在第 <span class="hljs-number">3</span> 天 (股票价格 = <span class="hljs-number">6</span>) 的时候卖出, 这笔交易所能获得利润 = <span class="hljs-number">6</span><span class="hljs-number">-2</span> = <span class="hljs-number">4</span> 。     随后，在第 <span class="hljs-number">5</span> 天 (股票价格 = <span class="hljs-number">0</span>) 的时候买入，在第 <span class="hljs-number">6</span> 天 (股票价格 = <span class="hljs-number">3</span>) 的时候卖出, 这笔交易所能获得利润 = <span class="hljs-number">3</span><span class="hljs-number">-0</span> = <span class="hljs-number">3</span> 。</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 109</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a>是 该题的特例，我们重点分析 一般情况。</p><hr><p>这一题我们先冷静分析，对于长度为N的$prices$，最大的交易次数为$[N/2]$。然后如果$k\ge N/2$，那么问题转化为无限次股票问题，直接按照<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">入门. 买卖股票的最佳时机含手续费</a>做法就可以了。</p><p>否则，我们可以把交易数$j$作为一个状态转移变量，那么</p><p>第j次交易流程应该是   持有→买入→保持→卖出，</p><ul><li><p>设$dp[j][0]$表示第$j+1$次交易完成后所能获得的最大利润(或者第$j$次交易开始时)。$dp[j][1]$表示第$j+1$次交易<strong>买入之后</strong>所能得到最大利润。</p></li><li><p>那么第j次交易卖出之前的最大利润要么是自己（保持），要么是上次卖出的。</p><script type="math/tex; mode=display">dp[j][0] = max(dp[j][0],dp[j-1][1] + prices[i])</script></li><li></li><li><p>我们观察到，第j次卖出之后最大利润要么是自己（保持），要么等于第j次买入之后，利用这个把整个交易链接起来，</p></li></ul><script type="math/tex; mode=display">dp[j-1][1] = max(dp[j-1][1], dp[j-1][0] - prices[i])</script><ul><li><p>这儿其实是逻辑问题，就是我们只有更新了$dp[j-1][1]$才能知道下一笔交易的初始最大利润，这里的最大利润是累积的。</p></li><li><p>初始条件：</p></li><li>$dp[i][0] = 0, dp[i][1] = -price[0],i\in (0,k]$</li></ul><p>每一笔交易之前的$dp[i][1]$都是无法取到的，所以设成一个不可能的值。</p><p>这一道题其实是有依赖的背包问题。</p><p>代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = prices.size();        <span class="hljs-comment">//由于k值极大，</span>        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>( k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(k &gt;= n/<span class="hljs-number">2</span> ) <span class="hljs-comment">//退化为无限次交易问题</span>        &#123;            <span class="hljs-keyword">int</span> cash = <span class="hljs-number">0</span>, hold = -prices[<span class="hljs-number">0</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            &#123;                cash = max(cash, hold + prices[i]);                hold = max(hold, cash - prices[i]);            &#125;            <span class="hljs-keyword">return</span> max(cash,hold);        &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(k+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)            dp[i][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;endl;</span>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k;j &gt; <span class="hljs-number">0</span>; j--)            &#123;<span class="hljs-comment">// 不能写成j = min(k,(n+1)/2) 有一些状态会影响后面合法的状态转移</span>                dp[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(dp[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);                dp[j][<span class="hljs-number">0</span>] = max(dp[j][<span class="hljs-number">0</span>], dp[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);                                <span class="hljs-comment">//对应交易加1</span>                <span class="hljs-comment">// printf(&quot;dp[%d][%d]=%d,dp[%d][%d]=%d\n&quot;,j-1,1,dp[j-1][1],j,0,dp[j][0]);</span>            &#125;        &#125;        <span class="hljs-comment">// cout&lt;&lt;endl;</span>        <span class="hljs-keyword">return</span> dp[k][<span class="hljs-number">0</span>];    &#125;&#125;;</code></pre><p>时间复杂度：</p><script type="math/tex; mode=display">\begin{cases}O(nk),\ k<n/2\\O(n), \ else\end{cases}</script><p>空间复杂度：</p><script type="math/tex; mode=display">\begin{cases}O(2*k),\ k<n/2\\O(1), \ else\end{cases}</script><p>这题还可以用dfs和记忆化搜索来做，有兴趣的读者可以尝试之。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode经典</tag>
      
      <tag>动态规划</tag>
      
      <tag>有限自动状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习III 线性模型</title>
    <link href="/2020/08/23/2020-08-23-ML3/"/>
    <url>/2020/08/23/2020-08-23-ML3/</url>
    
    <content type="html"><![CDATA[<h1 id="三、线性模型"><a href="#三、线性模型" class="headerlink" title="三、线性模型"></a>三、线性模型</h1><p>一元线性模型用向量表示为</p><script type="math/tex; mode=display">f(x)=w^Tx+b</script><p>其中$w$称为权重向量，$b$称为偏置。我们可以利用均方误差，来求得$w$与$b$.</p><script type="math/tex; mode=display">(w^*,b^*)=\arg \min\sum\limits_{i=1}^{m}(f(x_i)-y_i)^2</script><p>均方误差对应于几何中欧氏距离($Euclidean Distance$)。该方法被称为「<strong>最小二乘法</strong>」($least square method$)。</p><p>当然有更一般的形式“多元线性回归”。</p><script type="math/tex; mode=display">f(x_i)=\bf{w}^Tx_i+b</script><p>我们把数据集表示为矩阵$X$</p><script type="math/tex; mode=display">X= \left(\begin{array}{ccc}    x_1^T & 1\\x_2^T &1\\ \quad  ...    \\x_n^T &1    \end{array}\right)</script><p>则：</p><script type="math/tex; mode=display">\hat{\bf{w}}=\arg \min(\bf{y-X\hat{w}})^T(\bf{y-X\hat{w}})</script><p>令$E=(\bf{y-X\hat{w}})^T(\bf{y-X\hat{w}})$，对$w$求导得：</p><script type="math/tex; mode=display">\frac{\partial{E}}{\partial{\bf{w}}}=2\bf{X}^T(X\hat{w}-y)</script><p>当$X^TX$为满秩矩阵时，令$(6)$为$0$得:</p><script type="math/tex; mode=display">\hat{w}^*=\bf(X^TX)^{-1}X^Ty</script><p>然而现实任务中我们遇到的往往是非满秩矩阵，可以解出多个$\hat{w}$,选择哪一个解作为输出，由机器学习算法的归纳偏好决定，一般会引入正则化项($regularization$)。</p><p>为了更方便表示，我们引入“对数线性逻辑回归”：</p><script type="math/tex; mode=display">\ln y = w^Tx+b</script><p>这里的对数值其实是让线性回归模型的预测值与真实标记联系起来的作用。</p><p>一般地，我们考虑单调可微函数$g(.)$</p><script type="math/tex; mode=display">y = g^{-1}(w^Tx+b)</script><p>这里的$g(.)$我们称为联系函数。</p><p><strong>对数几率回归</strong></p><p><img src="\img\sigmoid.jpg" alt="img"></p><script type="math/tex; mode=display">y = \frac{1}{1+e^{-z}}</script><p>我们称之为Sigmoid函数。我们将其作为联系函数则：</p><script type="math/tex; mode=display">y= 1/(1+e\wedge (-w^Tx+b))</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念与公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一句能打败99.99999%的程序员的位操作代码</title>
    <link href="/2020/08/23/2020-8-23-bitoperation/"/>
    <url>/2020/08/23/2020-8-23-bitoperation/</url>
    
    <content type="html"><![CDATA[<h1 id="专题：位操作"><a href="#专题：位操作" class="headerlink" title="专题：位操作"></a>专题：位操作</h1><blockquote><p>位操作是一种很神奇的操作，真的很神奇————Tiancheng Lou</p></blockquote><p>位操作包括：</p><ul><li><p>¬ 取反（NOT）</p></li><li><p>∩ 按位或（OR）</p></li><li><p>⊕ 按位异或（XOR）</p></li><li><p>∪ 按位与（AND）</p></li><li><p><strong>移位</strong></p><ul><li><p>移位是一个二元运算符，用来将一个二进制数中的每一位全部都向一个方向移动指定位，溢出的部分将被舍弃，而空缺的部分填入一定的值。移位又分为</p><ul><li><p>算术移位：在位移运算符之前的数是<u><strong>有符号</strong></u>数，编译产生的汇编指令是算术位移，<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。</p></li><li><p>逻辑移位：在位移运算符（&gt;&gt;和&lt;&lt;）之前的数是<strong><u>无符号</u></strong>数，编译产生的汇编指令是逻辑位移，<code>&gt;&gt;&gt;</code>及<code>&lt;&lt;&lt;</code>。</p></li></ul></li></ul></li></ul><hr><p><strong>题目</strong></p><p>201 <a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/">数字范围按位与</a></p><p>461 <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></p><p>338 <a href="https://leetcode-cn.com/problems/counting-bits">比特位计数</a>（Medium）</p><ol><li><p>解数独</p></li><li><p><a href="https://leetcode-cn.com/problems/minimum-incompatibility/">最小不兼容性</a></p></li></ol><p>树状数组 的LowBit操作</p><p>….</p><hr><h2 id="Brian-kernighan算法"><a href="#Brian-kernighan算法" class="headerlink" title="Brian kernighan算法"></a><strong>Brian kernighan算法</strong></h2><p>我们使用长度为9的数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一个整数表示每个数字是否出现过。</p><p>具体地，数$b$ 的二进制表示的第$i$位（从低到高，最低位为第$0$位），当且仅当数字$i+1$已经出现过。例如当 b 的二进制表示为 $(011000100)_2$ 时，就表示数字 3，7，8 已经出现过。</p><p>位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：</p><ul><li><p>某个数中第$k$位为1，表示该位置不能填入数字$k+1$.我们先与上$(11111111)_2=(1FF)_{16}$消除高位的影响，然后对其取反，然后枚举。因为是需要9个bit状态，所以是左移九位。</p></li><li><p>我们可以使用按位异或运算$ \wedge$, 与 $1&lt;&lt;i$异或即可。</p></li><li><p>我们可以用 $b \&amp; (−b) $得到 b 二进制表示中最低位的 1，这是因为 $(−b)$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 如果和 $∼b$ 进行按位与运算，那么会得到 0，但是当 $\sim b$ 增加 1 之后，最低位的连续的 1 都变为 0，而最低位的 0 变为 1，对应到 $b$ 中即为最低位的 1，因此当 $b$ 和 $∼b+1$ 进行按位与运算时，只有最低位的 1 会被保留；</p></li><li><p>我们可以用$b$与最低位的1按位异或，就可以将其从$b$中去除，这样就可以枚举下一个1。同样的，我们可以用$b\&amp;(b-1)$达到同样的效果，这被称为<strong>Brian kernighan算法</strong>。</p><p>具体应用见$\lfloor$回溯算法$\rceil$    </p></li></ul><p>该算法的关键在于我们每次对$number$和$number-1$之间进行按位与操作后，$number$中最右边的1会变成0。</p><script type="math/tex; mode=display">n\&(n-1)</script><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log n)$。和位移方法类似，算法的时间复杂度取决于 $m$ 和 $n$ 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li><li>空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。</li></ul><hr><h2 id="内置二进制函数"><a href="#内置二进制函数" class="headerlink" title="内置二进制函数"></a>内置二进制函数</h2><p>大多数编程语言中，有现成的库函数（如STL）。如果这是一个项目中的问题，应该直接使用内置函数，而不是重复造轮子。</p><p>python</p><pre><code class="hljs python">bin(x ^ y).count(<span class="hljs-string">&#x27;1&#x27;</span>)</code></pre><p>C++</p><pre><code class="hljs C++">binset&lt;<span class="hljs-number">32</span>&gt;(x^y).count();</code></pre><p>当然还有更快的（在汇编层次上优化的）</p><ul><li><code>__builtin_popcount(x)</code>： x中1的位数。</li></ul><p>有时候我们想把二进制直接打印出来</p><p>在C++中可以用bitset</p><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*8&gt;(bit)&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//打印出来是32位</span></code></pre><ul><li><code>__builtin_ctz</code> 函数：用于求一个二进制数的最低位的 1 的右侧的 0 的个数。<br>示例： 求 <code>__builtin_ctz(8)</code>，由于 8 = (1000)  8=(1000) ，其最低位的 1 右侧的 0 的个数有 3 个，故为 3。</li></ul><p>Java</p><pre><code class="hljs java">Integer.bitCount(x ^ y);</code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><hr><h2 id="LowBit"><a href="#LowBit" class="headerlink" title="LowBit"></a>LowBit</h2><p>用于找到一个二进制数的最低位的 1，并把它 <strong>按照原来的位置</strong> 返回。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;</code></pre><p>那么如果是HighBit呢，</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_hight_bit</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> prev, curr;        prev = a;    curr = a;    <span class="hljs-keyword">while</span>(curr)    &#123;        prev = curr;        curr &amp;= prev - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> prev;&#125;</code></pre><hr><h2 id="Hamming距离"><a href="#Hamming距离" class="headerlink" title="Hamming距离"></a><strong>Hamming距离</strong></h2><h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461 汉明距离"></a>461 <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></h4><p>汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。</p><p>两个整数之间的汉明距离是对应位置上数字不同的位数。</p><p><img src="\img\hamming.png" alt="img"></p><p>根据以上定义，提出一种 XOR 的位运算，当且仅当输入位不同时输出为 1。</p><blockquote><p> 计算 x 和 y 之间的汉明距离，可以先计算 x XOR y，然后统计结果中等于 1 的位数。</p></blockquote><p>现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。</p><p><strong>布赖恩·克尼根算法</strong><br>思路</p><blockquote><p> 是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：10001000。</p></blockquote><p>上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。</p><p>这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p><blockquote><p> 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。</p></blockquote><p>基于以上思路，通过 2 次迭代就可以知道 10001000 中 1 的位数，而不需要 8 次。</p><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingDistance</span>(<span class="hljs-params">self, x, y</span>):</span>        xor = x ^ y        distance = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> xor:            distance += <span class="hljs-number">1</span>            <span class="hljs-comment"># remove the rightmost bit of &#x27;1&#x27;</span>​            xor = xor &amp; (xor - <span class="hljs-number">1</span>)​        <span class="hljs-keyword">return</span> distance</code></pre><p>注意：该算法发布在 1988 年 《C 语言编程第二版》的练习中（由 Brian W. Kernighan 和 Dennis M. Ritchie 编写），但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。顺便说一句，可以在上述书籍中找到更多位操作的技巧。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(1)$。与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。但是该方法需要的迭代操作更少。</p></li><li><p>空间复杂度：$O(1)$，与输入无关，使用恒定大小的空间。</p></li></ul><hr><h2 id="动态规划-最高有效位"><a href="#动态规划-最高有效位" class="headerlink" title="动态规划+最高有效位"></a><strong>动态规划</strong>+<strong>最高有效位</strong></h2><p>有一些位操作题目用动态规划解也十分方便和快速。</p><h4 id="338-比特位计数（Medium）"><a href="#338-比特位计数（Medium）" class="headerlink" title="338 比特位计数（Medium）"></a>338 <a href="https://leetcode-cn.com/problems/counting-bits">比特位计数</a>（Medium）</h4><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>假设有一个整数：</p><p>$x = (1001011101)_2 = (605)_{10}<br>    $</p><p>我们已经计算了从 $0$到 $x - 1$ 的全部结果。</p><p>我们知道，$x$与 我们计算过的一个数只有一位之差:</p><p>$x’ = (1011101)_2 = (93)_{10}$<br>它们只在最高有效位上不同。</p><p>让我们以二进制形式检查 $[0, 3]$ 的范围：</p><script type="math/tex; mode=display">0 = (00)\\1 = (01)\\2 = (10)\\3 = (11)</script><p>可以看出， 2 和 3 的二进制形式可以通过给 0 和 1 的二进制形式在前面加上 1 来得到。因此，它们的 pop_count 只相差 1。</p><p>类似的，我们可以使用 $[0, 3]$ 作为蓝本来得到 $[4, 7]$。</p><p>总之，对于pop count $P(x)$，我们有以下的状态转移函数：</p><script type="math/tex; mode=display">P(x + b) = P(x) + 1, b = 2^m > x</script><p>有了状态转移函数，我们可以利用动态规划从 0 开始生成所有结果。</p><p><strong>动态规划 + 最低有效位</strong></p><p>遵循上一方法的相同原则，我们还可以通过最低有效位来获得状态转移函数。</p><p>观察$x$ 和 $x’ = x / 2$的关系：</p><p>$x = (1001011101)_2 = (605)_{10}$</p><p>$x’ = (100101110)_2 = (302)_{10}$<br>可以发现 $x’$与 $x$ 只有一位不同，这是因为$x’$  可以看做 xx 移除最低有效位的结果。</p><p>这样，我们就有了下面的状态转移函数：</p><script type="math/tex; mode=display">P(x) = P(x >> 1) + (x \mod 2)</script><hr><h2 id="枚举二进制子集"><a href="#枚举二进制子集" class="headerlink" title="枚举二进制子集"></a>枚举二进制子集</h2><p>设我们有一个二进制<strong>掩码</strong>$mask$，我们想得到它子集，子集$sub$的定义为：$1\le sub\le mask$且$sub\&amp;mask!=0$的数的集合。一个很巧妙的方法是类比Brian算法</p><pre><code class="hljs gcode"><span class="hljs-keyword">sub</span> = mask<span class="hljs-keyword">while</span> <span class="hljs-keyword">sub</span>:<span class="hljs-keyword">sub</span> = <span class="hljs-comment">(sub-1)</span>&amp;mask</code></pre><p>让我们来看一道题</p><h4 id="1681-最小不兼容性（hard）"><a href="#1681-最小不兼容性（hard）" class="headerlink" title="1681. 最小不兼容性（hard）"></a><a href="https://leetcode-cn.com/problems/minimum-incompatibility/">1681. 最小不兼容性</a>（hard）</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你需要将这个数组划分到 <code>k</code> 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。</p><p>一个子集的 <strong>不兼容性</strong> 是该子集里面最大值和最小值的差。</p><p>请你返回将数组分成 <code>k</code> 个子集后，各子集 <strong>不兼容性</strong> 的 <strong>和</strong> 的 <strong>最小值</strong> ，如果无法分成分成 <code>k</code> 个子集，返回 <code>-1</code> 。</p><p>子集的定义是数组中一些数字的集合，对数字顺序没有要求。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>], k = <span class="hljs-number">2</span>输出：<span class="hljs-number">4</span>解释：最优的分配是 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 和 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 。不兼容性和为 (<span class="hljs-number">2</span><span class="hljs-number">-1</span>) + (<span class="hljs-number">4</span><span class="hljs-number">-1</span>) = <span class="hljs-number">4</span> 。注意到 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] 可以得到更小的和，但是第一个集合有 <span class="hljs-number">2</span> 个相同的元素，所以不可行。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">4</span>输出：<span class="hljs-number">6</span>解释：最优的子集分配为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]，[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]，[<span class="hljs-number">6</span>,<span class="hljs-number">8</span>] 和 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 。不兼容性和为 (<span class="hljs-number">2</span><span class="hljs-number">-1</span>) + (<span class="hljs-number">3</span><span class="hljs-number">-2</span>) + (<span class="hljs-number">8</span><span class="hljs-number">-6</span>) + (<span class="hljs-number">3</span><span class="hljs-number">-1</span>) = <span class="hljs-number">6</span> 。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">3</span>输出：<span class="hljs-number">-1</span>解释：没办法将这些数字分配到 <span class="hljs-number">3</span> 个子集且满足每个子集里没有相同数字。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li><li><code>nums.length</code> 能被 <code>k</code> 整除。</li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li></ul><hr><p>这一题最鲜明的特征就是——数组范围非常有限，最多16位，这就明示我们可能要使用位运算了，因为有很多状态，要结合dp。</p><p>一个直观的想法就是枚举子集，然后找到最小的那个解。所以要利用掩码mask，某一位为1表示 选择这个数，为0表示我们不选这个数。极端的两种情况是，我们什么都不选，那就是000…00（n个 0），或者全选111…111（n个1）.</p><p>我们就可以枚举$[1,1&lt;&lt;n)$的所有情况，然后我们考虑如何分割，按照题目要求，每个子集$sub$合理的条件为：</p><ul><li>包含$n/k$个1。</li><li>任意两个1对应nums中不同元素</li></ul><p>因而我们得到一个十分难以想到的状态转移方程：</p><script type="math/tex; mode=display">f[mask]=\min\limits_{isValid(sub)}(f[mask \oplus sub])+ value[sub])</script><p>其中，$\oplus$表示异或，$mask\oplus sub$表示除$sub$以外的所有其它子集，$value$是$sub$对应的不相容性。</p><p>对1的个数判断可以用<code>__builtin_popcount</code></p><p>代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumIncompatibility</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-keyword">int</span> m = n/k;<span class="hljs-comment">//每个子集的大小</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;n, <span class="hljs-number">-1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//0表示什么都不取，不兼容性为0</span>        <span class="hljs-comment">//mask 中 1表示选择 0表示不选择，sub是mask一个子集</span>        <span class="hljs-comment">// dp[mask] = min(dp[mask^sub]+value[sub]);</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">((<span class="hljs-number">1</span>&lt;&lt;n), <span class="hljs-number">-1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sub = <span class="hljs-number">1</span>; sub &lt; (<span class="hljs-number">1</span>&lt;&lt;n); sub ++)        <span class="hljs-keyword">if</span>(__builtin_popcount(sub) == m)        &#123;<span class="hljs-comment">//</span>            <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; freq;            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;            <span class="hljs-comment">//判断sub中任意两个1对应nums中元素不能相同</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            <span class="hljs-keyword">if</span>(sub&amp;(<span class="hljs-number">1</span>&lt;&lt;i))             &#123;                freq[nums[i]] ++;                 <span class="hljs-keyword">if</span>(freq[nums[i]] &gt; <span class="hljs-number">1</span>)                &#123;                    flag = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(flag)            &#123;                <span class="hljs-comment">//统计该子集的不兼容性</span>                <span class="hljs-keyword">int</span> min_ele = INT_MAX, max_ele = INT_MIN;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;k: freq)                &#123;                    min_ele = min(min_ele, k.first);                    max_ele = max(max_ele, k.first);                &#125;                value[sub] = (max_ele - min_ele);                <span class="hljs-comment">// cout&lt;&lt;bitset&lt;sizeof(int)*4&gt;(sub)&lt;&lt;&quot;,Value:&quot;&lt;&lt;(max_ele - min_ele)&lt;&lt;endl;</span>            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;mask &lt; (<span class="hljs-number">1</span>&lt;&lt;n);mask ++)        <span class="hljs-keyword">if</span>(__builtin_popcount(mask)%m == <span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sub = mask;sub; sub=(sub<span class="hljs-number">-1</span>)&amp;mask)            <span class="hljs-keyword">if</span>(value[sub]!=<span class="hljs-number">-1</span> &amp;&amp; dp[sub^mask] != <span class="hljs-number">-1</span>)            <span class="hljs-keyword">if</span>(dp[mask] == <span class="hljs-number">-1</span>)                dp[mask] = dp[mask^sub] + value[sub] ;            <span class="hljs-keyword">else</span>                 dp[mask] = min(dp[mask],dp[mask^sub]+value[sub]);        &#125;                <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre><p>直观来看，对于有 $i$ 个 1 的二进制数字，需要 $2^i$ 的时间复杂度。而有 $i$ 个 1 的二进制数字有 $C(n,i)$ 个，所以这段代 码的时间复杂度为 $\sum_{i=0}^{n} C(n,i)⋅2^i$。 根据二项式定理： <script type="math/tex">(1 + x)^n = \sum_{i = 0}^n C(n, i) x^i</script> 在本问题中 $x = 2$</p><p>时间复杂度是$O(3^n)$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅而巧妙的并查集</title>
    <link href="/2020/08/14/2020-8-14-what-is-UnionSet/"/>
    <url>/2020/08/14/2020-8-14-what-is-UnionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是并查集（UnionSet）"><a href="#什么是并查集（UnionSet）" class="headerlink" title="什么是并查集（UnionSet）"></a>什么是并查集（UnionSet）</h1><ol><li><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></p></li><li><p><a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿的数量</a></p></li><li><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">二维网格中探测环</a></p></li><li><p><a href="https://leetcode-cn.com/problems/evaluate-division/">除法求值</a>（带权值）            </p></li><li><p><a href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a>（无向图）</p></li><li><p><a href="https://leetcode-cn.com/problems/redundant-connection-ii">冗余连接II</a>(Hard)（有向图）</p></li><li><p><a href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a>(DFS,BFS,UnionSet均可以做,DFS,BFS更优)</p></li><li><p><del>句子相似性2(VIP)</del></p></li><li><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">等式方程可满足性</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">连通网络操作次数</a></p></li><li><p><a href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/">按公因数计算最大组件大小</a>（hard）</p></li><li><p><a href="https://leetcode-cn.com/problems/couples-holding-hands/">情侣牵手</a>（Hard）</p></li><li><a href="https://leetcode-cn.com/problems/accounts-merge/">账户合并</a></li></ol><blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/93647900">知乎传送门</a></p></blockquote><p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合之中</li></ul><p>在连通性问题中（如岛屿问题），并查集很有作用。<strong>核心思想</strong>是连通区域内所有点的根节点其实是同一个。将每个点映射为一个数字。先假设每个点的根节点就是它们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋给另一个点的根节点，这样两个点所在的连通区域又相互连通了。</p><p>好的我们一步一步来画板子（ddrdd）：</p><p>并查集的主要操作有：</p><ul><li><code>find(int m)</code> :查找$m$的根节点</li><li><code>isConnected(int m, int n)</code>：判断$m,n$两个点是否在同一个连通区域。</li><li><code>Union(int m, int n)</code>:合并$m,n$两个点所在的连通区域。</li></ul><p><strong>初始化</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> fa[MAXN];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n )</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;i++)        fa[i] = i;&#125;</code></pre><p><strong>查询</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(fa[x]==x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">return</span> find(fa[x]);&#125;</code></pre><p>一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><p><strong>合并</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;fa[find(i)] = find(j);&#125;</code></pre><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者.</p><p><strong>更新</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-keyword">if</span>(fa[i] != i) fa[i] = find(fa[i]);&#125;</code></pre><p>一般在对所有节点merge之后需要整体更新，避免漏掉连通分支。</p><hr><p>初级并查集效率较低，我们需要进行<strong>路径压缩</strong>。</p><p>我们添加元素可能会形成长链，想要从底部寻找根节点会越来越难。路径压缩是这样一种算法，每个元素到根节点的路径尽可能短。</p><p>我们可以在查找的过程中，<u>把沿途每个节点的父节点都设为根节点</u>。</p><p><strong>路径压缩后合并</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x==find(x)? x : (fa[x] = find(fa[x]));&#125;</code></pre><p>我们得到的并查集是这样的，很像一棵二叉树。</p><p><strong>按秩合并</strong></p><p>按路径压缩后的并查集结构仍是毕竟复杂的，比如现在我们有一棵较复杂的树，与一个单元素进行合并：</p><p><img src="/img/dsu_1.jpg" alt=""></p><p>那么是把7作为8的父节点好呢，还是8作为7父节点好呢：</p><p>当然是前者，因为后者会使树的深度加深。所以要<strong>把简单树往复杂树上合并。</strong></p><p>我们用于一个数组<code>rank[]</code>记录每个根节点对应树的深度。一开始，所有节点的秩设为1.合并时比较两个根节点，把秩小的往秩的根节点合并。</p><p><strong>初始化（按秩合并）</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)     &#123;        fa[i] = i;        rank[i] = <span class="hljs-number">1</span>;    &#125; &#125;</code></pre><p><strong>合并（按秩合并）</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = find(i),y = find(j);    <span class="hljs-keyword">if</span>(rank[x] &lt;= rank[y])         fa[x] = y;    <span class="hljs-keyword">else</span>         fa[y] = x;    <span class="hljs-keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)    &#123;<span class="hljs-comment">//如果秩相同，则新节点深度++</span>        rank[y]++;    &#125;   &#125;</code></pre><p>为什么根秩相同，深度要加1呢，如下图，我们有两个秩均为2 的树，现在要合并。</p><p><img src="/img/dsu_2.png" alt="img" style="zoom:67%;" /></p><p>我们把2的父节点设为5，这里深度加1，同样另一种合并方式也会使深度加1.</p><p><img src="\img\dsu_3.png" alt="img" style="zoom:67%;" /></p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；</p><p>2、代表元法：采用 parent 数组实现，以每个结点的根结点作为代表元；</p><p>3、并查集的优化有两种策略：</p><p>（1）<strong>路径压缩</strong>；</p><p>有「隔代压缩」与「完全压缩」。</p><ul><li>「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。</li><li>「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。</li></ul><p><img src="..\img\dsu_3.jpg" alt="image.png"></p><p>（2）按秩合并。</p><p>秩也有两种含义：</p><p>秩表示以当前结点为根结点的子树结点总数，即这里的「秩」表示 size 含义；<br>秩表示以当前结点为根结点的子树的高度，即这里的「秩」表示 rank 含义（更合理，因为查询时候的时间性能主要决定于树的高度）。<br>4、如果同时使用「路径压缩」与「按秩合并」，这里的「秩」就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的「参考」。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近 $O(1)$。</p><p><a href="https://www.zhihu.com/question/35090745">为什么并查集在路径压缩之后的时间复杂度是阿克曼函数?</a></p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1559-二维网格图中探测环"><a href="#1559-二维网格图中探测环" class="headerlink" title="1559. 二维网格图中探测环"></a><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">1559. 二维网格图中探测环</a></h4><p>给你一个二维字符网格数组 <code>grid</code> ，大小为 <code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 <strong>相同值</strong> 形成的环。</p><p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值</strong> 。</p><p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> 是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p><p>如果 <code>grid</code> 中有相同值形成的环，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="\img\5482e1.png" alt="img"></p><pre><code class="hljs smalltalk">输入：grid = [[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>]]输出：<span class="hljs-keyword">true</span>解释：如下图所示，有 <span class="hljs-number">2</span> 个用不同颜色标出来的环：</code></pre><p><img src="\img\5482e11.png" alt="img"> </p><hr><p>利用并查集的思想，相同的字母可以形成一个连通区域，从左上角开始，遇到相同字母则进行合并，合并时若发现$x$和$y$与$parent$相同，即形成环。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">250100</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> p[N];    <span class="hljs-keyword">int</span> cnt[N];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (p[x] != x) &#123;            x = find(p[x]);        &#125;        <span class="hljs-keyword">return</span> p[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;            cnt[find(b)] += cnt[find(a)];            p[find(a)] = find(b);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;            p[i] = i;            cnt[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsCycle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = grid.size();        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].size();        init();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>&lt; n &amp;&amp; grid[i][j] == grid[i + <span class="hljs-number">1</span>][j]) &#123;                    <span class="hljs-keyword">if</span> (find(i * m + j) == find((i + <span class="hljs-number">1</span>) * m + j)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        p[find(i * m + j)] = find((i + <span class="hljs-number">1</span>) * m + j);                    &#125;                &#125;                <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i][j] == grid[i][j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">if</span> (find(i * m + j) == find(i * m + j + <span class="hljs-number">1</span>)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        p[find(i * m + j)] = find(i * m + j + <span class="hljs-number">1</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h2 id="685-冗余连接II"><a href="#685-冗余连接II" class="headerlink" title="685. 冗余连接II"></a>685. 冗余连接II</h2><p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N-1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</p><p>树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：</p><ul><li><p>附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；</p></li><li><p>附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。</p></li></ul><blockquote><p><code>parent</code>用于保存上一个指向它的节点，仅此而已。</p></blockquote><p>在遍历图中的所有边之后，根据是否存在导致冲突的边和导致环路出现的边，得到附加的边。</p><ul><li><p>如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。</p></li><li><p>如果有导致冲突的边，记这条边为 $[u,v]$，则有两条边指向 v，另一条边为 $[\textit{parent}[v],v]$需要通过判断是否有导致环路的边决定哪条边是附加的边。</p></li><li><p>如果有导致环路的边，则附加的边不可能是 $[u,v]$（因为 $[u,v] $已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 $[\textit{parent}[v],v]$。</p></li><li><p>如果没有导致环路的边，则附加的边是后被访问到的指向 v 的边，因此附加的边是 $[u,v]$。</p></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;    <span class="hljs-keyword">int</span> conflict;<span class="hljs-comment">//记录具有多个父节点的边编号</span>    <span class="hljs-keyword">int</span> loop;<span class="hljs-comment">//记录生成环路的边编号</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            fa.emplace_back(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>( x == fa[x])        &#123;            <span class="hljs-keyword">return</span> x;        &#125;        fa[x] = find(fa[x]);        <span class="hljs-keyword">return</span> fa[x];    &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;        <span class="hljs-comment">//思路：并查集</span>        <span class="hljs-comment">//此题与全连接I的区别是，无向图变为有向图</span>        <span class="hljs-keyword">int</span> n = edges.size();        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//专门用于保存父节点，与并查集无关</span>        init(n+<span class="hljs-number">1</span>);        conflict = loop = <span class="hljs-number">-1</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;<span class="hljs-comment">//u -&gt; v</span>            <span class="hljs-keyword">int</span> u = edges[i][<span class="hljs-number">0</span>], v = edges[i][<span class="hljs-number">1</span>];             <span class="hljs-keyword">int</span> pu = find(u), pv = find(v);                        <span class="hljs-keyword">if</span>(pv!=v) <span class="hljs-comment">// 说明 e[1]已经有父节点，存在冲突</span>                conflict = i;            <span class="hljs-keyword">else</span>             &#123;                parent[v] = u;                <span class="hljs-keyword">if</span>(pv == pu)<span class="hljs-comment">//表示有环</span>                &#123;                    loop = i;                &#125;                <span class="hljs-keyword">else</span> fa[pv] = pu;                        &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conf:%d,loop:%d\n&quot;</span>,conflict,loop);        <span class="hljs-comment">//接下来需要判断哪个边导致了冗余</span>        <span class="hljs-keyword">if</span>(conflict&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//说明没有冲突，附加的边为环路最后出现的边</span>        &#123;            <span class="hljs-keyword">return</span> edges[loop];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若存在冲突，</span>        &#123;            <span class="hljs-keyword">if</span>(loop &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//没有环</span>            <span class="hljs-keyword">return</span> edges[conflict];            <span class="hljs-keyword">else</span> <span class="hljs-comment">//既有冲突也有环，则不可能是冲突的那一条边</span>            <span class="hljs-keyword">return</span> &#123;parent[edges[conflict][<span class="hljs-number">1</span>]],edges[conflict][<span class="hljs-number">1</span>]&#125;;        &#125;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;    &#125;&#125;;</code></pre><p>时间复杂度: $O(N \log N)$</p><p>空间复杂度：$O(N)$</p><hr><h2 id="952-按公因式计算最大组件的大小"><a href="#952-按公因式计算最大组件的大小" class="headerlink" title="952.按公因式计算最大组件的大小"></a>952.按公因式计算最大组件的大小</h2><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：</p><p>有 <code>A.length</code> 个节点，按从 <code>A[0]</code>到 <code>A[A.length - 1]</code> 标记；<br>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j]</code>之间才有一条边。<br>返回图中最大连通组件的大小。</p><p>示例 1：</p><p>输入：[4,6,15,35]<br>输出：4</p><p><img src="\img\ex1.png" alt="img" style="zoom:33%;" /></p><p>示例 2：</p><p>输入：[20,50,9,63]<br>输出：2</p><p><img src="\img\ex2.png" alt="img" style="zoom:33%;" /></p><p>示例 3：</p><p>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p><p><img src="\img\ex3.png" alt="img" style="zoom:33%;" /></p><p>提示：</p><p><code>1 &lt;= A.length &lt;= 200001 &lt;= A[i] &lt;= 100000</code></p><hr><p>按照并查集的思路求解</p><p>设$W = max(A[i]), R = \sqrt{W}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+A.length$个不同的质因数。质因数为本身的最多$A.length$个，非本身的质因数一定比$R$小，最多$R$个。</p><p>我们可以提取$A$中每个数的质因数，对每个质因数建立索引，然后利用并查集。</p><p><img src="\img\dsu_4.png" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;    <span class="hljs-keyword">int</span> res;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            fa.emplace_back(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//路径压缩</span>        <span class="hljs-keyword">while</span>(x != fa[x])        &#123;            fa[x] = fa[fa[x]];            x = fa[x];        &#125;        <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> x = find(i), y = find(j);        fa[x] = y;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestComponentSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = A.size();    <span class="hljs-comment">//这题是并查集的经典应用</span>    <span class="hljs-comment">//因为A的长度很大，不能采用双重循环遍历</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; factor[n];<span class="hljs-comment">//质因数索引</span>    <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a :A) maxVal = max(maxVal,a);    init(maxVal+<span class="hljs-number">1</span>);    res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:A)    &#123;        <span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)        <span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>)         &#123;            merge(a,i);            merge(a,a/i);        &#125;    &#125;    <span class="hljs-comment">//将A中的数映射为代表元,看那一些出现过</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(maxVal+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)    &#123;        cnt [find(A[i])]++;        res = max(res, cnt [find(A[i])]);    &#125;    <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p>时间复杂度：$O(N \sqrt{W})$，其中 $N$ 是 A 的长度，$W = \max(A[i])$。</p><p>空间复杂度： $O(M)$, 分别用了$fa$和$cnt$数组，$M$表示数组最大值。</p><hr><h2 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a>765. 情侣牵手</h2><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p><p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]输出: <span class="hljs-number">1</span>解释: 我们只需要交换row[<span class="hljs-number">1</span>]和row[<span class="hljs-number">2</span>]的位置即可。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]输出: <span class="hljs-number">0</span>解释: 无需交换座位，所有的情侣都已经可以手牵手了。</code></pre><p><strong>说明:</strong></p><ol><li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li><li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li></ol><hr><ol><li><strong>贪心解法</strong></li></ol><p>我们考虑每队情侣都由奇数编号和偶数编号组成，因为情侣数量有限，我们可以遍历所有情侣中编号为偶数的<code>1,2,4,6...2*N</code>， 对相应的奇数情侣交换，每交换一次则<code>res++</code>。具体地，如果偶数情侣位于偶数位置$i$，则奇数情侣位置一定是$i+1$, 否则，奇数情侣位置为$i-1$。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span>  Map&lt;Integer,Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="hljs-comment">//记录数字的位置</span>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> direct)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> temp, temp2;        temp = memo.get(i+<span class="hljs-number">1</span>);        memo.put(row[memo.get(i)+direct],temp);        memo.put(i+<span class="hljs-number">1</span>,memo.get(i)+direct);        temp2 = row[temp];        row[temp] = row[memo.get(i)+direct] ;        row[memo.get(i)+direct] = temp2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = row.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) memo.put(row[i],i);        <span class="hljs-comment">//我们只移动奇数，如果偶数位置是偶数，那么相邻奇数位置在右边，否则在左边</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i += <span class="hljs-number">2</span>)        &#123;            <span class="hljs-keyword">if</span>(memo.get(i) %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                swap(row,i,<span class="hljs-number">1</span>);                res ++;            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)-<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                swap(row,i,-<span class="hljs-number">1</span>);                res ++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><strong>时间复杂度</strong>:$O(N)$.</p><p>空间复杂度:$O(N)$,使用了一个长度为$N$哈希表。</p><ol><li><strong>并查集</strong></li></ol><p>我们重点放在并查集解法上。</p><p>我们设想一下加入有两对情侣互相坐错了位置，我们至多只需要换一次。<br>如果3对情侣相互坐错了位置，$A1+B2,B1+C2,C1+A2$。他们三个之间形成了一个连通图，我们只需要交换两次。<br>如果4对情侣相互坐错了位置，即这4对情侣不与其他情侣坐在一起，$A1+B2,B1+C2,C1+D2,D1+A2$.他们四个之间形成了一个连通图，他们只需要交换三次并且不用和其他情侣交换，就可以将这四对情侣交换好，<br>以此类推，其实就是假设k对情侣形成一个环状的错误链，我们<strong>最少</strong>需要交换k - 1次就可以将这k对情侣的位置排好。</p><blockquote><p>所以问题转化成$N$对情侣中，有几个这样的错误环。我们可以使用并查集来处理，每次遍历相邻的两个位置，如果他们本来就是情侣，他们处于大小为1的错误环中，只需要交换0次。如果不是情侣，说明他们两对处在同一个错误环中，我们将他们合并（union），将所有的错坐情侣合并和后，答案就是情侣对 - 环个数。<br>这也说明，最差的情况就是所有N对情侣都在一个环中，这时候我们需要$N - 1$调换。<br>最好情况每对情侣已经坐好了，已经有N个大小为1的环，这时候我们需要$N - N$次调换。</p></blockquote><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa,rank;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(x != fa[x]) fa[x] = getfa(fa[x]);        <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> fx = getfa(x),fy = getfa(y);        <span class="hljs-keyword">if</span>(fx != fy)        &#123;            <span class="hljs-keyword">if</span>(rank[fx] &lt; rank[fy])            &#123;                fa[fx] = fy;                rank[fy] += rank[fx];            &#125;<span class="hljs-keyword">else</span>            &#123;                fa[fy] = fx;                rank[fx] += rank[fy];            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; row)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = row.size(),m = n / <span class="hljs-number">2</span>,res = <span class="hljs-number">0</span>,circle = <span class="hljs-number">0</span>;        fa = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>),rank = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++) fa[i] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i += <span class="hljs-number">2</span>)            uni(row[i] / <span class="hljs-number">2</span>,row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>);<span class="hljs-comment">//本来是情侣的话，两者肯定相等，不会合并</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i ++)            <span class="hljs-keyword">if</span>(i == getfa(i))                circle ++;        <span class="hljs-keyword">return</span> m - circle;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习I 基本概念</title>
    <link href="/2020/08/04/2020-05-10-ML1/"/>
    <url>/2020/08/04/2020-05-10-ML1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学完算法，还想更深入一步，那么接触一下机器学习，是很有必要的，你需要知道当下为什么ML这么火，包括自动驾驶，人脸识别等都与之相关。有些甚至基本算法理论无法解释。</p><p>参考周志华《机器学习》</p></blockquote><p><strong>任务：</strong></p><p><strong>分类</strong>（classification）: 预测离散值。</p><p><strong>回归</strong>（regression）:预测连续值。</p><p>一般地，我们对训练集${(x_1,y_1),···,(x_m,y_m)}$进行学习，建立一个从输入空间$\chi$到输出空间$\Upsilon$的映射，对于二分类任务，通常$\Upsilon=\{-1,+1\}或\{0,1\}$；对于多分类任务，$|\Upsilon|&gt;2$,对于回归任务，$\Upsilon=\R,\R$为实数集。</p><p>学习完之后需要进行预测（testing）。</p><p>我们还可以进行<strong>聚类</strong>（clustering）操作，将训练集中数据分成若干组，每组称为一个<strong>簇</strong>（cluster），这些自动形成的簇可能对应一些潜在的概念划分。</p><p>根据训练数据是否有标记，学习任务可以大致分为两类：“<strong>监督学习</strong>”（supervised learning）和 “<strong>无监督学习</strong>”（unsupervised learning），分类和回归属于前者，而聚类属于后者。</p><p><strong>泛化</strong>（generalization），指模型适应新样本的能力。我们可以把学习过程看作是在<code>所有假设</code>（hypothesis）组成的空间中进行搜索的过程，搜索目标是找到与训练集“匹配”的假设。</p><p>书中介绍了NFL定理，即“天下没有免费午餐的定理”。不同的学习算法期望相同。</p><p>最后让我们一睹顶会的风采。</p><p>$ICML$：国际机器学习会议；</p><p>$NIPS$：国际神经信息处理系统会议；</p><p>$COLT$：国际学习理论会议；</p><p>$ECML$：欧洲机器学习会议；</p><p>$ACML$：亚洲机器学习会议；</p><p>然后是<em>顶级</em>期刊：</p><p>$JMLR$: Journal of Machine Learning Research;</p><p>$ML$: Machine Learning;</p><p>$IJCAI$:International Joint Conference on Artificial Intelligence</p><p>$AAAI$：（就是这么AI） Association for the Advance of Artificial Intelligence</p><p>$AI$，$JAIR$,$KDD$,$ICDM$,$CVPR$,以及IEEE一些期刊。</p><blockquote><p>如果能投给一篇，cs人生也算圆满了</p></blockquote><p>第二章：模型评估与选择。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念和公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习II 模型评估与选择</title>
    <link href="/2020/08/04/2020-08-4-ML2/"/>
    <url>/2020/08/04/2020-08-4-ML2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-经验误差与过拟合"><a href="#1-经验误差与过拟合" class="headerlink" title="1. 经验误差与过拟合"></a>1. 经验误差与过拟合</h2><p>学习在训练集上的误差称为“训练误差”，而在新样本上误差称为“泛化误差”。</p><p>实际上，我们通常得不到泛化性能很好的模型，原有有两种：</p><ul><li><strong>过拟合</strong>（overfitting）: 学习能力过于优秀，学到一些非一般的特性。</li><li><strong>欠拟合</strong>（underfitting）：对训练样本的一般性质尚未学好。</li></ul><p>机器学习面临的问题一般是$NP$难问题(<a href="https://blog.csdn.net/qq_21768483/article/details/80430590">什么是NP</a>)，因此只要相信$NP\ne P$那么过拟合将无法避免。</p><p>下面简单介绍从训练集得到测试集的方法：</p><ol><li><strong>留出法</strong>，按照比例从原始数据集分出训练和测试集；</li><li><strong>交叉验证</strong>（cross validation） ：先将数据集$D$划分为$k$个大小相似的互斥子集，即$D=D_1\cup D_2 \cup ···\cup D_j , D_i \cup D_j\ne \oslash$,每个子集$D_i$都尽可能保持数据分布的一致性，即从$D$中通过分层采样得到，然后每次用$k-1$给子集的并集作为训练集，余下的那个子集作为测试集；这样就可以得到$k$组训练/测试集。</li><li><strong>自助法</strong>（bootstrapping）减少训练集规模不同造成的误差。给定包含$m$个样本的数据集$D$，我们对它采样，产生数据集$D’$：每次随机从$D$中挑选一个样本，将其拷贝放入$D’$，然后再将该样本放回初始数据集$D$，这个过程重复$m$次后，我们得到大小为$m$的数据集$D’$，通过自助采样，约有$36.8\%$的样本未出现在采样数据集中，于是我能将$D’$用作训练集，而$D/D’$作为测试集，这适合数据小，难以划分的场景。</li></ol><h2 id="2-调参与最终模型"><a href="#2-调参与最终模型" class="headerlink" title="2. 调参与最终模型"></a>2. 调参与最终模型</h2><p>我们常把学得模型在实际使用中遇到的数据称为<strong>测试数据</strong>。</p><p>模型评估与选择中的数据集称为<strong>验证集</strong>。</p><ul><li><strong>性能度量</strong></li></ul><p>回归任务，最常使用的是均方误差（Mean Squared Error, MSE）.</p><pre><code>                                                             $ E(f;D)=\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;(f(x_i)-y_i)^2$</code></pre><ul><li><strong>错误率与精度</strong></li></ul><p>错误率是分类错误的样本数占样本总数的比例，精度$acc$则是正确的样本数占样本总数的比例。</p><blockquote><p>术语: FP:真正例 FN:假反例 FP:假正例 TN:真反例</p></blockquote><p>查准率$P=\frac{TP}{TP+FP}$，查全率：$R =\frac{TP}{TP+FN}$.</p><p>一般我们采用P-R图像来评价机器学习模型的优劣。若一个曲线包住另一个曲线，则证明前者性能好于后者。“平衡点”（BEP）就是查准率等于查全率的点。</p><p>更常用的是$F1$度量（调和平均）：$F1=\frac{2×P×R}{P+R}$，其原型是加权调和平均$F_\beta=\frac{(1+\beta^2)×P×R}{\beta^2×P+R}$,$\beta$度量了查全率对查准率的相对重要性。为了更好描述不同错误造成影响的大小，我们引入代价敏感 ，$cost_{01}$表示$TN$的代价,$cost_{10}$表示$FP$的代价。正例代价。</p><script type="math/tex; mode=display">P(+)=\frac{p×cost_{01}}{p×cost_{01}+(1-p)×cost_{10}}</script><p>泛化错误率为$\epsilon$,而测试错误率$\hat{\epsilon}$意味着在$m$给测试样本中恰有$\hat{\epsilon}×m$个错误数据。</p><ul><li><p><strong>比较检验</strong></p><ul><li>假设检验</li></ul><p>我们在实际任务中不知道学习器的泛化错误率，但是可以根据测试错误率推出泛化错误率的分布。泛化错误率为$\epsilon$，测试错误率$\hat{\epsilon}$，对于m个测试样本，根据概率论知识，我们知道 学习器测得测试错误率为$\hat{\epsilon}$的概率是</p><script type="math/tex; mode=display">P(\hat{\epsilon};\epsilon)=\binom{m}{\hat{\epsilon}×m}\epsilon^{\hat{\epsilon}×m}(1-\epsilon)^{\hat{\epsilon}(1-m)}</script><p>对$P$求导可知，在$\epsilon=\hat{\epsilon}$时最大，符合二项分布。</p><p><img src="\img\t_test.jpg" alt="n=6、p=0.5时的二项分布及正态近似"></p></li></ul><p>我们可使用“二项检验”($binomial  test$)来对 “$\epsilon\lt \epsilon_0$”进行检验，则在$1-\alpha$（置信度$confidence$）的概率内所能观测到的最大错误概率。若测试错误率$\hat{\epsilon}&lt;{\epsilon}$,即能以$1-\alpha$的置信度认为，学习器错误率不大于$\epsilon_0$</p><ul><li>t 检验</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念和公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抛砖引玉析回溯</title>
    <link href="/2020/08/02/2020-8-2-trackback-demo/"/>
    <url>/2020/08/02/2020-8-2-trackback-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析回溯法"><a href="#浅析回溯法" class="headerlink" title="浅析回溯法"></a>浅析回溯法</h1><blockquote><p>想必大家都玩过一些智力游戏，比如解数独，华容道，魔方，甚至围棋这些。 让我们用计算机去解决这些问题，并且使得时间尽可能短，一种可能的方法是<strong>回溯法</strong>，现在已经有用机器学习中的对抗学习(GAN)以及强化学习(RL)，著名的有AlphaGo以及OpenAI,后者甚至可以在最难的MOBA类游戏战胜人类。</p><p><strong>推荐阅读</strong>Liweiwei1419大佬的「<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级讲解</a>」</p><p>有四大类题目：</p><h3 id="题型一：排列、组合、子集相关问题"><a href="#题型一：排列、组合、子集相关问题" class="headerlink" title="题型一：排列、组合、子集相关问题"></a>题型一：排列、组合、子集相关问题</h3><h3 id="题型二：Flood-Fill"><a href="#题型二：Flood-Fill" class="headerlink" title="题型二：Flood Fill"></a>题型二：Flood Fill</h3><h3 id="题型三：字符串中的回溯问题"><a href="#题型三：字符串中的回溯问题" class="headerlink" title="题型三：字符串中的回溯问题"></a>题型三：字符串中的回溯问题</h3><h3 id="题型四：游戏问题"><a href="#题型四：游戏问题" class="headerlink" title="题型四：游戏问题"></a>题型四：游戏问题</h3></blockquote><ul><li><ol><li><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a></p></li><li><p><a href="https://leetcode-cn.com/problems/24-game/">24点游戏</a></p></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/n-queens/">N皇后</a></li></ol></li><li><ol><li><a href="">扫雷游戏</a></li></ol></li><li><ol><li><a href="">祖玛游戏</a></li></ol></li></ul><h2 id="679-24点游戏"><a href="#679-24点游戏" class="headerlink" title="679. 24点游戏"></a>679. 24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]输出: True解释: (<span class="hljs-number">8</span><span class="hljs-number">-4</span>) * (<span class="hljs-number">7</span><span class="hljs-number">-1</span>) = <span class="hljs-number">24</span></code></pre><p>示例 2:</p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<span class="hljs-string">输出:</span> <span class="hljs-literal">False</span></code></pre><p>注意:</p><p>`1. 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</p><ol><li>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</li></ol><hr><p>1<strong>.暴力法</strong></p><p>思路：因为此题规模不大，可以采用暴力法，我们先把4个数每一种排列考虑到，然后把每一种计算顺序考虑一下（最多三次运算），括号有两种情况，一个是<code>a*(b-(c/d))</code>，另一种是<code>(a+b)\*(c+d)</code>这里是举例子。最后是精度问题保证<code>|res-24.0|&lt;1e-5</code>即可。</p><p><strong>回溯法</strong></p><p>一共有四个数，三种操作。首先从四个数有序的选出两个数，有$4×3=12$种方法，并选择加减乘除不同的，用得到的结果取代选出的两个数字。</p><p>在剩下3个数有序选择2个数字，有6种方法，并选择四种运算符之一。</p><p>最后剩下2个数字，有两种不同的顺序，并选择4种运算操作之一。因此共有$12×4×6×4×2×4=9216$种选法。</p><p>实现时，有一些细节需要注意：</p><ul><li><p>除法运算为实数除法，因此结果为浮点数，列表中存储的数字也都是浮点数。在判断结果是否等于 2424 时应考虑精度误差，这道题中，误差小于 $10^{-6}$  可以认为是相等。</p></li><li><p>进行除法运算时，除数不能为 0，如果遇到除数为 0 的情况，则这种可能性可以直接排除。由于列表中存储的数字是浮点数，因此判断除数是否为 0 时应考虑精度误差，这道题中，当一个数字的绝对值小于 $10^{-6}$  时，可以认为该数字等于 0。</p></li></ul><p>还有一个可以优化的点。</p><p>加法和乘法都满足交换律，因此如果选择的运算操作是加法或乘法，则对于选出的 22 个数字不需要考虑不同的顺序，在遇到第二种顺序时可以不进行运算，直接跳过。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> TARGET = <span class="hljs-number">24</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">double</span> EPSILON = <span class="hljs-number">1e-6</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> ADD = <span class="hljs-number">0</span>, MULTIPLY = <span class="hljs-number">1</span>, SUBTRACT = <span class="hljs-number">2</span>, DIVIDE = <span class="hljs-number">3</span>;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgePoint24</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; l;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;num : nums) &#123;            l.emplace_back(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(num));<span class="hljs-comment">//转为double</span>        &#125;        <span class="hljs-keyword">return</span> solve(l);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; &amp;l)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l.size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (l.size() == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(l[<span class="hljs-number">0</span>] - TARGET) &lt; EPSILON;        &#125;        <span class="hljs-keyword">int</span> size = l.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;                <span class="hljs-keyword">if</span> (i != j) &#123;                    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; list2 = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;();                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; size; k++) &#123;                        <span class="hljs-keyword">if</span> (k != i &amp;&amp; k != j) &#123;                            list2.emplace_back(l[k]);                        &#125;                    &#125;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;                        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span> &amp;&amp; i &gt; j) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        <span class="hljs-keyword">if</span> (k == ADD) &#123;                            list2.emplace_back(l[i] + l[j]);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == MULTIPLY) &#123;                            list2.emplace_back(l[i] * l[j]);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == SUBTRACT) &#123;                            list2.emplace_back(l[i] - l[j]);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == DIVIDE) &#123;                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(l[j]) &lt; EPSILON) &#123;                                <span class="hljs-keyword">continue</span>;                            &#125;                            list2.emplace_back(l[i] / l[j]);                        &#125;                        <span class="hljs-keyword">if</span> (solve(list2)) &#123;                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                        &#125;                        list2.pop_back();                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$。一共有 $9216$ 种可能性，对于每种可能性，各项操作的时间复杂度都是 $O(1)$，因此总时间复杂度是 $O(1)$。</li><li>空间复杂度：$O(1)$。空间复杂度取决于递归调用层数与存储中间状态的列表，因为一共有 $4$ 个数，所以递归调用的层数最多为 $4$，存储中间状态的列表最多包含 $4$个元素，因此空间复杂度为常数。</li></ul><hr><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><p><code>数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</code></p><p>空白格用 ‘.’ 表示。</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>一个数独。</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p><p>答案被标成红色。</p><p>Note:</p><ol><li>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 9x9 形式的。</li></ol><hr><ol><li><strong>DFS+回溯</strong></li></ol><p>由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用$ \textit{line}[i]$，$\textit{column}[j]$，$\textit{block}[x][y]分别$表示第 $i$ 行，第 $j$ 列，第 $(x, y)$ 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。</p><blockquote><p>九宫格内坐标范围：$0\le x\le2,0 \le y \le 2$.具体的 第 $i$行第$j$列的数字，属于第$\lfloor \frac{i}{3},\frac{j}{3} \rfloor$个九宫格。$\lfloor$表示向下取整。</p></blockquote><p>我们首先对整个数独数组进行遍历，当我们遍历到第$i$行，第$j$个位置：</p><ul><li>如果该位置是一个空白格，那么我们将其加入一个用于存储空白格的列表中，方便后续进行递归。</li><li>如果该位置是一个数字，我们将$line$，$column$,$block$相应位置分别置为$True$。</li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">private</span> boolean[][] line = <span class="hljs-keyword">new</span> boolean [<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//行号和具体数字</span>    <span class="hljs-keyword">private</span> boolean[][] column = <span class="hljs-keyword">new</span> boolean [<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//列号和具体数字</span>    <span class="hljs-keyword">private</span> boolean[][] block = <span class="hljs-keyword">new</span> boolean [<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//第几个方块（3*x/3+y/3），具体数字</span>    <span class="hljs-keyword">private</span> boolean succ = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否成功填完</span>    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<span class="hljs-comment">//用于表示空格</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;        <span class="hljs-keyword">if</span>(pos == spaces.size())        &#123;            succ = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> x = spaces.get(pos)[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = spaces.get(pos)[<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;n &lt; <span class="hljs-number">9</span> ;  n++ )            <span class="hljs-keyword">if</span>(!line[x][n]&amp;&amp;!column[y][n]&amp;&amp;!block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>][n]) &#123;                board[x][y] = (<span class="hljs-keyword">char</span>)(n + <span class="hljs-string">&#x27;1&#x27;</span>);                line[x][n] = column[y][n] = block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>][n] = <span class="hljs-literal">true</span>;                backtrack(board, pos+<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(succ) <span class="hljs-keyword">return</span>;                line[x][n] = column[y][n] = block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>][n] = <span class="hljs-literal">false</span>;            &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">//遍历棋盘，如果遇到&#x27;.&#x27;则按照1-9填充，直到下一个数字无法被填充为止，进行回溯</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">9</span>;j++)                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)                &#123;                    line[i][(<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>)] = column[j][(<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>)]                            = block[i/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j/<span class="hljs-number">3</span>][(<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>)] = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">else</span>                  spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<span class="hljs-comment">//遇到&#x27;.&#x27;则将其坐标加入空格数组</span>        backtrack(board,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// public static void main(String args[])</span>    <span class="hljs-comment">// &#123;</span>    <span class="hljs-comment">//     char[][] board =&#123;&#123;&#x27;5&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;4&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;8&#x27;,&#x27;5&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;2&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;3&#x27;,&#x27;.&#x27;,&#x27;8&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;7&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;9&#x27;,&#x27;.&#x27;,&#x27;1&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;9&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;4&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;7&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;9&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;6&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;3&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;4&#x27;,&#x27;8&#x27;,&#x27;6&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;,</span>    <span class="hljs-comment">//                     &#123;&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;1&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;&#125;&#125;;</span>    <span class="hljs-comment">//     Solution s = new Solution();</span>    <span class="hljs-comment">//     s.solveSudoku(board);</span>    <span class="hljs-comment">// &#125;</span>&#125;</code></pre><p><strong>2. 位运算</strong></p><p>我们使用长度为9的数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一个整数表示每个数字是否出现过。</p><p>具体地，数$b$ 的二进制表示的第$i$位（从低到高，最低位为第$0$位），当且仅当数字$i+1$已经出现过。例如当 b 的二进制表示为 $(011000100)_2$ 时，就表示数字 3，7，8 已经出现过。</p><p>位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：</p><ul><li><p>对于第$i$行第$j$列的位置，$line[i]|column[j]|block[i/3*3+j/3]$中第$k$位为1，表示该位置不能填入数字$k+1$.我们先与上$(11111111)_2=(1FF)_{16}$消除高位的影响，然后对其取反，然后枚举。因为是需要9个bit状态，所以是左移九位。</p></li><li><p>我们可以使用按位异或运算$ \wedge$, 与 $1&lt;&lt;i$异或即可。</p></li><li><p>我们可以用 $b \&amp; (−b) $得到 b 二进制表示中最低位的 1，这是因为 $(−b)$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 如果和 $∼b$ 进行按位与运算，那么会得到 0，但是当 $\sim b$ 增加 1 之后，最低位的连续的 1 都变为 0，而最低位的 0 变为 1，对应到 $b$ 中即为最低位的 1，因此当 $b$ 和 $∼b+1$ 进行按位与运算时，只有最低位的 1 会被保留；</p></li><li><p>我们可以用$b$与最低位的1按位异或，就可以将其从$b$中去除，这样就可以枚举下一个1。同样的，我们可以用$b\&amp;(b-1)$达到同样的效果，这被称为<strong>Brian kernighan算法</strong>。</p><p>​    </p></li></ul><p><strong>代码</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] line = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<span class="hljs-comment">//存放二进制</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] column = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<span class="hljs-comment">//列号和具体数字</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] block = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<span class="hljs-comment">//第几个方块（3*x/3+y/3），具体数字</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> succ = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否成功填完</span>    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<span class="hljs-comment">//用于表示空格</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;        <span class="hljs-keyword">if</span>(pos == spaces.size())        &#123;            succ = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> x = spaces.get(pos)[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = spaces.get(pos)[<span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> mask = ~(line[x]|column[y]|block[x/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+y/<span class="hljs-number">3</span>])&amp;<span class="hljs-number">0x1ff</span>;        <span class="hljs-keyword">for</span>(;mask != <span class="hljs-number">0</span>; mask&amp;=(mask-<span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">//遍历每个1</span>            <span class="hljs-keyword">int</span> digit = mask&amp;(-mask);<span class="hljs-comment">//表示最低位的1</span>            <span class="hljs-keyword">int</span> shift = Integer.bitCount(digit-<span class="hljs-number">1</span>);<span class="hljs-comment">//比如 digit = 4 是2的2次方 (4-1).bitcount =  3, 3-1 = 2</span>            board[x][y] = (<span class="hljs-keyword">char</span>) (shift + <span class="hljs-string">&#x27;1&#x27;</span>);            flip(x, y, shift);<span class="hljs-comment">//翻转</span>            backtrack(board, pos + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (succ) <span class="hljs-keyword">return</span>;            flip(x, y, shift);<span class="hljs-comment">//翻转恢复</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;    <span class="hljs-comment">//遍历棋盘，如果遇到&#x27;.&#x27;则按照1-9填充，直到下一个数字无法被填充为止，进行回溯</span><span class="hljs-comment">//    List&lt;List&lt;Integer&gt;&gt; a = new ArrayList&lt;&gt;();</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">9</span>;j++)                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)                &#123;                    <span class="hljs-keyword">int</span> shift = (<span class="hljs-keyword">int</span>)(board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>);                    flip(i,j,shift);                &#125;                <span class="hljs-keyword">else</span>                  spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<span class="hljs-comment">//遇到&#x27;.&#x27;则将其坐标加入空格数组</span>        backtrack(board,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> shift)</span></span><span class="hljs-function">    </span>&#123;        line[i] ^= (<span class="hljs-number">1</span>&lt;&lt;shift);        column[j] ^= (<span class="hljs-number">1</span>&lt;&lt;shift);        block[i/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j/<span class="hljs-number">3</span>] ^= (<span class="hljs-number">1</span>&lt;&lt;shift);    &#125;&#125;</code></pre><hr><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><pre><code class="hljs awk">输入：<span class="hljs-number">4</span>输出：[ [<span class="hljs-string">&quot;.Q..&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">1</span>  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;..Q.&quot;</span>], [<span class="hljs-string">&quot;..Q.&quot;</span>,  <span class="hljs-regexp">//</span> 解法 <span class="hljs-number">2</span>  <span class="hljs-string">&quot;Q...&quot;</span>,  <span class="hljs-string">&quot;...Q&quot;</span>,  <span class="hljs-string">&quot;.Q..&quot;</span>]]解释: <span class="hljs-number">4</span> 皇后问题存在两个不同的解法。</code></pre><p>提示：</p><p>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</p><hr><p>学会使用编码，使访问指定元素的时间复杂度为$O(1)$</p><p><strong>方法一：基于集合的回溯</strong><br>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合$ columns、diagonals_1 $ 和 $\textit{diagonals}_2$ 分别记录每一列以及两个方向的每条斜线上是否有皇后。</p><p>列的表示法很直观，一共有 N 列，每一列的下标范围从 0 到 N-1，使用列的下标即可明确表示每一列。</p><p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/1.png" alt="fig1"></p><p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足行下标与列下标之差相等，例如 (0,0)和 (3,3)在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/2.png" alt="fig2"></p><p>方向二的斜线为从右上到左下方向，同一条斜线上的每个位置满足行下标与列下标之和相等，例如 (3,0) 和 (1,2) 在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条方向二的斜线。</p><p>每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; res;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; col_group, diag1, diag2;<span class="hljs-comment">//列，以及两条斜线，diag1表示(y-x)，而diag2表示(x+y)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(i==n) res.emplace_back(board);        <span class="hljs-comment">//将斜线上元素加入不可访问列表</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; n;y++)        <span class="hljs-keyword">if</span> (!col_group.count(y)&amp;&amp;!diag1.count(y-row)&amp;&amp;!diag2.count(row+y))        &#123;            board[row][y] = <span class="hljs-string">&#x27;Q&#x27;</span>;            col_group.insert(y);            diag1.insert(y-row);            diag2.insert(y+row);            backtrack(board,row+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>);            board[row][y] = <span class="hljs-string">&#x27;.&#x27;</span>;            col_group.erase(y);            diag1.erase(y-row);            diag2.erase(y+row);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">solveNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;       <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> &#123;&#123;<span class="hljs-string">&quot;Q&quot;</span>&#125;&#125;;       <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> &#123;&#125;;       <span class="hljs-keyword">this</span>-&gt;n = n;       <span class="hljs-comment">//基本思路，回溯法</span>       <span class="hljs-comment">//我们依次安排N个皇后的位置</span>       <span class="hljs-comment">//如果不满足题意则回溯</span>       <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">board</span><span class="hljs-params">(n,<span class="hljs-built_in">string</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;       backtrack(board,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);       <span class="hljs-keyword">return</span> res;     &#125;&#125;;</code></pre><hr><p>Bibliography</p><blockquote><ol><li><p><a href="https://deepmind.com/research/case-studies/alphago-the-story-so-far">https://deepmind.com/research/case-studies/alphago-the-story-so-far</a></p></li><li><p><a href="https://baike.baidu.com/item/阿尔法围棋/19319610?fromtitle=AlphaGo&amp;fromid=19315265&amp;fr=aladdin">AlphaGo百度百科</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空间极大问题通用策略</title>
    <link href="/2020/08/01/2020-8-1-common-way-solve-big-problem/"/>
    <url>/2020/08/01/2020-8-1-common-way-solve-big-problem/</url>
    
    <content type="html"><![CDATA[<h1 id="空间极大问题通用策略"><a href="#空间极大问题通用策略" class="headerlink" title="空间极大问题通用策略"></a>空间极大问题通用策略</h1><p>通常解在$2^n$的时间或者空间复杂度下，我们称为<strong>极大解空间</strong>。</p><p>而搜索空间通常按照组合数来算，达到$10^9$称为<strong>极大搜索空间</strong>。</p><p>解空间极大</p><ul><li><ol><li>子集</li></ol></li><li><ol><li>第k个排列</li></ol></li><li><ol><li>每个元音包含偶数次的最长子字符串</li></ol></li><li><ol><li>全排列</li></ol></li><li><ol><li>全排列2</li></ol></li><li><ol><li>子集2</li></ol></li><li><ol><li>递增子序列</li></ol></li><li><ol><li>删除无效括号</li></ol></li><li><ol><li>组合</li></ol></li><li><ol><li>组合总和II</li></ol></li><li>216.组合总和III</li></ul><p>搜索空间极大</p><ul><li><ol><li><a href="https://leetcode-cn.com/problems/maximize-grid-happiness/">最大网格幸福感 </a>(Hard)</li></ol></li></ul><blockquote><p>通常来说这类问题的解规模较大，很容易漏掉解，为此笔者提出一种解决问题的思路。</p></blockquote><p>比如全排列问题，组合问题等。让我们以78.<a href="https://leetcode-cn.com/problems/subsets/">子集</a>为例引入到情景中。</p><ul><li>全排列  $N!$</li><li>组合 $N!$</li><li>子集 $2^N$，每个元素可能存在或者不存在</li></ul><p>要确保结果<strong>完整</strong>且不<strong>重复</strong>，有多种策略：</p><ol><li><strong>递归</strong></li><li><strong>回溯</strong></li><li><strong>字典</strong></li><li><strong>数学</strong></li><li>**状态压缩</li></ol><h2 id="I-递归"><a href="#I-递归" class="headerlink" title="I. 递归"></a>I. 递归</h2><p>递归不一定是递归函数，而是逐层次的把nums下一个数与前面的数融合起来。</p><p>比如：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvcmVjdXJzaW9uLnBuZw?x-oss-process=image/format,png" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;    res.push_back(&#123;&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)    &#123;        <span class="hljs-keyword">auto</span> _res = res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;k :_res)        &#123;            k.push_back(c);            res.push_back(k);        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p><strong>剪枝及技巧</strong></p><p>很多时候dfs会经历不需要的中间状态，因此需要设计代码，避免不必要的递归。</p><p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p><p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p><p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p><h2 id="II-回溯"><a href="#II-回溯" class="headerlink" title="II. 回溯"></a>II. 回溯</h2><blockquote><p>注意：在大规模问题上，回溯法<strong>极容易</strong>超时。</p><p>正例：<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301.删除无效括号</a>(Hard)</p><p>反例：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>(Medium)(正确的解法是动态规划，而不是回溯)</p><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a href="https://baike.baidu.com/item/条件/1783021">条件</a>的某个<a href="https://baike.baidu.com/item/状态/33204">状态</a>的点称为“回溯点”。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvY29tYmluYXRpb25zLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>以该题为例，比如我们要在<code>[1,2,3]</code>中找到所有子集，思路是这样的：</p><p>定义一个回溯方法 backtrack(first, curr)，第一个参数为索引 first，第二个参数为当前子集 curr。</p><ul><li><p>如果当前子集构造完成，将它添加到输出集合中。</p></li><li><p>否则，从 first 到 n 遍历索引 i。</p><ul><li>将整数 nums[i] 添加到当前子集 curr。</li><li>继续向子集中添加整数：backtrack(i + 1, curr)。</li><li>从 curr 中删除 nums[i] 进行回溯。</li></ul></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvYmFja3RyYWNraW5nLnBuZw?x-oss-process=image/format,png" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;curr)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(first&gt;=n) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt; n; i++)        &#123;            curr.push_back(nums[i]);            res.push_back(curr);            backtrack(i+<span class="hljs-number">1</span>, curr);            curr.pop_back();        &#125;            &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//回溯法</span>                <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;        <span class="hljs-keyword">this</span>-&gt;n = nums.size();        <span class="hljs-keyword">this</span>-&gt;nums = nums;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; curr;                    backtrack(<span class="hljs-number">0</span>, curr);        res.push_back(&#123;&#125;);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><blockquote><p>注意，这里的第六行<code>for (int i = first; i &lt; n; i++)</code>非常关键，它保证各个子集是单调增的，避免了重复。</p></blockquote><p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p><p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p><p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p><h2 id="III-字典"><a href="#III-字典" class="headerlink" title="III. 字典"></a>III. 字典</h2><blockquote><p>该方法思路来自于Donald E. Knuth</p></blockquote><p>将每个子集映射到长度为n的掩码中，其中第i位掩码<code>nums[i]</code>为<code>1</code>，表示第i个元素在子集中， 如果第i位掩码<code>nums[i]</code>位<code>0</code>，表明第i位元素不在子集中。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvYml0bWFzazQucG5n?x-oss-process=image/format,png" alt="img"></p><p>乍看起来生成二进制数很简单，但如何处理左边填充 0 是一个问题。因为必须生成固定长度的位掩码：例如 <code>001</code>，而不是 <code>1</code>。因此可以使用一些位操作技巧：<br>$python$:<br><pre><code class="hljs python">nth_bit = <span class="hljs-number">1</span> &lt;&lt; n<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n):    <span class="hljs-comment"># generate bitmask, from 0..00 to 1..11</span>    bitmask = bin(i | nth_bit)[<span class="hljs-number">3</span>:]</code></pre><br>$C++$<br><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span>(<span class="hljs-params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span>        n = len(nums)        output = []                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n, <span class="hljs-number">2</span>**(n + <span class="hljs-number">1</span>)):            <span class="hljs-comment"># generate bitmask, from 0..00 to 1..11</span>            bitmask = bin(i)[<span class="hljs-number">3</span>:]                        <span class="hljs-comment"># append subset corresponding to that bitmask</span>            output.append([nums[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n) <span class="hljs-keyword">if</span> bitmask[j] == <span class="hljs-string">&#x27;1&#x27;</span>])                <span class="hljs-keyword">return</span> output</code></pre></p><p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p><p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p><p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p><hr><h2 id="IV-数学"><a href="#IV-数学" class="headerlink" title="IV. 数学"></a>IV. 数学</h2><blockquote><p>60.<a href="https://leetcode-cn.com/problems/permutation-sequence/">第k个排列</a></p></blockquote><p>这里我们将题目稍微变形一下。来讲解数学知识如何发挥巨大的作用的。</p><p>给你一个排列$s$，由数字<code>1-9</code>组成，在<strong>不求全排列</strong>的前提下，返回它是正序的第k个排列。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">213</span>输出: k = <span class="hljs-number">3</span>解释：<span class="hljs-number">123</span>全部的排列为 <span class="hljs-number">123</span>， <span class="hljs-number">132</span>， <span class="hljs-number">213</span>， <span class="hljs-number">231</span>， <span class="hljs-number">312</span>， <span class="hljs-number">321</span></code></pre><p>要想解决本题，首先需要了解一个简单的结论：</p><blockquote><p>对于 $n$ 个不同的元素（例如数 $1,2,⋯,n$），它们可以组成的排列总数目为 $n!$。</p></blockquote><p>对于给定的 $n$ 和 $k$，我们不妨从左往右确定第 $k$ 个排列中的每一个位置上的元素到底是什么。</p><p>我们首先确定排列中的首个元素 $a_1$ 。根据上述的结论，我们可以知道：</p><ul><li>以 1 为 $a_1$ 的排列一共有 $(n-1)!$ 个；<br>以 2 为 $a_1 $ 的排列一共有 $(n-1)!$ 个；<br>$\cdots⋯$<br>以 n 为 $a_1$ 的排列一共有 $(n-1)!$个。<br>由于我们需要求出从小到大的第 k 个排列，因此：</li></ul><p>如果 $k \leq (n-1)!$，我们就可以确定排列的首个元素为 1；<br>如果 $(n-1)! &lt; k \leq 2 \cdot (n-1)!$，我们就可以确定排列的首个元素为 2；<br>$\cdots⋯$<br>如果 $(n-1) \cdot (n-1)! &lt; k \leq n \cdot (n-1)!$，我们就可以确定排列的首个元素为 n。<br>因此，第 k 个排列的首个元素就是：</p><script type="math/tex; mode=display">a_1 = \lfloor \frac{k-1}{(n-1)!} \rfloor + 1</script><p>其中 $\lfloor x \rfloor$ 表示将 x 向下取整。</p><p>当我们确定了 $a_1$后，如何使用相似的思路，确定下一个元素 $a_2$呢？实际上，我们考虑以 $a_1$为首个元素的所有排列：</p><p>第 k 个排列实际上就对应着这其中的第</p><script type="math/tex; mode=display">k' = (k-1) \bmod (n-1)! + 1</script><p>个排列。这样一来，我们就把原问题转化成了一个完全相同但规模减少 1的子问题.</p><p><strong>代码</strong>：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">factorial</span><span class="hljs-params">(n)</span></span>;        factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;            factorial[i] = factorial[i - <span class="hljs-number">1</span>] * i;        &#125;        --k;        <span class="hljs-built_in">string</span> ans;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">valid</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;            <span class="hljs-keyword">int</span> order = k / factorial[n - i] + <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;                order -= valid[j];                <span class="hljs-keyword">if</span> (!order) &#123;                    ans += (j + <span class="hljs-string">&#x27;0&#x27;</span>);                    valid[j] = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            k %= factorial[n - i];        &#125;           <span class="hljs-keyword">return</span> ans;         &#125;&#125;;</code></pre><hr><h2 id="V-状态压缩"><a href="#V-状态压缩" class="headerlink" title="V. 状态压缩"></a>V. 状态压缩</h2><p>可以使用二进制或者,$bitset$进行状态压缩.</p><p>状态压缩经典问题：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. 每个元音包含偶数次的最长子字符串</a></p><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p><p>示例 1：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;eleetminicoworoep&quot;</span>输出：<span class="hljs-number">13</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetminicowor&quot;</span> ，它包含 e，i，o 各 <span class="hljs-number">2</span> 个，以及 <span class="hljs-number">0</span> 个 a，u 。</code></pre><p>示例 2：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;leetcodeisgreat&quot;</span>输出：<span class="hljs-number">5</span>解释：最长子字符串是 <span class="hljs-string">&quot;leetc&quot;</span> ，其中包含 <span class="hljs-number">2</span> 个 e 。</code></pre><p>示例 3：</p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;bcbcbc&quot;</span>输出：<span class="hljs-number">6</span>解释：这个示例中，字符串 <span class="hljs-string">&quot;bcbcbc&quot;</span> 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 <span class="hljs-number">0</span> 次。</code></pre><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li>s 只包含小写英文字母。</li></ul><p>定义$pre[i][k]$表示前$i$个字母，第$k$个元音字母总出现的次数。那么在$[i-1,j-1]$区间内，元音字母出现次数为$pre[j][k]-pre[i][k]$，在$O(1)$时间内得到第$k$个元音字母出现的次数。</p><p>同时我们要考虑避免枚举所有的$i$，计算以它结尾的满足条件的最长子字符串长度，我们要找到最小$i$使得$pre[j][k]-pre[i][k]$均为偶数。 我们需要利用【所有元音出现偶数次】这个条件，对于满足条件的子串而言，$pre[i][k]$和$pre[j][k]$的奇偶性一定相同，因为偶数一定是奇数+奇数，或者偶数+偶数组成。所以我们可以把$pre[i][k]$改为表示$[0,i-1]$的<strong>元音奇偶性</strong>。</p><p>此外我们还需要进行「状态压缩」：</p><pre><code class="hljs dts">&#123;<span class="hljs-symbol">  a:</span> cnta, <span class="hljs-comment">// a 出现次数的奇偶性</span><span class="hljs-symbol">  e:</span> cnte, <span class="hljs-comment">// e 出现次数的奇偶性</span><span class="hljs-symbol">  i:</span> cnti, <span class="hljs-comment">// i 出现次数的奇偶性</span><span class="hljs-symbol">  o:</span> cnto, <span class="hljs-comment">// o 出现次数的奇偶性</span><span class="hljs-symbol">  u:</span> cntu  <span class="hljs-comment">// u 出现次数的奇偶性</span>&#125;</code></pre><p>我们可以用二进制表示这些奇偶。</p><p>举一个例子，假如到第 $i $个位置，<code>u o i e a</code>出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 $(11001)_2=(25)_{10}$ 作为它的状态。</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = s.size(), res = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; vowel&#123;            &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>&#125;        &#125;;        <span class="hljs-comment">// 我们用pre[status]表示status状态对应的位置i，不断更新</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>,<span class="hljs-number">-1</span>)</span></span>;<span class="hljs-comment">//初始均为偶</span>        pre[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始状态，所有元音为偶数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)        &#123;            <span class="hljs-keyword">if</span>(vowel.count(s[i<span class="hljs-number">-1</span>]))            status ^= vowel[s[i<span class="hljs-number">-1</span>]];                        <span class="hljs-keyword">if</span>(~pre[status]) res = max(res,i - pre[status]); <span class="hljs-comment">//pre[status]!=-1</span>            <span class="hljs-keyword">else</span>             &#123;                pre[status] = i ;            &#125;                &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><blockquote><p>注意 18行的 ~pre[status]表示<strong>按位取反</strong>，包含了符号位，所以只有pre[status]不为-1，才为True。</p><p>$ \text{~} 0 = -1$， </p></blockquote><p>时间复杂度: $O(N)$. $N$为字符串长度。</p><p>空间复杂度: $O(1)$.</p><hr><blockquote><p> 一些子母问题（数字重复与不重复）</p></blockquote><ul><li>46 <a href="https://leetcode-cn.com/problems/permutations/">全排列</a></li></ul><p>数字不重复，求全排列，回溯法</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; output, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> len)</span></span>&#123;        <span class="hljs-comment">// 所有数都填完了</span>        <span class="hljs-keyword">if</span> (first == len) &#123;            res.emplace_back(output);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt; len; ++i) &#123;            <span class="hljs-comment">// 动态维护数组</span>            swap(output[i], output[first]);            <span class="hljs-comment">// 继续递归填下一个数</span>            backtrack(res, output, first + <span class="hljs-number">1</span>, len);            <span class="hljs-comment">// 撤销操作</span>            swap(output[i], output[first]);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;        backtrack(res, nums, <span class="hljs-number">0</span>, (<span class="hljs-keyword">int</span>)nums.size());        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><ul><li>47 <a href="https://leetcode-cn.com/problems/permutations-ii/">全排列2</a></li></ul><p>数字重复，求全排列【此时一定要用hash表】</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dict;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)        &#123;            res.push_back(arr);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:dict)        &#123;            <span class="hljs-keyword">if</span>(c.second&gt;<span class="hljs-number">0</span>)             &#123;                arr.push_back(c.first);                c.second--;                dfs(n<span class="hljs-number">-1</span>);                c.second++;                arr.pop_back();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permuteUnique</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;        <span class="hljs-keyword">this</span>-&gt;nums = nums;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)            dict[c]++;        dfs(nums.size());        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><ul><li><p>78 子集（上面作为例子讲了）</p></li><li><p>90 <a href="https://leetcode-cn.com/problems/subsets-ii/">子集2</a></p></li></ul><p>求包含重复元素的所有子集</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; data;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i == n) &#123;           res.push_back(tmp);           <span class="hljs-keyword">return</span> ;         &#125;        dfs(i + <span class="hljs-number">1</span>);        <span class="hljs-comment">//i是从n-1开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; data[i].second; j ++) &#123;            tmp.push_back(data[i].first);            dfs(i + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; data[i].second; j ++) tmp.pop_back();        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<span class="hljs-comment">//统计nums每个数字的个数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;            mp[x] ++;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : mp) &#123;            data.push_back(x);<span class="hljs-comment">//相当于把哈希表存到数组</span>        &#125;        n = data.size();        dfs(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;            &#125;&#125;;</code></pre><ul><li><ol><li><a href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列</a></li></ol></li></ul><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]输出: [[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">7</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]]</code></pre><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><hr><p><strong>方法1：二进制枚举+哈希</strong></p><p>我们用二进制0，1表示解选中或者不被选中。那么长度为$n$的序列，对应有$2^n$种可能，对于序列去重，我们可以采用串哈希算法，（Rabin-Karp算法），即对于一个序列${a_0,a_1,…,a_{n-1}}$，我们可以认为是一个$\max(a_i)+1$（记为b）进制的数。</p><script type="math/tex; mode=display">f(a)=\sum\limits_{i=0}^{n-1}b^i×a_i</script><p>在实际使用种，我们发现这个编码可能非常的大，我们可以把它模上一个大素数$P$，再映射到$int$范围。</p><script type="math/tex; mode=display">f(a)=\sum\limits_{i=0}^{n-1}b^i×a_i(mod \ P)</script><p>Rabin-karp编码</p><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MIN_VAL = <span class="hljs-number">-100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_VAL = <span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> mod)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//这里的base为数组的最大值, min_val 为数组可能最小值，题目给出,为了避免负数的情况</span><span class="hljs-comment">//这里的mod 是一个大素数</span><span class="hljs-comment">//时间复杂度 O(N) 慎用</span>    <span class="hljs-keyword">int</span> hashVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:temp)    &#123;        hashVal = <span class="hljs-number">1L</span>L*hashVal*base % mod + (c - MIN_VAL + <span class="hljs-number">1</span>);          hashVal %= mod;    &#125;    <span class="hljs-keyword">return</span> hashVal;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> hashValue = getHash(MAX_VAL, (<span class="hljs-keyword">int</span>)(<span class="hljs-number">1E9</span>)+<span class="hljs-number">7</span>);</code></pre><p>数组编码</p><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;    <span class="hljs-keyword">int</span> mask = i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)    &#123;        <span class="hljs-keyword">if</span>(j&amp;<span class="hljs-number">1</span>)         &#123;            ...        &#125;    mask &gt;&gt;= <span class="hljs-number">1</span>;&#125;&#125;</code></pre><p><strong>字符串编码</strong></p><p>在该方法中，我们将字符串看成一个 $\textit{base}$ 进制的数，它对应的十进制值就是哈希值。显然，两个字符串的哈希值相等，当且仅当这两个字符串本身相同。然而如果字符串本身很长，其对应的十进制值在大多数语言中无法使用内置的整数类型进行存储。因此，我们会将十进制值对一个大质数 $\textit{mod}$ 进行取模。此时：</p><ul><li><p>如果两个字符串的哈希值在取模后不相等，那么这两个字符串本身一定不相同；</p></li><li><p>如果两个字符串的哈希值在取模后相等，并不能代表这两个字符串本身一定相同。例如两个字符串的哈希值分别为 2 和 15，模数为 13，虽然 $2 \equiv 15 ~~ (\bmod~13)$，但它们不相同。</p></li></ul><p>一般来说，我们选取一个大于字符集大小（即字符串中可能出现的字符种类的数目）的质数作为 $base$，再选取一个在字符串长度平方级别左右的质数作为 $mod$，产生哈希碰撞的概率就会很低。</p><p><strong>复杂度分析</strong></p><p>假设序列的长度是 $n$。</p><ul><li>时间复杂度：$O(2^n \cdot n)$。这里枚举所有子序列的时间代价是 $O(2^n)$，每次检测序列是否合法和获取哈希值的时间代价都是 $O(n)$.</li><li>空间复杂度：$O(2^n)$。最坏情况下整个序列都是递增的，每个长度大于等于 2 的子序列都要加入答案，这里哈希表中要加入 $2^n$<br>  个元素，空间代价为 $O(2^n)$,用一个临时的数组来存当前答案，空间代价为 $O(n)$。</li></ul><p><strong>方法2：递归+剪枝</strong></p><p>这是一个递归枚举子序列的通用模板，即用一个临时数组 $\rm temp$ 来保存当前选出的子序列，使用 $\rm cur$ 来表示当前位置的下标，在 dfs(cur, nums) 开始之前，$[0, {\rm cur} - 1]$这个区间内的所有元素都已经被考虑过，而$ [{\rm cur}, n]$ 这个区间内的元素还未被考虑。在执行 dfs(cur, nums) 时，我们考虑 ${\rm cur}$ 这个位置选或者不选，如果选择当前元素，那么把当前元素加入到 $\rm temp$ 中，然后递归下一个位置，在递归结束后，应当把 $\rm temp$的最后一个元素删除进行回溯；如果不选当前的元素，直接递归下一个位置。</p><p>当然，如果我们简单地这样枚举，对于每一个子序列，我们还需要做一次 $O(n)$ 的合法性检查和哈希判重复，在执行整个程序的过程中，我们还需要使用一个空间代价 $O(2^n) $的哈希表来维护已经出现的子序列的哈希值。我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的都是合法的并且不重复：</p><p>使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的</p><p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p><ul><li><p>前者被选择，后者被选择</p></li><li><p>前者被选择，后者不被选择</p></li><li><p>前者不被选择，后者被选择</p></li><li><p>前者不被选择，后者不被选择</p><p>其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</p></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> last, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur == nums.size()) &#123;<span class="hljs-comment">//当前序号达到末尾才进行答案归纳</span>            <span class="hljs-keyword">if</span> (temp.size() &gt;= <span class="hljs-number">2</span>) &#123;                ans.push_back(temp);            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (nums[cur] &gt;= last) &#123;            temp.push_back(nums[cur]);            dfs(cur + <span class="hljs-number">1</span>, nums[cur], nums);            temp.pop_back();        &#125;        <span class="hljs-keyword">if</span> (nums[cur] != last) &#123;<span class="hljs-comment">//只有前后元素不相同才考虑不选</span>            dfs(cur + <span class="hljs-number">1</span>, last, nums);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">findSubsequences</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        dfs(<span class="hljs-number">0</span>, INT32_MIN, nums);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>空间极大问题</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 如何让Unordered_map支持pair作为键值</title>
    <link href="/2020/07/25/2020-07-25-how-Unordered_map-support-pair-as-key/"/>
    <url>/2020/07/25/2020-07-25-how-Unordered_map-support-pair-as-key/</url>
    
    <content type="html"><![CDATA[<blockquote><p>C++</p></blockquote><h1 id="如何让Unordered-map支持pair作为键值"><a href="#如何让Unordered-map支持pair作为键值" class="headerlink" title="如何让Unordered_map支持pair作为键值"></a>如何让Unordered_map支持pair作为键值</h1><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>&gt; </span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">pair_hash</span>//没这个<span class="hljs-title">pair</span> 就不能在<span class="hljs-title">unorder</span>——<span class="hljs-title">map</span>快乐的玩耍了</span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;T1, T2&gt;&amp; p)</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> hash&lt;T1&gt;()(p.first) ^ hash&lt;T2&gt;()( p.second);<span class="hljs-comment">//异或思想</span>    &#125;    <span class="hljs-comment">//如果遇到了&lt;3,5&gt;和&lt;5,3&gt;怎么办，皮神有想法，再把两个hash判断一遍</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;T1,T2&gt; &amp;lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;T1,T2&gt; &amp;rhs)</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> equal_to&lt;T1&gt;()(lhs.first,rhs.first) &amp;&amp; equal_to&lt;T2&gt;()(lhs.second,rhs.second);    &#125;&#125;;<span class="hljs-comment">//使用</span><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">double</span>,pair_hash&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,pair_hash&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; minDis;   minDis.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<span class="hljs-number">1.5</span>));</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>像python那样将任何对象变为dict的键值，C++把原有的hash函数删去了（处于性能考虑 )，所以要自己写。</p><p>然后用的话就根据需要，正常操作了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>嗯 Python中defaultdict有一点好处，就是可以直接用tuple作为键值，这样的话间接解决了list不能作为键值的问题，mark一下</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做一只可爱的小🐖背包 Cover「背包九讲」</title>
    <link href="/2020/07/25/2020-07-27-backpack-problem/"/>
    <url>/2020/07/25/2020-07-27-backpack-problem/</url>
    
    <content type="html"><![CDATA[<h1 id="做一只可爱的小🐖背包"><a href="#做一只可爱的小🐖背包" class="headerlink" title="做一只可爱的小🐖背包"></a>做一只可爱的小🐖背包</h1><blockquote><p>  推荐观看dd大牛：<a href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲的传送门</a>, <a href="https://www.bilibili.com/video/av33930433">「背包九讲」视频教程</a></p><p>  0-1 背包    </p><blockquote><p> 完全背包</p><blockquote><p>多重背包 I II III</p></blockquote><p>混合背包问题</p><blockquote><p>二维费用的背包问题</p></blockquote><p>分组背包问题</p><blockquote><p>背包问题求解方案数</p></blockquote><p>求背包问题的方案</p><blockquote><p>有依赖的背包问题</p></blockquote></blockquote></blockquote><h2 id="I-0-1背包问题"><a href="#I-0-1背包问题" class="headerlink" title="I. 0-1背包问题"></a>I. 0-1背包问题</h2><blockquote><p><u><strong>注意</strong>解空间极大问题有时可以转化0-1背包,从而避免TLE!</u></p></blockquote><p>题目：有一个容量为 V 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。</p><p>例子</p><pre><code class="hljs angelscript">背包最大容量：<span class="hljs-number">50</span>物品重量为：&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>&#125;物品价值为：&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;输出：<span class="hljs-number">8</span>解释：当选择物品重量为<span class="hljs-number">20</span>，<span class="hljs-number">30</span>或者<span class="hljs-number">10</span>，<span class="hljs-number">40</span>对应的价值最大。</code></pre><p>我们适当作一些约定：$dp[i][j]或dp[j]$表示最大价值，$i$为具体问题下物品编号或组编号，$j$为体积。$W_i$为价值数组，$V_i$为体积数组。</p><p>$N$表示物品数量，$C$表示背包容积，$Q$表示背包最大重量。</p><p>0-1 背包问题中，物品只有两种状态，装载或者不装载，因此被称为<strong>0-1背包</strong>。除此之外还有<strong>完全背包</strong>和<strong>多重背包</strong>。</p><ol><li><strong>找子问题</strong>，第一，包的当前容量比物品小，装不下，这时的最大价值和前<script type="math/tex">i-1</script>个物品的最大价值是一样的。我们令<script type="math/tex">dp[i][j]</script>表示前<script type="math/tex">i</script>个物品在背包容量为<script type="math/tex">j</script>所能达到的最大价值。第二，包的当前可用容量比物品大，这个时候要决定是否添加下一个物品，因为在体积相同的情况下，总价值不一定更大。</li><li>找到<strong>状态转移方程</strong>，我们用辅助函数$sumWeight(i)$表示当前物品的总重量。</li></ol><script type="math/tex; mode=display">dp[i][j]=\begin{cases}dp[i-1][j],\ sumWeight(i-1)+w[i-1]>j\\\max(dp[i-1][j-w[i-1]]+v[i-1], dp[i-1][j])，otherwise\end{cases}</script><ol><li><p>确定<strong>边界条件</strong>：</p><p><script type="math/tex">dp[0][j]=0</script>，不装物品时最大价值为0.，同理<script type="math/tex">dp[i][0]=0</script>，即背包容量为0时，最大价值也为0. </p></li></ol><p>时间复杂度：<script type="math/tex">O(V*N)</script>，状态数量为V*N, V为背包容量，N为物品数目，状态转移复杂度为<script type="math/tex">O(1)</script>。</p><p>空间复杂度：<script type="math/tex">O(V*N)</script>, 为dp数组大小。</p><blockquote><p>变式：要求完全装满背包。</p></blockquote><p>我们令<script type="math/tex">dp[0][j]=0</script>，不装物品时最大价值为0.，<script type="math/tex">dp[0][j]=-\infin</script>，这样的话，在<script type="math/tex">dp[n][V]</script>刚好大于0.</p><blockquote><p>优化：用一维数组表示</p></blockquote><p>因为dp的物品数量维度i，仅与前一项有关，因此可以优化。<u>为保证每个物品只能使用一次，我们倒序遍历所有的值，类似于贪心的思路，而反过来就变成了<strong>完全背包</strong>问题。想想为什么？</u></p><script type="math/tex; mode=display">dp[j] = \max(dp[j-w[i-1]]+v[i-1],dp[j])</script><p>注意后面的dp[j]其实是上一次的结果，这相当于滚动数组。优化后空间复杂度为<script type="math/tex">O(V)</script>。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">backpack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;val, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span>    <span class="hljs-keyword">int</span> N = val.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//dp[j]表示容量为j的最大价值</span>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V;i++) dp[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = V; j &gt;= weight[i<span class="hljs-number">-1</span>];j--)        dp[j] = max(dp[j],dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> dp[V];&#125;</code></pre><hr><h2 id="II-完全背包问题"><a href="#II-完全背包问题" class="headerlink" title="II. 完全背包问题"></a>II. 完全背包问题</h2><p>我们让每种物品数量可以无限<script type="math/tex">0-\infty</script>。</p><p>例子</p><pre><code class="hljs angelscript">背包最大容量：<span class="hljs-number">60</span>物品重量为：&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>&#125;物品价值为：&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;输出：<span class="hljs-number">10</span>解释：当选择物品重量为两个<span class="hljs-number">30</span>对应的价值最大。</code></pre><p>我们将上述优化算法由<strong>倒序遍历</strong>J变为<strong>正序遍历</strong>J即可实现。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">backpack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;val, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span>    <span class="hljs-keyword">int</span> N = val.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//dp[j]表示容量为j的最大价值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = weight[i<span class="hljs-number">-1</span>]; j &lt;= V;j++)    <span class="hljs-keyword">if</span>(dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]&gt;dp[j])    dp[j] = dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">return</span> dp[V];&#125;</code></pre><hr><h2 id="III-多重背包问题"><a href="#III-多重背包问题" class="headerlink" title="III. 多重背包问题"></a>III. 多重背包问题</h2><p>多重背包问题介于0-1背包和完全背包之间。</p><p>我们除了给出背包的最大容量，物品的体积V和价值W，还给出物品的最大数量S。</p><p><u>我们可以将多重背包问题转化为0-1背包，即将每种物品视为k种不同的物品</u>，这样的时间复杂度为<script type="math/tex">O(s×\sum k_i)</script>，由此可见，降低每件物品的数量可以大大降低其时间复杂度。我们运用一些tricky技巧，将原来数量为k的物品拆分为若干组，每组物品看成一件物品，其价值和重量为该组所有物品之和。每组物品包含原物品数目分别为: $1,2,4···k-2^c+1$，其中k为使得$k-2^c+1$大于0的最大整数$.得到新的时间复杂度为<script type="math/tex">O(s×\sum \log k_i)</script>。</p><p><strong>二进制优化</strong></p><pre><code class="hljs Cpp"><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//分别表示物品数量和背包容量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> w,v;<span class="hljs-comment">//用于分组</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">vector</span>&lt;object&gt; objects;    <span class="hljs-keyword">int</span> a,b,s,line = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;s)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s;k*=<span class="hljs-number">2</span>)        &#123;<span class="hljs-comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span>            s -= k;            objects.push_back(&#123;k*b,k*a&#125;);        &#125;        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) objects.push_back(&#123;s*b,s*a&#125;);        line ++;    &#125;    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;object:objects)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= object.v;k--)    &#123;        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span>    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>单调队列优化(Hard)</strong></p><p><code>0&lt;N≤10000&lt;N≤10000&lt;V≤200000&lt;V≤200000&lt;vi,wi,si≤20000</code></p><p>当数据范围变得极大，使用二进制将<code>TLE</code>，我们必须优化，这里有一种优化方式是单调队列优化。</p><p>因为我们需要的是$dp[j], dp[v+j], dp[2<em>v+j], dp[3</em>v+j], … , dp[k*v+j]$ 中的最大值，我们通过维护一个单调队列来维护这些数中最大值。</p><p>单调队列问题，最重要的两点<br>1）维护队列元素的个数，如果不能继续入队，弹出队头元素<br>2）维护队列的单调性，即：尾值$&gt;= dp[j + k<em>v] - k</em>w$</p><p>本题中，队列中元素的个数应该为 $s+1$ 个，即 $0 - s $个物品 $i$. 为了方便大家理解，我举例进行说明。</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">20010</span>;<span class="hljs-keyword">int</span> dp[N_MAX],pre[N_MAX],Q[N_MAX];<span class="hljs-comment">//分别表示物品数量和背包容量</span><span class="hljs-comment">//单调队列存的是体积，末尾存储最大价值。</span><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和背包容量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> v,w,s,l=<span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)    &#123;        <span class="hljs-built_in">memcpy</span>(pre,dp,<span class="hljs-keyword">sizeof</span> dp);<span class="hljs-comment">//copy dp-&gt;pre</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; v;j++)        &#123;<span class="hljs-comment">//j是余数，即C%k</span>            <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队列头部和尾部</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = j;k &lt;= C;k += v)            &#123;<span class="hljs-comment">// j+n*k==C</span>                <span class="hljs-keyword">if</span>(head&lt;=tail)                &#123;<span class="hljs-comment">//如果容量超过了S,则单调队列应该缩小 head++</span>                <span class="hljs-keyword">if</span>((k-s*v) &gt; Q[head]) head++;                <span class="hljs-comment">//如果k对应价值大于头部价值，那么不断，相当于把体积插入到使得队列单增的位置，tail--</span>                <span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;(pre[k] - (k - j)/v*w) &gt;= (pre[Q[tail]] - (Q[tail] - j)/v*w)) tail--;                dp[k] = max(dp[k],pre[Q[head]] + (k-Q[head])/v*w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>                &#125;                Q[++tail] =  k;            &#125;        &#125;    &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>说实话，笔者单调队列这里也不是很明白，需要再仔细讲究一下。</p><hr><h2 id="IV-混合背包"><a href="#IV-混合背包" class="headerlink" title="IV. 混合背包"></a>IV. 混合背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）；</li><li>第二类物品可以用无限次（完全背包）；</li><li>第三类物品最多只能用 $s_i$ 次（多重背包）；</li></ul><p>每种体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。</p><ul><li>$si=−1$ 表示第 $i$ 种物品只能用1次；</li><li>$si=0$ 表示第 $i$ 种物品可以用无限次；</li><li>$si&gt;0$ 表示第 $i$ 种物品可以使用 $si$ 次；</li></ul><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤100\\<br>0&lt;vi,wi≤100\\<br>−1≤si≤1000$</p><blockquote><hr></blockquote><p>我们直接分类讨论，状态转移直接分为<strong>无限个</strong>和<strong>非无限</strong>即可。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//分别表示物品数量和背包容量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> kind;    <span class="hljs-keyword">int</span> w,v;<span class="hljs-comment">//用于分组</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">vector</span>&lt;object&gt; objects;    <span class="hljs-keyword">int</span> v,w,s;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)    &#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-number">-1</span>) objects.push_back(&#123;<span class="hljs-number">-1</span>,w,v&#125;);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) objects.push_back(&#123;<span class="hljs-number">0</span>,w,v&#125;);        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s;k*=<span class="hljs-number">2</span>)        &#123;<span class="hljs-comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span>            s -= k;            objects.push_back(&#123;<span class="hljs-number">1</span>,k*w,k*v&#125;);        &#125;        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) objects.push_back(&#123;<span class="hljs-number">1</span>,s*w,s*v&#125;);    &#125;    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;object:objects)    <span class="hljs-keyword">if</span>(object.kind == <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = object.v;k &lt;= C;k++)    &#123;        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>    &#125;    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= object.v;k--)    &#123;        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="V-二维费用的背包问题"><a href="#V-二维费用的背包问题" class="headerlink" title="V. 二维费用的背包问题"></a>V. 二维费用的背包问题</h2><p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p><p>每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N≤1000\\<br>0&lt;V,M≤100\\0&lt;v_i,m_i≤100\\<br>0&lt;w_i≤1000$</p><p>其实非常容易进行扩展，将数组维度扩大，再加一层循环即可。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,Q;<span class="hljs-comment">//分别表示物品数量，背包体积容量，背包最大重量</span><span class="hljs-keyword">int</span> V[<span class="hljs-number">1001</span>],W[<span class="hljs-number">1001</span>],M[<span class="hljs-number">1001</span>];<span class="hljs-comment">//体积，价值和重量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> v,w,m,line = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C&gt;&gt;Q;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;m&gt;&gt;w)    &#123;        V[line] = v;        M[line] = m;        W[line] = w;                line ++;    &#125;    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>][Q+<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= V[i<span class="hljs-number">-1</span>];k--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = Q;j &gt;= M[i<span class="hljs-number">-1</span>];j--)    &#123;        dp[k][j] = max(dp[k][j],dp[k - V[i<span class="hljs-number">-1</span>]][j - M[i<span class="hljs-number">-1</span>]] + W[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k][j]);</span>    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C][Q];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="VI-分组背包问题"><a href="#VI-分组背包问题" class="headerlink" title="VI. 分组背包问题"></a>VI. 分组背包问题</h2><p>有 N 组物品和一个容量是 V 的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有 $N$ 组数据：</p><ul><li>每组数据第一行有一个整数 $S_i$，表示第 $i $个物品组的物品数量；</li><li>每组数据接下来有 $Si$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；</li></ul><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤100\\<br>0&lt;Si≤100\\<br>0&lt;vij,wij≤100$</p><blockquote><hr></blockquote><p>我们只需要对每组每一个物品进行讨论。求每组的dp是并列的关系，注意循环之间位置关系。枚举体积的循环在外面，而枚举组内物品循环在里面。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,v,w;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;        <span class="hljs-comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//每组物品的数量</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)    &#123;    <span class="hljs-built_in">cin</span>&gt;&gt; num;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; num; j++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;V[j]&gt;&gt;W[j];    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= <span class="hljs-number">0</span>;k--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;s &lt; num; s++)    <span class="hljs-keyword">if</span>(k &gt;= V[s])    &#123;        dp[k] = max(dp[k],dp[k - V[s]] + W[s]);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span>    &#125;            &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="VII-有依赖的背包问题（hard）-树形dp"><a href="#VII-有依赖的背包问题（hard）-树形dp" class="headerlink" title="VII. 有依赖的背包问题（hard）[树形dp]"></a>VII. 有依赖的背包问题（hard）[树形dp]</h2><p>有 $N$ 个物品和一个容量是 $V$ 的背包。</p><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><p>如下图所示：<br><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt="QQ图片20181018170337.png"></p><p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p><p>每件物品的编号是 $i$，体积是 $vi$，价值是 $wi$，依赖的父节点编号是 $pi$。物品的下标范围是 $1…N$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。</p><p>接下来有 $N$ 行数据，每行数据表示一个物品。<br>第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>如果 $p_i=−1$，表示根节点。 <strong>数据保证所有物品构成一棵树。</strong></p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N,V≤100\\1≤v_i,w_i≤100$</p><p>父节点编号范围：</p><ul><li>内部结点：$1≤p_i≤N$;</li><li>根节点 $pi=−1$;</li></ul><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">7</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="hljs angelscript"><span class="hljs-number">11</span></code></pre><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><pre><code class="hljs angelscript">我们选择根节点,价值为&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;，编号为<span class="hljs-number">1</span>的叶节点，我们选择&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;或&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;。编号为<span class="hljs-number">2</span>的叶节点，我们选择&#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>&#125;或&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;。 最大容积<span class="hljs-number">7</span>， 我们选择&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;和&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;,这样总体积就是<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span> = <span class="hljs-number">7.</span> 总价值为 <span class="hljs-number">2</span>+<span class="hljs-number">6</span>+<span class="hljs-number">3</span>=<span class="hljs-number">11.</span></code></pre><blockquote><hr></blockquote><p>这道题其实是分组背包和<u>树形dp</u>的结合。先考虑节点的数据表示我们用<code>vector&lt;int&gt; g[N_MAX]</code>表示二叉树。$dp[i][j]$表示，<strong>我们选择节点$i$为根节点，并且体积为$j$的最大价值。</strong></p><p>既然是树，我们就需要深度优先搜索（DFS）。由于子节点依赖于根节点，那么根节点必定占据一定空间，且初始价值应该等于根节点。</p><blockquote><p>初始条件：$ dp[root][j] = W_{root}, V_{root} \le j \le C$ , $C$表示背包容积。</p></blockquote><p>按照0-1背包思路，我们在$k \in[V_{root},C]$区间内逆向遍历，那么子节点的可用空间为$m \in [0,k-V_{root}]$. 可以类比分组背包的$k\in[0,C],s \in [0,num],where  k &gt; V_s$, $num$为组号。之后我们将每个子节点分别进行搜索，对$dp[root][k]$进行更新。</p><script type="math/tex; mode=display">dp[root][k] = \max(dp[root][k],dp[root][k-m]+dp[son][m])</script><blockquote><p>返回值：$dp[root][C]$</p></blockquote><p>弄清楚这一层写代码就不难了。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,p;<span class="hljs-comment">//物品数量，背包容积，父节点</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX][N_MAX];<span class="hljs-comment">//体积数组，价值数组，dp[i][j]选择第i个节点为根节点在体积为j对应最大价值</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[N_MAX];<span class="hljs-comment">//保存子节点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//cap表示容量，no表示节点编号</span>    <span class="hljs-comment">//root必选，所以我们初始化dp[root][V[root]~C] 为 W[root]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = V[root];j &lt;= C;i++) dp[root][j] = W[root];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;son:g[root])     &#123;        dfs(son);<span class="hljs-comment">//遍历子节点</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C; k &gt;= V[root]; k--)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt;= (k-V[root]);m++)<span class="hljs-comment">//分配给子树的空间不能大于C-V[son]</span>        &#123;            dp[root][k] = max(dp[root][k], dp[root][k-m] + dp[son][m]);<span class="hljs-comment">//根据不同的子节点更新父节点的值</span>            <span class="hljs-comment">// if(dp[root][k]) printf(&quot;rt:%d,sn:%d,dp[%d]:%d\n&quot;,root,son,k,dp[root][k]);</span>                    &#125;    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span>    <span class="hljs-keyword">int</span> root;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;p;        <span class="hljs-keyword">if</span>(~p) g[p].emplace_back(i);        <span class="hljs-keyword">else</span> root = i;    &#125;    dfs(root);    <span class="hljs-built_in">cout</span>&lt;&lt;dp[root][C];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="VIII-背包求解方案数"><a href="#VIII-背包求解方案数" class="headerlink" title="VIII.背包求解方案数"></a>VIII.背包求解方案数</h2><p>有 $N$件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$, 用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <strong>方案数</strong> 模 $10^9+7$ 的结果。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\\<br>0&lt;v_i,w_i≤1000$</p><blockquote><p>我们除了需要对价值$dp[j]$进行状态转移（同0-1背包），还需要对方案数进行转移，设$M[j]$表示物品总体积为$j$对应的方案数。</p><p>那么有：</p><script type="math/tex; mode=display">M[j] = \begin{cases}        M[j], M[j]>M[j-v_i]\\        M[j-v_i], M[j]<M[j-v_i]\\        M[j]+M[j-v_i], M[j]=M[j-v_i]\\        \end{cases}.</script><p>初始条件： $M[0] = 1$， 背包为空只有一种方案。</p></blockquote><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">1010</span>, MOD = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和容积</span><span class="hljs-keyword">int</span> dp[N_MAX],M[N_MAX];<span class="hljs-comment">//方案数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> v,w,line = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= C;i++) dp[i] = INT_MIN;    M[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//价值为0的方案为1，即全不放</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= v;k--)        &#123;               <span class="hljs-keyword">int</span> t  = max(dp[k],dp[k - v] + w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品，注意它们价值可能相同</span>            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<span class="hljs-comment">// 不是M[k]，否则三种方案叠加</span>            <span class="hljs-keyword">if</span>(t == dp[k-v]+w) s += M[k-v];            <span class="hljs-keyword">if</span>(t == dp[k]) s += M[k];<span class="hljs-comment">//这里不能写成else if ，两种路径分开考虑，求的是总方案数</span>            dp[k] = t;            M[k] =s%MOD;            <span class="hljs-comment">// printf(&quot;i:%d,k:%d,dp:%d,M:%d\n&quot;,i,k,dp[k],M[k]);</span>                    &#125;    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, maxw = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= C;j++)    &#123;        <span class="hljs-comment">// cout&lt;&lt;dp[j]&lt;&lt;&quot;,&quot;&lt;&lt;M[j]&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(dp[j] == dp[C])        &#123;            res += M[j];            res %= MOD;        &#125;    &#125;            <span class="hljs-built_in">cout</span>&lt;&lt;res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="IX-背包问题求具体方案"><a href="#IX-背包问题求具体方案" class="headerlink" title="IX. 背包问题求具体方案"></a>IX. 背包问题求具体方案</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。</p><h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p><p>物品编号范围是 $1…N$。</p><h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\\<br>0&lt;v_i,w_i≤1000$</p><blockquote><hr></blockquote><p>我们用一个二维dp数组$dp[i][j]$表示选取$i$个物品，体积为$j$对应的最大价值。这里的$i$是用来反推具体方案的。我们思考如何反推。</p><p>$dp[i][j] == dp[i-1][j]$说明不选第$i$个物品就能得到最大价值。</p><p>$dp[i][j]==dp[i-1][j-v[i-1]]+w[i-1]$表示选择第$i$个物品得到最大价值。</p><p>为了得到最小的字典序，我们可以采用贪心的策略。在进行状态转移的时候，我们按编号从大到小进行遍历。为了更直观的理解，我们举例：</p><p>设物品数4，背包容积5.  物品的体积$v_i$和价值$w_i$分别为: $[1,2],[2,4],[3,4],[4,6]$.  编号$i$的范围$[1,4]$</p><p>从$i=4$开始，我们从体积为0开始进行状态转移。最后的结果一定是最大价值。如下图所示：</p><pre><code class="hljs angelscript">i:<span class="hljs-number">4</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span> ←i:<span class="hljs-number">4</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">4</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">3</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span> ←i:<span class="hljs-number">3</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">2</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span> ←i:<span class="hljs-number">2</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">8</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">2</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">4</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span>i:<span class="hljs-number">1</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">8</span>  ←</code></pre><p>用$sum$表示剩余体积，开始$sum=5. $然后我们考虑 $dp[i][sum]==dp[i-1][sum-v[i]]+w[i]$ ，如果为True则选择第i个。</p><script type="math/tex; mode=display">dp[1][5]=8→dp[2][4]=6→dp[3][4]=6→dp[4][0]=0.</script><p>最后$sum==0$，表示找到字典序最小的方案。</p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">1010</span>;<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和容积</span><span class="hljs-keyword">int</span> dp[N_MAX][N_MAX];<span class="hljs-comment">//方案数</span><span class="hljs-keyword">int</span> v[N_MAX], w[N_MAX];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N;i++) <span class="hljs-built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = N;i &gt;= <span class="hljs-number">1</span> ;i--)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt;= C;k++)        &#123;             dp[i][k] = dp[i+<span class="hljs-number">1</span>][k];    <span class="hljs-comment">//这句话作用是使得k&lt;v[i]仍可进行反推</span>            <span class="hljs-keyword">if</span>(k &gt;= v[i])             dp[i][k]  = max(dp[i][k],dp[i+<span class="hljs-number">1</span>][k - v[i]] + w[i]);<span class="hljs-comment">//如果选和不选价值相同，那么我们贪心的进行选择</span>            <span class="hljs-comment">// printf(&quot;i:%d,k:%d,dp:%d\n&quot;,i,k,dp[i][k]);</span>        &#125;    &#125;    <span class="hljs-comment">// 根据结果反推具体方案</span>    <span class="hljs-keyword">int</span> sum = C;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N; i++)    &#123;        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][sum]&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(sum &gt;= v[i]&amp;&amp;dp[i][sum]==(dp[i+<span class="hljs-number">1</span>][sum-v[i]]+w[i]))        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;            sum -= v[i];        &#125;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="经典题目分析、"><a href="#经典题目分析、" class="headerlink" title="经典题目分析、"></a>经典题目分析、</h2><p><strong>例题</strong></p><ul><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</li></ul><hr><p><strong><a href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</strong></p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><pre><code class="hljs angelscript">输入：nums: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], S: <span class="hljs-number">3</span>输出：<span class="hljs-number">5</span>解释：<span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span> = <span class="hljs-number">3</span>一共有<span class="hljs-number">5</span>种方法让最终目标和为<span class="hljs-number">3</span>。</code></pre><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><blockquote><p>这道题看起来简单,实际上非常<code>Disgusting</code>.因为它给了三个提示,每一条都杀人诛心. </p></blockquote><p>这一次,我们每一个”物品”都必须选. <strong>我们考虑$dp[i][j]$表示$0-i$区间内组成$j$的方案数</strong>. 那么相应的状态方程为:</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</script><p>很多时候我们会因为惯性思维写成<code>nums[i-1]</code>但这是不对的,因为我们定义区间<code>[0,i]</code>.</p><p>然后很糟糕的是, 或者更糟糕的是, 中间可能产生负数目标的情况,为了避免数组越界,我们需要将数组整体搬移, 这时候第二个提示发挥作用.我们设这个$offset=1000$. </p><p>关于边界条件. 一开始我们很容易写成:</p><script type="math/tex; mode=display">dp[0][nums[0]+sum] = 1;         \\            dp[0][-nums[0]+sum] = 1;</script><p>第一个数可能为负或者正嘛. 但是如果第一个数为$0$.那么上面的式子将失效, 0 的相反数是其自身. 所以边界条件应该为:</p><script type="math/tex; mode=display">\left\{\begin{array}{lcr}2, nums[0]==0\\\begin{cases}dp[0][nums[0]+sum] = 1;\\         dp[0][-nums[0]+sum] = 1;\\\end{cases},otherwise\end{array}\right.</script><p>然后,你这样就以为大功告成了就大错特错了.</p><p>在双重循环中,我们必须要考虑$j$的范围,即$dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]$的适用条件. 并不是所有情况都可以用这个式子表示.</p><p>经过很长时间的摸索, $-sum \le j \le sum$, $sum$表示数组和,为了节省空间,我们也可以把1000改为$sum$:</p><script type="math/tex; mode=display">dp[i][j] =\left\{ \begin{array}{lcc}dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]],\\ \quad sum-nums[i] >=j>=nums[i]-sum\\dp[i-1][j-nums[i]],j>nums[i]-sum\\dp[i-1][j+nums[i]],j<sum-nums[i]\end{array}\right.</script><p>做完此题,深感出题人的恐怖.</p><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1000</span>;<span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;        <span class="hljs-comment">//子集问题，转换为0-1背包，动态规划解决。</span>        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-comment">//我们用dp[i][j]表示 0-i区间内组成j的方案数</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums) sum+= c;        S = S&gt;=<span class="hljs-number">0</span>?S:-S;        <span class="hljs-keyword">if</span>(S&gt;sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//为了使得负数也能被索引，我们必须加上它自身的绝对值</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>*sum+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">if</span>(!nums[<span class="hljs-number">0</span>]) dp[<span class="hljs-number">0</span>][sum] = <span class="hljs-number">2</span>;        <span class="hljs-keyword">else</span> &#123;            dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]+sum] = <span class="hljs-number">1</span>;                     dp[<span class="hljs-number">0</span>][-nums[<span class="hljs-number">0</span>]+sum] = <span class="hljs-number">1</span>;                &#125;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = -sum;j &lt;= sum;j++)        &#123;           <span class="hljs-keyword">if</span>(j+nums[i] &lt;= sum &amp;&amp; j-nums[i]&gt;=-sum)                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j-nums[i]+sum] + dp[i<span class="hljs-number">-1</span>][j+nums[i]+sum];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j-nums[i]&gt;=-sum)                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j-nums[i]+sum];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j+nums[i]&lt;=sum)                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j+nums[i]+sum];            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j+sum]&lt;&lt;endl;</span>        &#125;        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][S+sum];    &#125;&#125;;</code></pre><p>时间复杂度:$O(1)$, 因为题目已经告诉了具体范围不超过$O(20*2000)=O(40000)$,所以时间复杂度是常数.</p><p>空间复杂度:$O(N(2sum+1))$, 这里的$N$表示数组大小, $sum$表示数组之和. </p><p>同类题目还有416. 分割等和子数组.</p><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东方不败-&gt;回文问题</title>
    <link href="/2020/07/21/2020-08-19-manacher/"/>
    <url>/2020/07/21/2020-08-19-manacher/</url>
    
    <content type="html"><![CDATA[<h1 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h1><blockquote><p>直觉上：回文≈难题，LC上的回文难题, 但是总不能指望面试/周赛出中等题吧?</p></blockquote><ul><li><ol><li>回文对</li></ol></li><li><p>214.最短回文串</p></li><li><ol><li>分割回文串</li></ol></li><li><ol><li>统计不同的回文子序列</li></ol></li><li><ol><li>超级回文数</li></ol></li><li><ol><li>段式回文</li></ol></li><li>…</li></ul><h2 id="1-线性时间内解决回文串问题——Manacher算法-竞赛难度"><a href="#1-线性时间内解决回文串问题——Manacher算法-竞赛难度" class="headerlink" title="1. 线性时间内解决回文串问题——Manacher算法 {竞赛难度}"></a>1. 线性时间内解决回文串问题——Manacher算法 {竞赛难度}</h2><p>Manacher 算法是在<strong>线性时间</strong>!内求解最长回文子串的算法。在本题中，我们要求解回文串的个数，为什么也能使用 Manacher 算法呢？这里我们就需要理解一下 Manacher 的基本原理。</p><p>Manacher 算法的处理方式是在所有的相邻字符中间插入 $#$，比如 $abaaabaa$ 会被处理成 $#a#b#a#a#a#b#a#a#$，这样可以保证所有找到的回文串都是奇数长度的(因为$n+n+1=2n+1$)，以任意一个字符为回文中心，既可以包含原来的奇数长度的情况，也可以包含原来偶数长度的情况。假设原字符串为 $S$，经过这个处理之后的字符串为 $s$。</p><p>我们用 $f(i)$ 来表示以 $s$ 的第 $i$ 位为回文中心，可以拓展出的最大回文半径，那么 $f(i) - 1$ 就是以 $i$为中心的最大回文串长度 （想一想为什么）。</p><p>Manacher 算法依旧需要枚举 $s$ 的每一个位置并先假设它是回文中心，但是它会利用已经计算出来的状态来更新 $f(i)$，而不是向「中心拓展」一样盲目地拓展。具体地说，假设我们已经计算好了 $[1, i - 1] $区间内所有点的 $f$（即我们知道 $[1, i - 1] $这些点作为回文中心时候的最大半径）， 那么我们也就知道了 $[1, i - 1]$ 拓展出的回文达到最大半径时的回文右端点。例如 $i = 4$的时候 $f(i) = 5$，说明以第 4 个元素为回文中心，最大能拓展到的回文半径是 5，此时右端点为 $4 + 5 - 1 = 8$。所以当我们知道一个 $i$ 对应的 $f(i)$ 的时候，我们就可以很容易得到它的右端点为 $i + f(i) - 1$。</p><p>Manacher 算法如何通过已经计算出的状态来更新 $f(i)$ 呢？Manacher 算法要求我们维护「当前最大的回文的右端点 $r_m$」以及这个回文右端点对应的回文中心 $i_m$ 。我们需要顺序遍历 $s$，假设当前遍历的下标为 $i$。我们知道在求解 $f(i)$ 之前我们应当已经得到了从 $[1, i - 1]$ 所有的 $f$，并且当前已经有了一个最大回文右端点 $r_m$ 以及它对应的回文中心 $i_m$。</p><p><strong>初始化 $f(i)$</strong></p><ul><li>如果 $i \leq r_m$，说明 $i$ 被包含在当前最大回文子串内，假设 $j$ 是 $i $关于这个最大回文的回文中心 $i_m$的对称位置（即 $j + i = 2 \times i_m$），我们可以得到 $f(i)$ 至少等于 $\min\{f(j), r_m - i + 1\}$。这里将 $f(j)$ 和 $r_m - i + 1$取小，是先要保证这个回文串在当前最大回文串内。（思考：为什么 $f(j)$ 有可能大于 $r_m - i + 1$？）如果 $i &gt; r_m$，那就先初始化 $f(i) = 1$。</li></ul><p><strong>中心拓展</strong></p><ul><li>做完初始化之后，我们可以保证此时的$s[i + f(i) - 1] = s[i - f(i) + 1]$，要继续拓展这个区间，我们就要继续判断 $s[i + f(i)]$和 $s[i - f(i)]$是否相等，如果相等将 $f(i)$自增；这样循环直到 $s[i + f(i)] \neq s[i - f(i)]$，以此类推。我们可以看出循环每次结束时都能保证$ s[i + f(i) - 1] = s[i - f(i) + 1]$，而循环继续（即可拓展的条件）一定是 $s[i + f(i)] = s[i - f(i)]$。 这个时候我们需要注意的是不能让下标越界，有一个很简单的办法，就是在开头加一个 $\$$，并在结尾加一个 $!$，这样开头和结尾的两个字符一定不相等，循环就可以在这里终止。<br>这样我们可以得到 $s$ 所有点为中心的最大回文半径，也就能够得到 $S$ 中所有可能的回文中心的的最大回文半径，把它们累加就可以得到答案。</li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.size();        <span class="hljs-built_in">string</span> t = <span class="hljs-string">&quot;$#&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c: s) &#123;            t += c;            t += <span class="hljs-string">&#x27;#&#x27;</span>;        &#125;        n = t.size();        t += <span class="hljs-string">&#x27;!&#x27;</span>;        <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; (n);        <span class="hljs-keyword">int</span> iMax = <span class="hljs-number">0</span>, rMax = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;            <span class="hljs-comment">// 初始化 f[i]</span>            f[i] = (i &lt;= rMax) ? min(rMax - i + <span class="hljs-number">1</span>, f[<span class="hljs-number">2</span> * iMax - i]) : <span class="hljs-number">1</span>;            <span class="hljs-comment">// 中心拓展</span>            <span class="hljs-keyword">while</span> (t[i + f[i]] == t[i - f[i]]) ++f[i];            <span class="hljs-comment">// 动态维护 iMax 和 rMax</span>            <span class="hljs-keyword">if</span> (i + f[i] - <span class="hljs-number">1</span> &gt; rMax) &#123;                iMax = i;                rMax = i + f[i] - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span>            ans += (f[i] / <span class="hljs-number">2</span>);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h2 id="2-Rabin-Karp编码"><a href="#2-Rabin-Karp编码" class="headerlink" title="2. Rabin-Karp编码"></a>2. Rabin-Karp编码</h2><hr><h4 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214. 最短回文串"></a><a href="https://leetcode-cn.com/problems/shortest-palindrome/">214. 最短回文串</a></h4><p>给定一个字符串 <strong><em>s</em></strong>，你可以通过在字符串<strong>前面</strong>添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><p><strong>示例 1:</strong></p><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;aacecaaa&quot;</span>输出: <span class="hljs-string">&quot;aaacecaaa&quot;</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;abcd&quot;</span>输出: <span class="hljs-string">&quot;dcbabcd&quot;</span></code></pre><hr><p>我们可以用Rabin-Karp编码判断一个子集是否为回文串, 设$ASCII(i)$表示字符的ascii码.</p><p>$base$可以取比整个字符集大的素数, $mod$可以取一个很大的幂加上一个素数,比如$10^5+7$. $f(i)和\hat{f(i)}$分别表示字符串编码和对应的回文串编码.</p><script type="math/tex; mode=display">f(i) = f(i-1)*base\% mod + s[i]\\\hat{f(i)} = (\hat{f(i-1)} +s[i]*base^i)\%mod</script><p>由于题目只要求在字符串前加字符,因此可以判断$s$中最长回文前缀,</p><p>代码如下:</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">shortestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-comment">//思路，回文数判断：Manacher算法</span>        <span class="hljs-comment">//反过来思考：去掉最少几个字符它将称为回文数</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, mul = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> base = <span class="hljs-number">157</span>, mod = <span class="hljs-number">1E5</span>+<span class="hljs-number">7</span>;        <span class="hljs-keyword">int</span>  loc = <span class="hljs-number">1</span>;         <span class="hljs-keyword">int</span> n = s.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            left = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)left*base%mod + (<span class="hljs-keyword">int</span>)s[i];            right = (right+ (<span class="hljs-keyword">int</span>)s[i]*mul)%mod;            <span class="hljs-keyword">if</span>(left == right)             &#123;                loc = i;            &#125;            mul = (mul*base)%mod;         &#125;        <span class="hljs-built_in">string</span> add = (loc==n<span class="hljs-number">-1</span>)?<span class="hljs-string">&quot;&quot;</span>:s.substr(loc,n-loc);        reverse(add.begin(),add.end());        <span class="hljs-keyword">return</span> (add+s);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(|s|)$。</li><li>空间复杂度：$O(1)$。</li></ul><hr><h2 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a>336. 回文对</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>回文</tag>
      
      <tag>manacher算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启发式搜索——探索华容道</title>
    <link href="/2020/07/21/2020-7-28-HuaRongDao/"/>
    <url>/2020/07/21/2020-7-28-HuaRongDao/</url>
    
    <content type="html"><![CDATA[<h1 id="启发式搜索——探索华容道"><a href="#启发式搜索——探索华容道" class="headerlink" title="启发式搜索——探索华容道"></a>启发式搜索——探索华容道</h1><h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1 引入"></a>1 引入</h1><p>华容道问题，如下所示，在一个8x9的棋盘内，曹操要躲过五虎上将的围剿，成功从下方撤离华容道。卒子大小1x1，赵云，马超，黄忠，张飞均为1x2，关羽为2x1.</p><p><img src="https://img-blog.csdn.net/20161002102820064" alt="同质"></p><p>我们稍后再考虑如何具体解决。</p><p>我们不禁感叹老祖宗的智慧，华容道问题的推广——便是著名的N数码问题。下面是8数码问题，我们可以很容易得到它的状态空间为$O(9!)=O(1)$。</p><p><img src="https://exp-picture.cdn.bcebos.com/025d87c0affce18685f722c61f1fbee435daeb6c.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1" alt=""></p><p>更难的是15数码问题，或者31数码问题。传统的回溯或者dfs显然不能满足要求（TLE）。</p><h1 id="2-术语"><a href="#2-术语" class="headerlink" title="2 术语"></a>2 术语</h1><p>在搜索时需要解决的基本问题：</p><ul><li>搜索过程能否一定能找到一个解</li><li>找到一个解，是否为最优解</li><li>时间与空间复杂度如何</li><li>搜索过程是否终止运行或者陷入一个死循环</li></ul><p><strong>基本定义</strong></p><ol><li>状态（State）：描述问题在任一时刻所处状态的数据结构。</li><li>初始状态集S0，和目标状态集G</li><li>操作Operator：状态之间的转换函数</li><li>状态空间：四元组$（S，O，S_0，G）$</li></ol><p><strong>搜索分类</strong></p><p>盲目搜索：在特定问题不具有任何相关信息，包括DFS和BFS。</p><p>启发式搜索：考虑特定问题领域可应用的知识，动态地确定调用操作算子的步骤。优先选择较合适的操作算子，尽量减少不必要的搜索，以尽快到达目标状态。</p><blockquote><p>启发式搜索A与A*</p><p>它们都是定义一个评价函数$f$，然后对当前的搜索状态进行评估，然后找出一个代价最小的节点来扩展。A*表示的是最短路径的代价，在路径规划类问题中，它被证明是最优解法。</p></blockquote><p>启发式搜索的核心的思想是 <script type="math/tex">f(n)=g(n)+h(n)</script></p><p>$g^*(n)$：表示从初始节点s到当前节点n的最短路径的代价；</p><p>$h^*(n)$：表示从当前节点n到目标节点g的最短路径的代价；</p><p>$f^<em>(n)=g^</em>(n)+h^*(n)$：表示从初始节点s经过节点n到目标节点g的最短路径的代价。</p><p>  而$f(n)、g(n)和h(n)$则分别表示是对三$f^<em>(n)、g^</em>(n)、h^*(n)$个函数值的的估计值。是一种预测。A算法就是利用这种预测，来达到有效搜索的目的的。它每次按照$f(n)$值的大小对OPEN表中的元素进行排序，值小的节点放在前面，而值大的节点则被放在OPEN表的后面，这样每次扩展节点时，都是选择当前$f$值最小的节点来优先扩展。</p><p>当在算法A的评价函数中，使用的启发函数$h(n)$是处在$h^<em>(n)$的下界范围，即满足$h(n)\le h^</em>(n)$时，把这个算法就称为A*算法。</p><h1 id="3-十五数码求解"><a href="#3-十五数码求解" class="headerlink" title="3 十五数码求解"></a>3 十五数码求解</h1><p>利用bfs+位运算 </p><p> 设计一个启发函数，利用A*算法求解15数码问题。</p><p>原始状态为：</p><div class="table-container"><table><thead><tr><th>5</th><th>1</th><th>2</th><th>4</th></tr></thead><tbody><tr><td><strong>9</strong></td><td><strong>6</strong></td><td><strong>3</strong></td><td><strong>8</strong></td></tr><tr><td><strong>13</strong></td><td><strong>15</strong></td><td><strong>10</strong></td><td><strong>11</strong></td></tr><tr><td><strong>14</strong></td><td></td><td><strong>7</strong></td><td><strong>12</strong></td></tr></tbody></table></div><p>目标状态为：</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td></tr><tr><td><strong>9</strong></td><td><strong>10</strong></td><td><strong>11</strong></td><td><strong>12</strong></td></tr><tr><td><strong>13</strong></td><td><strong>14</strong></td><td><strong>15</strong></td></tr></tbody></table></div><p><strong>要求:</strong> 其中空格可以与相邻的上下左右格子交换，但不能越界。尽可能用与A*算法一致的思路实现算法, 求解到达目标的最小操作数.</p><hr><p>首先我们可以采取当前节点在搜索树的深度（初始为0）$h$作为$g(n)$。</p><p>之后要确定用何种启发函数$h(n)$，一种做法是统计<strong>不在位的数码个数</strong>，另一种是求<strong>离目标节点的剩余距离</strong>（计算曼哈顿距离、欧拉距离等），我们点到为止，有兴趣的读者可以深入研究。</p><p>采用曼哈顿距离，计算从当前节点到目标节点之间，水平与垂直距离总和。然后将结果乘以10，表示对剩余距离的估计(启发信息)。</p><p>以统计不在位的数码个数为例。算法步骤为：</p><ol><li><p>如果OPEN表为空，表明无法到达目标状态。（对于open表没有该子节点但close表中有的情况不予处理，因为如果close表中节点的$f(n)$小于现在新生成的子节点，那么前者的子节点的估价函数也会小于后者子节点的估价函数，相应地也先被扩展，最终也会最先找到最优解，因为本文的目标是找到一条最佳路径即可）。</p></li><li><p>把起始节点S放在OPEN表中，计算$f(S)$，并把其值和节点S联系起来。</p></li><li>如果OPEN表是一个空表，则没有解；否则继续。</li><li>从OPEN表中选择一个$f$最小的节点I。如果同时有几个节点满足要求（同时为最小），当其中有一个为目标节点则同时返回目标节点。否则就选择其中第一个节点。</li><li>把节点I从OPEN表中取出，并把它放到CLOSE列表之中。</li><li>如果I是目标节点，则成功退出，求得一个解。</li><li>扩展节点I，生成其全部后继节点。对于I的每一个后继节点J：<ol><li>计算$f(J)$;</li><li>如果J既不在OPEN表中，也不在CLOSE表中，则把它填入OPEN表中。从J加一指向父节点的指针，以便记住解答路径。</li><li>如果J已在OPEN表上，则比较刚刚对J计算过的$f$和前面计算过的该节点在该表中的值。如果该值较小，则<ul><li>以此值代替旧值；</li><li>从J指向I，而不是指向它的父节点；</li><li>如果J在CLOSE表中，则把它移回OPEN表。</li></ul></li></ol></li></ol><hr><div class="note note-warning">            <p>对于数据我们可以把它“状态压缩”为一个字符串，来降低时间开销，甚至可以用字典树来降低存储开销。有兴趣的读者可以思考一下。</p>          </div><p>代码实现：</p><p>运行结果</p><p><img src="../image-20201209202001368.png" alt="image-20201209202001368"></p><p><img src="../image-20201209202019921.png" alt="image-20201209202019921"></p><p>时间对比</p><div class="table-container"><table><thead><tr><th>方法</th><th>获取第一个解时间（10次实验取平均）</th></tr></thead><tbody><tr><td><code>outOfPlace</code>:不在位数字个数</td><td>0.003s</td></tr><tr><td><code>Manhattan</code>：曼哈顿距离</td><td>27.678s</td></tr><tr><td><code>Euclidean</code>：欧几里得距离</td></tr></tbody></table></div><h2 id="如何获得可行的测试样例"><a href="#如何获得可行的测试样例" class="headerlink" title="如何获得可行的测试样例"></a>如何获得可行的测试样例</h2><blockquote><p>这其实是HDU4021的一道竞赛题。不过很有意思。</p></blockquote><p>思路：看起来很像著名的“八数码”问题，首先，针对八个特殊位置（死角），如果这里有空位就把它和相邻的位置交换，这样之后如果两个状态的对应死角上的数字不同，那么显然是不能达到指定状态的，因为无法把死角处的数字换出去。</p><p>搞定了死角后就只剩下4×4的board了，这就变成了八数码问题的拓展——15数码。首先想想八数码是如何判断有解的：首先把所有数字（不包括空位的0）写成一行，就得到了一个1~8的排列，考虑空位的交换情况：1.左右交换，2.上下交换。对于左右交换而言，是不会改变写出的排列的逆序数的；而对上下交换，相当于在排列中向前或向后跳了两个位置，那么要么两个数都比它大或小，这样逆序数加2或减2，要么两个数一个比它大一个比它小，这样逆序数不变，综上，对于八数码问题，操作不会改变逆序数的奇偶性，所以只有初始状态和指定状态的逆序数奇偶性相同就有解。</p><p>弄清楚了八数码，扩展起来就容易了，现在我们将其扩展到N维（即N的board，N*(N-1)数码问题）。</p><p>首先无论N的奇偶，左右交换不改变逆序数，N为奇数时：上下交换逆序数增加N-1或减少N-1或不变，因为N为奇数，所以逆序数奇偶性不变；而N为偶数时：上下交换一次奇偶性改变一次。</p><p>结论：N为奇数时，初始状态与指定状态逆序数奇偶性相同即有解；N为偶数时，先计算出从初始状态到指定状态，空位要移动的行数m，如果初始状态的逆序数加上m与指定状态的逆序数奇偶性相同，则有解。</p><p><a href="https://www.cnblogs.com/sstealer/p/11296391.html">https://www.cnblogs.com/sstealer/p/11296391.html</a></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solvable</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;<span class="hljs-built_in">map</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//判断棋盘是否有解，对每一位统计其逆序数以及与“ ”的曼哈顿距离之和，最后判断和为奇数则有解，否则无解</span>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j] != <span class="hljs-string">&#x27; &#x27;</span>)                sum += (<span class="hljs-number">3</span> - i) + (<span class="hljs-number">3</span> - j);<span class="hljs-comment">//求曼哈顿距离，0在右下角为（3，3）</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>;f &lt; (i*n+j); f++)            &#123;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[f/n][f%n] &gt; <span class="hljs-built_in">map</span>[i][j])                    sum ++;            &#125;        &#125;    <span class="hljs-keyword">return</span> (sum&amp;<span class="hljs-number">1</span>); <span class="hljs-comment">//为奇数则有解，否则无解</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
      <tag>启发式搜索</tag>
      
      <tag>A*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口，滑动的艺术</title>
    <link href="/2020/07/21/2020-8-1-sliding-windows/"/>
    <url>/2020/07/21/2020-8-1-sliding-windows/</url>
    
    <content type="html"><![CDATA[<blockquote><p>滑动窗口是笔试中一大难点，幸运的是我们有模板</p></blockquote><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>Sliding Windows，是一类很看重细节的问题，题目通常为<code>Medium</code>或者<code>hard</code>。在滑动窗口中有两个指针，一个指针静止，而另一个指针保持移动。我们在s上滑动窗口，如果能够包含整个T（<strong>注意</strong>，T可能有重复字符），如果能收缩，我们就收缩窗口直到得到最小窗口。</p><p>滑动窗口一个有趣的应用是，计算机网络中的GBN协议，又称回退N步协议，它允许发送方发送多个分组而不需等待确认。</p></blockquote><ol><li><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">最小区间</a>(hard)</li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">可见点的最大数目</a></li><li><h4 id="删除子数组的最大得分"><a href="#删除子数组的最大得分" class="headerlink" title="删除子数组的最大得分"></a><a href="https://leetcode-cn.com/problems/maximum-erasure-value/">删除子数组的最大得分</a></h4></li></ol><hr><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><pre><code class="hljs nix">输入: <span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-attr">T</span> = <span class="hljs-string">&quot;ABC&quot;</span>输出: <span class="hljs-string">&quot;BANC&quot;</span></code></pre><p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><hr><p>在滑动窗口中有两个指针，一个指针静止，而另一个指针保持移动。我们在s上滑动窗口，如果能够包含整个T（<strong>注意</strong>，T可能有重复字符），如果能收缩，我们就收缩窗口直到得到最小窗口。</p><p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="fig1"></p><p>下面介绍一下滑动窗口法思路：</p><ol><li><p>我们在字符串S中使用左右指针技巧，初始化<code>left=right=0</code>，把索引<strong>左闭右开区间</strong><code>[left,right)</code>称为一个<code>窗口</code>。</p></li><li><p>我们先不断增加<code>right</code>指针扩大窗口，直到窗口中的字符串满足要求。</p></li><li><p>此时我们停止增加 <code>right</code>，转而不断增加<code>left</code>指针缩小窗口，直到窗口中的字符串不再满足要求。同时，每增加<code>left</code>，我们都要更新一轮结果。</p></li><li><p>重复2,3直到<code>right</code>到达字符串S的尽头。</p></li></ol><p>滑动窗口的基本框架</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(right&lt;s.size())&#123;window.add(s[right])right++<span class="hljs-keyword">while</span>(the window needs shrink)&#123;window.pop(s[left])left++&#125;&#125;</code></pre><hr><p>比较难的问题</p><h2 id="LC-632最小区间"><a href="#LC-632最小区间" class="headerlink" title="LC.632最小区间"></a>LC.632<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists">最小区间</a></h2><p>你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。</p><pre><code class="hljs angelscript">输入:[[<span class="hljs-number">4</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">24</span>,<span class="hljs-number">26</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">20</span>], [<span class="hljs-number">5</span>,<span class="hljs-number">18</span>,<span class="hljs-number">22</span>,<span class="hljs-number">30</span>]]输出: [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>]解释: 列表 <span class="hljs-number">1</span>：[<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">24</span>, <span class="hljs-number">26</span>]，<span class="hljs-number">24</span> 在区间 [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>] 中。列表 <span class="hljs-number">2</span>：[<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>]，<span class="hljs-number">20</span> 在区间 [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>] 中。列表 <span class="hljs-number">3</span>：[<span class="hljs-number">5</span>, <span class="hljs-number">18</span>, <span class="hljs-number">22</span>, <span class="hljs-number">30</span>]，<span class="hljs-number">22</span> 在区间 [<span class="hljs-number">20</span>,<span class="hljs-number">24</span>] 中。</code></pre><p>注意:</p><ol><li>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。</li><li>1 &lt;= k &lt;= 3500</li><li>-105 &lt;= 元素的值 &lt;= 105</li><li>对于使用Java的用户，请注意传入类型已修改为List<List<Integer>&gt;。重置代码模板后可以看到这项改动。</li></ol><hr><p>在讲这个方法之前我们先思考这样一个问题：有一个序列 <script type="math/tex">A = \{ a_1, a_2, \cdots, a_n \}</script> 和一个序列 <script type="math/tex">B = \{b_1, b_2, \cdots, b_m\}</script>，请找出一个 B 中的一个最小的区间，使得在这个区间中 A 序列的每个数字至少出现一次，请注意 A 中的元素可能重复，也就是说如果 A 中有 p 个 u，那么你选择的这个区间中 u 的个数一定不少于 p。</p><p>回到这道题，我们发现这两道题的相似之处在于都要求我们找到某个符合条件的最小区间，我们可以借鉴「76. 最小覆盖子串」的做法：这里序列 <script type="math/tex">\{ 0, 1, \cdots , k - 1 \}</script> 就是上面描述的 A 序列，即 k 个列表，我们需要在一个 B 序列当中找到一个区间，可以覆盖 A序列。这里的 B 序列是什么？我们可以用一个哈希映射来表示 B 序列—— B[i]表示 ii 在哪些列表当中出现过，这里哈希映射的键是一个整数，表示列表中的某个数值，哈希映射的值是一个数组，这个数组里的元素代表当前的键出现在哪些列表里。也许文字表述比较抽象，大家可以结合下面这个例子来理解。</p><p>如果列表集合为：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>: [<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-number">1</span>: [<span class="hljs-number">1</span>]<span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<span class="hljs-number">3</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]</code></pre><p>那么可以得到这样一个哈希映射</p><pre><code class="hljs angelscript"><span class="hljs-number">-1</span>: [<span class="hljs-number">0</span>] <span class="hljs-number">1</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>] <span class="hljs-number">2</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>] <span class="hljs-number">3</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>]</code></pre><p>我们得到的这个哈希映射就是这里的 BB 序列。我们要做的就是在 B 序列上使用双指针维护一个滑动窗口，并用一个哈希表维护当前窗口中已经包含了哪些列表中的元素，记录它们的索引。遍历 B 序列的每一个元素：</p><p>指向窗口右边界的指针右移当且仅当每次遍历到新的元素，并将这个新的元素对应的值数组中的每一个数加入到哈希表中<br>指向窗口左边界的指针右移当且仅当当前窗口内的元素包含 A中所有的元素，同时将原来左边界对应的值数组的元素们从哈希表中移除<br>答案更新当且仅当当前窗口内的元素包含 A 中所有的元素。</p><blockquote><p> 个人理解是，这题也一样可以套用模板，need（即B）哈希表的键为nums中出现的所有数字，值为该数字所在的所有数组在nums中的序号。window为一个长度为n的数组，只有当前的区间覆盖了所有nums中子数组，才能进行窗口缩小操作。注意,这里的left和right分别是nums中所有数的最大值和最小值。</p></blockquote><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;<span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#125;;<span class="hljs-keyword">int</span> n = nums.size();<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; B;<span class="hljs-comment">//B数组</span><span class="hljs-keyword">int</span> xMin = INT32_MAX, xMax = INT32_MIN;<span class="hljs-comment">//区间最大值和最小值</span><span class="hljs-comment">//这里的need包含了nums中所有数及其所在列表序号的映射对</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size();i++) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;c:nums[i])&#123;    B[c].push_back(i);    xMin = min(c,xMin);    xMax = max(c,xMax);&#125;<span class="hljs-comment">// sort(need.begin(),need.end());</span><span class="hljs-keyword">int</span> inside = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示包含最小区间的数组的个数,等于n表示窗口可以开始缩小</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">freq</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//A中每个子数组，被最小区间包含的次数</span><span class="hljs-keyword">int</span> left = xMin, right = xMin<span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> ansL = INT32_MAX, ansR = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> min_inter = INT32_MAX;<span class="hljs-keyword">while</span> (right &lt; xMax) &#123;    <span class="hljs-comment">// 右移窗口</span>    right++;    <span class="hljs-comment">// 进行窗口内数据的一系列更新</span>        <span class="hljs-keyword">if</span>(B.count(right))    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:B[right])    &#123;        freq[c]++;        <span class="hljs-keyword">if</span>(freq[c]==<span class="hljs-number">1</span>) inside++;    &#125;    <span class="hljs-comment">/*** debug 输出的位置 ***/</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);    <span class="hljs-comment">/********************/</span>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span>    <span class="hljs-keyword">while</span> (inside==n) &#123;        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span> &lt; min_inter||(right-left+<span class="hljs-number">1</span> == min_inter&amp;&amp;left&lt;ansL))        &#123;            min_inter = right-left+<span class="hljs-number">1</span>;            ansL = left;            ansR = right;        &#125;        <span class="hljs-keyword">if</span>(B.count(left))        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:B[left])        &#123;            freq[c]--;            <span class="hljs-keyword">if</span>(freq[c]==<span class="hljs-number">0</span>) inside--;        &#125;        <span class="hljs-comment">// 左移窗口，注意要放在后面，否则无法更新freq中左区间</span>        left++;            &#125;&#125;<span class="hljs-keyword">return</span> &#123;ansL,ansR&#125;;&#125;</code></pre><p>未完待续。。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>多指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红尘客栈之单调栈</title>
    <link href="/2020/07/21/2020-8-17-recognition-monostack/"/>
    <url>/2020/07/21/2020-8-17-recognition-monostack/</url>
    
    <content type="html"><![CDATA[<h1 id="炫酷skr的单调栈"><a href="#炫酷skr的单调栈" class="headerlink" title="炫酷skr的单调栈"></a>炫酷skr的单调栈</h1><ul><li><ol><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大矩形（Hard）</a></li></ol></li><li><p>85.<a href="https://leetcode-cn.com/problems/maximal-rectangle/">求最大矩形(Hard)</a></p></li><li><p>739.<a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度(Medium)</a></p></li><li><h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字</a></h4></li><li><p><a href="https://leetcode-cn.com/problems/create-maximum-number/">321. 拼接最大数（Hard）</a></p></li><li><p>多重背包问题III【详见背包九讲】</p></li></ul><blockquote><p>推荐阅读：<a href="https://blog.csdn.net/lucky52529/article/details/89155694">https://blog.csdn.net/lucky52529/article/details/89155694</a></p></blockquote><h3 id="模拟单调栈的数据push和pop"><a href="#模拟单调栈的数据push和pop" class="headerlink" title="模拟单调栈的数据push和pop"></a>模拟单调栈的数据push和pop</h3><blockquote><p>模拟实现一个递增单调栈：</p></blockquote><p>现在有一组数10，3，7，4，12。从左到右依次入栈，则如果<strong>栈为空</strong>或<strong>入栈元素值小于栈顶元素值</strong>，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。</p><ul><li>10入栈时，栈为空，直接入栈，栈内元素为10。</li><li>3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</li><li>7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</li><li>4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</li><li>12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</li></ul><p>细心的读者可能会问，既然单调栈有个循环，加上外面的循环，那么时间复杂度会不会是$O(n^2)$？ 其实不是，时间复杂度：$O(N)$。虽然外循环里面还有一个内循环，但内循环的次数受栈中剩余元素总数的限制，因此最终复杂度仍为 $O(N)。$.这一点可以和滑动窗口进行类比。</p><hr><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> <img src="\img\histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">10</span></code></pre><hr><p>这道题无论是暴力还是枚举均会超时（时间复杂度$O(N^2)$），最初的想法是用一个哈希表存<code>heights</code>中每一个高度「最长的横向距离」，最大面积等于<code>max(maxArea,heights[i]×len)</code>后来发现过于麻烦。但是直觉告诉我这是可行的，题解采用单调栈也验证了我的想法。</p><p>有一个<em>事实</em>需要注意：</p><ul><li>若后一个高度小于前一个高度，那么前一个高度将不会对后续的求最大面积操作产生影响。</li></ul><p>我们需要对$i$左右进行扩展，我们需要找到<strong>左右两侧最近且高度小于$h$的柱子，这和接雨水那一题非常相似</strong>。以</p><p>$[6,7,5,2,4,5,9,3]$为例，</p><ol><li>将6入栈，6左侧为哨兵，位置-1；</li><li>将7入栈，由于7&gt;6，故7不会被移除；</li><li>将5入栈，由于7&gt;5且6&gt;5，故6，7会被移除。此时栈为空，5左侧为哨兵，位置-1.</li><li>将2入栈，由于2&lt;5，5会被移除，2左侧为哨兵-1.</li><li>将4入栈</li><li>将5入栈</li><li>将9入栈</li><li>不断出栈直到遇到2&lt;3</li></ol><script type="math/tex; mode=display">\begin{array}\\1.[6(0)]\\2.[6(0),7(1)]\\3.[5(2)]\\4.[2(3)]\\5.[2(3),4(4)]\\6.[2(3),4(4),5(5)]\\7.[2(3),4(4),5(5),9(6)]\\8.[2(3),3(7)]\end{array}</script><p>这样以来我们得到左侧柱子的编号为$[-1,0,-1,-1,3,4,5,3]$，同样地，我们可以得到右侧柱子的编号$[2,2,3,8,7,7,7,8]$。  因而根据$(l_height-r_height-1)*height[i]$得到最大面积。</p><p>代码如下：</p><p>​     </p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;     <span class="hljs-keyword">if</span>(!heights.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-keyword">int</span> n = heights.size();     <span class="hljs-keyword">int</span> maxArea = INT32_MIN;    <span class="hljs-comment">//采用单调栈的思想，分别找到i左右两侧最近且高度小于h的柱子</span>    vector&lt;int&gt; lbound(n,0),rbound(n,0);    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; lstack,rstack;<span class="hljs-comment">//存放高度位置和下标</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    &#123;        <span class="hljs-keyword">if</span>(lstack.empty()) lbound[i] = <span class="hljs-number">-1</span>;<span class="hljs-comment">//哨兵 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heights[i] &gt; lstack.back().first)         &#123;            lbound[i] = lstack.back().second;        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">while</span>(!lstack.empty()&amp;&amp;heights[i]&lt;=lstack.back().first)lstack.pop_back();            <span class="hljs-keyword">if</span>(lstack.empty()) lbound[i] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">else</span> lbound[i] = lstack.back().second;        &#125;        lstack.push_back(&#123;heights[i],i&#125;);            &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>;j--)    &#123;        <span class="hljs-keyword">if</span>(rstack.empty()) rbound[j] = n;<span class="hljs-comment">//哨兵 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heights[j] &gt; rstack.back().first)         &#123;            rbound[j] = rstack.back().second;        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">while</span>(!rstack.empty()&amp;&amp;heights[j]&lt;=rstack.back().first) rstack.pop_back();            <span class="hljs-keyword">if</span>(rstack.empty()) rbound[j] = n;            <span class="hljs-keyword">else</span> rbound[j] = rstack.back().second;        &#125;        rstack.push_back(&#123;heights[j],j&#125;);            &#125;    <span class="hljs-comment">// for(auto &amp;c:lbound)</span>    <span class="hljs-comment">// printf(&quot;%d,&quot;,c);</span>    <span class="hljs-comment">// printf(&quot;\n&quot;);</span>    <span class="hljs-comment">// for(auto &amp;c:rbound)</span>    <span class="hljs-comment">// printf(&quot;%d,&quot;,c);</span>    <span class="hljs-comment">// printf(&quot;\n&quot;);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n;c++)    &#123;        <span class="hljs-keyword">if</span>(lbound[c]==<span class="hljs-number">-1</span>) maxArea = max(maxArea,rbound[c]*heights[c]);        <span class="hljs-keyword">else</span> maxArea = max(maxArea,(rbound[c]-lbound[c]<span class="hljs-number">-1</span>)*heights[c]);    &#125;    <span class="hljs-keyword">return</span> maxArea&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:maxArea;    &#125;&#125;;</code></pre><p>时间复杂度：$O(2N)$</p><p>空间复杂度: $O(4N)$，左右边界以及栈</p><p>但是此代码可以简化，把寻找左边界和寻找右边界放在一次迭代中完成。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;           <span class="hljs-comment">//84求柱状图的最大矩形，O(N)</span>           <span class="hljs-keyword">int</span> n = heights.size();           vector&lt;int&gt; left(n), right(n, n);           <span class="hljs-comment">//左右边界数组，维护每个矩形的最大左右宽度</span>           <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; mono_stack;<span class="hljs-comment">//单调栈</span>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;               <span class="hljs-keyword">while</span> (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;                   right[mono_stack.top()] = i;                   mono_stack.pop();               &#125;               left[i] = (mono_stack.empty() ? <span class="hljs-number">-1</span> : mono_stack.top());               mono_stack.push(i);           &#125;                      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;               ans = max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<span class="hljs-comment">//计算最大面积</span>           &#125;           <span class="hljs-keyword">return</span> ans;       &#125;</code></pre><p>可能看代码有些复杂，我们制作一个动画方便理解：</p><p>[动画正在制作之中。。。]</p><hr><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><hr><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 T[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 T[prevIndex] 和当前温度 T[i]，如果 T[i] &gt; T[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p><p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 T[i] 一定是 T[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><ul><li><p><strong>时间复杂度</strong>：$O(n)$，其中 n是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p></li><li><p><strong>空间复杂度</strong>：$O(n)$，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google划词搜索的秘密</title>
    <link href="/2020/07/21/2020-8-20-what-is-Trie/"/>
    <url>/2020/07/21/2020-8-20-what-is-Trie/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是前缀树Trie和前缀和？如何实现？"><a href="#什么是前缀树Trie和前缀和？如何实现？" class="headerlink" title="什么是前缀树Trie和前缀和？如何实现？"></a>什么是前缀树Trie和前缀和？如何实现？</h1><blockquote><p>前缀树又名<strong>Tries树</strong>、<strong>字典</strong>树、单词查找树等，常用于快速检索，大量字符串的排序和统计等。</p><p>LC208.<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现前缀树</a> - 制作板子</p><p>LC336.<a href="https://leetcode-cn.com/problems/palindrome-pairs/">回文对</a> - 结合回文</p><p>LC212.<a href="https://leetcode-cn.com/problems/word-search-ii/">单词搜索 II </a>- 类似 Boggle 的游戏。</p></blockquote><p><strong>三个基本性质</strong></p><ol><li>根节点不包含字符，除根节点外每个节点只包含一个字符</li><li>从根节点到某个节点，路径上所有的字符连在一起，就是这个节点所对应的字符串</li><li>每个节点的子节点所包含的字符都不同</li></ol><p><img src="\img\trie1.jpg" alt="Trie"></p><p><strong>应用场景</strong>：</p><p>1.自动补全</p><p><img src="\img\trie2.jpg" alt="自动补全"></p><p align="center" style="font:italic;color:gray"><i>图1. 谷歌的搜索建议</i></p><ol><li>拼写检查</li></ol><p><img src="\img\trie3.jpg" alt="image.png"></p><p align="center" style="font:italic;color:gray"><i>图2. 拼写检查</i></p><p>3.IP路由（最长前缀匹配）</p><p><img src="\img\trie4.jpg" alt="无效的图片地址"></p><p align="center"><i>图 3. 使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</i></p><ol><li>T9打字预测</li><li>Boggle单词游戏</li></ol><p>还有现成的高效结构如哈希表和平衡树，但为什么我们还要用前缀树呢，因为它有如下优势：</p><ul><li>找到具有同一前缀的全部键值</li><li>按词典枚举字符串的数据集</li></ul><p>Trie相比于哈希表的另一个优势是，随着哈希表长度增加，会出现大量冲突，时间复杂度可能会增加到$O(N)$. trie树子存储多个具有相同前缀的键时所用空间较少。因此前缀树只需要$O(m)$的空间，m为键长度。而在平衡树中需要$O(m\log n)$。</p><h2 id="设计Trie树"><a href="#设计Trie树" class="headerlink" title="设计Trie树"></a><strong>设计Trie树</strong></h2><p><strong>初始化</strong></p><p>我们设计一个Trie节点<code>node</code>具有如下属性：</p><ul><li>子树数组：因为字母表长度为26，所以数组长度为26；</li><li>结束标记，bool型表示，比如”apple”和”app”,后者是前者一个前缀，所以需要结束标记。</li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-keyword">bool</span> isEnd;    Trie* next[<span class="hljs-number">26</span>];<span class="hljs-keyword">public</span>:    Trie()    &#123;isEnd = <span class="hljs-literal">false</span>;        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(next));    &#125;&#125;;</code></pre><p><strong>插入键值</strong></p><p>我们从字符串头开始，如果字符<code>s[i]</code>存在于当前节点的子树数组中，那么我们直接递归进入该节点，否则我们创造新节点，再进入。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span></span><span class="hljs-function"></span>&#123;    Trie *node = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> &amp;c:word)    &#123;        <span class="hljs-keyword">if</span>(node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)        node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie(c);        node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];    &#125;&#125;</code></pre><p>注意这里我们把this作为根节点。所以每次new一个node都会产生一个根节点。  </p><ul><li>时间复杂度：$O(m)$，其中 $m$ 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 $m$ 次操作。</li></ul><ul><li>空间复杂度：$O(m)$。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 $m$ 个结点，使用 $O(m)$ 空间。</li></ul><p><strong>查找键值</strong></p><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始。检查当前节点中与键字符对应的链接。有两种情况：</p><p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。<br>不存在链接。若已无键字符，且当前结点标记为 End，则返回 true。否则有两种可能，均返回 false :<br>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。<br>没有键字符剩余，但当前结点没有标记为 End。也就是说，待查找键只是Trie树中另一个键的前缀。</p><pre><code class="hljs C++">  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;Trie* node = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> &amp;c:word)    &#123;        node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> node-&gt;isEnd;&#125;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(m)$。算法的每一步均搜索下一个键字符。最坏的情况下需要 $m$ 次操作。</li><li>空间复杂度 : $O(1)$。</li></ul><p><strong>查找 Trie 树中的键前缀</strong><br>该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “End” 标记，因为我们搜索的是键的前缀，而不是整个键。</p><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> startWith&#123;   <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   Trie* node = <span class="hljs-keyword">this</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> &amp;c:word)   &#123;   node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];   <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(m)$。算法的每一步均搜索下一个键字符。最坏的情况下需要 $m$ 次操作。</li><li>空间复杂度 : $O(1)$。</li></ul><hr><h2 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a>336. 回文对</h2><p>给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。</p><p>示例 1：</p><pre><code class="hljs lsl">输入：[<span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;dcba&quot;</span>,<span class="hljs-string">&quot;lls&quot;</span>,<span class="hljs-string">&quot;s&quot;</span>,<span class="hljs-string">&quot;sssll&quot;</span>]输出：[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]] 解释：可拼接成的回文串为 [<span class="hljs-string">&quot;dcbaabcd&quot;</span>,<span class="hljs-string">&quot;abcddcba&quot;</span>,<span class="hljs-string">&quot;slls&quot;</span>,<span class="hljs-string">&quot;llssssll&quot;</span>]</code></pre><p>示例 2：</p><pre><code class="hljs lua">输入：[<span class="hljs-string">&quot;bat&quot;</span>,<span class="hljs-string">&quot;tab&quot;</span>,<span class="hljs-string">&quot;cat&quot;</span>]输出：<span class="hljs-string">[[0,1],[1,0]]</span> 解释：可拼接成的回文串为 [<span class="hljs-string">&quot;battab&quot;</span>,<span class="hljs-string">&quot;tabbat&quot;</span>]</code></pre><hr><p>假设存在两个字符串$s1和s2$, $s1+s2$是一个回文串，记它们的长度分别为$len1和len2$.分情况进行讨论：</p><ol><li>$len1==len2$，此时$s1$是$s2$的翻转。</li><li>$len1&gt;len2$，此时仍然可以在$s1$找到一个前缀$s1’==s2$.</li><li>$len2&lt;len1$，同上。</li></ol><p><strong>注意</strong>：空串也是回文串。比如$s1=”aa”,s2=””$.</p><p>要实现这些操作，我们只需要设计一种能够在一系列字符串中查询「某个字符串的子串的翻转」是否存在的数据结构，有两种实现方法：</p><ol><li>我们可以使用字典树存储所有的字符串。在进行查询时，我们将待查询的子串<strong>逆序</strong>地在字典树上进行遍历，即可判断其是否存在。</li><li>我们可以使用哈希表存储所有字符串的翻转。在进行查询时，我们判断查询串是否在哈希表中出现，就可以判断其翻转子串是否存在。</li></ol><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-built_in">vector</span>&lt;Trie*&gt; child;    <span class="hljs-keyword">bool</span> end;<span class="hljs-comment">//结束的标志，表示在该节点结束</span>    <span class="hljs-keyword">int</span> index;<span class="hljs-comment">//该字符的下标，与end对应，默认-1，表示不存在</span>    <span class="hljs-keyword">char</span> val;     Trie() &#123;        val = <span class="hljs-string">&#x27; &#x27;</span>;        end = <span class="hljs-literal">false</span>;        index = <span class="hljs-number">-1</span>;        child.resize(<span class="hljs-number">26</span>);    &#125;    Trie(<span class="hljs-keyword">char</span> c) &#123;        val = c;        end = <span class="hljs-literal">false</span>;        index = <span class="hljs-number">-1</span>;        child.resize(<span class="hljs-number">26</span>);    &#125;        <span class="hljs-keyword">void</span> _insert(Trie* node, <span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> index)    &#123;        <span class="hljs-keyword">if</span>(i&gt;=word.size())         &#123;            node-&gt;end = <span class="hljs-literal">true</span>;            node-&gt;index = index;            <span class="hljs-keyword">return</span>;        &#125;           <span class="hljs-keyword">auto</span> &amp;n = node-&gt;child[(<span class="hljs-keyword">int</span>)(word[i]-<span class="hljs-string">&#x27;a&#x27;</span>)];         n = (n == <span class="hljs-literal">nullptr</span>)?<span class="hljs-keyword">new</span> Trie(word[i]):n;        _insert(n,word,i+<span class="hljs-number">1</span>,index);    &#125;    <span class="hljs-comment">/** Inserts a word into the trie. */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-comment">//root does not save char</span>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span>;        _insert(<span class="hljs-keyword">this</span>,word,<span class="hljs-number">0</span>,index);    &#125;    <span class="hljs-comment">/** Returns if the word is in the trie. */</span>    <span class="hljs-keyword">void</span> _search(<span class="hljs-built_in">string</span> mode, Trie *node, <span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">bool</span> &amp;isExist,<span class="hljs-keyword">int</span> &amp;index)    &#123;<span class="hljs-comment">//递归搜索，s为字符串，i为编号</span>      <span class="hljs-comment">// 上一个字符搜索到了才进行下一次搜索</span>       <span class="hljs-keyword">if</span>(i&lt;s.size()&amp;&amp;node-&gt;child[(<span class="hljs-keyword">int</span>)(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>)] &amp;&amp;node-&gt;child[(<span class="hljs-keyword">int</span>)(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>)]-&gt;val==s[i]&amp;&amp;!isExist)         _search(mode,node-&gt;child[(<span class="hljs-keyword">int</span>)(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>)],s,i+<span class="hljs-number">1</span>,isExist,index);        <span class="hljs-keyword">if</span>(!isExist)        <span class="hljs-keyword">if</span>(mode == <span class="hljs-string">&quot;search&quot;</span>) isExist = (i==s.size()&amp;&amp;node-&gt;end);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mode == <span class="hljs-string">&quot;prefix&quot;</span>) isExist = (i==s.size());        <span class="hljs-keyword">if</span>(isExist&amp;&amp;index==<span class="hljs-number">-1</span>)         index = node-&gt;index;            &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> isExist = <span class="hljs-literal">false</span>; <span class="hljs-keyword">int</span> i = <span class="hljs-number">-1</span>;        _search(<span class="hljs-string">&quot;search&quot;</span>,<span class="hljs-keyword">this</span>,word,<span class="hljs-number">0</span>,isExist,i);        <span class="hljs-keyword">return</span> i;    &#125;        <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> isExist = <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        _search(<span class="hljs-string">&quot;prefix&quot;</span>,<span class="hljs-keyword">this</span>,prefix,<span class="hljs-number">0</span>,isExist,i);        <span class="hljs-keyword">return</span> isExist;    &#125; &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-comment">//字典树版本</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;a,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = right - left + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; n/<span class="hljs-number">2</span>;i++)        <span class="hljs-keyword">if</span>(a[i+left]!=a[right-i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">palindromePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!words.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        Trie  tr;        <span class="hljs-comment">//将所有单词加入前缀树中</span>        <span class="hljs-keyword">int</span> n = words.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)         tr.insert(words[i],i);        <span class="hljs-comment">//遍历任意两个字符串</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            <span class="hljs-keyword">int</span> m = words[i].size();            <span class="hljs-built_in">string</span> sub = words[i];            reverse(sub.begin(),sub.end());            <span class="hljs-keyword">int</span> index = tr.search(sub);            <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;i,index&#125;);            <span class="hljs-keyword">if</span>(isPalindrome(words[i],<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>))             &#123;                <span class="hljs-keyword">int</span> index = tr.search(<span class="hljs-string">&quot;&quot;</span>);                <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;index,i&#125;);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)            &#123;                                <span class="hljs-keyword">if</span>(j&amp;&amp;isPalindrome(words[i],<span class="hljs-number">0</span>,j<span class="hljs-number">-1</span>))                &#123;                    <span class="hljs-built_in">string</span> sub = words[i].substr(j,m-j);                    reverse(sub.begin(),sub.end());                    <span class="hljs-keyword">int</span> index = tr.search(sub);                    <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;index,i&#125;);                &#125;                <span class="hljs-keyword">if</span>(isPalindrome(words[i],j,m<span class="hljs-number">-1</span>))                &#123;                    <span class="hljs-built_in">string</span> sub = words[i].substr(<span class="hljs-number">0</span>,j);                    reverse(sub.begin(),sub.end());                    <span class="hljs-keyword">int</span> index = tr.search(sub);                    <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;i,index&#125;);                &#125;                            &#125;        &#125;        <span class="hljs-keyword">return</span> res;            &#125;&#125;;</code></pre><p>时间复杂度: $O(N*M^2)$, $N$为字符数组总长度，$M$为字符串平均长度。</p><p>空间复杂度: $O(N*M)$。实际上由于字符前缀重合，用不到这么多空间。</p><hr><h2 id="扩展：删除元素"><a href="#扩展：删除元素" class="headerlink" title="扩展：删除元素"></a>扩展：删除元素</h2><p><a href="https://mp.weixin.qq.com/s/uDar0F7x9w5F3sHOB5tIDA">https://mp.weixin.qq.com/s/uDar0F7x9w5F3sHOB5tIDA</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>类树结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>臭名昭著的KMP算法</title>
    <link href="/2020/07/21/2020-8-29-KMP/"/>
    <url>/2020/07/21/2020-8-29-KMP/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法精讲"><a href="#KMP算法精讲" class="headerlink" title="KMP算法精讲"></a>KMP算法精讲</h2><blockquote><p>为什么说它臭名昭著呢？因为KMP 是最短小精悍,最强大,最不易理解,最容易健忘的算法之一.</p></blockquote><p><strong>术语约定</strong>：s为目标串，t为模式匹配串，KMP作用和<code>strStr()</code>相同</p><ul><li>KMP算法的核心在于获取PMT数组(Partly Matched Track)部分匹配数组，它是从$0$到$j$字串的前缀集合和后缀集合的最长公共字串长度</li></ul><p>​    为了编程方便，我们将第0位令为0，将PMT依次后移一位得到next数组，它其实是t数组与自身匹配运算，返回匹配的最长长度，所以</p><p>​    利用next数组信息，对目标串的匹配可以避免回溯过程。相当于用空间换时间，$T(N) = O(S+T)$, $S$，$T$表示目标串和模式串长度，一般的暴力解法为$O(S+T)$.</p><p>​    一个例子：</p><pre><code class="hljs yaml"><span class="hljs-attr">t  :</span> <span class="hljs-string">a</span> <span class="hljs-string">b</span> <span class="hljs-string">a</span> <span class="hljs-string">b</span> <span class="hljs-string">a</span> <span class="hljs-string">b</span> <span class="hljs-string">c</span> <span class="hljs-string">a</span><span class="hljs-attr">index:</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-attr">PMT :</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-string">next</span> <span class="hljs-string">:-1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span></code></pre><hr><p>C++代码</p><p>读者可以结合注释理解</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;next, <span class="hljs-built_in">string</span> t)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, k = <span class="hljs-number">-1</span>;        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(j &lt; t.size()<span class="hljs-number">-1</span>)        &#123;            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span> || t[j] == t[k])            &#123;                j++;k++;                next[j] = k;            &#125;            <span class="hljs-keyword">else</span> k = next[k];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//术语约定：s为目标串，t为模式匹配串，KMP作用和strStr()相同</span>        <span class="hljs-comment">//KMP算法的核心在于获取PMT数组(Partly Matched Track)部分匹配数组，它是从0到j字串的前缀集合和后缀集合的最长公共字串长度</span>        <span class="hljs-comment">//为了编程方便，我们将第0位令为0，将PMT依次后移一位得到next数组，它其实是t数组与自身匹配运算，返回匹配的最长长度，所以</span>        <span class="hljs-comment">//利用next数组信息，对目标串的匹配可以避免回溯过程。相当于用空间换时间，T(N) = O(S+T), S，T表示目标串和模式串长度，一般</span>        <span class="hljs-comment">//的暴力解法为O(S+T)</span>        <span class="hljs-comment">//一个例子：</span>        <span class="hljs-comment">//t    : a b a b a b c a</span>        <span class="hljs-comment">//index: 0 1 2 3 4 5 6 7 </span>        <span class="hljs-comment">//PMT  : 0 0 1 2 3 4 0 1</span>        <span class="hljs-comment">//next :-1 0 0 1 2 3 4 0</span>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(t.size(),<span class="hljs-number">0</span>)</span></span>;        get_next(next, t);        <span class="hljs-keyword">while</span>(i&lt;s.size() &amp;&amp; j&lt;(<span class="hljs-keyword">int</span>)t.size())        &#123;            <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==t[j])            &#123;                i++;j++;            &#125;            <span class="hljs-keyword">else</span> j = next[j];        &#125;         <span class="hljs-keyword">if</span>(j &gt;= t.size())            <span class="hljs-keyword">return</span>(i-j);        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>权力的游戏 之 零和博弈</title>
    <link href="/2020/07/21/2020-9-1-what-is-zero-sum/"/>
    <url>/2020/07/21/2020-9-1-what-is-zero-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是零和博弈-Zero-sum-？"><a href="#什么是零和博弈-Zero-sum-？" class="headerlink" title="什么是零和博弈(Zero sum )？"></a>什么是零和博弈(Zero sum )？</h1><blockquote><p>在零和博弈中，<strong>让自己最优</strong>和<strong>让对手最差</strong>其实是相同的目标！原因还是那句话，<strong>两人的总得分不会变化，自己多了，对手必然减少</strong>。</p></blockquote><p>在零和博弈问题中，一般会存在先手优势和后手劣势：</p><p><strong>先手优势</strong>：因为先手可以先走，所以可决定后手将要面对的局面。因此，后手虽然也会做出最优解，但是先手可以根据先发的优势，让后手进入最优解最差的局面。<br><strong>后手劣势</strong>：当先手走完后，虽然后手也会成为下一回合的先手，也可以做出最优解，但后手无法选择下一回合的局面。<br>所以一般零和博弈问题的关键都是要找出如何让后手陷入更差的局面的方法。</p><hr><p>例题</p><ul><li><ol><li><a href="https://leetcode-cn.com/problems/stone-game-iii/">石子游戏III</a>(Hard)</li></ol></li><li><p>877.<a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a>(Medium)</p></li><li><ol><li><a href="">预测赢家</a>(Medium)</li></ol></li><li><ol><li><a href="Medium">我能赢吗</a>(Medium)</li></ol></li><li><h4 id="1686-石子游戏-VI（Medium）"><a href="#1686-石子游戏-VI（Medium）" class="headerlink" title="1686. 石子游戏 VI（Medium）"></a><a href="https://leetcode-cn.com/problems/stone-game-vi/">1686. 石子游戏 VI</a>（Medium）</h4></li><li><h4 id="1690-石子游戏-VII"><a href="#1690-石子游戏-VII" class="headerlink" title="1690. 石子游戏 VII"></a><a href="https://leetcode-cn.com/problems/stone-game-vii/">1690. 石子游戏 VII</a></h4></li><li><h4 id="1563-石子游戏-V（Hard）"><a href="#1563-石子游戏-V（Hard）" class="headerlink" title="1563. 石子游戏 V（Hard）"></a><a href="https://leetcode-cn.com/problems/stone-game-v/">1563. 石子游戏 V</a>（Hard）</h4></li><li></li></ul><p>下面以486为例讲解</p><hr><h3 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a>预测赢家</h3><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p> <pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]输出：False解释：一开始，玩家<span class="hljs-number">1</span>可以从<span class="hljs-number">1</span>和<span class="hljs-number">2</span>中进行选择。如果他选择 <span class="hljs-number">2</span>（或者 <span class="hljs-number">1</span> ），那么玩家 <span class="hljs-number">2</span> 可以从 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）和 <span class="hljs-number">5</span> 中进行选择。如果玩家 <span class="hljs-number">2</span> 选择了 <span class="hljs-number">5</span> ，那么玩家 <span class="hljs-number">1</span> 则只剩下 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）可选。所以，玩家 <span class="hljs-number">1</span> 的最终分数为 <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>，而玩家 <span class="hljs-number">2</span> 为 <span class="hljs-number">5</span> 。因此，玩家 <span class="hljs-number">1</span> 永远不会成为赢家，返回 False 。</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">233</span>, <span class="hljs-number">7</span>]输出：True解释：玩家 <span class="hljs-number">1</span> 一开始选择 <span class="hljs-number">1</span> 。然后玩家 <span class="hljs-number">2</span> 必须从 <span class="hljs-number">5</span> 和 <span class="hljs-number">7</span> 中进行选择。无论玩家 <span class="hljs-number">2</span> 选择了哪个，玩家 <span class="hljs-number">1</span> 都可以选择 <span class="hljs-number">233</span> 。     最终，玩家 <span class="hljs-number">1</span>（<span class="hljs-number">234</span> 分）比玩家 <span class="hljs-number">2</span>（<span class="hljs-number">12</span> 分）获得更多的分数，所以返回 True，表示玩家 <span class="hljs-number">1</span> 可以成为赢家。</code></pre><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><hr><p>我们用$dp[l][r]$表示闭区间$[l,r]$内，自己「先手」能获得的分数最大值。那么函数<code>dfs(l,r)</code>返回<code>dp[l][r]</code>。并进行记录。</p><p><strong>记忆化搜索</strong> </p><p>$dp[l][r] = sum(l,r) - min(dp[l+1][r],dp[l][r-1])$</p><blockquote><p> 边界条件 $dp[l][l] = nums[l]$; 返回值：$dfs(nums,0,n-1)*2 &gt;= sum(nums,0,n-1)$</p></blockquote><p>时间复杂度：$O(2^n)$</p><p>空间复杂度: $O(n)$，递归的空间复杂度取决于使用了多少栈空间。</p><p><strong>动态规划</strong>    </p><p>$dp[l][r] = max(-dp[l+1][r] + nums[l],-dp[l][r-1]+nums[r])$</p><p>我们先在$nums[l],nums[r]$中进行选择，同时保证对手的$dp[l+1][r]或者dp[l][r-1]$最小。 </p><blockquote><p>边界条件 $dp[l][l] = nums[l]$, 返回值：$dp[0][n-1]&gt;=0$</p></blockquote><p>使用递归存在大量重复计算，时间复杂度很高，因而采用动态规划是更好的选择。<strong>注意</strong>：$i$的遍历要从$n$开始，即反过来。</p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度: $O(n)$，使用滚动数组优化。</p><h2 id="代码（DFS-记忆化搜索）"><a href="#代码（DFS-记忆化搜索）" class="headerlink" title="代码（DFS+记忆化搜索）"></a><strong>代码（DFS+记忆化搜索）</strong></h2><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allsum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//对下标l-r进行求和</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r;i++) sum += nums[i];        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//记忆化搜索，返回l,r使得先手优势最大的值</span>        <span class="hljs-keyword">if</span>(dp[l][r]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[l][r];        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l==r) &#123;dp[l][r]=nums[l];<span class="hljs-keyword">return</span> nums[l];&#125;        dp[l][r] = allsum(nums,l,r) - min(dfs(nums,l+<span class="hljs-number">1</span>,r),dfs(nums,l,r<span class="hljs-number">-1</span>));        <span class="hljs-comment">// printf(&quot;dp[%d][%d]=%d\n&quot;,lr,dp[l][r]);</span>        <span class="hljs-keyword">return</span> dp[l][r];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>&gt;=allsum(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p><strong>代码（DFS+记忆化搜索）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-comment">//表示[i,j]区间的最大值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) dp[i][i] = nums[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n;i &gt;= <span class="hljs-number">0</span>;i--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++)    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n &amp;&amp; j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)    &#123;        dp[i][j] = max(-dp[i+<span class="hljs-number">1</span>][j]+nums[i], -dp[i][j<span class="hljs-number">-1</span>]+nums[j]);        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;    </span>            &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><hr><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>游戏类问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown那些不为人知的酷炫特性</title>
    <link href="/2020/07/21/2020-9-3-Markdown%20-fantastic/"/>
    <url>/2020/07/21/2020-9-3-Markdown%20-fantastic/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-那些不为人知的炫🆒特性"><a href="#Markdown-那些不为人知的炫🆒特性" class="headerlink" title="Markdown 那些不为人知的炫🆒特性"></a>Markdown 那些不为人知的炫🆒特性</h1><hr><h2 id="新的甘特图功能，丰富你的文章（Mermaid语言）"><a href="#新的甘特图功能，丰富你的文章（Mermaid语言）" class="headerlink" title="新的甘特图功能，丰富你的文章（Mermaid语言）"></a>新的甘特图功能，丰富你的文章（Mermaid语言）</h2><pre><code class="hljs mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d</code></pre><ul><li>关于 <strong>甘特图</strong> 语法，参考 [这儿][2],</li></ul><h2 id="UML-图表（Mermaid语言）"><a href="#UML-图表（Mermaid语言）" class="headerlink" title="UML 图表（Mermaid语言）"></a>UML 图表（Mermaid语言）</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><pre><code class="hljs mermaid">sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</code></pre><p>这将产生一个流程图:</p><pre><code class="hljs mermaid">graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D</code></pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 [这儿][3],</li></ul><h2 id="FLowchart流程图（flow语言）"><a href="#FLowchart流程图（flow语言）" class="headerlink" title="FLowchart流程图（flow语言）"></a>FLowchart流程图（flow语言）</h2><p>我们依旧会支持flowchart的流程图，以中断处理流程为例：<br><pre><code class="hljs flow">start&#x3D;&gt;start: 开始mainProcess&#x3D;&gt;inputoutput: 主程序指令IRrequest&#x3D;&gt;condition: 有中断请求？IRoff&#x3D;&gt;operation: 关中断BPsaved&#x3D;&gt;operation: 保存断点IRrecog&#x3D;&gt;operation: 中断源识别protect&#x3D;&gt;operation: 保护现场IRservice&#x3D;&gt;operation: 中断服务recover&#x3D;&gt;operation: 恢复现场IRon&#x3D;&gt;operation: 开中断IRreturn&#x3D;&gt;operation: 中断返回end&#x3D;&gt;end: 主程序指令mainProcess-&gt;IRrequestIRrequest(no)-&gt;endIRrequest(yes)-&gt;IRoff-&gt;BPsaved-&gt;IRrecog-&gt;protect-&gt;IRservice-&gt;recover-&gt;IRon-&gt;IRreturn-&gt;end</code></pre></p><p>​                                                                                (a) 单极中断处理流程</p><pre><code class="hljs flow">start&#x3D;&gt;start: 开始mainProcess&#x3D;&gt;inputoutput: 主程序指令IRrequest&#x3D;&gt;condition: 有中断请求？IRoff&#x3D;&gt;operation: 关中断BPsaved&#x3D;&gt;operation: 保存断点IRrecog&#x3D;&gt;operation: 中断源识别protect&#x3D;&gt;operation: 保护现场和屏蔽字newMask&#x3D;&gt;operation: 设置新的屏蔽字IRon_&#x3D;&gt;operation: 重新开中断IRservice&#x3D;&gt;operation: 中断服务IRoff_&#x3D;&gt;operation: 重新关中断recover&#x3D;&gt;operation: 恢复现场和屏蔽字IRon&#x3D;&gt;operation: 开中断IRreturn&#x3D;&gt;operation: 中断返回end&#x3D;&gt;end: 主程序指令mainProcess-&gt;IRrequestIRrequest(no)-&gt;endIRrequest(yes)-&gt;IRoff-&gt;BPsaved-&gt;IRrecog-&gt;protect-&gt;newMask-&gt;IRon_IRon_-&gt;IRservice-&gt;IRoff_-&gt;recover-&gt;IRon-&gt;IRreturn-&gt;end</code></pre><p>​                                                                                (b) 多级中断处理流程</p><pre><code class="hljs flow">st&#x3D;&gt;start: Start:&gt;http:&#x2F;&#x2F;www.google.com[blank]e&#x3D;&gt;end:&gt;http:&#x2F;&#x2F;www.google.comop1&#x3D;&gt;operation: My Operationsub1&#x3D;&gt;subroutine: My Subroutinecond&#x3D;&gt;condition: Yesor No?:&gt;http:&#x2F;&#x2F;www.google.comio&#x3D;&gt;inputoutput: catch something...para&#x3D;&gt;parallel: parallel tasksst-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;parapara(path1, bottom)-&gt;sub1(right)-&gt;op1para(path2, top)-&gt;op1</code></pre><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://flowchart.js.org/">这儿</a>.</li></ul><p><a href="https://blog.csdn.net/Iccyco/article/details/106202945">https://blog.csdn.net/Iccyco/article/details/106202945</a></p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再也不想做图类题目了</title>
    <link href="/2020/07/21/2020-08-1-representation_of_graph/"/>
    <url>/2020/07/21/2020-08-1-representation_of_graph/</url>
    
    <content type="html"><![CDATA[<h1 id="图的表示和图算法"><a href="#图的表示和图算法" class="headerlink" title="图的表示和图算法"></a>图的表示和图算法</h1><ul><li><del>DFS&amp;BFS</del>(在相应专题讲)</li><li>拓扑排序</li><li>Dijkstra</li><li>Floyd算法</li><li>Bellman-Ford算法</li><li>SPFA算法</li></ul><blockquote><p>本博客介绍了四种图的表示方法，包括 邻接矩阵表示法，关联矩阵表示法，邻接表表示法，弧表示法，星形表示法。以及图的典型算法，包括Dijkstra, Floyd, Bellman-Ford以及SPFA算法。</p></blockquote><h2 id="1-邻接矩阵表示法"><a href="#1-邻接矩阵表示法" class="headerlink" title="1.邻接矩阵表示法"></a>1.邻接矩阵表示法</h2><p>如图：</p><p> <img src="\img\graph_1.png" alt="img"><img src="\img\graph_2.png" alt="img"></p><p>　　也就是说，如果两节点之间有一条弧，则邻接矩阵中对应的元素为1；否则为0。可以看出，这种表示法非常简单、直接。但是，在邻接矩阵的所有元素中，只有少量为非零元。如果网络比较稀疏，这种表示法浪费大量的存储空间，从而增加了在网络中查找弧的时间。</p><p>　　同样，对于网络中的权，也可以用类似邻接矩阵的 矩阵表示。只是此时一条弧所对应的元素不再是1，而是相应的权而已。如果网络中每条弧赋有多种权，则可以用多个矩阵表示这些权。</p><h2 id="2-关联矩阵表示法"><a href="#2-关联矩阵表示法" class="headerlink" title="2. 关联矩阵表示法"></a>2. 关联矩阵表示法</h2><p><img src="\img\graph_3.png" alt="img"><img src="\img\graph_4.png" alt="img"></p><p>　　也就是说，在关联矩阵中，<u>每行对应于图的一个节点，每列对应于图的一条弧</u>。如果一个节点是一条弧的起点，则关联矩阵中对应的元素为1；如果一个节点是一条弧的终点，则关联矩阵中对应的元素为 -1；如果一个节点与一条弧不关联，则关联矩阵中对应的元素为0。对于简单图，关联矩阵每列只含有两个非零元（一个 1，一个-1）可以看出，这种表示法也非常简单、直接。但是，在关联矩阵的所有$mn$ 个元素中，只有 $2m$个为非零元。如果网络比较稀疏，这种表示法也会浪费大量的存储空间。但由于关联矩阵有许多特别重要的理论性质，因此它在网络优化中是非常重要的概念。</p><p>　　同样，对于网络中的权，也可以通过对关联矩阵的扩展来表示。例如，如果网络中每条弧有一个权，我们可以把关联矩阵增加一行，把每一条弧所对应的权存储在增加的行中。如果网络中每条弧赋有多个权，我们可以把关联矩阵增加相应的行数，把每一条弧所对应的权存储在增加的行中。</p><h2 id="3-弧表示法"><a href="#3-弧表示法" class="headerlink" title="3.弧表示法"></a>3.弧表示法</h2><p><img src="\img\graph_5.png" alt="img"><img src="\img\graph_6.png" alt="img"></p><p>例如，例7所示的图，假设弧$(1,2)，(1,3)，(2,4)，(3,2)，(4,3)，(4,5)，(5,3)和(5,4)$上的权分别为$8，9，6，4，0，3，6和7$，则弧表表示如上：</p><p>为了便于检索，一般按照起点、终点的字典序顺序存储弧表，如上面的弧表就是按照这样的顺序存储的。</p><h2 id="4-邻接表表示法"><a href="#4-邻接表表示法" class="headerlink" title="4. 邻接表表示法"></a>4. 邻接表表示法</h2><p>　　邻接表表示法将图以邻接表（adjacency lists）的形式存储在计算机中。所谓图的邻接表，也就是图的所有节点的邻接表的集合；而对每个节点，它的邻接表就是它的所有出弧。邻接表表示法就是对图的每个节点，用一个单向链表列出从该节点出发的所有弧，链表中每个单元对应于一条出弧。为了记录弧上的权，链表中每个单元除列出弧的另一个端点外，还可以包含弧上的权等作为数据域。图的整个邻接表可以用一个指针数组表示。例如，例7所示的图，邻接表表示为</p><p><img src="\img\weighed_graph.png" alt="img"></p><h2 id="5-星形表示法"><a href="#5-星形表示法" class="headerlink" title="5.星形表示法"></a>5.星形表示法</h2><p>星形（star）表示法的思想与邻接表表示法的思想有一定的相似之处。对每个节点，它也是记录从该节点出发的所有弧，但它不是采用单向链表而是采用一个单一的数组表示。也就是说，在该数组中首先存放从节点1出发的所有弧，然后接着存放从节点2出发的所有孤，依此类推，最后存放从节点 出发的所有孤。对每条弧，要依次存放其起点、终点、权的数值等有关信息。这实际上相当于对所有弧给出了一个顺序和编号，只是从同一节点出发的弧的顺序可以任意排列。此外，为了能够快速检索从每个节点出发的所有弧，我们一般还用一个数组记录每个节点出发的弧的起始地址（即弧的编号）。在这种表示法中，可以快速检索从每个节点出发的所有弧，这种星形表示法称为前向星形（forward star）表示法。</p><p>例如，在例7所示的图中，仍然假设弧（1,2），（l,3），（2,4），（3,2），（4,3），（4,5），（5,3）和（5,4）上的权分别为8，9，6，4，0，3，6和7。此时该网络图可以用前向星形表示法表示如下：</p><p><img src="\img\graph_7.png" alt="img"><img src="\img\graph_8.png" alt="img"></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">邻接矩阵（暴力）</th><th style="text-align:center">邻接表（类似链表）</th></tr></thead><tbody><tr><td style="text-align:center"><strong>使用范围</strong></td><td style="text-align:center">稠密图</td><td style="text-align:center">主要是稀疏图</td></tr><tr><td style="text-align:center"><strong>空间耗费</strong></td><td style="text-align:center">$n^2$（ n<em>n</em>为点个数）</td><td style="text-align:center">理论上是 $e$（ $e$为边条数）</td></tr><tr><td style="text-align:center"><strong>实现方式</strong></td><td style="text-align:center">二维数组</td><td style="text-align:center">数组模拟链表、 $vector$</td></tr></tbody></table></div><h2 id="6-二分图"><a href="#6-二分图" class="headerlink" title="6. 二分图"></a>6. 二分图</h2><p>​    分图又称作二部图，是图论中的一种<a href="https://baike.baidu.com/item/特殊模型/19071206">特殊模型</a>。 设$G=(V,E)$是一个无向图，如果顶点V可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$（i，j）$所关联的两个顶点$i$和$j$分别属于这两个不同的顶点集$(i \in A,j \in B)$，则称图G为一个二分图。</p><p>关于二部图有一个重要的定理：G为二部图的充要条件是G中的每一个圈的长度都是偶数</p><p><a href="https://baike.baidu.com/pic/二分图/9089095/0/3c6d55fbb2fb43169079761121a4462309f7d373?fr=lemma&amp;ct=single"><img src="\img\bipartite graph.jpg" alt="img"></a></p><p>上图中U和V构造的点集所形成的圈长度不为奇数，所以是二分图。</p><p><a href="https://baike.baidu.com/pic/二分图/9089095/0/d52a2834349b033b409ef0b114ce36d3d539bd42?fr=lemma&amp;ct=single"><img src="\img\nonbipartite graph.jpg" alt="img"></a></p><p>上图中U和V和W构造的点集所形成的的圈长度为奇数，所以不是二分图。</p><p>参考：<a href="https://blog.csdn.net/qq_26822029/article/details/90382581">https://blog.csdn.net/qq_26822029/article/details/90382581</a></p><h2 id="XI-拓扑排序"><a href="#XI-拓扑排序" class="headerlink" title="XI.拓扑排序"></a>XI.拓扑排序</h2><blockquote><p>LC 课程表问题系列：207 210</p><p>核心特性，对于图G中任何一条有向边$(u,v)$，$u$在排列中都出现在$v$的前面，这样的排列称为「拓扑排序」。</p></blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为<strong>拓扑排序</strong>。</p><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）：</p><ul><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li><li>若图中存在环，则不存在拓扑排序</li></ul><p><strong><em>重点</em></strong>：如何判断有无环：如果某个节点的相邻节点处于探索状态（在visited中），但还未加入拓扑序列，则说明有环。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">graph</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,num</span>):</span>        self.graph = defaultdict(list)        self.visited = &#123;&#125;         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params">self,u,v</span>):</span>        self.graph[u].append(v)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canFinish</span>(<span class="hljs-params">self, numCourses: int, prerequisites: [[int]]</span>) -&gt; bool:</span>        g = graph(numCourses+<span class="hljs-number">1</span>)           topo_sort = []        <span class="hljs-keyword">for</span> lists <span class="hljs-keyword">in</span> prerequisites:            g.visited[lists[<span class="hljs-number">0</span>]] = <span class="hljs-literal">False</span>            <span class="hljs-keyword">for</span> i,it <span class="hljs-keyword">in</span> zip(range(<span class="hljs-number">1</span>,len(lists)), lists):                g.graph[lists[i]].append(lists[<span class="hljs-number">0</span>])                g.visited[lists[i]] = <span class="hljs-literal">False</span>                        isLoop = <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prerequisites <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> prerequisites[<span class="hljs-number">0</span>]: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-comment">#只要存在一种拓扑排序，返回true</span>        <span class="hljs-comment">#定义三种状态，未探索，探索中以及已经探索</span>        <span class="hljs-comment">#A-&gt;B: 表示A是B的先修课</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">vertex</span>):</span>            <span class="hljs-keyword">nonlocal</span> isLoop            <span class="hljs-keyword">if</span> isLoop: <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vertex <span class="hljs-keyword">in</span> g.graph.keys():                g.visited[vertex] = <span class="hljs-literal">True</span> <span class="hljs-comment">#标记为已经访问</span>                topo_sort.append(vertex)                <span class="hljs-keyword">return</span> <span class="hljs-comment">#如果已经访问则跳过</span>            g.visited[vertex] = <span class="hljs-literal">True</span> <span class="hljs-comment">#标记为已经访问</span>            <span class="hljs-keyword">for</span> neigbor <span class="hljs-keyword">in</span> g.graph[vertex]:<span class="hljs-comment">#遍历邻接顶点</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> g.visited[neigbor] :                    dfs(neigbor)                <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> neigbor <span class="hljs-keyword">in</span> topo_sort:<span class="hljs-comment">#如果某个节点的相邻节点处于探索状态（在visited中），但还未加入拓扑序列，则说明有环</span>                    isLoop = <span class="hljs-literal">True</span>                    <span class="hljs-keyword">return</span>             topo_sort.append(vertex)                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> g.graph.keys():            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isLoop <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> g.visited[v]:                dfs(v)                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> isLoop</code></pre><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度: $O(n+m)$，其中 $n$ 为课程数，$m$ 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p><p>空间复杂度: $O(n+m)$。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 $O(n+m)$。在深度优先搜索的过程中，我们需要最多 $O(n)$ 的栈空间（递归）进行深度优先搜索，并且还需要若干个 $O(n)$ 的空间存储节点状态、最终答案等。</p><hr><h1 id="Dijsktra算法"><a href="#Dijsktra算法" class="headerlink" title="Dijsktra算法"></a>Dijsktra算法</h1><blockquote><p><a href="https://www.luogu.com.cn/blog/FrozaFerrari/xue-tu-lun-ni-zhen-di-liao-xie-zui-duan-lu-ma-post">参考：米奇妙妙屋</a></p><p>在实际应用中，集中式路由选择算法用完整、全局性的网络知识计算出从元到目的地的最低开销路径。其获取全局状态信息的算法被称为链路状态LS算法。其中一种便是Dijkstra. 它通过链路状态广播实现。</p></blockquote><p>先用邻接矩阵存储数据，考虑采用一个二重循环，每次寻找出距离集合最近的一个点，然后数组标记它已经加入集合，然后在用当前点对不在集合中的点进行松弛，进行 <em>n</em> 次，整个操作就完成了,注意起点对应的最小距离是0.</p><p><strong>cpp代码</strong></p><p>数据预处理</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;weight_type, <span class="hljs-keyword">int</span>&gt;&gt; e[<span class="hljs-number">10005</span>];<span class="hljs-comment">//这个vector的元素类型为&lt;weight_type,int&gt;,第一个存储到当前点的权重，第二个存储顶点，长度为10005</span><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">10005</span>];<span class="hljs-comment">//表示当前点是否被访问,为什么是10005因为题目要求2 &lt;= n &lt;= 10^4</span><span class="hljs-keyword">int</span> edge_len;<span class="hljs-comment">//边的个数</span><span class="hljs-keyword">int</span> vetice_num;<span class="hljs-comment">//顶点个数</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vetice;<span class="hljs-comment">//包含所有顶点的vector  </span><span class="hljs-keyword">int</span> n;<span class="hljs-comment">// 顶点个数</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<span class="hljs-comment">//边数组</span><span class="hljs-built_in">vector</span>&lt;weight_type&gt; weight;<span class="hljs-comment">//权重数组，和边数组对应</span><span class="hljs-comment">//**重要，初始化图，根据题目修改相应入口参数</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * @description: 初始化图</span><span class="hljs-comment"> * @param &#123;type&#125; //n为顶点的个数，edges为边个数，s为对应权重，start为起点，end为终点,direct是true为双向,false为单向</span><span class="hljs-comment"> * @return &#123;type&#125; Null</span><span class="hljs-comment"> * @author: Durant Thorvals</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, <span class="hljs-built_in">vector</span>&lt;weight_type&gt;&amp; s, <span class="hljs-keyword">bool</span> direct)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">this</span>-&gt;n = n;    <span class="hljs-keyword">this</span>-&gt;edges = edges;    <span class="hljs-keyword">this</span>-&gt;weight = s;    edge_len = edges.size();<span class="hljs-comment">//边的个数</span>    vetice_num = n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;edge_len;i++)    &#123;        e[edges[i][<span class="hljs-number">0</span>]].push_back(&#123;s[i],edges[i][<span class="hljs-number">1</span>]&#125;);        <span class="hljs-keyword">if</span>(direct) e[edges[i][<span class="hljs-number">1</span>]].push_back(&#123;s[i],edges[i][<span class="hljs-number">0</span>]&#125;);<span class="hljs-comment">//因为是双向的，所以要再加一条相反的边     </span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edge_len;i++)    &#123;            <span class="hljs-keyword">if</span>(!count(vetice.begin(),vetice.end(),edges[i][<span class="hljs-number">0</span>])) vetice.push_back(edges[i][<span class="hljs-number">0</span>]);            <span class="hljs-keyword">if</span>(!count(vetice.begin(),vetice.end(),edges[i][<span class="hljs-number">1</span>])) vetice.push_back(edges[i][<span class="hljs-number">1</span>]);    &#125;&#125;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;left, T <span class="hljs-keyword">const</span> &amp;right)</span></span><span class="hljs-function">    </span>&#123;    <span class="hljs-comment">// 以y比较。输出结果为y较大的在前y相同时，先进入队列的元素在前。</span>        <span class="hljs-keyword">return</span> (left.first &gt; right.first); <span class="hljs-comment">// left.first在后面，顶部元素first最大</span>    &#125;&#125;;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;weight_type,<span class="hljs-keyword">int</span>&gt; data;<span class="hljs-function">weight_type <span class="hljs-title">dijkstra</span><span class="hljs-params">( <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<span class="hljs-comment">//不能处理带负权的边</span>    <span class="hljs-keyword">if</span>(start == end ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//优先队列是按照pair的第一个元素进行排序</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;weight_type&gt; <span class="hljs-title">minDis</span><span class="hljs-params">(vetice_num,INT32_MAX)</span></span>;<span class="hljs-comment">//与e不同的是，存储的是最大的权重</span>    <span class="hljs-built_in">priority_queue</span>&lt;data,<span class="hljs-built_in">vector</span>&lt;data&gt;,cmp&lt;data&gt;&gt; pq;<span class="hljs-comment">//用一个优先队列，顶部是权重最小的，这样可以把时间复杂度降低至O((e+n)logn)</span>        pq.push(&#123;<span class="hljs-number">0</span>,start&#125;);<span class="hljs-comment">//相乘值从1.0开始, 如果是cost从0开始</span>    minDis[start] = <span class="hljs-number">0</span>;<span class="hljs-comment">//同上</span>    <span class="hljs-keyword">while</span>(!pq.empty()&amp;&amp;pq.top().second!=end)<span class="hljs-comment">//队列不为空</span>    &#123;        <span class="hljs-keyword">auto</span> cur  = pq.top().second;<span class="hljs-comment">//w表示权重，v表示节点</span>        pq.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:e[cur])<span class="hljs-comment">//搜寻与当前节点k相邻的所有节点</span>        &#123;            <span class="hljs-keyword">int</span> dis = t.first;            <span class="hljs-keyword">int</span> nextnode = t.second;            <span class="hljs-keyword">if</span>((minDis[cur] + dis) &lt; minDis[nextnode])           &#123;                 minDis[nextnode] = minDis[cur] + dis;                  pq.push(&#123;minDis[nextnode],nextnode&#125;);<span class="hljs-comment">//则加入到优先队列之中</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> minDis[end]==INT32_MIN?<span class="hljs-number">-1</span>:minDis[end];    &#125;</code></pre><p>当然也可以采用匿名函数, 这样的话将减少优先队列空间占用。</p><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> cmp = [&amp;minDis](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; right)&#123;      <span class="hljs-keyword">return</span> minDis[left] &gt; minDis[right];&#125;;<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt;pq(cmp);</code></pre><p>Java</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> INTL = <span class="hljs-number">0x3f3f3f3f_3f3f3f3fl</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNABLE2REACH = -<span class="hljs-number">1</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * A simple implementation of Dijkstra algorithm.</span><span class="hljs-comment"> * Time complexity: O(VlogV+E), where E is the number of edges, and V denotes the number of vertices.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> verticesCnt the number of vertices in the graph</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> graph every 1D array should be &#123;from, to, weight&#125; with no duplicated or negative-weighted edge</span><span class="hljs-comment"> *              the from and to values should be in the range [0, verticesCnt)</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> src the source node of Dijkstra algorithm</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> des the destination node of Dijkstra algorithm</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the minimal cost from src to des</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> verticesCnt, <span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> des)</span> </span>&#123;<span class="hljs-keyword">if</span>(src == des) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//preprocessing the graph</span>List&lt;<span class="hljs-keyword">int</span>[]&gt;[] edges = <span class="hljs-keyword">new</span> List[verticesCnt];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; verticesCnt;i++)&#123;    edges[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge:graph)&#123;    <span class="hljs-keyword">int</span> from = edge[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> to = edge[<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> cost = edge[<span class="hljs-number">2</span>];    edges[from].add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;to,cost&#125;);<span class="hljs-comment">//&#123;from:&#123;to,cost&#125;&#125;</span>    edges[to].add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;from,cost&#125;);&#125;<span class="hljs-keyword">int</span>[] minDis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[verticesCnt];Arrays.fill(minDis,INF);minDis[src] = <span class="hljs-number">0</span>;PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(        <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;                <span class="hljs-keyword">return</span> Integer.compare(minDis[o1],minDis[o2]);            &#125;        &#125;);pq.offer(src);<span class="hljs-comment">//压入队列</span><span class="hljs-keyword">while</span>(!pq.isEmpty()&amp;&amp;pq.peek()!=des)&#123;    <span class="hljs-keyword">int</span> cur = pq.poll();<span class="hljs-comment">//取顶元素并弹队列</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] next:edges[cur])    &#123;        <span class="hljs-keyword">int</span> nextnode = next[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> dis = next[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>( (dis + minDis[cur]) &lt; minDis[nextnode])        &#123;            minDis[nextnode] = dis + minDis[cur];            pq.offer(nextnode);        &#125;    &#125;&#125;<span class="hljs-keyword">return</span> (minDis[des] == INF)? UNABLE2REACH:minDis[des];&#125;</code></pre><hr><h4 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h4><p>难度中等29</p><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]]输出：<span class="hljs-number">2</span>解释：路径 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 连续格子的差值绝对值最大为 <span class="hljs-number">2</span> 。这条路径比路径 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] 更优，因为另一条路劲差值最大值为 <span class="hljs-number">3</span> 。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]]输出：<span class="hljs-number">1</span>解释：路径 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 的相邻格子差值绝对值最大为 <span class="hljs-number">1</span> ，比路径 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 更优。</code></pre><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png" alt="img"></p><pre><code class="hljs angelscript">输入：heights = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]输出：<span class="hljs-number">0</span>解释：上图所示路径不需要消耗任何体力。</code></pre><p><strong>提示：</strong></p><ul><li><code>rows == heights.length</code></li><li><code>columns == heights[i].length</code></li><li><code>1 &lt;= rows, columns &lt;= 100</code></li><li><code>1 &lt;= heights[i][j] &lt;= 106</code></li></ul><p>此题虽然是图类问题，但根据零神的解答，有二分法，最短路，并查集，三种做法。真乃大神也。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神奇的多指针 【cover 脑筋急转弯💡】</title>
    <link href="/2020/07/21/2020-7-30-pointers/"/>
    <url>/2020/07/21/2020-7-30-pointers/</url>
    
    <content type="html"><![CDATA[<h1 id="多指针问题-amp-脑筋急转弯"><a href="#多指针问题-amp-脑筋急转弯" class="headerlink" title="多指针问题&amp;脑筋急转弯"></a>多指针问题&amp;脑筋急转弯</h1><hr><blockquote><ol><li><p><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></p></li><li><p><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p></li><li><p><a href="https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">删除最短的子数组使剩余数组有序</a></p></li><li><a href="https://leetcode-cn.com/problems/string-compression/">压缩字符串</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表II（快慢指针）（Medium）</a></li></ol><h3 id="脑筋急转弯系列"><a href="#脑筋急转弯系列" class="headerlink" title="脑筋急转弯系列"></a>脑筋急转弯系列</h3><ol><li><p><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列（即C++内置next_permutation）(Medium)</a></p></li><li><p><a href="https://leetcode-cn.com/problems/remove-k-digits/">移掉k位数字（Medium）</a></p></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">去除重复字母（Medium）</a></li><li><a href="https://leetcode-cn.com/problems/create-maximum-number/">拼接最大数（hard）</a></li><li><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/">不同字符的最小子序列（Medium）</a></li></ol></blockquote><h1 id="多指针问题"><a href="#多指针问题" class="headerlink" title="多指针问题"></a>多指针问题</h1><p>很多时候多指针（双指针，三指针，快慢指针）能极大的帮助我们降低时间复杂度。</p><p>比如求链表到数第N个节点，以及判断链表中是否有环。</p><p>首先我们介绍Floyd判圈法</p><h2 id="Floyd判圈法"><a href="#Floyd判圈法" class="headerlink" title="Floyd判圈法"></a>Floyd判圈法</h2><p><strong>想法</strong></p><p>当然一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。</p><p><strong>算法</strong></p><p>Floyd 的算法被划分成两个不同的 阶段 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 null 并退出。否则，用 相遇节点 来找到环的入口。</p><p>阶段 1</p><p>这里我们初始化两个指针 - 快指针和慢指针，分别位于链表头。我们每次移动慢指针一步、快指针两步，直到快指针无法继续往前移动。如果在某次移动后，快慢指针指向了同一个节点，我们就返回它。否则，我们继续，直到 while 循环终止且没有返回任何节点，这种情况说明没有成环，我们返回 null 。</p><p>下图说明了这个算法的工作方式：</p><p><img src="..\img\floyd.jpg" alt="image.png" style="zoom:50%;" /></p><p>环中的节点从 0 到 $C-1$ 编号，其中 $C$ 是环的长度。非环节点从 $-F$ 到 $−1 $编号，其中 $F$ 是环以外节点的数目。 $F$ 次迭代以后，慢指针指向了 0 且快指针指向某个节点 $h$ ，其中 $F≡h(modC)$ 。这是因为快指针在 $F$ 次迭代中遍历了 $2F$ 个节点，且恰好有 $F$ 个在环中。继续迭代 $C-h$ 次，慢指针显然指向第 $C-h$ 号节点，而快指针也会指向相同的节点。原因在于，快指针从 $h$ 号节点出发遍历了 $2(C-h)$ 个节点。</p><script type="math/tex; mode=display">h+2(C−h)=2C−h≡C−h(modC)</script><p>因此，如果列表是有环的，快指针和慢指针最后会同时指向同一个节点，因此被称为 <strong>相遇</strong> 。</p><p>阶段 2</p><p>给定阶段 1 找到的相遇点，阶段 2 将找到环的入口。首先我们初始化额外的两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p><p>下面的图将更好的帮助理解和证明这个方法的正确性。</p><p><img src="..\img\floyd2.jpg" alt="image.png" style="zoom:50%;" /></p><p>我们利用已知的条件：慢指针移动 1 步，快指针移动 2 步，来说明它们相遇在环的入口处。（下面证明中的 tortoise 表示慢指针，hare 表示快指针）</p><script type="math/tex; mode=display">\begin{aligned} 2 \cdot distance(tortoise) &= distance(hare) \\ 2(F+a) &= F+a+b+a \\ 2F+2a &= F+2a+b \\ F &= b \\ \end{aligned}</script><p>因为 $F=b$ ，指针从 $h$ 点出发和从链表的头出发，最后会遍历相同数目的节点后在环的入口处相遇。</p><p>444题可作为练习。</p><hr><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，</em>b，c 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><pre><code class="hljs angelscript">给定数组 nums = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>]，和 target = <span class="hljs-number">0</span>。满足要求的四元组集合为：[  [<span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],  [<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],  [<span class="hljs-number">-2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]</code></pre><hr><p>这是一道非常经典的多指针题目，题目的条件设计的是如此特殊，以至于 用多指针恰到好处。</p><p>原因是：1. 四个数而不是任意多的数，因此可以用有限多的指针进行记录。2. 题目要求求所有不重复的结果，指针可以在数组上滑动，自然能产生不同结果，去重是多指针的特长。3.这道题不适合用dfs，原因是dfs会产生很多分支$O(2^N)$量级，很容易TLE。而使用多指针，时间复杂度为$O(n^3)$。</p><p>为了避免枚举到重复四元组，则需要保证每一重循环枚举到的元素不小于其上一重循环枚举到的元素，且在同一重循环中不能多次枚举到相同的元素。</p><p>为了实现上述要求，可以对数组进行排序，并且在循环过程中遵循以下两点：</p><ul><li><p>每一种循环枚举到的下标必须大于上一重循环枚举到的下标；</p></li><li><p>同一重循环中，如果当前元素与上一个元素相同，则跳过当前元素。</p></li></ul><p>我们再分情况讨论：</p><p>使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。假设两重循环枚举到的前两个数分别位于下标$i$ 和 $j$，其中 $i&lt;j$。初始时，左右指针分别指向下标 $j+1$ 和下标 $n-1$。每次计算四个数的和，并进行如下操作：</p><ul><li><p>如果和等于 $target$，则将枚举到的四个数加到答案中，然后将左指针右移直到遇到不同的数，将右指针左移直到遇到不同的数；</p></li><li><p>如果和小于 $target$，则将左指针右移一位；</p></li><li><p>如果和大于 $target$，则将右指针左移一位。</p></li></ul><p>具体的剪枝可以看代码。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">fourSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; quadruplets;        <span class="hljs-keyword">if</span> (nums.size() &lt; <span class="hljs-number">4</span>) &#123;            <span class="hljs-keyword">return</span> quadruplets;        &#125;        sort(nums.begin(), nums.end());        <span class="hljs-keyword">int</span> length = nums.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">3</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//剪枝</span>            &#125;            <span class="hljs-keyword">if</span> (nums[i] + nums[length - <span class="hljs-number">3</span>] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target) &#123;                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//下一层迭代的的条件</span>            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length - <span class="hljs-number">2</span>; j++) &#123;                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>, right = length - <span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span> (left &lt; right) &#123;                    <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];                    <span class="hljs-keyword">if</span> (sum == target) &#123;                        quadruplets.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;                            left++;                        &#125;                        left++;                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;                            right--;                        &#125;                        right--;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;                        left++;                    &#125; <span class="hljs-keyword">else</span> &#123;                        right--;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> quadruplets;    &#125;&#125;;</code></pre><p>类似：<a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a> 不过这个题只用哈希表做就行了，稍索然无味。</p><hr><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75.颜色分类"></a>75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]输出: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]</code></pre><hr><p>我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。</p><p><img src="\img\pointer1.jpg" alt="image.png"></p><p>此题思路很直观，本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p><p>但是细节很需要注意，细节往往能致人于死地。</p><ol><li>中间指针curr起始位置为0，不是1，为什么？</li><li>若nums[curr]==0，则与nums[p0]互换时curr++，而nums[curr]==1，curr不需要—，为什么？</li></ol><p>这两个问题实质是相同的，我们需要让curr在p0前面，去接近p1，相当于给你一个方向，你去前进。这样理解会不会好些。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>, mid =<span class="hljs-number">0</span>, end = nums.size()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(begin&lt;=mid &amp;&amp; mid&lt;=end)        &#123;            <span class="hljs-comment">// mid = begin;</span>            <span class="hljs-keyword">if</span>(nums[mid]==<span class="hljs-number">0</span>)            &#123;                swap(nums[mid],nums[begin]);                begin++;                mid ++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==<span class="hljs-number">2</span>)            &#123;                swap(nums[mid],nums[end]);                end--;            &#125;            <span class="hljs-keyword">else</span> mid ++;                    &#125;    &#125;&#125;;</code></pre><hr><h2 id="1574-删除最短的子数组使剩余数组有序"><a href="#1574-删除最短的子数组使剩余数组有序" class="headerlink" title="1574.删除最短的子数组使剩余数组有序"></a>1574.<a href="https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">删除最短的子数组使剩余数组有序</a></h2><p>给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。</p><p>一个子数组指的是原数组中连续的一个子序列。</p><p>请你返回满足题目要求的最短子数组的长度。</p><p>示例 1：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]输出：<span class="hljs-number">3</span>解释：我们需要删除的最短子数组是 [<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] ，长度为 <span class="hljs-number">3</span> 。剩余元素形成非递减数组 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>] 。</code></pre><p>另一个正确的解为删除子数组 [3,10,4] 。<br>示例 2：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">4</span>解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 <span class="hljs-number">4</span> 的子数组，要么删除 [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]，要么删除 [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]。</code></pre><p>示例 3：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">0</span>解释：数组已经是非递减的了，我们不需要删除任何元素。</code></pre><p>示例 4：</p><pre><code class="hljs angelscript">输入：arr = [<span class="hljs-number">1</span>]输出：<span class="hljs-number">0</span></code></pre><p>提示：</p><p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>0 &lt;= arr[i] &lt;= 10^9</code></p><hr><p>双指针，先找出最大有序前缀pre和最大有序后缀suf, 若pre==n则表示全部有序，若pre == suf &amp;&amp; suf == 0则表示全部逆序</p><p>  前缀指针i和后缀指针j，i从0开始，j从后缀起点开始, </p><ul><li><p>如果arr[i] &lt;= arr[j]，则表示[0:i]和[j:-1]可以形成升序，计算值并和min比较</p><p>然后前缀指针右移，选择更大的值进行比较</p></li><li><p>如果arr[i] &gt; arr[j]，则表示后缀值过小，后缀向后移直到能形成升序</p></li></ul><p>「左指针是用来缩小距离，右指针是用来组成非降序」！</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfShortestSubarray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;    <span class="hljs-keyword">if</span>(arr.size()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//双指针，先找出最大有序前缀pre和最大有序后缀suf</span>    <span class="hljs-comment">//若pre==n则表示全部有序，若pre == suf &amp;&amp; suf == 0则表示全部逆序</span>    <span class="hljs-comment">// 前缀指针i和后缀指针j，i从0开始，j从后缀起点开始</span>    <span class="hljs-comment">// 如果arr[i] &lt;= arr[j]，则表示[0:i]和[j:-1]可以形成升序，计算值并和min比较</span>    <span class="hljs-comment">//然后前缀指针右移，选择更大的值进行比较</span>    <span class="hljs-comment">// 如果arr[i] &gt; arr[j]，则表示后缀值过小，后缀向后移直到能形成升序</span>    <span class="hljs-comment">//前缀指针的作用是缩小距离，后缀指针作用是形成升序</span>    <span class="hljs-keyword">int</span> n = arr.size();    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, suf = n<span class="hljs-number">-1</span>;<span class="hljs-comment">//分别记录最长前缀的下标和最长后缀的下标</span>    <span class="hljs-keyword">while</span>(pre+<span class="hljs-number">1</span>&lt;n &amp;&amp; arr[pre] &lt;= arr[pre+<span class="hljs-number">1</span>]) pre++;    <span class="hljs-keyword">while</span>(suf&gt;<span class="hljs-number">0</span> &amp;&amp; arr[suf<span class="hljs-number">-1</span>] &lt;= arr[suf]) suf--;    <span class="hljs-keyword">if</span>(pre+<span class="hljs-number">1</span> == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//全部升序</span>    <span class="hljs-keyword">if</span>(suf == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//全部逆序</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = suf;        <span class="hljs-comment">//只选择前缀或后缀需要删除的最小数量</span>    <span class="hljs-keyword">int</span> res = min(n-pre<span class="hljs-number">-1</span>, suf);    <span class="hljs-keyword">while</span>(i&lt;=pre &amp;&amp; j&lt;n  &amp;&amp; i &lt;= j)    <span class="hljs-keyword">if</span>(arr[i] &lt;= arr[j])             res = min(res,j-(++i));    <span class="hljs-keyword">else</span> j++;    <span class="hljs-keyword">return</span> res;        &#125;&#125;;</code></pre><p>时间复杂度: $O(N)$, </p><p>空间复杂度：$O(1)$</p><hr><h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></h2><p>给定一组字符，使用<a href="https://baike.baidu.com/item/原地算法">原地算法</a>将其压缩。</p><p>压缩后的长度必须始终小于或等于原数组长度。</p><p>数组的每个元素应该是长度为1 的<strong>字符</strong>（不是 int 整数类型）。</p><p>在完成<a href="https://baike.baidu.com/item/原地算法">原地</a><strong>修改输入数组</strong>后，返回数组的新长度。</p><p><strong>进阶：</strong><br>你能否仅使用O(1) 空间解决问题？</p><p><strong>示例 1：</strong></p><pre><code class="hljs smalltalk">输入：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>]输出：返回 <span class="hljs-number">6</span> ，输入数组的前 <span class="hljs-number">6</span> 个字符应该是：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;2&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;2&quot;</span>,<span class="hljs-comment">&quot;c&quot;</span>,<span class="hljs-comment">&quot;3&quot;</span>]说明：<span class="hljs-comment">&quot;aa&quot;</span> 被 <span class="hljs-comment">&quot;a2&quot;</span> 替代。<span class="hljs-comment">&quot;bb&quot;</span> 被 <span class="hljs-comment">&quot;b2&quot;</span> 替代。<span class="hljs-comment">&quot;ccc&quot;</span> 被 <span class="hljs-comment">&quot;c3&quot;</span> 替代。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>]</span>输出：返回 1 ，输入数组的前 1 个字符应该是：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>]</span>解释：没有任何字符串被替代。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs smalltalk">输入：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>]输出：返回 <span class="hljs-number">4</span> ，输入数组的前<span class="hljs-number">4</span>个字符应该是：[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;1&quot;</span>,<span class="hljs-comment">&quot;2&quot;</span>]。解释：由于字符 <span class="hljs-comment">&quot;a&quot;</span> 不重复，所以不会被压缩。<span class="hljs-comment">&quot;bbbbbbbbbbbb&quot;</span> 被 “b12” 替代。注意每个数字在数组中都有它自己的位置。</code></pre><p><strong>提示：</strong></p><ul><li>所有字符都有一个ASCII值在<code>[35, 126]</code>区间内。</li><li><code>1 &lt;= len(chars) &lt;= 1000</code>。</li></ul><hr><p>使用双指针，将产生立竿见影的效果。</p><p>用一个指针p1作为锚点，指示一个特定字符，而p2则在p1基础上进行滑动，计算后面有多少个与锚点相同的字符。p4用于指示下一个锚点，是所有指针中最快的，res用于记录原地替换的长度。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars)</span> </span>&#123;        <span class="hljs-comment">//使用双指针,注意原地替换只考虑被替换部分的值</span>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>,p4 = <span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = chars.length;        <span class="hljs-keyword">while</span>(p1 &lt; n)        &#123;            <span class="hljs-keyword">char</span> c = chars[p1];            p2 = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(p4 &lt; n &amp;&amp; chars[p4] == c) &#123;p2++;p4++;&#125;            chars[res++] = c;            <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;            <span class="hljs-comment">//将p2按位分解进行替换</span>            p1 = p4;            <span class="hljs-keyword">if</span>(p2&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果只有一个字符则不进行替换</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> it: (<span class="hljs-string">&quot;&quot;</span> + p2).toCharArray())            &#123;                chars[res++] = it;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p>这里使用了技巧</p><p><code>(&quot;&quot; + p2).toCharArray()</code>将整型数直接转换为字符数组进行操作。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，其中 $N$ 是 <code>chars</code> 的长度。</li><li>空间复杂度：$O(1)$，三个指针的占用空间。</li></ul><h1 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h1><p>推荐题解：<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/">一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～</a></p><p>有一种思想叫<strong>正难则反</strong>。下面这几题就可以很好体现。</p><p>比如<a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a>，题目问的是不断移除两端的数，使得x刚好减到0，我们倒过来想，所谓操作数最小，不就是两端的移去的数最少吗？也就是中间那部分最大。所以我们只要用一个<strong>滑动窗口</strong>，保证窗口的和为$sum-x$且长度最大即可，问题迎刃而解。</p><p>比如说 ，<a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字</a>，移除的反面是添加，我们添加「移除剩下来的数」，移除的数「直接跳过」就好了。这道题的本质是单调栈。</p><p>然后我们看一下402的升级版，<a href="https://leetcode-cn.com/problems/create-maximum-number/">321. 拼接最大数</a>，一个数组变成了两个数组，要从某个两个数组里挑选k个数，反过来想就是两个数组移除$d = n+m-k$个数，使得结果最大，这样我们可以分别枚举两个数组分别移除$i$，和$d-i$个数，函数就是402稍微从剩下最小数改变成最大数。然后用归并排序类似的合并就好了。</p><hr><h4 id="321-拼接最大数"><a href="#321-拼接最大数" class="headerlink" title="321. 拼接最大数"></a><a href="https://leetcode-cn.com/problems/create-maximum-number/">321. 拼接最大数</a></h4><p>给定长度分别为 <code>m</code> 和 <code>n</code> 的两个数组，其元素由 <code>0-9</code> 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 <code>k (k &lt;= m + n)</code> 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p><p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 <code>k</code> 的数组。</p><p><strong>说明:</strong> 请尽可能地优化你算法的时间和空间复杂度。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入:nums1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]nums2 = [<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>]k = <span class="hljs-number">5</span>输出:[<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入:nums1 = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]nums2 = [<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>]k = <span class="hljs-number">5</span>输出:[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>]</code></pre><p><strong>示例 3:</strong></p><pre><code class="hljs angelscript">输入:nums1 = [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]nums2 = [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>]k = <span class="hljs-number">3</span>输出:[<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]</code></pre><hr><p>按照上述思路我们需要注意的是，因为返回数组，所以不用考虑前导0问题，然后合并的时候如果两个数相等，我们要继续比较后面的数，直到两个数不等或者到达数组尾部，比如<code>9,8,3</code>和<code>3,4,6,5</code>，k = 7, 我们希望得到<code>9,8,3,4,6,5,3</code>。</p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">removeKdigits</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">//去除k个数使得结果最大 402稍微改一下</span>    <span class="hljs-keyword">int</span> n = num.size();    <span class="hljs-keyword">if</span>(n &lt;= k) <span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> num;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)    &#123;        <span class="hljs-keyword">int</span> cur = num[i];        <span class="hljs-keyword">int</span> nex = (i+<span class="hljs-number">1</span>&lt;n)?num[i+<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span> &amp;&amp; !res.empty()&amp;&amp;cur &gt; res.back())        &#123;            res.pop_back();            k--;            &#125;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span> ||cur &gt;= nex)         &#123;            res.push_back(num[i]);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>) k--;    &#125;    <span class="hljs-keyword">while</span>(!res.empty()&amp;&amp;k &gt; <span class="hljs-number">0</span>) &#123;res.pop_back();k--;&#125;    <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;a, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;b)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = a.size();        <span class="hljs-comment">//比较两个数组的大小，长度相同</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">if</span>(a[i]&lt;b[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]&gt;b[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;s1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;s2)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//类似于归并排序的合并</span>        <span class="hljs-keyword">int</span> m = s1.size(), n = s2.size();        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)        &#123;            <span class="hljs-keyword">if</span>(s1[i]&gt;s2[j])            ret.push_back(s1[i++]);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1[i]&lt;s2[j])            ret.push_back(s2[j++]);            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//如果两数相等，再超逐个比较下一位</span>                <span class="hljs-keyword">int</span> a = i, b = j;                <span class="hljs-keyword">while</span>(s1[a]==s2[b]) &#123;                    <span class="hljs-keyword">if</span>(a+<span class="hljs-number">1</span> &lt; m) a++;                                          <span class="hljs-keyword">if</span>(b+<span class="hljs-number">1</span> &lt; n) b++;                    <span class="hljs-keyword">if</span>(a+<span class="hljs-number">1</span>==m &amp;&amp; b+<span class="hljs-number">1</span>==n) <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span>(s1[a] &gt; s2[b]) ret.push_back(s1[i++]);                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1[a] &lt; s2[b]) ret.push_back(s2[j++]);                <span class="hljs-keyword">else</span>&#123;                    ret.push_back(s1[i++]);                    ret.push_back(s2[j++]);                    &#125;                &#125;        &#125;        <span class="hljs-keyword">while</span>(i&lt;m)            ret.push_back(s1[i++]);        <span class="hljs-keyword">while</span>(j&lt;n)            ret.push_back(s2[j++]);            <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = nums1.size(), n = nums2.size();        k = n+m-k;<span class="hljs-comment">//算出要移去多少个数</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; s1,s2,s3,res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= k;i++)<span class="hljs-comment">//暴力枚举</span>        &#123;            <span class="hljs-keyword">if</span>(i&gt;m||(k-i)&gt;n) <span class="hljs-keyword">continue</span>;            s1 = removeKdigits(nums1,i);<span class="hljs-comment">//取i个数且最大,402函数改一下</span>            s2 = removeKdigits(nums2,k-i);            s3 = merge(s1,s2);<span class="hljs-comment">//合并</span>             <span class="hljs-keyword">if</span>(res.empty()||larger(s3,res)) res = s3;                     &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【面试向】十种排序算法</title>
    <link href="/2020/07/21/2020-7-30-sorting-magic/"/>
    <url>/2020/07/21/2020-7-30-sorting-magic/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>排序算法及例题</p>          </div><h1 id="面试基础之十种排序算法"><a href="#面试基础之十种排序算法" class="headerlink" title="面试基础之十种排序算法"></a>面试基础之十种排序算法</h1><blockquote><p>包括冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序，计数排序，桶排序，基数排序。研究它们算法，以及最好最坏平均时间复杂度和空间复杂度，是否为就地替换以及稳定性。</p><p>排序不能只是为了解决排序而已，有时候利用排序的思想可以解决意想不到的的问题哦！</p><p>推荐阅读：<em><a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></em></p></blockquote><p><img src="\img\Sorting comparation.png" alt="Sorting comparation"></p><p><strong>复杂度</strong></p><ul><li><p>平方阶$O(n^2)$ 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p></li><li><p>线性对数阶$O(nlogn)$ 排序 快速排序、堆排序和归并排序,希尔排序；</p></li><li><p>线性阶$ O(n)$ 排序 计数排序，基数排序，此外还有桶、箱排序。</p></li></ul><p><strong>关于稳定性</strong></p><ul><li><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p></li><li><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p></li></ul><p><strong>名词解释</strong>：</p><ul><li>n：数据规模</li><li>k：”桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><p><strong>题目</strong></p><ul><li><ol><li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前k个高频元素</a><strong>（堆排序）</strong></li></ol></li><li><h4 id="215-数组中的第K个最大元素-快排板子"><a href="#215-数组中的第K个最大元素-快排板子" class="headerlink" title="215. 数组中的第K个最大元素 快排板子"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a> 快排板子</h4></li><li><h4 id="207-课程表（拓扑排序）"><a href="#207-课程表（拓扑排序）" class="headerlink" title="207. 课程表（拓扑排序）"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a>（拓扑排序）</h4></li><li><h4 id="210-课程表-II（拓扑排序）"><a href="#210-课程表-II（拓扑排序）" class="headerlink" title="210. 课程表 II（拓扑排序）"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a>（拓扑排序）</h4></li><li><p><a href="https://leetcode-cn.com/problems/reverse-pairs/">493. 翻转对</a>（Hard）<strong>归并排序板子</strong></p></li><li>1606.<a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">找到处理最多请求的服务器</a>(Hard) （堆排序思想）</li></ul><hr><h2 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p><h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p><h3 id="3-什么时候最快"><a href="#3-什么时候最快" class="headerlink" title="3. 什么时候最快"></a>3. 什么时候最快</h3><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="4-什么时候最慢"><a href="#4-什么时候最慢" class="headerlink" title="4. 什么时候最慢"></a>4. 什么时候最慢</h3><p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><hr><h2 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h2><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p><hr><h2 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h2><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h3 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><h3 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p><hr><h2 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h2><h3 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="1-算法步骤-3"><a href="#1-算法步骤-3" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p><p>按增量序列个数 k，对序列进行 k 趟排序；</p><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt="img"></p><hr><h2 id="1-5-归并排序"><a href="#1-5-归并排序" class="headerlink" title="1.5 归并排序"></a>1.5 归并排序</h2><h3 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的<strong>分而治之</strong>思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h3 id="3-动图演示"><a href="#3-动图演示" class="headerlink" title="3. 动图演示"></a>3. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mergePair</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l &gt;= r<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-comment">//进行局部排序</span>        <span class="hljs-keyword">int</span> leftSum = mergePair(nums,l,mid);        <span class="hljs-keyword">int</span> rightSum = mergePair(nums,mid,r);        <span class="hljs-keyword">int</span> m = mid, n = r;        <span class="hljs-keyword">int</span> pl = l, pr = mid, sumPair = <span class="hljs-number">0</span>;        <span class="hljs-comment">//合并两个排序数组</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(r-l+<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">while</span>(pl &lt; m &amp;&amp; pr &lt; n)        &#123;            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) nums[pl] &gt; (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)nums[pr]*<span class="hljs-number">2</span>) &#123;                <span class="hljs-comment">// cout&lt;&lt;pl&lt;&lt;&quot;,&quot;&lt;&lt;pr&lt;&lt;endl;</span>                sumPair += (m-pl);                pr++;            &#125;                        <span class="hljs-keyword">else</span> pl++;        &#125;        pl = l; pr = mid;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(pl &lt; m &amp;&amp; pr &lt; n)        &#123;            <span class="hljs-keyword">if</span>(nums[pl] &gt; nums[pr])             &#123;                sorted[i++] = nums[pr++];            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[pl] &lt; nums[pr])            &#123;                sorted[i++] = nums[pl++];            &#125;            <span class="hljs-keyword">else</span>            &#123;                sorted[i++] = nums[pr++];                sorted[i++] = nums[pl++];            &#125;                    &#125;        <span class="hljs-keyword">while</span>(pl &lt; m)        &#123;            sorted[i++] = nums[pl++];        &#125;        <span class="hljs-keyword">while</span>(pr &lt; n)        &#123;            sorted[i++] = nums[pr++];        &#125;        <span class="hljs-comment">//更新nums</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l;i &lt; r;i++)             nums[i] = sorted[i-l];        <span class="hljs-keyword">return</span> sumPair+leftSum+rightSum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        n = nums.size();        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//采用归并排序，采用分治思想,前提是数组已经有序</span>        <span class="hljs-comment">// cout&lt;&lt;endl;/</span>         <span class="hljs-keyword">return</span> mergePair(nums,<span class="hljs-number">0</span>,n);    &#125;&#125;;</code></pre><p>上面是根据493.写的归并板子，我们可以提取出几个优化的点：</p><ul><li>数组传递应该均采用引用传参！</li><li>在更新nums时候我们选择 <code>vector&lt;int&gt; sorted(r-l+1);</code>然后直接按下标赋值；而不是 <code>vector&lt;int&gt; sorted;</code>再进行<code>push_back</code>。 前者可以帮助我们节省大量时间，比如493 亲测帮助笔者节省了一倍时间。</li><li>遇到INT_MAX这样的问题直接long long就好了，不需要多想。</li></ul><hr><h2 id="1-6-快速排序"><a href="#1-6-快速排序" class="headerlink" title="1.6 快速排序"></a>1.6 快速排序</h2><blockquote><p>面试要点：平均时间复杂度$O(N\log N)$，最好情况$O(N\log N)$，最坏情况$O(N^2)$,空间复杂度O($\log N$)</p></blockquote><p>快速排序非常神奇但是很容易忘记，因此需要经常记忆。在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。</p><blockquote><p><em>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p></blockquote><p>快速排序$a[l…r]$是一个典型的分治算法，参考《算法导论》第七章P95。</p><h3 id="1-算法步骤-4"><a href="#1-算法步骤-4" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><h3 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><p>随机分区</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> q = randomPartition(a, l, r);        <span class="hljs-keyword">if</span> (q == index) &#123;            <span class="hljs-keyword">return</span> a[q];        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="hljs-number">1</span>, r, index) : quickSelect(a, l, q - <span class="hljs-number">1</span>, index);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomPartition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = rand() % (r - l + <span class="hljs-number">1</span>) + l;        swap(a[i], a[r]);        <span class="hljs-keyword">return</span> partition(a, l, r);    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> x = a[r], i = l - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = l; j &lt; r; ++j) &#123;            <span class="hljs-keyword">if</span> (a[j] &lt;= x) &#123;                swap(a[++i], a[j]);            &#125;        &#125;        swap(a[i + <span class="hljs-number">1</span>], a[r]);        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        srand(time(<span class="hljs-number">0</span>));        <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>, nums.size() - k);    &#125;&#125;;</code></pre><p>递归版本</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort_recursive</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;    <span class="hljs-keyword">if</span> (start &gt;= end)        <span class="hljs-keyword">return</span>;    T mid = arr[end];    <span class="hljs-keyword">int</span> left = start, right = end - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span>        <span class="hljs-keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="hljs-comment">//试图在左侧找到一个比枢纽元更大的元素</span>            left++;        <span class="hljs-keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="hljs-comment">//试图在右侧找到一个比枢纽元更小的元素</span>            right--;        <span class="hljs-built_in">std</span>::swap(arr[left], arr[right]); <span class="hljs-comment">//交换元素</span>    &#125;    <span class="hljs-keyword">if</span> (arr[left] &gt;= arr[end])        <span class="hljs-built_in">std</span>::swap(arr[left], arr[end]);    <span class="hljs-keyword">else</span>        left++;    quick_sort_recursive(arr, start, left - <span class="hljs-number">1</span>);    quick_sort_recursive(arr, left + <span class="hljs-number">1</span>, end);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;    quick_sort_recursive(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);&#125;</code></pre><p>迭代版本</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Range</span> &#123;</span>    <span class="hljs-keyword">int</span> start, end;    Range(<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>) &#123;        start = s, end = e;    &#125;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T arr[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;     <span class="hljs-comment">// r[]模擬堆疊,p為數量,r[p++]為push,r[--p]為pop且取得元素</span>    Range r[len];    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    r[p++] = Range(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span> (p) &#123;        Range range = r[--p];        <span class="hljs-keyword">if</span> (range.start &gt;= range.end)            <span class="hljs-keyword">continue</span>;        T mid = arr[range.end];        <span class="hljs-keyword">int</span> left = range.start, right = range.end - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            <span class="hljs-keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;            <span class="hljs-keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;            <span class="hljs-built_in">std</span>::swap(arr[left], arr[right]);        &#125;        <span class="hljs-keyword">if</span> (arr[left] &gt;= arr[range.end])            <span class="hljs-built_in">std</span>::swap(arr[left], arr[range.end]);        <span class="hljs-keyword">else</span>            left++;        r[p++] = Range(range.start, left - <span class="hljs-number">1</span>);        r[p++] = Range(left + <span class="hljs-number">1</span>, range.end);    &#125;&#125;</code></pre><hr><p>​        </p><h2 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7. 堆排序"></a>1.7. 堆排序</h2><blockquote><p>1606.<a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">找到处理最多请求的服务器</a>(Hard)</p></blockquote><hr><p>堆是一种数据结构，类似于树。它最好最坏，平均时间复杂度都是$O(\log n)$，也是不稳定排序。</p><blockquote><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p></blockquote><h3 id="1-算法步骤-5"><a href="#1-算法步骤-5" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>堆排序的原理如下，大顶堆排序对应升序，小顶堆排序对应降序。以大顶堆为例，我们将数组的N个元素构建成大顶堆，那么整个序列的最大值就是堆的根节点，我们将根节点与堆最后一个节点进行交换，再对余下的（N-1）个元素进行相同的操作，直到整个堆只有一个节点。</p><h3 id="2-动画演示"><a href="#2-动画演示" class="headerlink" title="2.动画演示"></a>2.动画演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="img"></p><p><strong>代码（大顶堆）</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">for</span> (; (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> &lt;= len;) &#123;            <span class="hljs-keyword">int</span> lson = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> rson = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> large;            <span class="hljs-keyword">if</span> (lson &lt;= len &amp;&amp; nums[lson] &gt; nums[i]) &#123;                large = lson;            &#125;            <span class="hljs-keyword">else</span> &#123;                large = i;            &#125;            <span class="hljs-keyword">if</span> (rson &lt;= len &amp;&amp; nums[rson] &gt; nums[large]) &#123;                large = rson;            &#125;            <span class="hljs-keyword">if</span> (large != i) &#123;                swap(nums[i], nums[large]);                i = large;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;            maxHeapify(nums, i, len);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>)nums.size() - <span class="hljs-number">1</span>;        buildMaxHeap(nums, len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len; i &gt;= <span class="hljs-number">1</span>; --i) &#123;            swap(nums[i], nums[<span class="hljs-number">0</span>]);            len -= <span class="hljs-number">1</span>;            maxHeapify(nums, <span class="hljs-number">0</span>, len);        &#125;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        heapSort(nums);        <span class="hljs-keyword">return</span> nums;    &#125;&#125;;</code></pre><p>小顶堆可以进行类比。</p><p>下面我们介绍一下各语言的内置堆结构</p><p><strong>C++</strong></p><blockquote><p>在<code>algorithm</code>头文件内</p></blockquote><pre><code class="hljs arduino">STL 堆操作（<span class="hljs-number">1</span>）make_heap()构造堆<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make_heap</span><span class="hljs-params">(first_pointer,end_pointer,compare_function)</span></span>;默认比较函数是(&lt;)，即最大堆。函数的作用是将[<span class="hljs-built_in">begin</span>,<span class="hljs-built_in">end</span>)内的元素处理成堆的结构，这个compare_function要自己写<span class="hljs-comment">//大顶堆</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MaxHeapCmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> x &lt; y;    &#125;&#125;;<span class="hljs-comment">//小顶堆</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MinHeapCmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> x &gt; y;    &#125;&#125;;（<span class="hljs-number">2</span>）push_heap()添加元素到堆<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_heap</span><span class="hljs-params">(first_pointer,end_pointer,compare_function)</span></span>;新添加一个元素在末尾，然后重新调整堆序。该算法必须是在一个已经满足堆序的条件下。先在<span class="hljs-built_in">vector</span>的末尾添加元素，再调用push_heap（<span class="hljs-number">3</span>）pop_heap()从堆中移出元素<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_heap</span><span class="hljs-params">(first_pointer,end_pointer,compare_function)</span></span>;把堆顶元素取出来，放到了数组或者是<span class="hljs-built_in">vector</span>的末尾。要取走，则可以使用底部容器（<span class="hljs-built_in">vector</span>）提供的pop_back()函数。先调用pop_heap再从<span class="hljs-built_in">vector</span>中pop_back元素（<span class="hljs-number">4</span>）sort_heap()对整个堆排序排序之后的元素就不再是一个合法的堆了。</code></pre><hr><h2 id="1-8-计数排序"><a href="#1-8-计数排序" class="headerlink" title="1.8 计数排序"></a>1.8 计数排序</h2><h3 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><ol><li>计数排序的特征</li></ol><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><h3 id="1-算法步骤-6"><a href="#1-算法步骤-6" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h3 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></p><h2 id="-6"><a href="#-6" class="headerlink" title=" "></a> </h2><hr><h2 id="1-9-桶排序"><a href="#1-9-桶排序" class="headerlink" title="1.9 桶排序"></a>1.9 桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h3><p>当输入的数据可以均匀的分配到每一个桶中。</p><h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h3><p>当输入的数据被分配到了同一个桶中。</p><h3 id="3-示意图"><a href="#3-示意图" class="headerlink" title="3. 示意图"></a>3. 示意图</h3><p>元素分布在桶中：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BUCKET_NUM = <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>&#123;</span>        explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125;        ListNode* mNext;        <span class="hljs-keyword">int</span> mData;&#125;;<span class="hljs-function">ListNode* <span class="hljs-title">insert</span><span class="hljs-params">(ListNode* head,<span class="hljs-keyword">int</span> val)</span></span>&#123;        ListNode dummyNode;        ListNode *newNode = <span class="hljs-keyword">new</span> ListNode(val);        ListNode *pre,*curr;        dummyNode.mNext = head;        pre = &amp;dummyNode;        curr = head;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;                pre = curr;                curr = curr-&gt;mNext;        &#125;        newNode-&gt;mNext = curr;        pre-&gt;mNext = newNode;        <span class="hljs-keyword">return</span> dummyNode.mNext;&#125;<span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode *head1,ListNode *head2)</span></span>&#123;        ListNode dummyNode;        ListNode *dummy = &amp;dummyNode;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span>!=head1 &amp;&amp; <span class="hljs-literal">NULL</span>!=head2)&#123;                <span class="hljs-keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;                        dummy-&gt;mNext = head1;                        head1 = head1-&gt;mNext;                &#125;<span class="hljs-keyword">else</span>&#123;                        dummy-&gt;mNext = head2;                        head2 = head2-&gt;mNext;                &#125;                dummy = dummy-&gt;mNext;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=head1) dummy-&gt;mNext = head1;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=head2) dummy-&gt;mNext = head2;               <span class="hljs-keyword">return</span> dummyNode.mNext;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> arr[])</span></span>&#123;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;ListNode*&gt; <span class="hljs-title">buckets</span><span class="hljs-params">(BUCKET_NUM,(ListNode*)(<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;                <span class="hljs-keyword">int</span> index = arr[i]/BUCKET_NUM;                ListNode *head = buckets.at(index);                buckets.at(index) = insert(head,arr[i]);        &#125;        ListNode *head = buckets.at(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;BUCKET_NUM;++i)&#123;                head = Merge(head,buckets.at(i));        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;                arr[i] = head-&gt;mData;                head = head-&gt;mNext;        &#125;&#125;</code></pre><hr><h2 id="1-10-基数排序"><a href="#1-10-基数排序" class="headerlink" title="1.10 基数排序"></a>1.10 基数排序</h2><h3 id="分类-算法"><a href="#分类-算法" class="headerlink" title="分类 算法"></a><em>分类</em> <a href="https://www.runoob.com/w3cnote_genre/algorithm">算法</a></h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>  <strong>LSD</strong>（Least significant digital）：排序方式由数值的最右边（低位）开始</p><p>  <strong>MSD</strong>（Most significant digital）：由数值的最左边（高位）开始。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>以LSD为例，假设原来有一串数值如下所示：</p><p>73, 22, 93, 43, 55, 14, 28, 65, 39, 81</p><ol><li>首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：</li></ol><pre><code class="hljs basic"><span class="hljs-number">0</span><span class="hljs-symbol">1 </span><span class="hljs-number">81</span><span class="hljs-symbol">2 </span><span class="hljs-number">22</span><span class="hljs-symbol">3 </span><span class="hljs-number">73</span> <span class="hljs-number">93</span> <span class="hljs-number">43</span><span class="hljs-symbol">4 </span><span class="hljs-number">14</span><span class="hljs-symbol">5 </span><span class="hljs-number">55</span> <span class="hljs-number">65</span><span class="hljs-number">6</span><span class="hljs-number">7</span><span class="hljs-symbol">8 </span><span class="hljs-number">28</span><span class="hljs-symbol">9 </span><span class="hljs-number">39</span></code></pre><ol><li>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</li></ol><p>81, 22, 73, 93, 43, 14, 55, 65, 28, 39</p><p>接着再进行一次分配，这次是根据十位数来分配：</p><pre><code class="hljs 0">01 142 22 283 394 435 556 657 738 819 93</code></pre><ol><li>接下来将这些桶子中的数值重新串接起来，成为以下的数列：</li></ol><p>14, 22, 28, 39, 43, 55, 65, 73, 81, 93</p><p>这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p><p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个<a href="https://baike.baidu.com/item/数组">数组</a>中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的<a href="https://baike.baidu.com/item/数组">数组</a>中。</p><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h3 id="2-LSD-基数排序动图演示"><a href="#2-LSD-基数排序动图演示" class="headerlink" title="2. LSD 基数排序动图演示"></a>2. LSD 基数排序动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3. 代码"></a>3. 代码</h3><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-comment">//LSD</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">//exp就是基数，每次扩大为10倍</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">buf</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//</span>    <span class="hljs-keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());<span class="hljs-comment">//maxval为最大的元素</span>    <span class="hljs-keyword">while</span> (maxVal &gt;= <span class="hljs-built_in">exp</span>) &#123; <span class="hljs-comment">//可以免去计算最大元素的位数</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//桶</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">int</span> digit = (nums[i] / <span class="hljs-built_in">exp</span>) % <span class="hljs-number">10</span>;<span class="hljs-comment">//计算数每一位在桶内数量</span>            cnt[digit]++;         &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            cnt[i] += cnt[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//这里相当于求前缀和，统计之前总共有多少数字</span>        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">int</span> digit = (nums[i] / <span class="hljs-built_in">exp</span>) % <span class="hljs-number">10</span>;<span class="hljs-comment">//从后往前</span>            buf[cnt[digit] - <span class="hljs-number">1</span>] = nums[i];<span class="hljs-comment">//更新buf，这里buf下标0相当于个位</span>            cnt[digit]--;        &#125;        copy(buf.begin(), buf.end(), nums.begin());<span class="hljs-comment">//更新nums数组</span>        <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>;<span class="hljs-comment">//基底乘10</span>    &#125;&#125;</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间效率: 设待排序列为$n$个记录，$d$个关键码，关键码的取值范围为$radix$，则进行链式基数排序的<a href="https://baike.baidu.com/item/时间复杂度">时间复杂度</a>为$O(d(n+radix))$，其中，一趟分配时间复杂度为$O(n)$，一趟收集时间复杂度为$O(radix)$，共进行d趟分配和收集。</li><li>空间效率：需要$2*radix$个指向队列的辅助空间，以及用于<a href="https://baike.baidu.com/item/静态链表">静态链表</a>的n个<a href="https://baike.baidu.com/item/指针">指针</a>。</li></ul><hr><h2 id="XI-拓扑排序"><a href="#XI-拓扑排序" class="headerlink" title="XI.拓扑排序"></a>XI.拓扑排序</h2><blockquote><p>LC 课程表问题系列：207 210</p><p>核心特性，对于图G中任何一条有向边$(u,v)$，$u$在排列中都出现在$v$的前面，这样的排列称为「拓扑排序」。</p></blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为<strong>拓扑排序</strong>。</p><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）：</p><ul><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li><li>若图中存在环，则不存在拓扑排序</li></ul><p><strong><em>重点</em></strong>：如何判断有无环：如果某个节点的相邻节点处于探索状态（在visited中），但还未加入拓扑序列，则说明有环。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">graph</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,num</span>):</span>        self.graph = defaultdict(list)        self.visited = &#123;&#125;         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params">self,u,v</span>):</span>        self.graph[u].append(v)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canFinish</span>(<span class="hljs-params">self, numCourses: int, prerequisites: [[int]]</span>) -&gt; bool:</span>        g = graph(numCourses+<span class="hljs-number">1</span>)           topo_sort = []        <span class="hljs-keyword">for</span> lists <span class="hljs-keyword">in</span> prerequisites:            g.visited[lists[<span class="hljs-number">0</span>]] = <span class="hljs-literal">False</span>            <span class="hljs-keyword">for</span> i,it <span class="hljs-keyword">in</span> zip(range(<span class="hljs-number">1</span>,len(lists)), lists):                g.graph[lists[i]].append(lists[<span class="hljs-number">0</span>])                g.visited[lists[i]] = <span class="hljs-literal">False</span>                        isLoop = <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prerequisites <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> prerequisites[<span class="hljs-number">0</span>]: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-comment">#只要存在一种拓扑排序，返回true</span>        <span class="hljs-comment">#定义三种状态，未探索，探索中以及已经探索</span>        <span class="hljs-comment">#A-&gt;B: 表示A是B的先修课</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">vertex</span>):</span>            <span class="hljs-keyword">nonlocal</span> isLoop            <span class="hljs-keyword">if</span> isLoop: <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vertex <span class="hljs-keyword">in</span> g.graph.keys():                g.visited[vertex] = <span class="hljs-literal">True</span> <span class="hljs-comment">#标记为已经访问</span>                topo_sort.append(vertex)                <span class="hljs-keyword">return</span> <span class="hljs-comment">#如果已经访问则跳过</span>            g.visited[vertex] = <span class="hljs-literal">True</span> <span class="hljs-comment">#标记为已经访问</span>            <span class="hljs-keyword">for</span> neigbor <span class="hljs-keyword">in</span> g.graph[vertex]:<span class="hljs-comment">#遍历邻接顶点</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> g.visited[neigbor] :                    dfs(neigbor)                <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> neigbor <span class="hljs-keyword">in</span> topo_sort:<span class="hljs-comment">#如果某个节点的相邻节点处于探索状态（在visited中），但还未加入拓扑序列，则说明有环</span>                    isLoop = <span class="hljs-literal">True</span>                    <span class="hljs-keyword">return</span>             topo_sort.append(vertex)                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> g.graph.keys():            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isLoop <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> g.visited[v]:                dfs(v)                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> isLoop</code></pre><blockquote><p>复杂度分析</p></blockquote><p>时间复杂度: $O(n+m)$，其中 $n$ 为课程数，$m$ 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p><p>空间复杂度: $O(n+m)$。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 $O(n+m)$。在深度优先搜索的过程中，我们需要最多 $O(n)$ 的栈空间（递归）进行深度优先搜索，并且还需要若干个 $O(n)$ 的空间存储节点状态、最终答案等。</p><h2 id="-7"><a href="#-7" class="headerlink" title=" "></a> </h2><hr>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2020/07/21/2020-07-21-dynamic-planning/"/>
    <url>/2020/07/21/2020-07-21-dynamic-planning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划(DP)的重要性我就不用说了，<code>LeetCode</code> 上DP问题数量仅次于数组。</p><p>个人感觉，DP问题就像斐波那契数列一样，你需要找到能够递归的通式子，我们把这个式子称作<strong>状态转移方程</strong>（$transfer  eqution$）。本文采取题目加讲解的方式，中等题目强调找出状态转移方程，难题则附加代码研究细节，此篇可作为你刷DP类问题的初探。题目中可能有一些显性关键词，如<strong>最大方案数，最短距离，所有可能结果，不同路径</strong>，暗示可能要采用dp。</p><p>记忆化搜索和dp是姊妹关系，前者强调<strong>以递归的方式自顶向下，保存中间结果</strong>，而后者强调<strong>以迭代否到方，式自底向上，直到最终结果</strong>。记忆化搜索没有dp那么直观，在特定的问题（如140）能发挥更好的效果，不过一般来说，会dp已经足够了。</p><p>dp问题解决<strong>步骤</strong>：</p><ul><li>定义dp数组含义</li><li>找出状态转移方程</li><li>确定初始条件和返回值</li><li>确定循环的结构</li></ul></blockquote><p>然后，现在我们干一件事情，把DP题目罗列出来，做了这么多题，我得到的启示是dp类问题没有套路，lc上题目多以中等和困难为主，唯一的方法就是多做题。如果想在周赛完成三题以上者，动态规划就是不得不迈过去的坎！</p><p><strong>入门</strong></p><ol><li><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a> (Easy)</li><li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a> (Easy)</li><li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a>(Easy)</li></ol><p><strong>提升</strong></p><ol><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径2</a>(Medium)</li></ol><p><strong>进阶</strong></p><ol><li><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的搜索二叉树</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a>(medium)</li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">最大字序和</a>(Easy)</li><li><a href="https://leetcode-cn.com/problems/word-break/solution/">单词拆分</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/word-break-ii/">单词拆分II(Hard)</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/perfect-squares">完全平方数</a>(Medium)</li><li><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大和</a>(Hard)</li></ol><p><strong>挑战</strong></p><ol><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/remove-boxes">移除盒子</a>(Hard)</li></ol><p><strong>实战</strong></p><ol><li><p><a href="https://leetcode-cn.com/problems/count-all-possible-routes/">统计所有可能路径</a>(Hard)</p></li><li><p><a href="https://leetcode-cn.com/problems/UlBDOe/">秋叶收藏集</a>(Medium)</p></li><li><p><a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/">统计不同回文子串数目</a>(Hard)</p></li><li><h4 id="两个子序列的最大点积-Hard"><a href="#两个子序列的最大点积-Hard" class="headerlink" title=" 两个子序列的最大点积(Hard)"></a><a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/"> 两个子序列的最大点积</a>(Hard)</h4></li></ol><p>配合<a href="http://zxi.mytechroad.com/blog/leetcode-problem-categories/?from=singlemessage">Huahua’s problem set</a>. 食用更佳！</p><hr><p>下面结合实例分析</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. <a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h2><p>非常经典！</p><p>用$dp[i]$表示爬上第i个梯子的方法数。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i] = dp[i-1] + dp[i-2];</script><p>边界条件: $dp[0] = 1, dp[1]=1$</p><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>用$dp[i]$表示爬上第i个梯子的<code>最小</code>消耗。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i] = min\{dp[i-1] + cost[i-1], dp[i-2] + cost[i-1]\};</script><p>边界条件: $dp[0] = 0, dp[1]=0$</p><p><strong>总结，这两题能这么做是因为，它们相邻两项的间距是恒定的要么为1，要么为2.</strong></p><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. <a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h2><blockquote><p>老dp了，还贪讷</p></blockquote><p>一眼看上去以为是跳跃游戏类似的贪心算法，没想到是老dp换了层皮。</p><p>以$dp[i]$表示前ii个元素中最大金额。<br>我们这样想，第$i-1$个元素$nums[i-1]$是否取到取决于前面一个元素是否取，如果前一个元素不取就是$dp[i-2]+nums[i-1]$，如果前一个元素取到就是$dp[i-1]$。</p><p>边值条件$dp[0]=0,dp[1]=nums[0]$，注意下标对应关系。</p><hr><p>再看跟路径有关的问题</p><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. <a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h2><p>用$dp[i][j]$表示从原点到达(m,n)的<code>最小</code>路径和。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i][j] = min(dp[i][j-1], dp[i-1][j])+grid[i][j];</script><p>边界条件: </p><script type="math/tex; mode=display">dp[0][i] = dp[0][i-1] + grid[0][i](0 \le{i}\le{m}), \\dp[j][0] = dp[j-1][0] + grid[j][0](0 \le{j}\le{n})</script><p>这题很特殊的地方是，先求完边界条件才能进行DP操作。</p><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. <a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h2><p>这题和上一题的区别是，不用管路径开销，这样的话我们可以把路径都设为1。</p><p>用$dp[i][j]$表示从原点到达(m,n)的<code>不同</code>路径数目。那么<br>状态转移方程 </p><script type="math/tex; mode=display">dp[i][j] = dp[i][j-1]+ dp[i-1][j];</script><p>边界条件: </p><script type="math/tex; mode=display">dp[0][i] = 1(0 \le{i}\le{m}), \\dp[j][0] = 1(0 \le{j}\le{n})</script><h2 id="63-不同路径2"><a href="#63-不同路径2" class="headerlink" title="63. 不同路径2"></a>63. <a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径2</a></h2><p>用$dp[i][j]$表示从<code>原点</code>到$(i,j)$的路径总数，只不过这题玩了一点花样，加入障碍物，和<code>62</code>异曲同工。上一题我们把边界，包括上边界和左边界，都设为1。这一题，我们想如果遇到障碍物在$(i,j)$，那么肯定$dp[i][j]=0$对吧？然后对于边界，一旦$dp[0][j]==0或dp[i][0]==0$表明，之后的全到不了，因为上左边界分别只有一条路径。</p><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{array}{lcl}dp[i-1][j]+dp[i][j-1],       & {obstacleGrid[i][j]!=1}\\0,     & {obstacleGrid[i][j]==1}\\\end{array} \right.</script><blockquote><p>边界</p><script type="math/tex; mode=display">dp[0][j] =\left\{ \begin{array}{lcr} 0, dp[0][j-1]!=0||obstacleGrid[0][j]==0\\1, {dp[0][j-1]!=0}\\\end{array} \right.\\,\\dp[i][0] =\left\{ \begin{array}{lcr} 0, {dp[i-1][0]==0||obstacleGrid[i][0]==0}\\1, {dp[i-1][0]!=0}\\\end{array} \right.</script></blockquote><p><strong>总结，因为路径问题只能向下或向右走和爬楼梯的只能走一步或者两步都是异曲同工的，把状态转移方程和边界条件想出来有助于快速解决问题</strong></p><hr><blockquote><p>此外，涉及到求规律的问题，一般先列出几项再使用dp</p></blockquote><h2 id="96-不同的搜索二叉树"><a href="#96-不同的搜索二叉树" class="headerlink" title="96. 不同的搜索二叉树"></a>96. 不同的搜索二叉树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">3</span>输出: <span class="hljs-number">5</span>解释:给定 n = <span class="hljs-number">3</span>, 一共有 <span class="hljs-number">5</span> 种不同结构的二叉搜索树:   <span class="hljs-number">1</span>         <span class="hljs-number">3</span>     <span class="hljs-number">3</span>      <span class="hljs-number">2</span>      <span class="hljs-number">1</span>    \       /     /      / \      \     <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     <span class="hljs-number">1</span>      <span class="hljs-number">1</span>   <span class="hljs-number">3</span>      <span class="hljs-number">2</span>    /     /       \                 \   <span class="hljs-number">2</span>     <span class="hljs-number">1</span>         <span class="hljs-number">2</span>                 <span class="hljs-number">3</span></code></pre><script type="math/tex; mode=display">f[i] = \begin{cases}2×(f[i-1]+···+f[(i-1)/2])+f[i/2]^2,i\%2!=0\\2×(f[i-1]+···+f[(i-1)/2])，otherwise\\\end{cases}</script><hr><p>事实上我们在方法一中推导出的 $G(n)$函数的值在数学上被称为卡塔兰数 $C_n $</p><p> 。卡塔兰数更便于计算的定义如下:$C_0 = 1, \qquad C_{n+1} = {2(2n+1)}/{n+2}C_n$,证明过程可以参考上述文献，此处不再赘述。</p><blockquote><p>下面我们看一些富有技巧而实际很简单 的dp问题</p></blockquote><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>输出: <span class="hljs-number">4</span></code></pre><hr><p>可以使用动态规划降低时间复杂度。我们用 $dp(i, j)$ 表示以 $(i, j)$ 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 $dp(i, j)$的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置$(i, j)$,检查在矩阵中该位置的值：</p><p>如果该位置的值是 0，则 $dp(i,j)=0$，因为当前位置不可能在由 1 组成的正方形中；</p><p>如果该位置的值是 1，则 $dp(i, j)$ 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><script type="math/tex; mode=display">dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</script><p>形子矩阵的官方题解，其中给出了详细的证明。</p><p>此外，还需要考虑边界条件。如果 $i$ 和 $j$ 中至少有一个为 $0$，则以位置 $(i,j)$ 为右下角的最大正方形的边长只能是 1，因此 $dp(i, j) = 1$。</p><blockquote><p>扩展85.最大矩形(Hard)<br>1277.统计全为1的正方形子矩阵</p></blockquote><hr><h2 id="53-最大字序和"><a href="#53-最大字序和" class="headerlink" title="53. 最大字序和"></a>53. <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">最大字序和</a></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><pre><code class="hljs angelscript">示例:输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。</code></pre><p>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><hr><p>一般人思路是暴力法，我承认，这的确很舒服，但是告诉你有$O(n)$的方法，你会怎么想呢。</p><p>用$dp[i]$，如何表示才具有可行性。刚开始想的是序号从$0-n-1$的最大字序和。后来发现存在$dp[i-1]与nums[i-1]$断开的情况，而且中间的和一定不大于0. 官解给的是 <em>以第i个数结尾的连续数组最大和。</em>也就是不存在断开的情况。妙，实在是妙！</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1]+nums[i-1],num[i-1])</script><p>max里面前者表示存在新的后续元素使之更大，后者是新元素比原来的和更大。</p><blockquote><p> 边界条件：</p></blockquote><p>$dp[0] = 0$</p><p>此外还可以用滚动数组降低空间复杂度。</p><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]输出: <span class="hljs-literal">true</span>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。</code></pre><hr><p>这一题可以正好填补一些我们思路上的空白。即，动态规划的迭代并不一定是连续的，很有可能存在跳跃。</p><p>用$dp[i]$表示s前i个字符能否由字典中单词组成。那么$dp[i]=dp[j] \text{and}  dict.check(s.substr(j,i-j));$，check在这里检查$s[j:i-1]$与字典中某一个单词匹配。初始条件为$dp[0]=true$空字符一定匹配，实际上，dp中大部分元素都是$false$。</p><h2 id="140-单词拆分II"><a href="#140-单词拆分II" class="headerlink" title="140.单词拆分II"></a>140.单词拆分II</h2><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p><strong>说明：</strong></p><ul><li>分隔时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;catsanddog&quot;</span>wordDict = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>]<span class="hljs-section">输出:</span>[  <span class="hljs-string">&quot;cats and dog&quot;</span>,  <span class="hljs-string">&quot;cat sand dog&quot;</span>]</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;pineapplepenapple&quot;</span>wordDict = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>, <span class="hljs-string">&quot;applepen&quot;</span>, <span class="hljs-string">&quot;pine&quot;</span>, <span class="hljs-string">&quot;pineapple&quot;</span>]<span class="hljs-section">输出:</span>[  <span class="hljs-string">&quot;pine apple pen apple&quot;</span>,  <span class="hljs-string">&quot;pineapple pen apple&quot;</span>,  <span class="hljs-string">&quot;pine applepen apple&quot;</span>]<span class="hljs-section">解释: 注意你可以重复使用字典中的单词。</span></code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;catsandog&quot;</span>wordDict = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<span class="hljs-section">输出:</span>[]</code></pre><hr><p>这一题是139单词拆分的进阶版。只不过要求返回所有结果，我们可以用DP或者记忆化搜索来做。我们思考，如果采用动态规划，是自底向上的，我们无法判断拆分的可行性，导致大量<strong>冗余无效</strong>的状态转移。比如：</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;aaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaaaaa&quot;</span>]</code></pre><p>s中包含b，而单词列表不包含，自底向上仍然会对每个下标进行大量匹配，导致TLE。</p><p>更好的做法是「记忆化搜索」。</p><p>我们用哈希表存储中间结果，以达到降低时间复杂度的目的。</p><p>我们用$dp[i]$表示 $s[i\rightarrow n-1]$，其中n表示s的大小，能够拆分成单词的所有结果。</p><p>我们在$index==n$时候再进行初始化$dp[index]$数组，此时正是最大迭代深度。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; dp;    <span class="hljs-comment">//dp[i]保存i~n-1的所有可能单词拆分（含空格）</span>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; wordSet;    <span class="hljs-keyword">int</span> n;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;    n = s.size();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;w:wordDict)        wordSet.insert(w);    backtrack(s,<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">int</span> index)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//进行记忆化搜索</span>        <span class="hljs-keyword">if</span>(!dp.count(index))        &#123;<span class="hljs-comment">//如果没有更新这个dp</span>            <span class="hljs-comment">//初始化一下dp</span>            <span class="hljs-keyword">if</span>(index == n)            &#123;                dp[index] = &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;                <span class="hljs-keyword">return</span> ;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = index+<span class="hljs-number">1</span>;j &lt;= n;j++)            &#123;                <span class="hljs-built_in">string</span> word = s.substr(index,j-index);<span class="hljs-comment">//向前回溯</span>                <span class="hljs-keyword">if</span>(wordSet.count(word))                &#123;                    <span class="hljs-comment">// cout&lt;&lt;&quot;word:&quot;&lt;&lt;word&lt;&lt;endl;</span>                    backtrack(s,j);                    <span class="hljs-comment">//更新dp</span>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it: dp[j])                        dp[index].push_back(it.empty()?word:word+<span class="hljs-string">&quot; &quot;</span>+it);                &#125;            &#125;        &#125;    &#125;&#125;;</code></pre><p>观察代码，我们先把递归任务完成，再逐渐把单词加入到dp中，此时dp只会被更新一次，极大的降低了时间复杂度。</p><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">6</span>解释: 子数组 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 有最大乘积 <span class="hljs-number">6</span>。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>]输出: <span class="hljs-number">0</span>解释: 结果不能为 <span class="hljs-number">2</span>, 因为 [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>] 不是子数组。</code></pre><hr><p>这道题我们很容易陷入惯性思维，与最大子序和相似，我们可以设定$dp[i]$为以$nums[i-1]$为末尾的最大乘积，很容易知道 </p><script type="math/tex; mode=display">dp[i]=max\{dp[i-1]*nums[i-1],nums[i-1]\}</script><p>但是这一题与53不同的是，负负得正，比如$[-9,1,-8]$得到最大和是72而不是1. 所以我们需要分类讨论，$num[i-1]$正负性，还要设计一个求最小积的$mdp[i]$，与求最大积$Mdp[i]$相对，具体如下：</p><script type="math/tex; mode=display">Mdp=\begin{cases}    \max\{Mdp[i-1]*nums[i-1],nums[i-1]\},nums[i-1]>0\\    \max\{mdp[i-1]*nums[i-1],nums[i-1]\},otherwise\\    \end{cases}\\    \\    \\    \\mdp=\begin{cases}    \min\{mdp[i-1]*nums[i-1],nums[i-1]\},nums[i-1]>0\\    \min\{Mdp[i-1]*nums[i-1],nums[i-1]\},otherwise\\    \end{cases}</script><p>初始条件$mdp[1]=nums[0],Mdp[1]=nums[0].$</p><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">12</span>输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4.</span></code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: n = <span class="hljs-number">13</span>输出: <span class="hljs-number">2</span>解释: <span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9.</span></code></pre><hr><p>这个例子表明dp算法可以和其它算法结合在一起，比如贪心算法。</p><p>我们设$minSquare(i)$表示数字$i$对应的最小完全平方数数目，那么：</p><script type="math/tex; mode=display">minSquare(i) = \min\limits_{1\le k < i}(minSqaure(i-k)+1)</script><p>但其实我们并不需要全部计算出$minSquare(i-k)$的值，因为中间结果可能出现$minSquare(i-k)$，因此我们可以采用哈希表加速。</p><blockquote><p>边界条件：minSquare(0)=0; // 注意这个条件是虚构的</p></blockquote><p>我们先找到小于n的所有完全平方数然后从1开始到n，找到最小数。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(n\cdot\sqrt{n})$，在主步骤中，我们有一个嵌套循环，其中外部循环是 $n$ 次迭代，而内部循环最多需要 $\sqrt{n}$ 迭代。</li><li>空间复杂度：$\mathcal{O}(n)$，使用了一个一维数组 dp。</li></ul><hr><blockquote><p>下面我们看一些复杂的DP问题。</p></blockquote><h2 id="410-分割数组的最大和"><a href="#410-分割数组的最大和" class="headerlink" title="410. 分割数组的最大和"></a>410. <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大和</a></h2><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>注意:<br>数组长度 n 满足以下条件:</p><ul><li>1 ≤ n ≤ 1000</li><li>1 ≤ m ≤ min(50, n)</li></ul><p>示例:<br><pre><code class="hljs angelscript">输入:nums = [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]m = <span class="hljs-number">2</span>输出:<span class="hljs-number">18</span>解释:一共有四种方法将nums分割为<span class="hljs-number">2</span>个子数组。其中最好的方式是将其分为[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] 和 [<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]，因为此时这两个子数组各自的和的最大值为<span class="hljs-number">18</span>，在所有情况中最小。</code></pre></p><hr><p><code>将数组分割为m段，求...</code>是动态规划的常见问法。</p><p>我们可以令$dp[i][j]$表示数组前$i$个数分割为$j$段，所能得到最大连续子数组和的最小值，我们可以考虑第$j$段的具体范围，即我们可以枚举$k$，将前$k$个数分割为$j-1$段，而第$k+1$到第$i$个数为第$j$段，此时，这$j$段数组中和的最大值等于$dp[k][j-1]$与$sum(k+1,i)$中和的较大值，其中$sum(a,b)$表示$nums[i]在[a,b]$的范围和。</p><p>状态转移方程：</p><script type="math/tex; mode=display">dp[i][j]=\min\limits_{k=0}^{i-1}(\max(dp[k][j-1],\sum\limits_{k+1}^i{nums[i]})</script><p>边界条件:</p><script type="math/tex; mode=display">dp[0][0] = 0;</script><p>时间复杂度: $O(n^2m)$,其中$n$是数组长度，$m$是分成非空的连续子数组个数，总状态数$O(n×m)$,状态转移时间$O(n)$。<br>空间复杂度：$O(n×m)$为动态规划数组开销。</p><blockquote><p>“我🤮饱了，后面还有吗” </p><p>“当然”</p></blockquote><p>下面介绍一下字符串中的dp解法，比如10. 正则表达式匹配 和 44. 通配符匹配。 都是很经典的dp。 寥寥几句足以把超复杂的可能性涵盖其中，真让人不尽感叹造物主的鬼斧神工。</p><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.<a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><pre><code class="hljs 1c">&#x27;.&#x27; 匹配任意单个字符&#x27;*&#x27; 匹配零个或多个前面的那一个元素</code></pre><p>所谓匹配，是要涵盖 整个字符串 s的，而不是部分字符串。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;aa&quot;</span>p = <span class="hljs-string">&quot;a&quot;</span><span class="hljs-section">输出: false</span><span class="hljs-section">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span></code></pre><p>示例 2:</p><pre><code class="hljs smalltalk">输入:s = <span class="hljs-comment">&quot;aa&quot;</span>p = <span class="hljs-comment">&quot;a*&quot;</span>输出: <span class="hljs-keyword">true</span>解释: 因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-comment">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。</code></pre><p>示例 3:</p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;ab&quot;</span>p = <span class="hljs-string">&quot;.*&quot;</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span></code></pre><p>示例 4:</p><pre><code class="hljs smalltalk">输入:s = <span class="hljs-comment">&quot;aab&quot;</span>p = <span class="hljs-comment">&quot;c*a*b&quot;</span>输出: <span class="hljs-keyword">true</span>解释: 因为 <span class="hljs-string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="hljs-string">&#x27;c&#x27;</span> 为 <span class="hljs-number">0</span> 个, <span class="hljs-string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="hljs-comment">&quot;aab&quot;</span>。</code></pre><p>示例5<br><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>s = <span class="hljs-string">&quot;mississippi&quot;</span>p = <span class="hljs-string">&quot;mis*is*p*.&quot;</span><span class="hljs-section">输出: false</span></code></pre></p><hr><p>我们用 $dp[i][j]$ 表示 s 的前 i 个字符与 pp 中的前 j 个字符是否能够匹配。在进行状态转移时，我们考虑 pp 的第 jj 个字符的匹配情况：</p><ul><li>如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母，即<script type="math/tex; mode=display">dp[i][j] =  (s[i-1]==p[j-1] \&\& dp[i-1][j-1]</script></li></ul><p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 ss 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p><ul><li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</p></li><li><p>不匹配字符，将该组合扔掉，不再进行匹配。</p></li></ul><p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{array}{lcr}dp[i-1][j]||dp[i][j-2],\ s[i]==p[j-1]\\dp[i][j-2],\ s[i]\ne p[j-1]\end{array}\right.</script><ul><li>在任意情况下，只要 $p[j]$ 是<code>.</code>，那么 $p[j]$ 一定成功匹配 ss 中的任意一个小写字母。</li></ul><p>最终的状态转移方程如下：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}\text{if}\ (p[j]\ne '*')=\begin{cases}dp[i-1][j-1], matches(s[i],p[j]) \\false, \ otherwise\end{cases}\\\\otherwise = \begin{cases}dp[i-1][j]\ || \ dp[i][j-2], matches(s[i],p[j-1])\\dp[i][j-2], otherwise\end{cases}\end{cases}</script><p>其中$\textit{matches}(x, y)$ 判断两个字符是否匹配的辅助函数。只有当 y 是 <code>.</code> 或者 x 和 y 本身相同时，这两个字符才会匹配。</p><blockquote><p> 细节</p></blockquote><p>动态规划的边界条件为 $ dp[0][0] = true $，即两个空字符串是可以匹配的。最终的答案即为 $dp[m][n]$，其中 m和 n 分别是字符串 s 和 p 的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。</p><p>在上面的状态转移方程中，如果字符串 p 中包含一个字符+星号的组合（例如 $a<em>$），那么在进行状态转移时，会先将 a 进行匹配（当 $p[j]$ 为 a 时），再将 a</em> 作为整体进行匹配（当 $p[j]$ 为 <em> 时）。然而，在题目描述中，我们必须将 a</em> 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。</p><p>C++代码</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>&#123;        <span class="hljs-keyword">int</span> m = s.size();        <span class="hljs-keyword">int</span> n = p.size();        <span class="hljs-keyword">auto</span> matches = [&amp;](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>];        &#125;;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;                    f[i][j] |= f[i][j - <span class="hljs-number">2</span>];                    <span class="hljs-keyword">if</span> (matches(i, j - <span class="hljs-number">1</span>)) &#123;                        f[i][j] |= f[i - <span class="hljs-number">1</span>][j];                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (matches(i, j)) &#123;                        f[i][j] |= f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> f[m][n];    &#125;&#125;;</code></pre><hr><h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a>44. <a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h2><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><pre><code class="hljs C++"><span class="hljs-string">&#x27;?&#x27;</span> 可以匹配任何单个字符。<span class="hljs-string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。两个字符串完全匹配才算匹配成功。</code></pre><p>说明:</p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li></ul><hr><p>我们用$dp[i][j]$表示s的第$i$个字符与p的第$j$个字符是否匹配。</p><ul><li><p>第一种情况是字母与字母匹配，即</p><script type="math/tex; mode=display">dp[i][j] =  (s[i-1]==p[j-1] \&\& dp[i-1][j-1])</script></li><li><p>第二种情况是$p[j]$是问好，则对$s[i]$没有任何要求</p><script type="math/tex; mode=display">dp[i][j] = (p[j-1]=='?'\&\&dp[i-1][j-1])</script></li><li><p>第三种情况，是遇到$’’*’’$，这种情况最为复杂，因为不知道星号要匹配多少个字符，这里很容易想到<code>回溯</code>方法，但是回溯一般会超时，著名的KMP算法是因为了避免回溯才会那么快。</p><p>所以我们想这个星号可以使用多次，也可以一次都不使用。</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j]||dp[i][j-1]</script><p>后面一项表示不使用星号，前面一项表示使用星号。</p><p>总结一下：</p><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{array}{lcr}s[i-1]==p[j-1] \&\& dp[i-1][j-1]，'a-z'\\p[j-1]=='?'\&\&dp[i-1][j-1],'?'\\dp[i-1][j]||dp[i][j-1], '*'\end{array}\right.</script></li></ul><blockquote><p>边界条件：</p><p>也就是$dp[0][0]$，我们不能单纯认为开始两个字符相等就是$dp[0][0]==True$。因为$p$有星号和问号开头的情况。<br>$dp[0][0]=(s[0]==p[0])||(p[0]==’?’)||(p[0]==’*’)$</p></blockquote><ol><li><p>若两个字符串为空，$dp[0][0]$也为True.</p><script type="math/tex; mode=display">dp[i][0]=!s.size()</script><p>即空字符串无法匹配非空字符串。</p></li><li><p>若s为空，p全为”*”，才能完成匹配。</p><script type="math/tex; mode=display">dp[0][j] = (p[j]=='*')\&\&dp[0][j-1]</script></li></ol><p>我们可以发现，$dp[i][0]$的值恒为假，$dp[0][j]$ 在 $j$ 大于模式 $p$ 的开头出现的星号字符个数之后，值也恒为假，而 $dp[i][j]$ 的默认值（其它情况）也为假，因此在对动态规划的数组初始化时，我们就可以将所有的状态初始化为 False，减少状态转移的代码编写难度。</p><p>此外还要考虑字符串的硬边界。此外，<strong>注意</strong>下标对$dp[i][j]$表示$s[i-1]$与$p[j-1]$匹配，因为下标是从0开始的。</p><p>Python 实现：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">self, s: str, p: str</span>) -&gt; bool:</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> s: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> p: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>             m = len(s); n = len(p)    dp = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>) ]    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>) <span class="hljs-keyword">or</span> (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">or</span> (s <span class="hljs-keyword">and</span> s[<span class="hljs-number">0</span>]==p[<span class="hljs-number">0</span>])     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">not</span> len(s)    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):        dp[<span class="hljs-number">0</span>][j] = (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">and</span> dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):            dp[i][j] = (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> \                        (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">and</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> \                        (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-keyword">and</span> (dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-keyword">or</span> dp[i][j<span class="hljs-number">-1</span>]))            print(<span class="hljs-string">&quot;(%d,%d):&quot;</span>%(i,j),dp[i][j])    <span class="hljs-keyword">return</span> dp[m][n]</code></pre><p>C++实现：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (!p.size() &amp;&amp; s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (!s.size() &amp;&amp; !p.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">int</span> m = s.size(), n = p.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)||(p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>)||(s.size()&amp;&amp;s[<span class="hljs-number">0</span>]==p[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++) dp[i][<span class="hljs-number">0</span>] = !s.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++) dp[<span class="hljs-number">0</span>][j] = (p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;*&#x27;</span>) &amp;&amp; dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++)        dp[i][j] = (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) || \                            (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) || \                            (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; (dp[i<span class="hljs-number">-1</span>][j] || dp[i][j<span class="hljs-number">-1</span>]));        <span class="hljs-keyword">return</span> dp[m][n];                &#125;&#125;;</code></pre><p>明显是C++要快些()，嘻嘻😂，而且内存占用要小些</p><p>老规矩，下面分析时间复杂度和空间复杂度.</p><p>时间复杂度：$O(MN)$</p><p>空间复杂度:$O(NM)$ $N和M$分别表示目标串和模式串的长度。我们可以使用<code>滚动数组</code>对空间进行优化，即用两个长度为 $n+1$ 的一维数组代替整个二维数组进行状态转移，空间复杂度为$ O(n)$。</p><p>当然这题也有贪心解法，有兴趣的小伙伴可以研究一下。</p><hr><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 <a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h2><p>这一题在LC上属于难题分类，但实际上通过率高达59.6%，是一道名副其实的<code>Easy</code>题。</p><p>但是我们想说的dp千变万化，不离其宗。题目做多了自然就有想法了。</p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><hr><p>我们用$dp[i][j]$表示word1前i个字符转换为word2前j个字符所需的<code>最小</code>操作数。 </p><p>然后在word1插入一个字符相当于$dp[i][j]=dp[i-1][j]+1$，一定会多出来一个步骤。</p><p>然后在word1删除一个字符相当于$dp[i][j]=dp[i][j-1]+1$，也一定会多出来一个步骤。</p><p>如果word1最后一个字符通过替换得到word2，那么要分情况，如果最后一个字符相同，那么$dp[i][j]=dp[i-1][j-1]$，否则$dp[i][j]=dp[i-1][j-1]+1$.</p><blockquote><p>边界条件 $dp[0][j] = j,dp[i][0]=i$</p></blockquote><p>就是完全的删除或者完全插入。</p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">string</span> word2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!word1.size()) <span class="hljs-keyword">return</span> word2.size();        <span class="hljs-keyword">if</span>(!word2.size()) <span class="hljs-keyword">return</span> word1.size();        <span class="hljs-comment">//dp[i][j]表示word1的前i位替换为word2前i位所需的最小步数</span>        <span class="hljs-keyword">int</span> m = word1.size(), n = word2.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (word1[<span class="hljs-number">0</span>]==word2[<span class="hljs-number">0</span>])? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=m ;i++) dp[i][<span class="hljs-number">0</span>] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ;j++) dp[<span class="hljs-number">0</span>][j] = j;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=m; i++ )        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++ )        &#123;            <span class="hljs-keyword">int</span> exchange = (word1[i<span class="hljs-number">-1</span>]==word2[j<span class="hljs-number">-1</span>])?dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]:dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;            dp[i][j] = min(exchange, min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>));        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;;</code></pre><blockquote><p>小伙伴如果有收获，请点赞留言哦Σ(っ °Д °;)っ</p></blockquote><hr><h2 id="5494-统计所有可行路径"><a href="#5494-统计所有可行路径" class="headerlink" title="5494. 统计所有可行路径"></a><a href="https://leetcode-cn.com/problems/count-all-possible-routes/">5494. 统计所有可行路径</a></h2><p>给你一个 互不相同 的整数数组，其中 locations[i] 表示第 i 个城市的位置。同时给你 start，finish 和 fuel 分别表示出发城市、目的地城市和你初始拥有的汽油总量</p><p>每一步中，如果你在城市 i ，你可以选择任意一个城市 j ，满足  j != i 且 0 &lt;= j &lt; locations.length ，并移动到城市 j 。从城市 i 移动到 j 消耗的汽油量为 |locations[i] - locations[j]|，|x| 表示 x 的绝对值。</p><p>请注意， fuel 任何时刻都 不能 为负，且你 可以 经过任意城市超过一次（包括 start 和 finish ）。</p><p>请你返回从 start 到 finish 所有可能路径的数目。</p><p>由于答案可能很大， 请将它对 10^9 + 7 取余后返回。</p><p>示例 1：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>], start = <span class="hljs-number">1</span>, finish = <span class="hljs-number">3</span>, fuel = <span class="hljs-number">5</span>输出：<span class="hljs-number">4</span>解释：以下为所有可能路径，每一条都用了 <span class="hljs-number">5</span> 单位的汽油：<span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span></code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], start = <span class="hljs-number">1</span>, finish = <span class="hljs-number">0</span>, fuel = <span class="hljs-number">6</span>输出：<span class="hljs-number">5</span>解释：以下为所有可能的路径：<span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">1</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">3</span><span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span></code></pre><p>示例 3：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">2</span>, fuel = <span class="hljs-number">3</span>输出：<span class="hljs-number">0</span>解释：没有办法只用 <span class="hljs-number">3</span> 单位的汽油从 <span class="hljs-number">0</span> 到达 <span class="hljs-number">2</span> 。因为最短路径需要 <span class="hljs-number">4</span> 单位的汽油。</code></pre><p>示例 4 ：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">0</span>, fuel = <span class="hljs-number">3</span>输出：<span class="hljs-number">2</span>解释：总共有两条可行路径，<span class="hljs-number">0</span> 和 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> 。</code></pre><p>示例 5：</p><pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">2</span>, fuel = <span class="hljs-number">40</span>输出：<span class="hljs-number">615088286</span>解释：路径总数为 <span class="hljs-number">2615088300</span> 。将结果对 <span class="hljs-number">10</span>^<span class="hljs-number">9</span> + <span class="hljs-number">7</span> 取余，得到 <span class="hljs-number">615088286</span> 。</code></pre><p>提示：</p><ul><li><code>2 &lt;= locations.length &lt;= 1001 &lt;= locations[i] &lt;= 10^9所有 locations 中的整数 互不相同 。0 &lt;= start, finish &lt; locations.length1 &lt;= fuel &lt;= 200</code></li></ul><hr><p>此题乃背包问题的变形。背包内有一些物品，拿相邻两个物品需要时间，这个时间取决于它们的重量差，一共给你<code>fuel</code>时间，问开始拿<code>start</code>物品，最后拿<code>finsih</code>物品有多少种可行方案。</p><p>老规矩，<strong>动态规划</strong>和<strong>记忆化搜索</strong>都能做。</p><p><strong>动态规划</strong></p><p>设$dp[i][f]$表示从起点到达第$i$个城市<strong>刚好消耗f个汽油</strong>的可行路径数。这里强调刚好是把问题变成离散化。刚开始容易想成最多消耗f汽油。这样做的问题是，会产生大量重复解。而刚好消耗则把总的汽油数进行恰当分解，得到结果唯一。</p><ul><li>状态转移方程：$dp[i][f] = dp[i][f] + dp[j][f-cost[i,j]]$</li></ul><p>这里的$cost[i,j]$表示从第$i$个城市到第$j$个城市消耗的汽油，即$abs(locations[i]-locations[j])$。</p><blockquote><p>这里不是max而是+=的形式，想一想为什么。因为我们从起点到$j$城市的路径数知道了，接下来是求$j-&gt;i$的路径数。且保证汽油消耗刚好为$f$。此时$j-&gt;i$路径数是$1$,因为是直达。严格意义上讲，(start-&gt;j-&gt;i)路径数为$1*dp[j][cost[i,j]]$，是相乘的关系。然后可能有别的路径所以把这些相加，即得到总的路径数。</p></blockquote><ul><li><p>初始化条件：$dp[start][0]=1$ ，需要注意的是很容易把从初始到每个城市的路径数初始化为1. 这样做会造成重复。我们在进行状态转移时，就会考虑这些情况。</p></li><li><p>循环条件：</p></li></ul><p>$i,j$两个城市是并列关系，只要两个城市互不相同就可以访问，且可以重复访问，不管是否到达终点，所以我们<strong>考虑消耗汽油为$f$前提下</strong>，从起点到$i$可行路径数。把汽油数作为最外层循环，否则城市将不能循环访问！</p><ul><li>求解目标：</li></ul><p>我们最终求解，$\sum\limits_{i} dp[finish][f_i]$</p><ul><li><p>细节，由于dp中间结果可能非常大，每做一次状态转移都要取模。</p></li><li><p>代码实现：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    ll mod = <span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRoutes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span> </span>&#123;                <span class="hljs-comment">//老思路dp, 不过这里的节点可以反复遍历，直到汽油耗光为止,可以转化为完全背包</span>        <span class="hljs-keyword">int</span> n = locations.size();        res = <span class="hljs-number">0</span>;        <span class="hljs-comment">//dp[i][f]表示从起点到第i城市刚好消耗f燃料的可行路径数。</span>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &gt;(fuel+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))</span></span>;        <span class="hljs-comment">//初始条件</span>        dp[start][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;       <span class="hljs-comment">//状态转移</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt;= fuel; f++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(j!=i)        &#123;        <span class="hljs-keyword">int</span> cost = <span class="hljs-built_in">abs</span>(locations[i]-locations[j]);        <span class="hljs-keyword">if</span>(f &gt;= cost)         &#123;             dp[i][f] +=  dp[j][f-cost] ;             dp[i][f] %= mod;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d-&gt;%d,cost:%d,dp:%d\n&quot;</span>,start,j,i,cost,dp[i][f]);        &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt;= fuel ;f++)         <span class="hljs-keyword">if</span>(dp[finish][f])        &#123;            res += dp[finish][f];            res %= mod;        &#125;        <span class="hljs-keyword">return</span> res%mod;    &#125;&#125;;</code></pre><ul><li>时间复杂度：$O(N^2*f)$. $N$为城市数，$f$为总汽油量</li><li>空间复杂度:   $O(N*f)$.</li></ul></li></ul><p><strong>记忆化搜索</strong></p><p>根据题目给的数据范围，数组长度不太大,<code>fuel</code>不太大，判断记忆化搜索可行。</p><p><code>2 &lt;= locations.length &lt;= 1001 &lt;= locations[i] &lt;= 10^9所有 locations 中的整数 互不相同 。0 &lt;= start, finish &lt; locations.length1 &lt;= fuel &lt;= 200</code></p><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">205</span>];<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span></span>&#123;        <span class="hljs-comment">//返回从start到finish的可行路径数</span>        <span class="hljs-keyword">if</span>(dp[start][fuel] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[start][fuel];        ll ans = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> len = locations.size();        <span class="hljs-keyword">if</span>(start == finish) ans++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-keyword">int</span> diff = <span class="hljs-built_in">abs</span>(locations[i] - locations[start]);            <span class="hljs-keyword">if</span>(start == i) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(fuel - diff &gt;= <span class="hljs-number">0</span>)&#123;                ans = (ans + dfs(locations, i, finish, fuel - diff)) % MOD;            &#125;        &#125;        dp[start][fuel] = (ans % MOD);        <span class="hljs-keyword">return</span> dp[start][fuel];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRoutes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span> </span>&#123;        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));        <span class="hljs-keyword">return</span> dfs(locations, start, finish, fuel);    &#125;&#125;;</code></pre><hr><h2 id="LCP-19-秋叶收藏集"><a href="#LCP-19-秋叶收藏集" class="headerlink" title="LCP 19. 秋叶收藏集"></a>LCP 19. 秋叶收藏集</h2><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 <code>leaves</code>， 字符串 <code>leaves</code> 仅包含小写字符 <code>r</code> 和 <code>y</code>， 其中字符 <code>r</code> 表示一片红叶，字符 <code>y</code> 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>leaves = &quot;rrryyyrryyyrr&quot;</code></p><p>输出：<code>2</code></p><p>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>leaves = &quot;ryr&quot;</code></p><p>输出：<code>0</code></p><p>解释：已符合要求，不需要额外操作</p></blockquote><p><strong>提示：</strong></p><ul><li><code>3 &lt;= leaves.length &lt;= 10^5</code></li><li><code>leaves</code> 中只包含字符 <code>&#39;r&#39;</code> 和字符 <code>&#39;y&#39;</code></li></ul><hr><p>乍一看没有思路，很难想到是动态规划来做。但其实我们可以这样想，把字符串分为三个部分，每一个部分都是<code>连续</code>的，我们可以利用这一点来构建状态转移方程。<code>| r:0 | y:1 |  r:2 |</code></p><p>我们用三种状态来表示，0，1，2。因为三种状态出现顺序必须是0，1，2. 所以每组的第一个字符编号必须大于它的状态编号。</p><p>设$dp[i][j]$表示$leaves[0-j]$，最末尾为状态$j$对应的最小操作数。</p><ul><li>第一个状态前面不存在任何状态，因此没有比较，直接写就行：</li></ul><p>$dp[i][0] = dp[i-1][0]+isRed(i)$</p><p>$isRed$表示第i个字符是否为<code>&#39;r&#39;</code>如果是，返回1，否则返回0.</p><ul><li>处于第二种状态的字符，前面要么是第一种状态，要么是第二种状态，所以为：</li></ul><p>$dp[i][1]=min(dp[i-1][1],dp[i-1][0])+isYellow(i)$</p><ul><li><p>处于第三种状态的字符，前面要么是第二种状态，要么是第三种状态，不可能是第一种状态，因为题目规定每一部分至少一个。</p><p>$dp[i][2]=min(dp[i-1][1],dp[i-1][2])+isRed(i)$</p><p>&gt;<br>&gt;</p><blockquote><p>边界条件</p></blockquote></li></ul><p>一旦出现<code>min</code>这种形式，我们就需要剔除不合理条件，特别是这种求最小的题目，用0初始化要特别谨慎。</p><p>$dp[0][0] = isYellow(i)$</p><p>$dp[0][1]=INT_MAX\\dp[0][2]=INT_MAX\\dp[1][2]=INT_MAX$</p><p>这些都是不可能出现的状态。</p><p>最后返回结果是<code>dp[n-1][2]</code>，因为这是一个连续状态转移过程。</p><p>用cpp写的时候千万<strong>不要</strong>写成</p><p><code>dp[i][2] = min(dp[i-1][2],dp[i-1][1]) + (leaves[i] == &#39;y&#39;)?1:0;</code></p><p>?优先级比较低，它会等前面表达式执行完，而 <code>1+true=1</code>，很容易犯错。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(<span class="hljs-built_in">string</span> leaves)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = leaves.size();        <span class="hljs-comment">//采用动态规划，设dp[i][j]表示 </span>        <span class="hljs-comment">// 0-i片叶子中，第i片叶子处于状态j的最小操作数</span>        <span class="hljs-comment">// |  r:0  |  y:1  |   r:2  |</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>));         dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (leaves[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;y&#x27;</span>)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;        <span class="hljs-comment">// dp[0][1] = INT_MAX;</span>        <span class="hljs-comment">// dp[0][2] = INT_MAX;</span>        <span class="hljs-comment">// dp[1][2] = INT_MAX;</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n;i++)        &#123;            dp[i][<span class="hljs-number">0</span>] = (leaves[i]==<span class="hljs-string">&#x27;y&#x27;</span>) ? dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>:dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) dp[i][<span class="hljs-number">1</span>] = (leaves[i] == <span class="hljs-string">&#x27;r&#x27;</span>)? min(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>:min(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span>) dp[i][<span class="hljs-number">2</span>] = (leaves[i] == <span class="hljs-string">&#x27;y&#x27;</span>)? min(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>:min(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);            <span class="hljs-comment">// printf(&quot;i:%d,dp[0]:%d,dp[1]:%d,dp[2]:%d\n&quot;,i,dp[i][0],dp[i][1],dp[i][2]);</span>        &#125;        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];    &#125;&#125;;</code></pre><hr><h2 id="730-统计不同回文子序列"><a href="#730-统计不同回文子序列" class="headerlink" title="730. 统计不同回文子序列"></a><a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/">730. 统计不同回文子序列</a></h2><p>给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并<strong>返回该数字与 <code>10^9 + 7</code>的模。</strong></p><p>通过从 S 中删除 0 个或多个字符来获得子序列。</p><p>如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。</p><p>如果对于某个 <code>i</code>，<code>A_i != B_i</code>，那么 <code>A_1, A_2, ...</code> 和 <code>B_1, B_2, ...</code> 这两个字符序列是不同的。</p><p><strong>示例 1：</strong></p><pre><code class="hljs 1c">输入：S = &#x27;bccb&#x27;输出：<span class="hljs-number">6</span>解释：<span class="hljs-number">6</span> 个不同的非空回文子字符序列分别为：&#x27;b&#x27;, &#x27;c&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;bcb&#x27;, &#x27;bccb&#x27;。注意：&#x27;bcb&#x27; 虽然出现两次但仅计数一次。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：S = <span class="hljs-string">&#x27;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&#x27;</span>输出：<span class="hljs-number">104860361</span>解释：共有 <span class="hljs-number">3104860382</span> 个不同的非空回文子序列，对 <span class="hljs-number">10</span>^<span class="hljs-number">9</span> + <span class="hljs-number">7</span> 取模为 <span class="hljs-number">104860361</span>。</code></pre><p><strong>提示：</strong></p><ul><li>字符串 <code>S</code> 的长度将在<code>[1, 1000]</code>范围内。</li><li>每个字符 <code>S[i]</code> 将会是集合 <code>&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;</code> 中的某一个。</li></ul><hr><p>这是一道典型周赛型难题。结果的数值可能非常大，甚至需要取模。</p><p>这道题我最开始思路是类比子集问题然后用dfs求所有情况。 然后看到<code>S[1,1000]</code>的范围我打消了这个念头，然后去看题解doge。本题难度极大，要弄懂需要很长时间，我们这思考一些巧妙的途径，参考【小鱼爱吃香干】的<a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/solution/dong-tai-gui-hua-dui-qu-jian-dpfen-lei-tao-lun-by-/">题解</a>。</p><p>设子字符串为$s[i…j]$，设$dp[i][j]$ 表示子串中回文的数目。我们采取【黑箱操作】，也就是只考虑当前$i,j$而不考虑每个子状态对整体状态影响，比如s=“abc”, 我们对子串”a”，<code>count(&quot;a&quot;) = 1;</code>同时<code>count(&quot;abc&quot;)=3</code>也考虑了“a”。</p><ul><li><p>若<code>s[i]!=s[j]</code>先看几个例子</p></li><li><p>```<br>count(“bc”) = count(“b”) + count(“c”) - count(“”) = 1 + 1 - 0 = 2<br>count(“bcc”) = count(“bc”) + count(“cc”) - count(“c”) = 2 + 2 - 1 = 3<br>count(“ab”) = count(“a”) + count(“b”) - count(“”) = 1 + 1 - 0 = 2<br>count(“abc”) = count(“ab”) + count(“bc”) - count(“b”) = 2 + 2 - 1 = 3<br>count(“abcc”) = count(“abc”) + count(“bcc”) - count(“bc”) = 3 + 3 - 2 = 4<br>count(“abccb”) = count(“abcc”) + count(“bccb”) - count(“bcc”) = 4 + 6 - 3 = 7</p><pre><code class="hljs markdown">  那么状态转移方程很容易得到：两边的dp减去中间重合的部分。   $dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]=dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-1</span>]+dp[<span class="hljs-string">i+1</span>][<span class="hljs-symbol">j</span>]-dp[<span class="hljs-string">i+1</span>][<span class="hljs-symbol">j-1</span>]$<span class="hljs-bullet">-</span> 若<span class="hljs-code">`s[i]==s[j]`</span><span class="hljs-bullet">-</span> <span class="hljs-code">```</span><span class="hljs-code">  count(&quot;cbc&quot;) = 2 * count(&quot;b&quot;) + 2 = 4</span><span class="hljs-code">  count(&quot;bcab&quot;) = 2 * count(&quot;ca&quot;) + 2 = 6</span><span class="hljs-code">  </span><span class="hljs-code">  count(&quot;bcbcb&quot;) = 2 * count(&quot;cbc&quot;) + 1 = 2 * 4 + 1 = 9</span><span class="hljs-code">  count(&quot;bbcabb&quot;) = 2 * count(&quot;bcab&quot;) - count(&quot;ca&quot;) = 10</span><span class="hljs-code">  </span></code></pre></li><li></li><li><p>两边的两个字符可以和中间任何一个回文子串结合形成新的回文子串，同时如果中间没有两边的字符，比如”dabcbad”，还要考虑两边字符作为新的回文串，所以是$2*dp[i+1][j-1]$。设两边字符为x</p></li><li><p>如果$s[i+1:j-1]$中有一个x :  那么只有$xx$是新回文串：$dp[i][j]=2*dp[i+1][j-1]+1$</p></li><li><p>如果$s[i+1:j-1]$中没有x :  那么$xx$和$x$是新回文串：$dp[i][j]=2*dp[i+1][j-1]+2$</p></li><li><p>否则，这个时候，需要考虑向中间收缩，设l,r表示左右两个指针，$l=i+1,r=j-1$，循环若$s[l]$不等于$s[i]$,$l$加1，直到相等.这是为了取出中间不为回文的核。去掉重复。</p></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> mod = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;    <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">endInMiddle</span><span class="hljs-params">(<span class="hljs-built_in">string</span> sub,<span class="hljs-keyword">char</span> ex)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:sub) <span class="hljs-keyword">if</span>(c==ex) &#123;len++;<span class="hljs-keyword">if</span>(len&gt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;&#125;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPalindromicSubsequences</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-comment">//思路前缀和+动态规划</span>        n = s.size();        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[n][n];        <span class="hljs-comment">// memset(&amp;dp,-1,sizeof(dp));//memset只能初始化0，-1，因为它们补码和自身相同，纯属巧合</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;               dp[i][j] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i&gt;j) dp[i][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//所有i&gt;j的分量设为0</span>        &#125;        <span class="hljs-keyword">int</span> j;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;k &lt; n;k++) <span class="hljs-comment">//设计步进</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;            j = i+k;            <span class="hljs-keyword">if</span>(j &gt;= n) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(s[i] != s[j])            &#123;    dp[i][j] = (dp[i][j<span class="hljs-number">-1</span>] - dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + dp[i+<span class="hljs-number">1</span>][j] + mod)%mod ;<span class="hljs-comment">//+mod是避免负数的情况</span>            &#125;<span class="hljs-keyword">else</span>             &#123;                <span class="hljs-keyword">int</span> endmid = endInMiddle(s.substr(i+<span class="hljs-number">1</span>,j-i<span class="hljs-number">-1</span>),s[i]);                <span class="hljs-keyword">if</span>(endmid == <span class="hljs-number">0</span>)                    dp[i][j] = (<span class="hljs-number">2</span>*dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span> + mod)%mod;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(endmid == <span class="hljs-number">1</span>)                    dp[i][j] = (<span class="hljs-number">2</span>*dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span> + mod)%mod;                <span class="hljs-keyword">else</span>                 &#123;                    <span class="hljs-keyword">int</span> l = i+<span class="hljs-number">1</span>, r = j<span class="hljs-number">-1</span>;                    <span class="hljs-keyword">while</span>(l &lt; n&amp;&amp;s[l]!=s[i]) l++;                    <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp;s[r]!=s[j]) r--;                    dp[i][j] = (<span class="hljs-number">2</span>*dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] - dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>] + mod)%mod;                &#125;            &#125;        &#125;                <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]%mod;        &#125;&#125;;</code></pre><hr><h2 id="1458-两个子序列的最大点积"><a href="#1458-两个子序列的最大点积" class="headerlink" title="1458. 两个子序列的最大点积"></a><a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/">1458. 两个子序列的最大点积</a></h2><p>给你两个数组 <code>nums1</code> 和 <code>nums2</code> 。</p><p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p><p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code> 的一个子序列而 <code>[1,5,3]</code> 不是。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：nums1 = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>], nums2 = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-6</span>]输出：<span class="hljs-number">18</span>解释：从 nums1 中得到子序列 [<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>] ，从 nums2 中得到子序列 [<span class="hljs-number">3</span>,<span class="hljs-number">-6</span>] 。它们的点积为 (<span class="hljs-number">2</span>*<span class="hljs-number">3</span> + (<span class="hljs-number">-2</span>)*(<span class="hljs-number">-6</span>)) = <span class="hljs-number">18</span> 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：nums1 = [<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>], nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">-6</span>,<span class="hljs-number">7</span>]输出：<span class="hljs-number">21</span>解释：从 nums1 中得到子序列 [<span class="hljs-number">3</span>] ，从 nums2 中得到子序列 [<span class="hljs-number">7</span>] 。它们的点积为 (<span class="hljs-number">3</span>*<span class="hljs-number">7</span>) = <span class="hljs-number">21</span> 。</code></pre><p><strong>示例 3：</strong></p><pre><code class="hljs angelscript">输入：nums1 = [<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>], nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">-1</span>解释：从 nums1 中得到子序列 [<span class="hljs-number">-1</span>] ，从 nums2 中得到子序列 [<span class="hljs-number">1</span>] 。它们的点积为 <span class="hljs-number">-1</span> 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li><li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><hr><p>参考我写的题解:<a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/solution/liang-chong-zhuang-tai-de-dong-tai-gui-hua-by-dura/">https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/solution/liang-chong-zhuang-tai-de-dong-tai-gui-hua-by-dura/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Durant终于有个家写写东西了</title>
    <link href="/2020/07/19/2020-07-19-damn_blog/"/>
    <url>/2020/07/19/2020-07-19-damn_blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上周，非常有幸接触到<code>Hux</code>大佬的博客，深感震撼，而且他也在Github上分享了Jekyll源码,star&gt;5000。我决定DIY一番，不然对不起程序员的身份。</p></blockquote><h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><p>好不容易搭建好了，结果写好的markdown样子和Hux完全不同。</p><ol><li>标签前面有<code>#</code>，而且是有标签的那种</li><li>图片不显示</li><li>公式不显示</li><li>语法没高亮，没行号 </li><li>目录没显示</li><li>评论区没显示</li></ol><p>这叫我如何能忍。是可忍，孰不可忍。</p><hr><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><ol><li>将 <code>_config.yml</code>文件的<code>anchorjs</code>改为<code>false</code>。这主要是跳转用的，不需要。</li><li><p>采用网络图片，刷新几次就好了<del><strong>玄学</strong></del></p></li><li><p>Kramdown主要是<code>$$ ... $$</code>表示公式区域，它会自动渲染为mathjax标签。之前用VS code自带的markdown math 是以<code>$ ... $</code>。疏忽了。<br>在<code>_include</code>的<code>head.html</code>加入一句话，在post文件前加<code>latex:true</code>即可。</p></li></ol><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">if</span></span> page.latex == true %&#125;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endif</span></span> %&#125;</span></code></pre><ol><li>之前以为是C++，改成cpp就能高亮了，呃</li></ol><h1 id="I-want-more"><a href="#I-want-more" class="headerlink" title="I want more"></a>I want more</h1><p>作为一个前端，后端小白，还是很想扩展一下博客的功能的····，满足自己的装bei心里。</p><ol><li>加入评论功能</li><li>统计访问量</li><li>为博客加入点赞功能</li><li>花里胡哨的功能</li></ol><ol><li>博客搜索</li><li>博客置顶</li><li>访问加速</li><li>访客限制</li><li>（高级）在网站上直接post&amp;push</li></ol><hr><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>hexo简单强大，完爆Github page。</p><p>配置Hexo<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">传送门</a></p><p>配置<a href="https://blog.csdn.net/frone/article/details/81170627">Mathjax</a></p><p><a href="https://www.cnblogs.com/codehome/p/8428738.html">上传本地图片</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>朝花夕拾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>麻麻终于不用担心我分不清楚线段树和树状数组了！</title>
    <link href="/2020/07/17/2020-07-17-fenwicktree-segmentTree/"/>
    <url>/2020/07/17/2020-07-17-fenwicktree-segmentTree/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树和树状数组"><a href="#线段树和树状数组" class="headerlink" title="线段树和树状数组"></a>线段树和树状数组</h1><blockquote><p>“树状数组和线段树都是用于维护数列信息的数据结构，支持单点/区间修改，单点/区间询问信息。以增加权值与询问区间权值和为例，其余的信息需要维护也都类似。时间复杂度均为$O(logn)$。 ”</p><p><a href="https://zhuanlan.zhihu.com/p/191524460">详细的数学证明</a></p></blockquote><ul><li>练习题目<ul><li><ol><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">计算右侧小于当前元素的个数</a></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">最大子序和</a></li></ol></li><li><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327.区间和的个数</a></li></ul></li></ul><h1 id="I-树状数组"><a href="#I-树状数组" class="headerlink" title="I. 树状数组"></a>I. 树状数组</h1><h2 id="Fenwick-Tree"><a href="#Fenwick-Tree" class="headerlink" title="Fenwick Tree"></a>Fenwick Tree</h2><p>地中海的程序猿们研究数组，时候遇到这样一个问题: 有一个数组$S$从$0 - n-1$，现在要在$O(logn)$ 的时间复杂度内，搜索一个确定的值（或修改）$w$并且对区间 $[a,b]$ 求和。空间复杂度必须严格限制在$O(n)$.</p><p>他们想到了二叉搜索树(BST)，对于平衡二叉树其插入和删除的时间复杂度都是$O(logn)$，因为树是类似于嵌套列表的思想，进而可以想到二叉堆，这是一种非嵌套列表，也可以实现$O(logn)$。于是有了下面这张图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vQUtNZXIvMTIyODU5OS9vX1RyZWVBcnJheS5qcGc?x-oss-process=image/format,png" alt="FenwickTree"></p><blockquote><p>解释一下，编号为$x$的节点上统计着$[x-lowbit(x)+1,x]$这一段区间的信息，$x$的父亲就是$x+lowbit(x)$,我们要维护数组$C$上的信息，存储在数组$A$中。</p></blockquote><p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的$f[i]$的个数也是2的幂。</p><h2 id="1-Lowbit函数"><a href="#1-Lowbit函数" class="headerlink" title="1. Lowbit函数"></a>1. Lowbit函数</h2><blockquote><p>返回参数转换为二进制后，最后一个1的位置所代表的数值。</p></blockquote><p>比如34转换为二进制就是0010 0010, Lowbit(34)返回2. 程序上 我们可以用<code>((Not I)+1) AND I</code>, 比如NOT(0010 0010) = 1101 1101, 加1之后为 1101 1110，再与上I,为0000 0010(2)。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;</code></pre><h2 id="2-新建数组"><a href="#2-新建数组" class="headerlink" title="2. 新建数组"></a>2. 新建数组</h2><p>我们定义一个数组BIT，用以维护A的前缀和，</p><script type="math/tex; mode=display">BIT_i = \sum\limits_{j=i-lowbit(i)+1}^{i} A_{j}</script><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_N; i++)    &#123;        BIT[i] = A[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">2</span>; j &gt;= i - lowbit(i); j--)            BIT[i] += A[j];    &#125;&#125;</code></pre><h2 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h2><p>假设现在要在$A[i]$的值增加$\delta$, 那么需要将$BIT$在所有含$A[i]$的区间都加上一个数，<br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> w)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">// 在下标k、加上w</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&lt; tr.size();j+=low_bit(j)) tr[j]+=w;    &#125;</code></pre></p><h2 id="4-区间求和"><a href="#4-区间求和" class="headerlink" title="4. 区间求和"></a>4. 区间求和</h2><p>假设我们需要计算$\sum\limits_{i=1}^kA_i$的值。</p><ol><li>首先，将$ans$初始化为$k$</li><li>将$ans$的值加上$BIT[i]$</li><li>将$i$的值减去$Lowbit(i)$</li><li>重复2 . 3 步骤直到$i$的值变为0.</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i))        ans += BIT[i];    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>应用：求<a href="https://blog.csdn.net/cattycat/article/details/5640838">逆序数</a></p><blockquote><p>练习 <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">LC315. 计算右侧小于当前元素的个数</a></p></blockquote><h1 id="II-线段树"><a href="#II-线段树" class="headerlink" title="II. 线段树"></a>II. 线段树</h1><h2 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h2><blockquote><p>使用线段树可以快速查找某一个节点在若干线段中出现的次数，时间复杂度为$O(logN)$，而未优化的空间复杂度为$2N$，一般要开$4N$的数组防止越界。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvYmQzZWIxMzUzM2ZhODI4YmNiNWZlODVmZmUxZjQxMzQ5NzBhNWEwOQ?x-oss-process=image/format,png" alt="线段树"></p><p>除了叶子节点外，对于$[a,b]$线段节点，其有两个子节点, 左子节点$[a,(a+b)/2]$和右子节点$[(a+b)/2+1,b]$。由于线段树在程序竞赛中被广泛应用，这种结构被$ACMer$和$OIer$戏谑为必须掌握的数据结构。一般地，我们先定义一个线段树节点结构体:</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> start;<span class="hljs-comment">//线段左节点</span>    <span class="hljs-keyword">int</span> end;<span class="hljs-comment">//线段右节点</span>    <span class="hljs-keyword">int</span> sum;<span class="hljs-comment">//线段对应的和</span>    <span class="hljs-keyword">int</span> lazytag;<span class="hljs-comment">//懒标记</span>    SegmentNode *left;    SegmentNode *right;    SegmentNode():start(<span class="hljs-number">0</span>),end(<span class="hljs-number">0</span>),sum(<span class="hljs-number">0</span>)&#123;&#125;&#125;;</code></pre><p>请务必熟悉理解<code>上述</code>结构！</p><h2 id="1-建立树"><a href="#1-建立树" class="headerlink" title="1. 建立树"></a>1. 建立树</h2><p>我们对区间$[l,r]$建立线段树，是一个自上而下过程。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;        self-&gt;start = l;self-&gt;end = r;        <span class="hljs-keyword">if</span>(l==r)        &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        self-&gt;left = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;left,l,mid);        self-&gt;right = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;right,mid+<span class="hljs-number">1</span>,r);    &#125;</code></pre><h2 id="2-单点修改"><a href="#2-单点修改" class="headerlink" title="2. 单点修改"></a>2. 单点修改</h2><p>从根节点开始,以递归的方式不断更新sum值，直到叶子节点即<code>区间长度为1</code>，每个区间的sum值等于左子区间的sum值，加上右子区间的sum值。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos&lt;self-&gt;start||pos&gt;self-&gt;end) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(self-&gt;start == self-&gt;end)    &#123;        self-&gt;sum += k;        <span class="hljs-keyword">return</span>;     &#125;    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&gt;pos) add(self-&gt;left,pos,k);    <span class="hljs-keyword">else</span> add(self-&gt;right,pos,k);    self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;&#125;</code></pre><h2 id="3-区间查询"><a href="#3-区间查询" class="headerlink" title="3. 区间查询"></a>3. 区间查询</h2><ul><li>第一种情况是当前的区间范围完全在$[l,r]$内，这个时候把当前区间的$sum$值返回即可，</li><li>第二张情况是当前节点的<code>左子节点</code>的<code>右端点</code>和$[l,r]$有交集。这个时候就搜索左子节点。</li><li>第三张情况是当前节点的<code>右子节点</code>的<code>左端点</code>和$[l,r]$有交集。这个时候就搜索右子节点。<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//这里的i,j分别代表要搜索的区间</span>    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(i&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=j)    &#123;        <span class="hljs-keyword">return</span> self-&gt;sum;     &#125;    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j);    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j);    <span class="hljs-keyword">return</span> s;&#125;</code></pre><h2 id="4-延迟标记"><a href="#4-延迟标记" class="headerlink" title="4. 延迟标记"></a>4. 延迟标记</h2></li></ul><p>对于区间修改，这里会遇到一个问题：为了使所有sum值都保持正确，每一次插入操作可能要更新$O(N)$个sum值，从而使时间复杂度退化为$O(N)$。所以就有了Lazytag，如果一个节点有延迟标记，那么表明这个节点已经被修改过了。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_tag</span><span class="hljs-params">(SegmentNode *self,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span> </span>&#123;    self-&gt;sum += (r-l+<span class="hljs-number">1</span>)*v;self-&gt;lazytag+=v;<span class="hljs-comment">//标记只对儿子有影响，自己在打标记的同时一起把统计信息更改了。</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(SegmentNode *self,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    add_tag(self-&gt;left,l,mid,self-&gt;lazytag);    add_tag(self-&gt;right,mid+<span class="hljs-number">1</span>,r,self-&gt;lazytag);    self-&gt;lazytag = <span class="hljs-number">0</span>;<span class="hljs-comment">//把当前标记分别传给两个儿子然后清空</span>&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-comment">//[l,r]为当前区间,[L,R]为要修改的区间</span>    <span class="hljs-keyword">if</span>(l&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=r) &#123;        add_tag(self,l,r,v);<span class="hljs-comment">//打标记</span>        <span class="hljs-keyword">return</span>;&#125;    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;    push_down(self,l,r);<span class="hljs-comment">//下传标记</span>    <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j,v);    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j,v);    <span class="hljs-keyword">return</span> s;&#125;</code></pre><h1 id="III-树状数组和线段树比较"><a href="#III-树状数组和线段树比较" class="headerlink" title="III. 树状数组和线段树比较"></a>III. 树状数组和线段树比较</h1><div class="table-container"><table><thead><tr><th style="text-align:center">数据结构</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">适用特点</th></tr></thead><tbody><tr><td style="text-align:center">线段树</td><td style="text-align:center">$O(logN)$</td><td style="text-align:center">O(N)</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">树状数组</td><td style="text-align:center">$O(logN)$</td><td style="text-align:center">O(N)</td><td style="text-align:center">空间复杂度略低，容易扩展到多维，适用范围较线段树小</td></tr></tbody></table></div><hr><p>下面看一些经典题目吧</p><h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/">最大子序和</a></h1><p>其实这题除了用动态规划，还可以用线段树做。</p><p><strong>这个分治方法类似于「线段树求解 LCIS 问题」的 pushUp 操作</strong>。 当然，如果读者有兴趣的话，推荐看一看线段树区间合并法解决 <code>多次询问</code> 的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p><p>我们定义一个操作<code>get(a,l,r)</code>表示查询a序列$[l,r]区$间内的最大字段和。对于一个区间，我们取$m = [\frac{l+r}{2}]$,然后<code>逐层递归</code>。最关键的问题是：</p><ul><li><p>我们要维护区间什么信息？</p></li><li><p>我们如何合并这些信息？</p></li></ul><p>  对于一个区间$[l,r]$，<code>lSum</code>表示$[l,r]$以$l$为左端点的最大子段和；<code>rSum</code>表示$[l,r]$以$r$为右端点的最大子段和，<code>mSum</code>表示$[l,r]$</p><p>  内的最大子段和。<code>iSum</code>表示$[l,r]$的区间和。</p><ul><li><code>iSum</code>是左右区间的子段和的和。</li><li>对于 $[l, r]$ 的 <code>lSum</code>，存在两种可能，它要么等于「左子区间」的 <code>lSum</code>，要么等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>lSum</code>，二者取大。</li><li>对于 $[l, r]$ 的 <code>rSum</code>，存在两种可能，它要么等于「右子区间」的 <code>rSum</code>，要么等于「右子区间」的 <code>iSum</code> 加上「左子区间」的 <code>rSum</code>，二者取大。</li><li>对于<code>mSum</code>，存在三种可能，要么完全在左区间，要么完全在中间，要么两边都有，我想你已经猜到了，就是左区间的<code>rSum</code>加上右区间的<code>lSum</code>。</li></ul><p>好的已经可以开始写代码了</p><hr><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Status</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">int</span> lSum, rSum, mSum, iSum;        <span class="hljs-comment">// 分别表示，以l为左端点的最大子序和，以r为右端点的最大子序和，</span>        <span class="hljs-comment">// mSum表示区间[l,r]最大子序和</span>        <span class="hljs-comment">//iSum表示区间和</span>    &#125;;    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums,<span class="hljs-keyword">int</span>  l,<span class="hljs-keyword">int</span>  r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> (Status)&#123;nums[l],nums[l],nums[l],nums[l]&#125;;        <span class="hljs-keyword">int</span> m = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        Status lpus = get(nums,l,m);        Status rpus = get(nums,m+<span class="hljs-number">1</span>,r);        <span class="hljs-keyword">int</span> lSum = max(lpus.lSum, lpus.iSum + rpus.lSum);        <span class="hljs-keyword">int</span> rSum = max(rpus.rSum, rpus.iSum + lpus.rSum);        <span class="hljs-keyword">int</span> iSum = lpus.iSum + rpus.iSum;        <span class="hljs-keyword">int</span> mSum = max(lpus.rSum+ rpus.lSum,max(lpus.mSum, rpus.mSum));        <span class="hljs-keyword">return</span> (Status)&#123;lSum,rSum,mSum,iSum&#125;;     &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> get(nums, <span class="hljs-number">0</span> , nums.size()<span class="hljs-number">-1</span>).mSum;    &#125;</code></pre><p>然后我们分析一下时间和空间复杂度。</p><p>时间复杂度：$O(n)$，我们把递归过程看成二叉树的先序遍历，那么这颗二叉树时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 $O(\log n)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为 $O(n)$。<br>空间复杂度：递归会使用 O(\log n)O(logn) 的栈空间，故渐进空间复杂度为 $O(logn)$。 </p><hr><h1 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a>315. <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a></h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>示例：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 解释：<span class="hljs-number">5</span> 的右侧有 <span class="hljs-number">2</span> 个更小的元素 (<span class="hljs-number">2</span> 和 <span class="hljs-number">1</span>)<span class="hljs-number">2</span> 的右侧仅有 <span class="hljs-number">1</span> 个更小的元素 (<span class="hljs-number">1</span>)<span class="hljs-number">6</span> 的右侧有 <span class="hljs-number">1</span> 个更小的元素 (<span class="hljs-number">1</span>)<span class="hljs-number">1</span> 的右侧有 <span class="hljs-number">0</span> 个更小的元素</code></pre><hr><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentNode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> start;    <span class="hljs-keyword">int</span> end;    <span class="hljs-keyword">int</span> sum;    SegmentNode *left;    SegmentNode *right;    SegmentNode():start(<span class="hljs-number">0</span>),end(<span class="hljs-number">0</span>),sum(<span class="hljs-number">0</span>)&#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">//---------------------------Segment tree solution----------------------------</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;        self-&gt;start = l;self-&gt;end = r;        <span class="hljs-keyword">if</span>(l==r)        &#123;            <span class="hljs-comment">// self-&gt;sum = l;</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;        self-&gt;left = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;left,l,mid);        self-&gt;right = <span class="hljs-keyword">new</span> SegmentNode();        build(self-&gt;right,mid+<span class="hljs-number">1</span>,r);        <span class="hljs-comment">// self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(pos&lt;self-&gt;start||pos&gt;self-&gt;end) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(self-&gt;start == self-&gt;end)        &#123;            self-&gt;sum += k;            <span class="hljs-keyword">return</span>;         &#125;        <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&gt;pos) add(self-&gt;left,pos,k);        <span class="hljs-keyword">else</span> add(self-&gt;right,pos,k);        self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(i&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=j)        &#123;            <span class="hljs-keyword">return</span> self-&gt;sum;         &#125;        <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j);        <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j);        <span class="hljs-keyword">return</span> s;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller_SegmentTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> nums;        SegmentNode *root = <span class="hljs-keyword">new</span> SegmentNode();        <span class="hljs-comment">//find the min and max val in nums</span>        <span class="hljs-keyword">int</span> min_val = INT_MAX, max_val = INT_MIN;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)&#123;min_val=min(min_val,c);max_val = max(max_val,c);&#125;        build(root,min_val,max_val);        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;        <span class="hljs-comment">// for(auto &amp;c:nums) </span>        <span class="hljs-comment">//     add(root,c,1);//All sub interval adds 1</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.size()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>;i--)        &#123;            add(root,nums[i],<span class="hljs-number">1</span>);            res[i] = search(root,min_val,nums[i]<span class="hljs-number">-1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;<span class="hljs-comment">//------------------------------Fenwick Tree Solution----------------------------------</span><span class="hljs-comment">//Due to the uncertainty of scale of data, we discretize the array</span>    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tr;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//pow(2,x)</span>        <span class="hljs-keyword">return</span> (x&amp;(-x));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&gt;<span class="hljs-number">0</span>; j-=low_bit(j)) res+=tr[j];        <span class="hljs-keyword">return</span> res;    &#125;       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> w)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">// add k to node w</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&lt; tr.size();j+=low_bit(j)) tr[j]+=w;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller_Fenwick</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-comment">//First, we discretize the vector and delete the repeated nums</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp = nums;        sort(tmp.begin(),tmp.end());        <span class="hljs-keyword">auto</span> c = unique(tmp.begin(),tmp.end());        tmp.erase(c,tmp.end());        <span class="hljs-keyword">int</span> new_len = c - tmp.begin();        <span class="hljs-comment">// we define a unordered-map to count the number of tmp</span>        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; ump;        tr = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(new_len + <span class="hljs-number">1</span>);<span class="hljs-comment">//redefine the tr to (new_len+1) default value</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;new_len;i++)            ump[tmp[i]] = count++;<span class="hljs-comment">//redefine the discretized values into serialized values using hashmap</span>        <span class="hljs-comment">//we build the Fenwick tree and do summation and addition</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = nums.size()<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--)        &#123;            count = ump[nums[k]];<span class="hljs-comment">// count of number</span>            res[k] = sum(count<span class="hljs-number">-1</span>);            add(count,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><hr><h1 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327. 区间和的个数"></a><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></h1><p>给定一个整数数组 <code>nums</code>，返回区间和在 <code>[lower, upper]</code> 之间的个数，包含 <code>lower</code> 和 <code>upper</code>。<br>区间和 <code>S(i, j)</code> 表示在 <code>nums</code> 中，位置从 <code>i</code> 到 <code>j</code> 的元素之和，包含 <code>i</code> 和 <code>j</code> (<code>i</code> ≤ <code>j</code>)。</p><p><strong>说明:</strong><br>最直观的算法复杂度是 <em>O</em>(<em>n</em>2) ，请在此基础上优化你的算法。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: nums = [<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-1</span>], lower = <span class="hljs-number">-2</span>, upper = <span class="hljs-number">2</span>,输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">3</span>个区间分别是: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]，它们表示的和分别为: <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>。</code></pre><hr><p>该题的方法奇多，可谓是百家争鸣。不论是传统的归并排序还是线段树，树状数组，都值得好好研究，举一反三，刷题不累！</p><p>方法一：前缀和+归并排序，虽然归并操作是$O(nlogn)$。</p><p>思路与算法</p><p>设前缀和数组为 $\textit{preSum}$，则问题等价于求所有的下标对$ (i,j)$，满足</p><p>$preSum[j]−preSum[i]∈[lower,upper]$</p><p>我们先考虑如下的问题：给定两个升序排列的数组 $n_1, n_2$ ，试找出所有的下标对 $(i,j)$，满足</p><p>$n_2[j] - n_1[i] \in [\textit{lower}, \textit{upper}]$</p><p>在已知两个数组均为升序的情况下，这一问题是相对简单的：我们在 $n_2$中维护两个指针$ l,r$。起初，它们都指向 $n_2$<br>的起始位置。随后，我们考察 $n_1$ 的第一个元素。首先，不断地将指针 l 向右移动，直到$ n_2[l] \ge n_1[0] + \textit{lower}$为止，此时， l 及其右边的元素均大于或等于$ n_1[0] + \textit{lower}$；随后，再不断地将指针 rr 向右移动，直到$ n_2[r] &gt; n_1[0] + \textit{upper}$为止，则 rr 左边的元素均小于或等于 $n_1[0] + \textit{upper}$。故区间 $[l,r)$ 中的所有下标 j，都满足$n_2[j] - n_1[0] \in [\textit{lower}, \textit{upper}]<br>$</p><p>在解决这一问题后，原问题就迎刃而解了：我们采用归并排序的方式，能够得到左右两个数组排序后的形式，以及对应的下标对数量。对于原数组而言，若要找出全部的下标对数量，只需要再额外找出左端点在左侧数组，同时右端点在右侧数组的下标对数量，而这正是我们此前讨论的问题。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSumRecursive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt;&amp; sum, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span> (left == right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> n1 = countRangeSumRecursive(sum, lower, upper, left, mid);            <span class="hljs-keyword">int</span> n2 = countRangeSumRecursive(sum, lower, upper, mid + <span class="hljs-number">1</span>, right);            <span class="hljs-keyword">int</span> ret = n1 + n2;            <span class="hljs-comment">// 首先统计下标对的数量</span>            <span class="hljs-keyword">int</span> i = left;            <span class="hljs-keyword">int</span> l = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> r = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;                <span class="hljs-keyword">while</span> (l &lt;= right &amp;&amp; sum[l] - sum[i] &lt; lower) l++;                <span class="hljs-keyword">while</span> (r &lt;= right &amp;&amp; sum[r] - sum[i] &lt;= upper) r++;                ret += (r - l);                i++;            &#125;            <span class="hljs-comment">// 随后合并两个排序数组</span>            <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;            <span class="hljs-keyword">int</span> p1 = left, p2 = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (p1 &lt;= mid || p2 &lt;= right) &#123;                <span class="hljs-keyword">if</span> (p1 &gt; mid) &#123;                    sorted[p++] = sum[p2++];                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 &gt; right) &#123;                    sorted[p++] = sum[p1++];                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (sum[p1] &lt; sum[p2]) &#123;                        sorted[p++] = sum[p1++];                    &#125; <span class="hljs-keyword">else</span> &#123;                        sorted[p++] = sum[p2++];                    &#125;                &#125;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sorted.size(); i++) &#123;                sum[left + i] = sorted[i];            &#125;            <span class="hljs-keyword">return</span> ret;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;        <span class="hljs-keyword">long</span> s = <span class="hljs-number">0</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt; sum&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v: nums) &#123;            s += v;            sum.push_back(s);        &#125;        <span class="hljs-keyword">return</span> countRangeSumRecursive(sum, lower, upper, <span class="hljs-number">0</span>, sum.size() - <span class="hljs-number">1</span>);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N\log N)$，其中 N 为数组的长度。设执行时间为 $T(N)$，则两次递归调用的时间均为 $T(N/2)$，最后需要 $O(N)$的时间求出下标对数量以及合并数组，故有$<br>T(N)=2⋅T(N/2)+O(N)$</p><p>根据主定理，有$ T(N) = O(N\log N)$。</p><p>空间复杂度：$O(N)4。设空间占用为$ M(N)4，递归调用所需空间为 $M(N/2)4，而合并数组所需空间为 $O(N)$，故</p><p>$<br>M(N)=max{M(N/2),O(N)}=M(N/2)+O(N)$</p><p>根据主定理，有 $M(N) = O(N)$。</p><blockquote><p>前缀和数组先加入0，可以简化我们很多代码！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2020/06/25/2020-06-25-C++memory_management/"/>
    <url>/2020/06/25/2020-06-25-C++memory_management/</url>
    
    <content type="html"><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><blockquote><p>内存管理是非常让人头疼的事情，因为一不小心就可能导致内存泄漏，为此很多C++程序员跑路到java或python，？？？但是反过来说，优秀的程序员知道如何管理内存，并显式获得速度的飞跃。</p></blockquote><p>内存分类：</p><ol><li><p><strong>静态内存</strong>：用来保存局部<code>static</code>对象，类的<code>static</code>数据成员以及定义在任何函数之外的变量。</p></li><li><p><strong>栈内存</strong>：用来保存定义在函数内的非<code>static</code>对象。</p><p>分配在静态或栈内存中的对象由编译器自动创建和销毁。</p></li><li><p><strong>动态内存</strong>，又被称为<strong>堆</strong>(heap)，由程序的生命周期所控制，我们的代码必须<em>显式</em>的销毁它们。</p></li></ol><p>通常我们用<code>new</code>创建一个对象，然后用<code>delete</code>销毁它。</p><blockquote><p>未完待续</p></blockquote><p><img src="../img/memorymanagement.png" alt="image-20201020201342900"></p><p><img src="2020-06-25-C++memory_management/image-20201020210657315.png" alt="image-20201020210657315"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全手写实现AVL树</title>
    <link href="/2020/05/10/2020-04-30-avl-tree/"/>
    <url>/2020/05/10/2020-04-30-avl-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="全手写实现AVL树"><a href="#全手写实现AVL树" class="headerlink" title="全手写实现AVL树"></a>全手写实现AVL树</h1><blockquote><p>本文阅读大概需要45分钟，<strong>独立</strong>编程需要两天，建议预留充足的时间和咖啡。</p></blockquote><p>（友情提示，笔者基本未参考网络资料，边思考边写代码，100%干货，学AVL看这一篇就够了）</p><p>学树的顺序，一般来说是：二叉树-&gt;二叉查找树-&gt;AVL树-&gt;2-3-4树-&gt;红黑树。它们的难度依次递增。不得不说的是，树是计算机科学最重要研究课题之一。在算法类面试当中，树的考察也是不可或缺的。</p><p><img src="https://img-blog.csdnimg.cn/20200425225354848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>先简单回顾一下二叉查找树：</p><p>一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/二叉树">二叉树</a>：</p><p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3）左、右子树也分别为二叉排序树；</p><p>（4）没有键值相等的结点。</p><p>让我们介绍一种全新的<strong><em>自平衡二叉树（斜体加粗表示这玩意很酷炫）\</em></strong>。相信在你学完并且理解之后。会觉得之前学的树都太low了。</p><p>你可能觉得AVL是某些niubilious（自造词，牛批的意思）的英文缩写。事实是，AVL树的名字来源于它的发明作者G.M. <strong>A</strong>delson-<strong>V</strong>elsky 和 E.M. <strong>L</strong>andis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。</p><p>它的特点是：<strong>左右子树高度差（平衡因子）的绝对值小于等于1.</strong> （红色加粗的字体表明你应该记住这句话）</p><p>下面邀请插画师turtle配合演示，事实上，整个AVL树的插入和删除操作我们都会作图演示，保证你能看懂：</p><p><img src="https://img-blog.csdnimg.cn/20200425231356816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>感谢turtle先生，你今天的粉色画笔非常好看！</p></blockquote><p> 数字代表val，字母代表payload。你可以借助字典中的key和value来理解。最下面的数字，我们称为<strong>平衡因子（balance factor,bf）</strong>。只有一棵树所有节点平衡因子在1,0,-1之间，这棵树才是平衡的。 所谓的树的高度，就是垂直方向，从当前节点到根节点的最大深度。<strong>平衡因子等于左右子树高度差，叶子节点平衡因子一定为0。</strong></p><p><em>为什么要满足这个条件呢？（斜体表示你问了一个问题）</em>因为我们希望一棵树尽量对称均匀，看起来漂亮（删除线表示这是错误的理解）我们先区分两个概念</p><ol><li><strong>满二叉树：</strong>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树为<em>满二叉树（国内定义）</em>。</li><li><strong>完全二叉树：</strong>若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都<strong>连续集中在最左边</strong>，这就是完全二叉树。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200425233454747.png" alt="img"></p><p>​                                                                                                        <strong>满二叉树</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvZjlkY2QxMDBiYWExY2QxMTcxZmFmMWJkYjUxMmM4ZmNjMmNlMmRkYQ?x-oss-process=image/format,png" alt="img" style="zoom:50%;" /></p><p>​                                                                                                <strong>完全二叉树</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>AVL树是一种完全二叉树，因为这个特性，我们发现它的插入，删除操作最好最坏的情况都是log(n)。</p><p><em>这是怎么得来的？</em> 你如果只是死记而不理解的话，这会很糟糕，你可能会记混淆。一棵完全二叉树的深度设为k ， 那么前k-1层一共有2^(k-1)-1个节点，最后一层节点数最少为0，最多为2^(k-1)。设节点总数为N。那么2^(k-1)-1&lt;=N&lt;=2^(k-1)-1+2^(k-1)=2^k-1。解得： k-1&lt;Log2(N+1)&lt;k，按照层数递归的思想，我们的时间复杂度就是O(logN)量级的。</p><p>由于之前的博客已经讲解了<a href="https://blog.csdn.net/qq_32439305/article/details/105741842">二叉查找树</a>。下面让我们思考，在插入过程如何保持二叉树动态平衡。</p><p>希望你能保持足够的耐心，关闭音乐，集中注意力，只要不是咖啡撒到键盘上就行。</p><p>下面是插入操作的实现.</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span> (<span class="hljs-params">self, val, payload</span>):</span>    <span class="hljs-keyword">if</span> self.root:        self._put(val, payload,self.root)    <span class="hljs-keyword">else</span>:        self.root = BSTNode(val,payload)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_put</span>(<span class="hljs-params">self,val,payload,currentNode</span>):</span>    <span class="hljs-keyword">if</span> val &lt;= currentNode.val:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currentNode.left_child:            left_new = BSTNode(val,payload,parent=currentNode)            currentNode.left_child = left_new        <span class="hljs-keyword">else</span>:            self._put(val,payload,currentNode.left_child)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currentNode.right_child:            right_new = BSTNode(val,payload,parent=currentNode)            currentNode.right_child = right_new        <span class="hljs-keyword">else</span>:            self._put(val,payload,currentNode.right_child)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这是BST插入的相关代码。下面介绍添加节点时的平衡操作：</p><h1 id="Put方法实现"><a href="#Put方法实现" class="headerlink" title="Put方法实现"></a>Put方法实现</h1><ul><li>我们先考虑当前节点bf的变化，如果当前节点的bf大于1或小于-1，说明我们需要进行<strong>旋转</strong>操作，下面我会详细介绍；否则在当前节点为左子节点时，我们将其父节点的bf加 1，当前节点为右子节点，其父节点减1. <strong>这里其实是一个递归操作，</strong>每当子节点改变，其上层的所有父节点需要改变，除非某个父节点的平衡因子为0.</li><li>我们先介绍几种平衡方法：<strong><em>左旋(L_Rot)，右旋(R_Rot)，LR双旋(LR_doubRot)，RL双旋(RL_doubRot)</em></strong>。它们是你前所未见的炫操作。</li></ul><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p><strong>1.左旋（感谢<a href="https://blog.csdn.net/sun_tttt">Sun_TTTT博客</a>精彩配图）</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTMzNTQ4MC8yMDE4MDIvMTMzNTQ4MC0yMDE4MDIyMjIzNTQzMDIwNi0xOTk0NjkwMzQwLmdpZg" alt="左旋"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>简而言之就是某个节点的父节点变成了其左子节点，对于原来的左子节点，变成原来父节点的右节点。</p><p><strong>2.右旋</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTMzNTQ4MC8yMDE4MDIvMTMzNTQ4MC0yMDE4MDIyMjIzNTUwMzEyNC0xNDE1MDk5MzcuZ2lm" alt="右旋"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>简而言之就是某个节点的父节点变成了其右子节点，对于原来的右子节点，变成原来父节点的左节点。</p><p><strong>3.LR双旋</strong></p><p><img src="https://img-blog.csdnimg.cn/20200426232346142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>它是左旋和右旋的结合版。</p><p><strong>4.RL双旋</strong></p><p>LR双旋的相反版本。</p><p>至于AVL是如何设计出这样的结构，这不是人类考虑的问题了。但是笔者理解是，为了保持节点平衡，尽可能降低树的高度，在红黑树中也有类似的操作。</p><p>好了，介绍了这几种旋转方法，我猜你已经晕头转向了。但是好戏刚刚开始。</p><ul><li>关于旋转：什么时候进行什么样的旋转？<em>我们需要一点想象力(Ignite your Imagination)。</em></li><li><p>对于直线型结构和回旋镖型结构，如下图所示。在当前节点的平衡因子小于-1且左子节点不存在并且当前节点的右子节点的左子节点存在，那么表示我们需要进行RL双旋，否则进行左旋；在当前节点的平衡因子大于1且右子节点不存在并且当前节点的左子节点的右子节点存在，那么表示我们需要进行LR双旋，否则进行右旋。</p><p> <img src="https://img-blog.csdnimg.cn/20200429130542284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 80%;" /></p></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429130844114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码如下，供参考：</p><pre><code class="hljs python"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">renew_balance_factor</span>(<span class="hljs-params">self,currNode:AVLNode</span>):</span>     <span class="hljs-keyword">if</span> currNode.balance_factor&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> currNode.balance_factor&lt;<span class="hljs-number">-1</span>:         <span class="hljs-keyword">if</span> self.isrebalance: self.rebalance(currNode)         <span class="hljs-keyword">return</span>      <span class="hljs-keyword">if</span> currNode.isLeftChild():          currNode.parent.balance_factor+=<span class="hljs-number">1</span>     <span class="hljs-keyword">elif</span> currNode.isRightChild():         currNode.parent.balance_factor-=<span class="hljs-number">1</span>     <span class="hljs-keyword">if</span> currNode.parent!=<span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> currNode.parent.balance_factor != <span class="hljs-number">0</span> :                  self.renew_balance_factor(currNode.parent)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rebalance</span>(<span class="hljs-params">self,currNode:AVLNode</span>):</span>     <span class="hljs-keyword">if</span> currNode.balance_factor&gt;<span class="hljs-number">1</span>:<span class="hljs-comment"># left-heavy sub tree</span>         <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currNode.right_child <span class="hljs-keyword">and</span> currNode.left_child.right_child:             self.LR_doubRot(currNode)             <span class="hljs-keyword">return</span>          <span class="hljs-keyword">else</span>:             self.R_Rot(currNode)     <span class="hljs-keyword">elif</span> currNode.balance_factor&lt;<span class="hljs-number">-1</span>:<span class="hljs-comment"># right-heavy sub tree</span>         <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currNode.left_child <span class="hljs-keyword">and</span> currNode.right_child.left_child:             self.RL_doubRot(currNode)         <span class="hljs-keyword">else</span>:             self.L_Rot(currNode)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>旋转后平衡因子如何更新</li></ul><p>我们在BST中插入节点，如果发现某个节点的平很因子大于1或小于-1。就表示我们该进行自平衡操作了。进行R单旋的情况是直线型结构：</p><p><img src="https://img-blog.csdnimg.cn/20200426233308794.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我们只需要将当前节点16绕7旋转至其右节点即可。其他节点不作改变。我们旋转的同时也<em>必须考虑平衡因子的变化</em>，这里会涉及</p><p>到比较复杂的数学推导，不过没必要紧张，你完全可以画图理解。</p><p><img src="https://img-blog.csdnimg.cn/20200426234231887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我们只需要更新A和B的平衡因子即可。</p><p><img src="https://img-blog.csdnimg.cn/20200428192052711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上面的new old 分别表示新老节点，h(·)表示节点高度。你看到这可能已经跃跃欲试了，数学可是我的强项呀！ L单旋同理。</p><p>很不幸的是，对于大部分人，包括笔者，数学都不是我们的强项！<strong>所以我们需要调动程序员思维。</strong>正所谓“车到山前必有路”。</p><p>思考替代方案中。。。</p><hr><p>很棒，你已经有了思路，我可以直接获取节点的高度啊！只需要编写一个get_node_bf（）函数就行了。需要注意的是，我们需要得到的是该节点左右子树中高度的<em>最大值。</em>所以我们必须进行递归左右子树，左右子树的“路径”，个数我们不知道：按照h(Node) = 1 + max(h(left_child),h(right_child)). 因此我们需要用两个列表path_level_l 和 path_level_r 来分别存储左右子树各个路径的高度。最后套用公式就是该节点的高度。</p><p>我们稍微整理一下思路写出代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_level</span>(<span class="hljs-params">node,depth,path_level</span>):</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>            <span class="hljs-keyword">if</span> node.isLeaf(): path_level.append(depth);<span class="hljs-keyword">return</span>              depth+=<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> node.left_child:                get_level(node.left_child,depth,path_level)            <span class="hljs-keyword">if</span> node.right_child:                get_level(node.right_child,depth,path_level)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果是叶子节点其高度为1，bf为0，我们再写一个求节点bf的函数：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_bf</span>(<span class="hljs-params">self,currNode:AVLNode</span>)-&gt;int:</span>        <span class="hljs-comment"># obtain current node&#x27;s bf</span>        max_l = max_r =<span class="hljs-number">0</span>        path_level_l = []        path_level_r = []        <span class="hljs-keyword">if</span> currNode.isLeaf():            <span class="hljs-keyword">return</span> (max_l-max_r)        <span class="hljs-keyword">else</span>:            get_level(currNode.left_child,<span class="hljs-number">1</span>,path_level_l)            get_level(currNode.right_child,<span class="hljs-number">1</span>,path_level_r)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path_level_l: max_l = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:max_l = max(path_level_l)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path_level_r: max_r = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>: max_r = max(path_level_r)            <span class="hljs-keyword">return</span> (max_l - max_r)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>进行LR单旋的是“回旋镖型结构”：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200426233513572.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我们同样进行平衡因子的动态更新，不过这次只用调用get_node_bf函数即可。注意C先变为B的父节点，B为C左子节点，A再变为C的右子节点，C的父节点改为A的父节点。A的父节点改为C是不是非常简单呢？</p><ul><li>下面我们将上述过程可视化：</li></ul><p>以下面数据为例：</p><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> = &#123;16:&#x27;<span class="hljs-type">A</span>&#x27;,3:&#x27;<span class="hljs-type">B</span>&#x27;,7:&#x27;<span class="hljs-type">C</span>&#x27;,11:&#x27;<span class="hljs-type">D</span>&#x27;,9:&#x27;<span class="hljs-type">E</span>&#x27;,26:&#x27;<span class="hljs-type">F</span>&#x27;,18:&#x27;<span class="hljs-type">G</span>&#x27;,14:&#x27;<span class="hljs-type">H</span>&#x27;,15:&#x27;<span class="hljs-type">I</span>&#x27;&#125;</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200429131256439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200429131329106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> 大家可以自行验证另一个完全相反的过程，检查自己的代码有无纰漏。</p><p>好了，非常高兴你能坚持看到这，如果你觉得困的话，可以明天再看删除操作：</p><h1 id="Del-方法实现"><a href="#Del-方法实现" class="headerlink" title="Del 方法实现"></a>Del 方法实现</h1><p>你已经喝完了咖啡，是否还感觉困呢？咖啡不要放太多糖。</p><p>Del 方法比put方法稍微复杂一点，但是我们有了put的相关方法，因而不会太麻烦。我们构建了上述二叉树，现在尝试依次删除150，130，160，140，155，120，157。</p><p>删除有三种情况：</p><ol><li>删除叶子节点；</li><li>删除节点只有一个子节点；</li><li>删除节点有两个子节点。</li></ol><p>如果你认真看了我关于二叉查找树的博客的话，会发现万变不离其宗。我们只需要在每次删除节点后更新bf即可。为此我们设计函数update_del_bf（）。如果我们发现当前节点不平衡，就将其通过旋转的方式平衡，继续更新它的父节点；如果节点平衡，我们依次更新父节点，直到父节点为None止。</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_del_bf</span>(<span class="hljs-params">self,currNode:AVLNode</span>):</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> currNode:<span class="hljs-keyword">return</span>    currNode.balance_factor = self.get_node_bf(currNode)    <span class="hljs-keyword">if</span> currNode.balance_factor&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> currNode.balance_factor&lt;<span class="hljs-number">-1</span>:        <span class="hljs-keyword">if</span> self.isrebalance: self.rebalance(currNode)        self.update_del_bf(currNode.parent)        <span class="hljs-keyword">return</span>         <span class="hljs-keyword">if</span> currNode.parent:<span class="hljs-comment">#update all parent bf         </span>        self.update_del_bf(currNode.parent)</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>好了删除操作我们也完成了，下面以图片的形式展示整个删除过程。</p><p><img src="https://img-blog.csdnimg.cn/20200429142633426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429142942653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429143050100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200429143153960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">上面就是，整个插入和删除的过程，相信你一定会有许多收获或者疑问，欢迎留言或者email .</p><p><a href="https://gitee.com/durantSaaS/data_structure_source_plan/blob/master/Advanced/AVL_tree.py">源代码在这里！</a></p><p>下一期介绍红黑树*</p>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>平衡树 - python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花拳绣腿学红黑</title>
    <link href="/2020/05/10/2020-05-10-red-black-tree/"/>
    <url>/2020/05/10/2020-05-10-red-black-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="花拳绣腿学红黑"><a href="#花拳绣腿学红黑" class="headerlink" title="花拳绣腿学红黑"></a>花拳绣腿学红黑</h1><p>一提到红黑树，你应该是这样想的。。。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTM5MzcwMTEwODUsMzIyNzA1Mjk5NSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上一期我们详细分析了<a href="https://blog.csdn.net/qq_32439305/article/details/105758962">AVL树</a>，相信你已经对二叉平衡树有了非常棒的理解。这一期我们开始介绍红黑树，红黑树在网上有很多资源，但是讲的不严谨，也不全面。笔者初学时也浪费了许多时间，因此我将非常细致的讲解，将自己踩过的坑晒出来，保证你能看懂。</p><p>红黑树和AVL树的区别是：<strong>AVL树是严格平衡的二叉树，红黑树是弱平衡的二叉树。和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此相同节点数的前提下，AVL树的高度往往低于红黑树。</strong>AVL树根据节点的平衡因子进行调整，而红黑树是根据颜色进行调整。大致地说，红黑树理解上较容易，而实现起来，需要注意的细节要更多（比如说考虑叔叔节点）。推荐大佬<a href="https://blog.csdn.net/Gosick_Geass_Gate/article/details/88556840">博客</a>：比较两者不同。</p><p><em>为什么要学二叉树呢？（斜体表示你问了一个很棒的问题）：</em></p><ul><li><strong>红黑树的结点增删改查效率非常优良，都为log(n) ,</strong> 应用方面：1. Linux内核进程调度由红黑树管理进程控制块。 2. Epoll用红黑树管理事件块。 3. nginx服务器用红黑树管理定时器。 4. C++ STL中的map和set的底层实现为红黑树。 5. Java中的TreeMap和TreeSet由红黑树实现。 6. Java8开始，HashMap中，当一个桶的链表长度超过8，则会改用红黑树。</li></ul><p>下面我们看一下红黑树的性质：</p><p><strong>1. 每个节点要么是黑色，要么是红色</strong> </p><p><strong>2. 根节点一定为黑色</strong> </p><p><strong>3. 每一个空节点(null / NIL)都是黑色（注意空节点不等于根节点）</strong></p><p><strong>4.一旦一个节点为黑色，它的孩子一定为黑色，也就是说，不可能有父子节点同时为红色。</strong></p><p><strong>5. 对每个节点而言，从每个黑色节点到叶子节点的节点数量相同。</strong></p><p>因此我们需要对树可视化函数稍作修改，对每个节点上色。对turtle，使用 t.fillcolor来设置填充颜色，t.begin_fill和t.end_fill来实现开始填充和结束填充，非常方便。</p><p><img src="https://img-blog.csdnimg.cn/20200505232447788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>笔者得到的树如上图所示，是不是很美观呢？但是光美观是不够的，我们还得实现背后的逻辑，而这也是最酷炫的部分。我保证，如果你能亲手成就一个红黑树，能让你“快乐”很长时间。</p><p>和AVL树类似，红黑树只需要在节点类加入颜色属性即可。为了后期代码方便，我们实现两个函数，一个是获取当前节点的叔叔节点get_uncle，另一个是获取兄弟节点get_brother</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uncle</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.parent <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.parent.parent: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-keyword">if</span> self.parent.parent.hasBothChildren():        <span class="hljs-keyword">if</span> self.parent.isLeftChild():            <span class="hljs-keyword">return</span> self.parent.parent.right_child        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.parent.parent.left_child<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_brother</span>(<span class="hljs-params">self</span>):</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.parent : <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-keyword">if</span> self.parent.hasBothChildren():        <span class="hljs-keyword">if</span> self.isLeftChild():            <span class="hljs-keyword">return</span> self.parent.right_child        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.parent.left_child</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 好了，我们依旧从插入和删除来讨论算法</p><h2 id="1-Put方法实现"><a href="#1-Put方法实现" class="headerlink" title="1. Put方法实现"></a>1. Put方法实现</h2><p>我们和AVL树类比，其实就是将平衡因子改变的过程变为更新颜色的过程而已，为此我们需要实现一个函数renew_color。需要注意的是每当创建一个新的叶子节点时候，它都应该是红色的。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>旋转过程在我上篇的AVL树博客中已经介绍（需要的读者自行食用），红黑树中的旋转也完全相同。</p><p>我们来作一些简单的设定。</p><p><img src="https://img-blog.csdnimg.cn/20200505232447788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在这幅图中，当前节点为B，那么其兄弟节点为E，其父节点为D，它的叔节点为A，祖父节点为C。</p><p>我们由浅入深 循序渐进来化解这个问题：</p><p>（1）若树为空树，那么直接添加一个节点作为根节点，且为黑色（事实上，根节点一定为黑色）。</p><p>（2）插入节点的key已经存在，那么我们只需要将节点的val更新成新的val即可。</p><p>（3）插入节点的父节点为黑节点，那么插入新节点不会影响树的平衡，直接插入即可。</p><p>（4）插入节点 的父节点为红色节点，插入节点也为红色，明显不平衡。且父节点肯定不是根节点，我们需要详细的讨论这种情况：</p><p><strong>1. 叔叔节点存在，并且叔叔节点为红色：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200514132939126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当前节点为B，此时父节点的左子树和右子树肯定是不平衡的。给你10s请你想一想，如何满足性质5？</p><p>一种直观的想法是将父节点D\C全部变为黑色，然后将当前节点B和其兄弟节点I</p><p>变为红色。</p><p><img src="https://img-blog.csdnimg.cn/20200514133333470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后我们需要考虑当前节点的祖父节点的颜色F。如果它不是根节点，我们需要将其颜色变为红色，然后将祖父节点变为当前节点继续向上平衡。注意，只有所有子树都平衡的情况下，整个树才是平衡的。简言之，红黑树平衡是至下而上的，而AVL树是自上而下的。</p><p><strong>2. 插入节点的父节点是左子节点</strong></p><p>这时候我们看当前节点是左子节点还是右子节点：</p><p><strong>右子节点：我们对祖父节点A进行LR双旋，祖父节点变为红色，父节点变为黑色 。</strong></p><p><img src="https://img-blog.csdnimg.cn/2020051413435664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>左子节点：对祖父节点A进行R单旋，同时将父节点颜色设为黑色，叔叔节点设为红色</strong></p><p><img src="https://img-blog.csdnimg.cn/20200514135453274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>3. 插入节点的父节点是右子节点</strong></p><p>与左子节点情况刚好相反，故不再演示，但是调试时候注意考虑这种情况。</p><p><em>OK，上面便是插入操作，我们来测试一下，数据为data = {12:’A’,1:’B’,9:’C’,2:’D’,3:’E’,2.5:’F’,11:’G’,10:’H’,2.4:’I’,6:’J’}</em><img src="https://img-blog.csdnimg.cn/20200514135937654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20200514140103721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><h2 id="2-Del方法实现"><a href="#2-Del方法实现" class="headerlink" title="2. Del方法实现"></a>2. Del方法实现</h2><p>现在我们考虑更复杂的删除情况。你需要一杯咖啡，因为接下来内容会比较多和干燥。但是我保证你看完之后会很有启发。</p><p>现在我们写一个def <strong>delitem</strong>函数，这样我们就能使用del 关键字删除特定key了。我们先简单回顾一下，</p><p>（1）如果待删除的结点是叶子结点，则直接删除即可。</p><p>（2）如果待删除的结点只有一个孩子，则设定currNode.parent.left_child = currNode.left_child或者currNode.parent.right_child = currNode.right_child，替换节点为其独子。　　</p><p>（3）如果待删除的结点有两个孩子，则可以找它的<strong>后继</strong>，将值覆盖过来，之后情况转变成删除前驱或者后继结点，回到（1）和     （2）。</p><p>删除的<strong>含义</strong>在于，删的不是节点本身，而是它的“替身”。（你可以想象成JOJO里的替身使者:-&gt;）</p><p>下面是 <strong>正片</strong> 即在<strong>删除之前</strong>，我们必须更新颜色和进行旋转，这些在函数update_del_color()中体现：</p><p>先考虑几个边值条件：</p><p><strong>1. 树为空，直接返回None即可；</strong></p><p><strong>2. 利用get_node函数找到需要删除的节点，如果没找到，直接返回None。</strong></p><p><strong>3. 如果替换节点是红色的，将其改为黑色，因为删除红色节点不会影响平衡</strong></p><p>所谓的再平衡无异乎是找兄弟或者父母去“借”，是不是很形象呢{坏笑}：<br>我们可以将<strong>当前节点分为左子节点和右子节点</strong>两种情况，它们是完全对称的，</p><ul><li>先考虑左子节点情况：</li></ul><p>​    假设实际被删除节点为C，</p><p><strong>（a）父节点为红色，且兄弟节点没有子节点</strong></p><p>我们将父节点变为黑色，同时将兄弟节点变为红色（兄弟节点一定没有子节点）。下面这个图可以直观展现这点：</p><p><img src="https://img-blog.csdnimg.cn/20200514201702553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>（b）父节点为黑色，且兄弟节点没有子节点</strong></p><p>我们将兄弟节点颜色改为红色，之后再对父节点执行update_del_color进行递归。</p><p><img src="https://img-blog.csdnimg.cn/20200514191528935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>（c）兄弟节点左子节点存在，且为红色节点，右节点随意</strong></p><p> 那么这个时候我们需要考虑父节点B的颜色，因为兄弟左子节点D为红色，我们可以把它借出去，涂成父节点的颜色，再将父节点颜色设为黑色。之后对父节点B进行RL双旋，但是不要改变节点颜色，只有在插入时才改变节点颜色。</p><p><img src="https://img-blog.csdnimg.cn/20200514193714675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里白色表示颜色不确定。</p><p><strong>（d）兄弟节点右子节点存在，且为红色节点，左子节点为黑色</strong></p><p>兄弟变为父节点颜色，同时父节点变为黑色，而且右侄子变为黑色。再对父节点进行左旋。</p><p><img src="https://img-blog.csdnimg.cn/20200514194840326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>（e）兄弟节点有两个儿子，且兄弟为红色节点</strong></p><p>我们直接对父节点左旋，这就变成上面兄弟为黑色情况，再调用update_del_color对父节点进行递归：</p><p><img src="https://img-blog.csdnimg.cn/20200514201513136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>当前节点为右子节点，刚好相反，故不再赘述</li></ul><p>下面我们将完整的过程展现出来，根据July的博客<a href="https://blog.csdn.net/v_july_v/article/details/6284050。">https://blog.csdn.net/v_july_v/article/details/6284050。</a></p><p>依次删除12 1 9 2 0 11 7 19 4 15 18 5 14 13 10 16 6 3 8 17。 大家可以作一个对比，如果你有任何问题，请立刻在下方留言！笔者不胜感激。</p><ul><li>完整的红黑树</li></ul><p><img src="https://img-blog.csdnimg.cn/20200514202205266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514202813225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514202921413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203019653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203205400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> <img src="https://img-blog.csdnimg.cn/20200514203706923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/2020051420352144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203800625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203823648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203914829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514203951941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204138852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204152841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204239757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204302184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204326749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204346475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204356989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204427970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200514204443441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDM5MzA1,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>希望本文对你有帮助，</p><p><a href="https://gitee.com/durantSaaS/data_structure_source_plan/blob/master/Advanced/RedBlackTree.py">源代码</a>在这里！</p><p>码字不易，希望大家多多转发，多点赞！邮箱durant2019@sina.com</p>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>平衡树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
