<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>双胞胎DFS与BFS</title>
    <link href="/2020/09/27/2020-8-12-dfs-bfs/"/>
    <url>/2020/09/27/2020-8-12-dfs-bfs/</url>
    
    <content type="html"><![CDATA[<h1 id="专题-DFS-amp-BFS"><a href="#专题-DFS-amp-BFS" class="headerlink" title="专题:DFS&amp;BFS"></a>专题:DFS&amp;BFS</h1><blockquote><p> DFS:深度优先搜索，BFS：广度优先搜索，是最频繁被考察的算法知识点之一。我们来找一些例题专门研究一下。</p></blockquote><p>二叉树里面的三种遍历既可以用DFS（递归写法），也可以用BFS（迭代+栈），而层序遍历对应的就是BFS。</p><p>在图论中，DFS是万金油算法，其衍生的如Dijisktra(优先队列)，SPFA算法是<strong>最短路</strong>的主流算法。</p><p>下面介绍一类二维矩阵中典型的「岛屿问题」，来加深理解，在整体DFS框架中又隐藏一些彩蛋，加以利用的话可以极大的优化算法。</p><ul><li><a href="https://leetcode-cn.com/problems/number-of-islands/">L200. 岛屿数量</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/surrounded-regions/">L130.被围绕的区域 (Medium)</a></li><li><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a> （Easy）</li><li><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> （Medium）</li><li><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a> （Hard）</li></ul><hr><h2 id="1-被围绕的区域"><a href="#1-被围绕的区域" class="headerlink" title="1.被围绕的区域"></a>1.被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span></code></pre><p>运行你的函数后，矩阵变为：</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span></code></pre><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><hr><p><strong>思路</strong>：常规的想法是在矩阵中找到所有湖然后判断其是否与边界0相连，显然，这不是一个很好的注意，有可能一开碰到边界，也有可能最后找到边界，也有可能中间碰到边界。</p><p>所以此时需要换一种思路，我们找到一个「DFS触发条件」，以减少任务量，一种思路是从四个边界出发，如果为<code>&#39;O&#39;</code>，则进入DFS，将所有的<code>&#39;O&#39;</code>改为<code>&#39;A&#39;</code>，之后遍历完之后，将所有剩余的<code>&#39;O&#39;</code>改为<code>&#39;X&#39;</code>即可。</p><h2 id="2-岛屿的数量"><a href="#2-岛屿的数量" class="headerlink" title="2. 岛屿的数量"></a>2. 岛屿的数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1:</p><pre><code class="hljs prolog">[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]]输出: <span class="hljs-number">1</span></code></pre><p>示例 2:</p><pre><code class="hljs prolog">输入:[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>]]输出: <span class="hljs-number">3</span></code></pre><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><hr><p><strong>思路：</strong>同样地，我们判断一个岛屿与哪些1相连是很困难的，因此需要转换思路，我们把「DFS触发条件」设定为<code>grid[x][y]==&#39;1&#39;</code>，此时岛屿数量加1，把遍历过的点改为0.即可。</p><p><strong>时间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。</p><p><strong>空间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 $M×N$。</p><h2 id="3-最大人工岛（Hard）"><a href="#3-最大人工岛（Hard）" class="headerlink" title="3. 最大人工岛（Hard）"></a>3. 最大人工岛（Hard）</h2><p>在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。</p><p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]输出: <span class="hljs-number">3</span>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，最终连通两个小岛得到面积为 <span class="hljs-number">3</span> 的岛屿。</code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]输出: <span class="hljs-number">4</span>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。</code></pre><p>示例 3:</p><pre><code class="hljs angelscript">输入: [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]输出: <span class="hljs-number">4</span>解释: 没有<span class="hljs-number">0</span>可以让我们变成<span class="hljs-number">1</span>，面积依然为 <span class="hljs-number">4</span>。</code></pre><p>说明:</p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= grid.length = grid[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">50</span><span class="hljs-symbol">0 </span>&lt;= grid[i][j] &lt;= <span class="hljs-number">1</span></code></pre><hr><p>在解这道题之前，我们需要想到一些边界情况;</p><ol><li>全为陆地，则无法填海，<code>maxArea = m*n</code>,m,n分别为地图横纵尺寸。</li><li>全为海洋，则仍可以填岛，<code>maxArea = 1</code>.</li><li>只有一座连通岛，那么此时填充的作用仅仅是扩大面积而不是连通相邻的岛，<code>maxArea = maxArea+1</code>.</li></ol><p>那么如何填充使得面积最大，这个通过题目的简单例子是无法感受到的，比如下面这种情况</p><script type="math/tex; mode=display">[[0,0,1,0,0,0,0,1,0,0,0,0,0],\\ [0,0,0,0,0,0,0,1,1,1,0,0,0],\\ [0,1,1,0,1,0,0,0,0,0,0,0,0],\\ [0,1,0,0,1,1,0,0,1,0,1,0,0],\\ [0,1,0,0,1,1,0,0,1,1,1,0,0],\\ [0,0,0,0,0,0,0,0,0,@,*,0,0],\\ [0,0,0,0,0,0,0,1,1,1,0,0,0],\\ [0,0,0,0,0,0,0,1,1,0,0,0,0]]\\</script><p>（1）<code>@=0,*=0</code>,此时可以把@变为1，最大面积为<code>5+5+1=11</code>。</p><p>（2）<code>@=0,*=1</code>,此时可以把@变为1或者*下方的0变为1，最大面积为<code>6+5+1=12</code>。</p><p><strong>思路</strong>：把连通岛编号<code>index(&gt;=2)</code>。统计每个人工岛的最大面积（通过dfs）。然后再遍历地图，把所有为<code>0</code>的地方，<u>研究其是否连接<em>至少</em>两个岛，即上下左右方向链接不同<code>index</code>的岛屿。</u></p><p>这样的话，我们就能兼顾所有情况。C++代码如下。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m,n,maxArea,index;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; base_area;<span class="hljs-comment">//基础面积哈希表</span>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; d = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">outRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> (x&gt;=m||y&gt;=n||x&lt;<span class="hljs-number">0</span>||y&lt;<span class="hljs-number">0</span>) ;<span class="hljs-comment">//越界检查</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> &amp;area)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//找到至少两个index不相等的岛屿，并统计它们的面积</span>        <span class="hljs-keyword">int</span> base_index = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(!outRange(x+d[i][<span class="hljs-number">0</span>],y+d[i][<span class="hljs-number">1</span>])&amp;&amp;grid[x+d[i][<span class="hljs-number">0</span>]][y+d[i][<span class="hljs-number">1</span>]])             &#123;                base_index = grid[x+d[i][<span class="hljs-number">0</span>]][y+d[i][<span class="hljs-number">1</span>]];                <span class="hljs-keyword">if</span>(!count(temp.begin(),temp.end(),base_index))area += base_area[base_index];                temp[i] = base_index;            &#125;        &#125;                            &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid, <span class="hljs-keyword">int</span> &amp;area)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">// cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot;,y:&quot;&lt;&lt;y&lt;&lt;endl;</span>        <span class="hljs-keyword">if</span>(outRange(x,y)|| grid[x][y]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;        grid[x][y] = index;<span class="hljs-comment">//已经走过的陆地标记为index</span>        area+=<span class="hljs-number">1</span>;        dfs(x+<span class="hljs-number">1</span>,y,grid,area);         dfs(x<span class="hljs-number">-1</span>,y,grid,area);         dfs(x,y+<span class="hljs-number">1</span>,grid,area);         dfs(x,y<span class="hljs-number">-1</span>,grid,area);             &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!grid.size()||!grid[<span class="hljs-number">0</span>].size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = grid.size();        n = grid[<span class="hljs-number">0</span>].size();        maxArea = <span class="hljs-number">0</span>;        index = <span class="hljs-number">2</span>;        <span class="hljs-comment">//1.研究基础未填岛情况，把各个岛屿的面积保存再哈希表中</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;            dfs(i,j,grid,area);            base_area[index] = area;            <span class="hljs-built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,area:&quot;</span>&lt;&lt;base_area[index]&lt;&lt;<span class="hljs-built_in">endl</span>;            index++;               maxArea = max(maxArea,area);        &#125;        <span class="hljs-comment">//2.研究填岛情况，遍历所有的0</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)        &#123;<span class="hljs-comment">//如果&lt;u&gt;研究其是否连接*至少*两个岛，即上下左右方向链接不同`index`的岛屿</span>            <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;            connect(i,j,grid,area);            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,area:&quot;</span>&lt;&lt;area&lt;&lt;<span class="hljs-built_in">endl</span>;            maxArea = max(area,maxArea);        &#125;        <span class="hljs-comment">//研究几种需要填岛的特殊情况</span>        <span class="hljs-comment">//1.没有陆地 maxArea==0</span>        <span class="hljs-comment">//2.最大面积岛屿旁边没有相邻岛maxArea!=0, max_fillArea==0</span>        <span class="hljs-keyword">if</span>(maxArea==(m*n)) <span class="hljs-keyword">return</span> m*n;        <span class="hljs-keyword">return</span> maxArea+<span class="hljs-number">1</span>;<span class="hljs-comment">//没有海洋或没有岛</span>    &#125;&#125;;</code></pre><p>时间和空间可以根据代码进行分析。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>DFS</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法I 决策树</title>
    <link href="/2020/09/27/ML4_DecisionTree/"/>
    <url>/2020/09/27/ML4_DecisionTree/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习算法I-决策树"><a href="#机器学习算法I-决策树" class="headerlink" title="机器学习算法I: 决策树"></a>机器学习算法I: 决策树</h1><p>决策树的基本算法是「<strong>分而治之</strong>」。</p><p>设有训练集$D$以及属性集$A$. 函数<code>TreeGenerate(D,A)</code>算法如下：</p><ul><li><p>我们生成树节点node，若D中样本全部属于同一类别C.就将node标记为C类叶节点。</p></li><li><p>如果A为空集或者D中样本在A上取值相同，那么将node标记为叶节点，其类别标记为D中样本数最多的类。然后返回。</p></li><li><p>从A中选择最优划分属性$a^*$.</p></li><li><p>对最优划分属性的每个子属性$a_i$:</p><ul><li>为node生成一个分支，令$D_v$表示$D$在$a^*$上取值为$a_i$的样本子集；<ul><li>如果$D_v$为空，那么将分支节点标记为叶节点，其类别标记为$D$中样本最多的类。并返回。</li><li>以$TreeGenrate(D_v,A/(a_*))为分支节点$</li></ul></li></ul><p>最后输出一棵以node为根节点的决策树。</p></li></ul><h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><p>如何选择最优划分属性？我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即纯度（purity）越来越高。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k=1,2,..n)$，则$D$的信息熵定义为</p><script type="math/tex; mode=display">Entropy(D)=-\sum_\limits{k=1}^{n}p_k\log_2 p_k</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>决策树</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必须掌握数据结构-二叉树</title>
    <link href="/2020/09/23/2020-9-23-binary_tree/"/>
    <url>/2020/09/23/2020-9-23-binary_tree/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs markdown">&#123;% note success %&#125;二叉树&#123;% endnote %&#125;</code></pre><h1 id="二叉树相关算法"><a href="#二叉树相关算法" class="headerlink" title="二叉树相关算法"></a>二叉树相关算法</h1><blockquote><p>一看到二叉树，基本上可以确定是DFS或者BFS了，比较单调，但是也有一些很复杂的题目。二叉树，根据实际需要，演变为二叉搜索树，2-3-4树，平衡树（红黑树、AVL树），在计算机系统中占据重要地位。</p></blockquote><p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 $n(n&gt;0)$ 个有限节点组成一个具有层次关系的集合。</p><p><img src="\img\binary_1.png" alt=""></p><p>把它叫做「树」是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>它具有以下的特点：</p><ul><li>每个节点都只有有限个子节点或无子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li><li>树里面没有环路。</li></ul><p>我们将介绍</p><ul><li>二叉树的表示</li><li><p>二叉树的遍历</p></li><li><p>二叉树序列化以及反序列化</p></li><li>树形dp</li><li>最近公共祖先（LCA）</li><li>二叉平衡树</li><li>二叉树路径求和</li></ul><hr><p><strong>部分题目</strong></p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">968.二叉树监控（Hard）</a></li><li>124.二叉树最大路径（Hard）</li><li>99.恢复二叉搜索树（Hard）</li><li>297.二叉树序列化与反序列化</li><li><ol><li>从中序遍历和前序遍历构造二叉树</li></ol></li><li><ol><li>从中序遍历和后序遍历构造二叉树</li></ol></li><li><ol><li>二叉树最近公共祖先</li></ol></li><li><ol><li>从先序遍历还原二叉树（Hard）</li></ol></li></ul><hr><h2 id="二叉树的表示"><a href="#二叉树的表示" class="headerlink" title="二叉树的表示"></a>二叉树的表示</h2><p>我们一般采用结构体或者类来表示树节点。一棵树由其根节点<strong>唯一</strong>的表示。</p><p>C++</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span>    <span class="hljs-keyword">int</span> val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(<span class="hljs-number">0</span>), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;    TreeNode(<span class="hljs-keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;</code></pre><p>Java</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> TreeNode left;    <span class="hljs-keyword">public</span> TreeNode right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">this</span>(x, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, TreeNode _left, TreeNode _right)</span></span>&#123;        val = x;        left = _left;        right = _right;    &#125;&#125;</code></pre><p>python</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span></code></pre><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>由许多方法可以帮我们完成遍历：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）、层序遍历。</p><p>采用递归是非常trivial的。我们思考迭代的方式。</p><p><strong>前序遍历</strong></p><ol><li>首先申请一个新的栈，记为stack；</li><li>声明一个结点treeNode，让其指向node结点；</li><li>如果treeNode的不为空，将treeNode的值打印，并将treeNode入栈，然后让treeNode指向treeNode的右结点，</li><li>重复步骤3，直到treenode为空；</li><li>然后出栈，让treeNode指向treeNode的右孩子</li><li>重复步骤3，直到stack为空.</li></ol><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;            <span class="hljs-comment">//迭代访问节点的左孩子，并入栈</span>            <span class="hljs-keyword">while</span>(treeNode != <span class="hljs-keyword">null</span>)&#123;                System.out.print(treeNode.data+<span class="hljs-string">&quot; &quot;</span>);                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-comment">//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                treeNode = stack.pop();                treeNode = treeNode.rightChild;            &#125;        &#125;    &#125;</code></pre><p><strong>中序遍历</strong></p><p><em>*对于一棵二叉搜索树而言，其中序遍历是非递减的。</em>，这可以成为许多题目的key。</p><p>例如：<code>[5,3,7,2,4,6,8]</code>，其中序遍历（根左右）为<code>[2,3,4,5,6,7,8]</code>，前序遍历（左根右）<code>[5,3,2,4,7,6,8]</code>，后序（左右根）遍历<code>[2,4,3,6,8,7,5]</code></p><ul><li>算法</li></ul><ol><li>申请一个新栈，记为stack，申请一个变量cur，初始时令treeNode为头节点；</li><li>先把treeNode节点压入栈中，对以treeNode节点为头的整棵子树来说，依次把整棵树的左子树压入栈中，即不断令treeNode=treeNode.leftChild，然后重复步骤2；</li><li>不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点记为treeNode，打印node的值，并让treeNode= treeNode.right，然后继续重复步骤2；</li><li>当stack为空并且cur为空时结束。</li></ol><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;            <span class="hljs-keyword">while</span>(treeNode != <span class="hljs-keyword">null</span>)&#123;                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                treeNode = stack.pop();                System.out.print(treeNode.data+<span class="hljs-string">&quot; &quot;</span>);                treeNode = treeNode.rightChild;            &#125;        &#125;    &#125;</code></pre><p><strong>后序遍历</strong></p><p>我们需要一个标记位来记忆我们此时节点上一个节点，具体看代码注释</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraveralWithStack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();        TreeNode treeNode = node;        TreeNode lastVisit = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//标记每次遍历最后一次访问的节点</span>        <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<span class="hljs-comment">//节点不为空，结点入栈，并且指向下一个左孩子</span>            <span class="hljs-keyword">while</span>(treeNode!=<span class="hljs-keyword">null</span>)&#123;                stack.push(treeNode);                treeNode = treeNode.leftChild;            &#125;            <span class="hljs-comment">//栈不为空</span>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;                <span class="hljs-comment">//出栈</span>                treeNode = stack.pop();                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 这块就是判断treeNode是否有右孩子，</span><span class="hljs-comment">                 * 如果没有输出treeNode.data，让lastVisit指向treeNode，并让treeNode为空</span><span class="hljs-comment">                 * 如果有右孩子，将当前节点继续入栈，treeNode指向它的右孩子,继续重复循环</span><span class="hljs-comment">                 */</span>                <span class="hljs-keyword">if</span>(treeNode.rightChild == <span class="hljs-keyword">null</span> || treeNode.rightChild == lastVisit) &#123;                    System.out.print(treeNode.data + <span class="hljs-string">&quot; &quot;</span>);                    lastVisit = treeNode;                    treeNode  = <span class="hljs-keyword">null</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    stack.push(treeNode);                    treeNode = treeNode.rightChild;                &#125;            &#125;        &#125;    &#125;</code></pre><p><strong>层序遍历</strong></p><p>层序遍历比较简单</p><ol><li>首先申请一个新的队列，记为queue；</li><li>将头结点head压入queue中；</li><li>每次从queue中出队，记为node，然后打印node值，如果node左孩子不为空，则将左孩子入队；如果node的右孩子不为空，则将右孩子入队；</li><li>重复步骤3，直到queue为空。</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelorder</span><span class="hljs-params">(TreeNode *root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; postorder;    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;    q.push(root);    TreeNode *node;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> num_node = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> q_size = q.size();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; q_size;i++)        &#123;            node = q.front();            postorder.emplace_back(node-&gt;val);            <span class="hljs-keyword">if</span>(node-&gt;left) q.push(node-&gt;left);            <span class="hljs-keyword">if</span>(node-&gt;right) q.push(node-&gt;right);            <span class="hljs-keyword">delete</span> node;            q.pop();         &#125;    &#125;    <span class="hljs-keyword">return</span> postorder;&#125;</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li><p>从前序遍历和中序遍历构造二叉树</p></li><li><p>从后序遍历和中序遍历构造二叉树</p></li></ol><p>我们要知道，中序遍历作用是确定左右子树与根节点的相对位置。我们建立一个哈希表记录中序遍历所有节点的位置，然后在前序遍历寻找，直到遇到叶子节点。</p><hr><h2 id="二叉树序列化和反序列化"><a href="#二叉树序列化和反序列化" class="headerlink" title="二叉树序列化和反序列化"></a>二叉树序列化和反序列化</h2><blockquote><p>我们需要将字符串转化为树或者反过来就需要序列化和反序列化。</p></blockquote><h4 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h4><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>示例:</strong> </p><pre><code class="hljs lsl">你可以将以下二叉树：    <span class="hljs-number">1</span>   / \  <span class="hljs-number">2</span>   <span class="hljs-number">3</span>     / \    <span class="hljs-number">4</span>   <span class="hljs-number">5</span>序列化为 <span class="hljs-string">&quot;[1,2,3,null,null,4,5]&quot;</span></code></pre><p><strong>提示:</strong> 这与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://leetcode-cn.com/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>说明:</strong> 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><hr><p><strong>C++代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; res&#123;root&#125;;        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_Q;<span class="hljs-comment">//用于从树中解析出数字到res数组中</span>        <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;[&quot;</span>;        node_Q.push(root);        <span class="hljs-keyword">while</span> (!node_Q.empty())        &#123;            TreeNode *node = node_Q.front();node_Q.pop();            <span class="hljs-keyword">if</span> (node-&gt;left)            &#123;                node_Q.push(node-&gt;left);                res.push_back(node-&gt;left);            &#125;<span class="hljs-keyword">else</span>                res.push_back(<span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">if</span> (node-&gt;right)            &#123;                node_Q.push(node-&gt;right);                res.push_back(node-&gt;right);            &#125;<span class="hljs-keyword">else</span>                res.push_back(<span class="hljs-literal">NULL</span>);        &#125;        <span class="hljs-keyword">while</span>(!res.back()) res.pop_back();<span class="hljs-comment">//去掉多余的NULL</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c:res)             <span class="hljs-keyword">if</span>(c) &#123;s += to_string(c-&gt;val);s+=<span class="hljs-string">&quot;,&quot;</span>;&#125;            <span class="hljs-keyword">else</span>  s += <span class="hljs-string">&quot;null,&quot;</span>;        s.pop_back();        s+=<span class="hljs-string">&quot;]&quot;</span>;        <span class="hljs-keyword">return</span> s;    &#125;        <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span> </span>&#123;        <span class="hljs-comment">//data forms like &quot;[72,1,4,6,null,5,3,null,null,null,null,null,2]&quot;</span>        <span class="hljs-comment">//时间复杂度：O(n),空间复杂度O(3n)</span>        <span class="hljs-keyword">if</span>(!data.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; data_list;        <span class="hljs-built_in">string</span> num;        <span class="hljs-keyword">bool</span> num_flag = <span class="hljs-literal">false</span>;        <span class="hljs-comment">//将字符串转换为只含有数字和Null的数组,考虑负号和多位数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.size();i++)        &#123;            <span class="hljs-keyword">if</span>((data[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;data[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)||data[i]==<span class="hljs-string">&#x27;-&#x27;</span>)            &#123;                num += data[i];                num_flag = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i] == <span class="hljs-string">&#x27;n&#x27;</span>)            &#123;                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;                data_list.push_back(<span class="hljs-string">&quot;null&quot;</span>);                i += <span class="hljs-number">3</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num_flag) &#123;data_list.push_back(num);num = <span class="hljs-string">&quot;&quot;</span>;num_flag = <span class="hljs-literal">false</span>;&#125;        &#125;        TreeNode *root = <span class="hljs-keyword">new</span> TreeNode(stoi(data_list[<span class="hljs-number">0</span>]));        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_Q; <span class="hljs-comment">//用于装载所有不为null的节点</span>        data_list.erase(data_list.begin());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c: data_list)             <span class="hljs-keyword">if</span> (c!=<span class="hljs-string">&quot;null&quot;</span>) node_Q.push(<span class="hljs-keyword">new</span> TreeNode(stoi(c)));            <span class="hljs-keyword">else</span> node_Q.push(<span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; node_stack; <span class="hljs-comment">//用于构建树结构</span>        node_stack.push(root);        <span class="hljs-keyword">while</span> (!node_stack.empty())        &#123;            TreeNode * node = node_stack.front();node_stack.pop();            <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (!node_Q.empty())             &#123;                node-&gt;left = node_Q.front();node_Q.pop();                node_stack.push(node-&gt;left);            &#125;            <span class="hljs-keyword">else</span> node-&gt;left = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">if</span> (!node_Q.empty())             &#123;                    node-&gt;right = node_Q.front();node_Q.pop();                node_stack.push(node-&gt;right);            &#125;            <span class="hljs-keyword">else</span> node-&gt;right = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre><p><strong>Java代码</strong></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNodeHelper</span></span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root The root node of a binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The level traversal serialization of this binary tree. For the syntax of serialization,</span><span class="hljs-comment">     * check https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation</span><span class="hljs-comment">     * or https://support.leetcode-cn.com/hc/kb/article/1194353/.</span><span class="hljs-comment">     * If the root node contains any circle, it will return &quot;Error! Cycle found in the binary tree!&quot;.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">treeNodeToString</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;        &#125;        StringBuilder SB = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);        Deque&lt;TreeNode&gt; BFS = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();        HashSet&lt;TreeNode&gt; memo = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        BFS.offer(root);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;        TreeNode cur;        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span>)&#123;            cur = BFS.poll();            <span class="hljs-keyword">if</span> (memo.contains(cur))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error! Cycle found in the binary tree!&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (cur != <span class="hljs-keyword">null</span>)&#123;                --cnt;                SB.append(Integer.toString(cur.val));                SB.append(<span class="hljs-string">&#x27;,&#x27;</span>);                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>)&#123;                    ++cnt;                &#125;                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>)&#123;                    ++cnt;                &#125;                BFS.offer(cur.left);                BFS.offer(cur.right);                memo.add(cur);            &#125;            <span class="hljs-keyword">else</span>&#123;                SB.append(<span class="hljs-string">&quot;null,&quot;</span>);            &#125;        &#125;        SB.setCharAt(SB.length()-<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;]&#x27;</span>);        <span class="hljs-keyword">return</span> SB.toString();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input a level traversal serialization of a VALID binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The root node of the deserialized binary tree. if the input is not valid,</span><span class="hljs-comment">     * the result is undefined. To check the validity, you need these codes:</span><span class="hljs-comment">     * input = input.trim(); input = input.substring(1, input.length()-1)</span><span class="hljs-comment">     * if (input.charAt(0) == &#x27;[&#x27;) Then it may be a valid serialization.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">stringToTreeNode</span><span class="hljs-params">(String input)</span></span>&#123;        input = input.trim();        input = input.substring(<span class="hljs-number">1</span>, input.length()-<span class="hljs-number">1</span>);        String[] nodes = input.split(<span class="hljs-string">&quot;,&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length = nodes.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i)&#123;            nodes[i] = nodes[i].trim();        &#125;        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span> (nodes[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">true</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[<span class="hljs-number">0</span>]));            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            TreeNode ret = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[<span class="hljs-number">0</span>]));            Deque&lt;TreeNode&gt; BFS = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            BFS.offer(ret);            <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;            TreeNode cur;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;                cur = BFS.poll();                <span class="hljs-keyword">if</span> (++idx &gt;= length)&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">false</span>)&#123;                    cur.left = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[idx]));                    BFS.offer(cur.left);                &#125;                <span class="hljs-keyword">if</span> (++idx &gt;= length)&#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nodes[idx].equals(<span class="hljs-string">&quot;null&quot;</span>) == <span class="hljs-keyword">false</span>)&#123;                    cur.right = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(nodes[idx]));                    BFS.offer(cur.right);                &#125;            &#125;            <span class="hljs-keyword">return</span> ret;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input the treeNode you want to implement deep copy of a binary tree</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> If the input treeNode represents a valid binary tree, return a deep copy;</span><span class="hljs-comment">     * if the input treeNode is null or it doesn&#x27;t represent a valid binary tree, return null;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">TreeNodeDeepCopy</span><span class="hljs-params">(TreeNode input)</span></span>&#123;        <span class="hljs-keyword">if</span> (input == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        String copyStr = TreeNodeHelper.treeNodeToString(input);        <span class="hljs-keyword">if</span> (copyStr.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;[&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//It means the input TreeNode is not valid, so return a null pointer;</span>        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> TreeNodeHelper.stringToTreeNode(copyStr);        &#125;    &#125;&#125;</code></pre><p><strong>Python代码</strong>（附带绘图）</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> turtleprintTree_switch = <span class="hljs-literal">True</span><span class="hljs-keyword">if</span> printTree_switch:    t = turtle.Turtle()    t.penup()    t.speed(<span class="hljs-string">&#x27;fast&#x27;</span>)<span class="hljs-comment">#&#x27;fastest&#x27; &#x27;fast&#x27; &#x27;normal&#x27; &#x27;slow&#x27; &#x27;slowest&#x27;</span>    t.shape(<span class="hljs-string">&#x27;turtle&#x27;</span>)<span class="hljs-comment">#arrow&quot;, &quot;turtle&quot;, &quot;circle&quot;, &quot;square&quot;, &quot;triangle&quot;, &quot;classic&quot;</span><span class="hljs-comment"># Definition for a binary tree node.</span>null = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>         self.val = x         self.left = <span class="hljs-literal">None</span>         self.right = <span class="hljs-literal">None</span><span class="hljs-comment">#___________________________Visualize a tree___________________________________</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">printTree</span>():</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,tree</span>):</span>        self.radius = <span class="hljs-number">50</span>        self.level = <span class="hljs-number">0</span>        self.branch_length = <span class="hljs-number">4</span>*self.radius        self.node_memo = &#123;&#125;        self.draw_binary_tree(tree,(<span class="hljs-number">0</span>,<span class="hljs-number">300</span>),self.level)            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_node</span>(<span class="hljs-params">self,data,start_pos</span>):</span>        <span class="hljs-comment"># draw the node</span>        (x,y) = start_pos        length = len(str(data))        t.setx(x);t.sety(y)        t.pendown()        t.setheading(<span class="hljs-number">0</span>)        t.circle(self.radius)        t.penup();t.goto(x-length/<span class="hljs-number">2</span>*<span class="hljs-number">16</span>,y+self.radius<span class="hljs-number">-8</span>);t.pendown()        t.write(data, font=(<span class="hljs-string">&quot;Arial&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;normal&quot;</span>))        t.penup()        t.setx(x)        t.sety(y)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_branch</span>(<span class="hljs-params">self,start_pos,orient,level</span>):</span>        <span class="hljs-comment">#draw the branch</span>        (x,y) = start_pos        t.setx(x);t.sety(y)        t.pendown()        t.setheading(<span class="hljs-number">180</span>)        <span class="hljs-keyword">if</span> orient == <span class="hljs-string">&#x27;left&#x27;</span>:            t.left(<span class="hljs-number">15</span>+<span class="hljs-number">20</span>*level)            t.forward(self.branch_length-level*<span class="hljs-number">20</span>)        <span class="hljs-keyword">elif</span> orient == <span class="hljs-string">&#x27;right&#x27;</span>:            t.left(<span class="hljs-number">180</span>-(<span class="hljs-number">15</span>+<span class="hljs-number">20</span>*level))            t.forward(self.branch_length-level*<span class="hljs-number">20</span>)        t.penup()        <span class="hljs-keyword">return</span> t.pos()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_binary_tree</span>(<span class="hljs-params">self,p,start_pos,level</span>):</span>        (x,y) = start_pos        self.node_memo[p] = (x,y+self.radius)        <span class="hljs-keyword">if</span> p!=<span class="hljs-literal">None</span>:            level+=<span class="hljs-number">1</span>            print(<span class="hljs-string">&quot;level:&quot;</span>,level)            self.draw_node(p.val,(x,y))            <span class="hljs-keyword">if</span> p.left!=<span class="hljs-literal">None</span>:                (x1,y1) = self.draw_branch((x,y),<span class="hljs-string">&#x27;left&#x27;</span>,level)                self.draw_binary_tree(p.left,(x1,y1<span class="hljs-number">-2</span>*self.radius),level)                        <span class="hljs-keyword">if</span> p.right!=<span class="hljs-literal">None</span>:                (x2,y2)=self.draw_branch((x,y),<span class="hljs-string">&#x27;right&#x27;</span>,level)                self.draw_binary_tree(p.right,(x2,y2<span class="hljs-number">-2</span>*self.radius),level)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_node_coord</span>(<span class="hljs-params">self,node</span>)-&gt;tuple:</span>        <span class="hljs-comment">#return the coord of the node circle centre</span>        <span class="hljs-keyword">return</span> self.node_memo[node]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_line</span>(<span class="hljs-params">self,coord1, coord2,pensize=<span class="hljs-number">5</span>,pen_color=<span class="hljs-string">&#x27;red&#x27;</span></span>):</span> <span class="hljs-comment">#from 1 to 2</span>        (x,y) = coord1          t.penup()        t.pensize(pensize)        t.pencolor(pen_color)        t.setx(x);t.sety(y)        t.pendown()        t.goto(coord2[<span class="hljs-number">0</span>],coord2[<span class="hljs-number">1</span>])        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">thank_turtle</span>():</span><span class="hljs-comment"># used when tree drawing ends</span>    turtle.done()<span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Encodes a tree to a single string.</span><span class="hljs-string">        </span><span class="hljs-string">        :type root: TreeNode</span><span class="hljs-string">        :rtype: str</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>        res = [(root.val, root)]        node_Q = deque()        node_Q.appendleft((root.val, root))        node = root        <span class="hljs-keyword">while</span> node_Q:            tup = node_Q.popleft()            a = tup[<span class="hljs-number">0</span>]; node = tup[<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> node.left:                node_Q.append((node.left.val, node.left))                res.append((node.left.val, node.left))            <span class="hljs-keyword">else</span>:                res.append((<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">None</span>))            <span class="hljs-keyword">if</span> node.right:                node_Q.append((node.right.val, node.right))                res.append((node.right.val, node.right))            <span class="hljs-keyword">else</span>:                res.append((<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">None</span>))        <span class="hljs-comment"># remove redundant nones and stringify it</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:             node = res[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: res.pop()            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span>        ret = []        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:             <span class="hljs-keyword">if</span> r != <span class="hljs-string">&#x27;null&#x27;</span>:                ret.append(str(r[<span class="hljs-number">0</span>]))            <span class="hljs-keyword">else</span>:                ret.append(r[<span class="hljs-number">0</span>])         <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>+<span class="hljs-string">&#x27;,&#x27;</span>.join(ret)+<span class="hljs-string">&#x27;]&#x27;</span>                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Decodes your encoded data to tree.</span><span class="hljs-string">        </span><span class="hljs-string">        :type data: str</span><span class="hljs-string">        :rtype: TreeNode</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-comment"># first we have to transform the string to a list </span>        <span class="hljs-comment"># and supplement the missing none</span>        <span class="hljs-comment"># it&#x27;s totally a reversal process of serialization</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        deserial =  data[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)        root = TreeNode(deserial[<span class="hljs-number">0</span>])        node_Q = deque()        <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> deserial[<span class="hljs-number">1</span>:]:             <span class="hljs-keyword">if</span> i!=<span class="hljs-string">&#x27;null&#x27;</span>: node_Q.append(TreeNode(int(i)))            <span class="hljs-keyword">else</span>: node_Q.append(<span class="hljs-literal">None</span>)        node_stack = deque()        node_stack.append(root)        <span class="hljs-keyword">while</span> node_stack:            node = node_stack.popleft()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node: <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">if</span> node_Q:                 node.left = node_Q.popleft()                node_stack.append(node.left)            <span class="hljs-keyword">else</span>: node.left = <span class="hljs-literal">None</span>            <span class="hljs-keyword">if</span> node_Q:                 node.right = node_Q.popleft()                node_stack.append(node.right)            <span class="hljs-keyword">else</span>: node.right = <span class="hljs-literal">None</span>        <span class="hljs-keyword">return</span> root</code></pre><hr><h2 id="树形dp（竞赛难度）"><a href="#树形dp（竞赛难度）" class="headerlink" title="树形dp（竞赛难度）"></a>树形dp（竞赛难度）</h2><p> 一般来说树形dp在设状态转移方程时都可以用f[i][]表示i这颗子树怎么怎么样的最优解，实现时一般都是用子树更新父亲（即从下向上更新），那么首先应该考虑的是一个一个子树的更新父亲还是把所有子树都算完了在更新父亲？这就要因题而异了，一般来说有两种情况：    1. <strong>需要把所有子树的信息都掌握之后再更新子树的就需要把所有子树都算完了在更新父亲</strong>。</p><ol><li><strong>而像树上背包这样的问题就需要一个一个的更新，每次都用一个子树更新已经更新完的子树+父亲，最后就可以将这一部分的子树更新完了，再继续往上更新，最后根节点就是答案。</strong></li></ol><p>其实上面的两种情况可以总结成一种情况就是一个个子树更新父亲，一般来说第一种情况应用更多，也能解决第二情况的问题，只不过如果符合第二种情况的时候用第二种可以速度更快一点，毕竟你省了一遍循环嘛。</p><ul><li><p>有依赖的背包问题（见相应专题）</p></li><li><ol><li>监控二叉树</li></ol><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2></li></ul><h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h4><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">1</span>解释：如图所示，一台摄像头足以监控所有节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="img"></p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>]输出：<span class="hljs-number">2</span>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><hr><p>假设根节点为$root$,其左右子节点分别为$left$,$right$。</p><ul><li>如果根节点处放摄像头，那么左右子节点不需要放摄像头。</li><li>如果根节点处不放摄像头，则左右节点之一必须要放摄像头。</li></ul><p>通过以上的分析，二叉树节点主要有三种状态：</p><ol><li>根节点处必须放摄像头的条件下，覆盖整棵树需要的摄像头数目。</li><li>覆盖整颗树需要的摄像头数目，无论$root$是否放摄像头。</li><li>覆盖两颗子树需要的摄像头数目，无论$root$是否被覆盖到。</li></ol><p>设三种状态下需要的摄像头数量分别为$a,b,c$。那么一定有$a\ge b\ge c$。</p><p>设左子树的对应上述状态变量分别为$l_a,l_b,l_c$,右子树的对应上述状态变量分别为$r_a,r_b,r_c$,那么有：</p><ul><li>$a = l_c+r_c+1$</li><li>$b=min(a,min(l_a+r_b,l_b+r_a))$，左子树和右子树肯定有一个根节点有摄像头，另一个没有，如果两个都有，则说明产生冗余，不是最优解。</li><li>$c=min(a,l_b+r_b)$,对c而言，要保证两颗子树均被覆盖，要么root放摄像头,那么等于$a$，要么不放，即为$l_b+r_b$。</li></ul><p>对于边界条件的判断。</p><p>如果该节点为<code>null</code>那么相当于无论用多少个摄像头都无法覆盖$a=INT_MAX,b=0,c=0$</p><hr><p><strong>代码</strong></p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_MAX = <span class="hljs-number">0x3f3f3f3f</span>;    <span class="hljs-keyword">int</span> res;    <span class="hljs-keyword">int</span>[] dfs(TreeNode root)    &#123;<span class="hljs-comment">//返回a,b,c</span>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;INT_MAX,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">int</span>[]l = dfs(root.left);        <span class="hljs-keyword">int</span>[]r = dfs(root.right);        <span class="hljs-keyword">int</span> l_a = l[<span class="hljs-number">0</span>], r_a = r[<span class="hljs-number">0</span>], l_b = l[<span class="hljs-number">1</span>], r_b = r[<span class="hljs-number">1</span>], l_c = l[<span class="hljs-number">2</span>], r_c = r[<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span> a = l_c + r_c + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = Math.min(a,Math.min(l_a+r_b,l_b+r_a));        <span class="hljs-keyword">int</span> c = Math.min(a,l_b + r_b);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b,c&#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> dfs(root)[<span class="hljs-number">1</span>];    &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>经典数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂内存中堆和栈的区别</title>
    <link href="/2020/09/18/CS_heap_stack/"/>
    <url>/2020/09/18/CS_heap_stack/</url>
    
    <content type="html"><![CDATA[<h1 id="弄懂内存中堆和栈的区别"><a href="#弄懂内存中堆和栈的区别" class="headerlink" title="弄懂内存中堆和栈的区别"></a>弄懂内存中堆和栈的区别</h1><blockquote><p>知识的<a href="https://blog.csdn.net/myqq1418/article/details/81584761">传送门</a></p></blockquote><p><strong>栈区</strong>($stack$)：由编译器自动分配释放，存放函数的参数值，以及局部变量的值，其操作方式类似数据结构的栈。</p><p><strong>堆区</strong>($heap$)：一般由程序员分配释放，若程序不释放，会被操作系统回收。其操作方式类似于数据结构的链表。</p><p><strong>全局区</strong>($static$)：全局变量和静态变量的存储在一起，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><p><strong>文字常量区</strong>：常量和字符串等。</p><p><strong>程序代码区</strong>：程序的二进制代码。</p><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p><img src="\img\heap_1.png" alt="image-20200918200847502"></p><p><img src="\img\heap_2.png" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局初始化区</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局初始化区</span><span class="hljs-keyword">char</span> *p1; <span class="hljs-comment">//全局未初始化区</span>main() &#123;    <span class="hljs-keyword">int</span> b; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> *p2; <span class="hljs-comment">//栈</span>    <span class="hljs-keyword">char</span> *p3 = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//123456\0在常量区，p3在栈上。</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; <span class="hljs-comment">//全局（静态）初始化区</span>    p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//堆区，程序员自己申请，new也是的</span>    p2 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    <span class="hljs-comment">//分配得来得10和20字节的区域就在堆区。</span>    <span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>计算机组成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存 - 堆</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java八大数据类型以及封装类</title>
    <link href="/2020/09/18/Java_notes/"/>
    <url>/2020/09/18/Java_notes/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>Java基础学习</p>          </div><span class="label label-java">text</span><h1 id="Java八大数据类型以及封装类"><a href="#Java八大数据类型以及封装类" class="headerlink" title="Java八大数据类型以及封装类"></a>Java八大数据类型以及封装类</h1><p>Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者<a href="http://lib.csdn.net/base/operatingsystem">操作系统</a>的改变而改变。</p><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>short：16位，最<a href="http://lib.csdn.net/base/hadoop">大数据</a>存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>boolean：只有true和false两个取值。</p><p>char：16位，存储Unicode码，用单引号赋值。</p><div class="table-container"><table><thead><tr><th>单类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>Int</th><th>long</th><th>float</th><th>double</th><th>void</th></tr></thead><tbody><tr><td>二进制位数</td><td>1</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>32</td><td>64</td><td>—</td></tr><tr><td>封装器类</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td><td>Void</td></tr></tbody></table></div><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>$(byte，short，char)—int—long—float—double$</p><h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><p>X转字符串</p><ul><li>调用类转换方法：<code>X.toString()</code></li><li>自动类型转换：<code>X+&quot;&quot;</code></li><li>使用String方法，<code>String.ValueOf(X)</code></li></ul><p>转字符</p><ul><li>调用类转换方法：<code>X.toCharArray()</code></li></ul><p>字符串转X</p><p>①先转换成相应的封装器实例,再调用对应的方法转换成其它类型</p><p>例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue()</p><p>②静态parseXXX方法</p><pre><code class="hljs Java">String s = <span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-keyword">byte</span> b = Byte.parseByte( s );<span class="hljs-keyword">short</span> t = Short.parseShort( s );<span class="hljs-keyword">int</span> i = Integer.parseInt( s );<span class="hljs-keyword">long</span> l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );</code></pre><h1 id="Java引用类型"><a href="#Java引用类型" class="headerlink" title="Java引用类型"></a>Java引用类型</h1><p>Java有 5种引用类型（对象类型）：类 (Class) 接口(Interface) 数组 (List/ArrayList)枚举(enum) 标注</p><p>引用类型：底层结构和基本类型差别较大</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪婪却巧妙的贪心算法</title>
    <link href="/2020/09/02/2020-8-25-greedy/"/>
    <url>/2020/09/02/2020-8-25-greedy/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法及其应用"><a href="#贪心算法及其应用" class="headerlink" title="贪心算法及其应用"></a>贪心算法及其应用</h1><ul><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></li><li><a href="https://leetcode-cn.com/problems/jump-game-ii/">45.跳跃游戏II</a></li><li><a href="https://leetcode-cn.com/problems/jump-game/">55.跳跃游戏</a></li></ul><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p></blockquote><h2 id="最长上升序列"><a href="#最长上升序列" class="headerlink" title="最长上升序列"></a>最长上升序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]输出: <span class="hljs-number">4</span> 解释: 最长的上升子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 $O(n^2)$ 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p><hr><p>考虑一个简单的贪心，如果我们要求上升子序列尽可能长，那么要求序列上升的尽可能慢，因此要求每次最后加的数尽可能小。</p><p>基于以上思路，我们维护一个数组$d[i]$，表示长度为$i$的上升子序列末尾元素的最小值，用$len$记录目前最长上升长度。起始$d[1]=nums[0]$。</p><p>同时我们可以注意到，$d[i]$是关于$i$单调递增的。因为如果$d[j]\ge d[i]$且$j&lt;i$,我们考虑从长度为$i$的最长上升序列的末尾删除$i-j$个元素，那么这个序列的长度变为$j$，且第$j$个元素必然小于$d[i]$，也就小于$d[j]$.那么我们就找到一个长度为$j$的最长上升序列。且末尾元素比$d[j]$小，从而产生矛盾，单调性得证。</p><p>我们遍历数组，并更新$d[]$和$len$的值。如果$nums[i]&gt;d[len]$则更新$len+=1$，否则在$d[1…len]$中找到满足$d[i-1]&lt;nums[j]&lt;d[i]$的下标，并更新$d[i]=nums[j]$。</p><p>由于$d[]$单调，我们可以采用二分查找的方法，优化算法时间复杂度至$O(N\log N)$。</p><ul><li>设当前已求得最长上升子序列长度为$len$，初始为1，从前往后遍历数组$nums$，在遍历到$nums[i]$时：<ul><li>若$nums[i]&gt;d[len]$，直接加入到d数组末尾，$len+=1$.</li><li>否则，在d数组二分查找，找到第一个比$nums[i]$小的数$d[k]$，并更新$d[k+1] = nums[i]。$</li></ul></li></ul><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//最长子序列长度，可以通过dp</span>        <span class="hljs-comment">//同时利用哈希表，搜索过的空间就不搜索了</span>        <span class="hljs-comment">//注意，下一个较大元素可能不选，反而总长度会更长</span>        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//包含nums[i-1]，且以之为结束的最大子串长度</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;        d[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)        &#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; d[len]) d[++len]=nums[i];            <span class="hljs-keyword">else</span> <span class="hljs-comment">//在d进行二分查找,找到第一个比nums[i]小的数nums[k]</span>            &#123;                <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>,l = <span class="hljs-number">0</span>,r = len;                <span class="hljs-keyword">while</span>(l&lt;=r)                &#123;                    <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(nums[i] &gt; d[mid])                    &#123;                        k = mid;                        l = mid+<span class="hljs-number">1</span>;                    &#125;                     <span class="hljs-keyword">else</span> r = mid<span class="hljs-number">-1</span>;                &#125;                 d[k+<span class="hljs-number">1</span>] = nums[i];                         &#125;        &#125;        <span class="hljs-keyword">return</span> len;                &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学和信号应用于解题</title>
    <link href="/2020/09/02/2020-8-25-math/"/>
    <url>/2020/09/02/2020-8-25-math/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hi这里数学仅仅指数论和几何以及离散数学，没有谁用高等数学出题的，不过你也可以试试，让面试官刮目相看。我们重点研究一些很经典的数学问题。</p></blockquote><h1 id="利用数学、信号理论解题"><a href="#利用数学、信号理论解题" class="headerlink" title="利用数学、信号理论解题"></a>利用数学、信号理论解题</h1><blockquote><p>包括但不限于数论，几何，排列组合等。。。</p><p>LC上有很多题目是和数学相关的，如果我们有一定的数学基础，那么解起题来事半功倍！</p></blockquote><ul><li><ol><li><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/">圆和矩形是否有重叠</a></li></ol></li><li>求质因数（GCD）</li><li>快速幂算法</li><li>FFT算法</li><li>Java bitCount的实现</li></ul><h2 id="质因数求解"><a href="#质因数求解" class="headerlink" title="质因数求解"></a>质因数求解</h2><p>设$ R = \sqrt{A}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+1$个不同的质因数。质因数为本身的只有一个，非本身的质因数一定比$R$小，最多$R$个。</p><p><strong>策略</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)<span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>) &#123;...&#125;</code></pre><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><p>交替递归，可以有效减小迭代次数。$(a,b)\rightarrow ( b,a\%b)$直到有一个数为0.</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">return</span> gcd(b, a % b);&#125;</code></pre><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote><p><a href="https://blog.csdn.net/qq_19782019/article/details/85621386">https://blog.csdn.net/qq_19782019/article/details/85621386</a></p></blockquote><p>我们思考一个问题，求$2^{100}$的最后三位数。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fastPower</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % <span class="hljs-number">1000</span>;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="FFT算法"><a href="#FFT算法" class="headerlink" title="FFT算法"></a>FFT算法</h2><hr><h2 id="1-完全平方数"><a href="#1-完全平方数" class="headerlink" title="1. 完全平方数"></a>1. 完全平方数</h2><p>1770年，<a href="[https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem](https://en.wikipedia.org/wiki/Lagrange&#39;s_four-square_theorem">Lagrange</a>)证明了一个定理，被称为四平方数定理，它指出每个自然数都能表示为四个平方整数之和：</p><script type="math/tex; mode=display">p=a_0^2+a_1^2+a_2^2+a_3^2</script><p>这就规定了问题的上限，即最大的平方数个数是4.</p><p>注意，这里0也被当成完全平方数。</p><p>后来1797年，<a href="https://en.wikipedia.org/wiki/Adrien-Marie_Legendre">Legendre</a>用他的三平方定理完成了四平方定理，正整数可以表示为三个平方和的一个特殊条件：</p><script type="math/tex; mode=display">n\ne 4^k(8m+7) \Leftrightarrow p=a_0^2+a_1^2+a_2^2</script><p>在我们分解为（底部情况）三平方数之前，还有两种特例需要检查：</p><ol><li><p>该数本身是一个完全平方数 即<code>n=(int)(sqrt(n)*sqrt(n))</code></p></li><li><p>如果一个数可以分解为两个平方数之和，不幸的是，我们只能通过枚举来找到这样的数。</p></li></ol><p><strong>算法：</strong></p><ol><li><p>检查该数是否为完全平方数</p></li><li><p>如果该数可以表示为$n == 4^k(8m+7)$，那么可以确切的说，答案肯定为4；</p></li></ol><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) n /= <span class="hljs-number">4</span>;<span class="hljs-keyword">if</span>((n<span class="hljs-number">-7</span>)%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>) res = <span class="hljs-number">4</span>;</code></pre><ol><li>我们看该数，是否能由更少的完全平方数组成。</li></ol><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n<span class="hljs-number">-1</span>;k &gt;= <span class="hljs-number">1</span>;k--)&#123;    <span class="hljs-keyword">if</span>(isPerfectSquare(n*n-k*k)) res = <span class="hljs-number">2</span>;&#125;</code></pre><p><strong>代码：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> n == ((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n))*((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n));    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//一些很特殊的情况12 = 2^2+2^2+2^2; 18 = 3^2+3^2;1000= 30^2+10^2;61=5^2+6^2</span>    <span class="hljs-keyword">if</span>(isPerfectSquare(n)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> nn = n;    <span class="hljs-comment">//判断是否为四平方数</span>    <span class="hljs-keyword">while</span>(nn%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) nn/=<span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span>((nn<span class="hljs-number">-7</span>)%<span class="hljs-number">8</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n<span class="hljs-number">-1</span>;k &gt;= <span class="hljs-number">1</span>;k--)    <span class="hljs-keyword">if</span>(isPerfectSquare(k))    &#123;        <span class="hljs-comment">// printf(&quot;%d:\n&quot;,k);</span>        <span class="hljs-keyword">if</span>(isPerfectSquare(n-k)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>： 最好的情况下是$O(1)$，比如$n$是完全平方数, 最坏$O(N)$，即该数有两个平方数组成。</li><li><strong>空间复杂度</strong>:   $O(1)$，常数级别空间占用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>几何</tag>
      
      <tag>信号理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>貌似很难懂的DSA是什么？</title>
    <link href="/2020/09/02/2020-9-2-fsm/"/>
    <url>/2020/09/02/2020-9-2-fsm/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是确定有限状态自动机（Deterministic-State-Automata）？"><a href="#什么是确定有限状态自动机（Deterministic-State-Automata）？" class="headerlink" title="什么是确定有限状态自动机（Deterministic State Automata）？"></a>什么是确定有限状态自动机（Deterministic State Automata）？</h1><p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p><ul><li>有一个特殊的状态，被称作「初始状态」。</li><li>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</li></ul><p>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p><p>一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。</p><p>自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。</p><p>自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。</p><hr><p><strong>例题：</strong></p><ul><li><ol><li><a href="">有效的数字</a>(Hard)</li></ol></li><li>剑指Offer 20. <a href="">表示数值的字符串</a>(Medium)</li></ul><hr><p>以 剑指Offer 20. <a href="">表示数值的字符串</a>(Medium) 为例。</p><blockquote><p> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p></blockquote><hr><p><strong>思路与算法</strong></p><p>根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p><ol><li>起始的空格</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点</li><li>小数部分</li><li>字符$E$</li><li>指数部分的符号位</li><li>指数的整数部分</li><li>结束的空格</li></ol><p>下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。</p><p>最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：</p><p><img src="\img\image-fsa.png" alt="image-20200902111512582"></p><p>在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 \text{e}e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。</p><hr><p><strong>代码</strong>：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">enum</span> state    &#123;        STATE_INIT,        <span class="hljs-comment">// STATE_SPACE,</span>        STATE_SIGN,        STATE_INTEGER,        STATE_POINT_INT,        STATE_POINT_NOT_INT,        STATE_DECIMAL,        STATE_EXP,        STATE_EXP_SIGN,        STATE_EXP_INT,        STATE_END,    &#125;;    <span class="hljs-keyword">enum</span> charType    &#123;        CHAR_NUM,        CHAR_SPACE,        CHAR_POINT,        CHAR_EXP,        CHAR_SIGN,        CHAR_INVALID,    &#125;;    <span class="hljs-function">charType <span class="hljs-title">getCharType</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_NUM;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span> CHAR_SPACE;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_POINT;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;E&#x27;</span>||ch == <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_EXP;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;+&#x27;</span>||ch==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> CHAR_SIGN;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CHAR_INVALID;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">int</span> len = s.length();        state sta = STATE_INIT;        <span class="hljs-comment">//用哈希表存储状态转移方程</span>        <span class="hljs-built_in">unordered_map</span>&lt;state,<span class="hljs-built_in">unordered_map</span>&lt;charType,state&gt;&gt; transfer&#123;            &#123;                STATE_INIT, &#123;&#123;CHAR_SPACE,STATE_INIT&#125;,                            &#123;CHAR_SIGN, STATE_SIGN&#125;,                            &#123;CHAR_NUM, STATE_INTEGER&#125;,                            &#123;CHAR_POINT,STATE_POINT_NOT_INT&#125;            &#125;&#125;,            &#123;                STATE_SIGN,&#123;&#123;CHAR_NUM, STATE_INTEGER&#125;,                           &#123;CHAR_POINT, STATE_POINT_NOT_INT&#125;,            &#125;&#125;,            &#123;                STATE_DECIMAL,  &#123;&#123;CHAR_NUM, STATE_DECIMAL&#125;,                                &#123;CHAR_EXP, STATE_EXP&#125;,                                &#123;CHAR_SPACE, STATE_END&#125;            &#125;&#125;,            &#123;                STATE_INTEGER,  &#123;&#123;CHAR_NUM, STATE_INTEGER&#125;,                                &#123;CHAR_EXP,STATE_EXP&#125;,                                &#123;CHAR_POINT,STATE_POINT_INT&#125;,                                &#123;CHAR_SPACE,STATE_END&#125;            &#125;&#125;,            &#123;                STATE_POINT_NOT_INT,&#123;&#123;CHAR_NUM, STATE_DECIMAL&#125;            &#125;&#125;,            &#123;                STATE_POINT_INT,&#123;&#123;CHAR_SPACE,STATE_END&#125;,                                &#123;CHAR_NUM,STATE_DECIMAL&#125;,                                &#123;CHAR_EXP,STATE_EXP&#125;            &#125;&#125;,            &#123;                STATE_EXP,  &#123;&#123;CHAR_SIGN, STATE_EXP_SIGN&#125;,                            &#123;CHAR_NUM, STATE_EXP_INT&#125;            &#125;&#125;,            &#123;                STATE_EXP_SIGN,&#123;&#123;CHAR_NUM, STATE_EXP_INT&#125;            &#125;&#125;,            &#123;                STATE_EXP_INT,&#123;&#123;CHAR_NUM,STATE_EXP_INT&#125;,                                &#123;CHAR_SPACE,STATE_END&#125;&#125;            &#125;,            &#123;                STATE_END,&#123;&#123;CHAR_SPACE,STATE_END&#125;,&#125;            &#125;        &#125;;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)        &#123;            charType ct = getCharType(s[i]);            <span class="hljs-comment">//如果是非法状态，直接返回false</span>                    <span class="hljs-keyword">if</span>(!transfer[sta].count(ct)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            sta = transfer[sta][ct];                    &#125;         <span class="hljs-keyword">return</span> sta == STATE_END || sta == STATE_INTEGER || sta == STATE_POINT_INT || sta == STATE_DECIMAL|| sta == STATE_EXP_INT;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>有限自动状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索vs动态规划</title>
    <link href="/2020/08/28/2020-8-28-memorized-search/"/>
    <url>/2020/08/28/2020-8-28-memorized-search/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索vs动态规划"><a href="#记忆化搜索vs动态规划" class="headerlink" title="记忆化搜索vs动态规划"></a>记忆化搜索vs动态规划</h1><ul><li><blockquote><p>记忆化搜索实际上是递归来实现的，但是递归的过程中有许多的结果是被反复计算的，这样会大大降低算法的执行效率。　而记忆化搜索是在递归的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，因此极大的提高了算法的效率。</p></blockquote></li></ul><blockquote><p>记忆化搜索与动态规划区别：记忆化搜索：「<strong>自顶向下</strong>」，动态规划：「<strong>自底向上</strong>」。所有动态规划能解决的问题，记忆化搜索也能解决，唯一要注意的是动态规划不容易超时，但空间占用大，而记忆化搜索因为递归较多，容易TLE。    </p></blockquote><ul><li><a href="">546.移除盒子</a>(Hard)</li><li><a href="https://leetcode-cn.com/problems/burst-balloons/solution/chuo-qi-qiu-by-leetcode-solution/">312.戳气球</a>(Hard)</li><li><a href="">1575.可行路径数</a>(hard)</li><li><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a>(Medium)（结合状态压缩）</li></ul><hr><h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h2><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code>，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>]输出: <span class="hljs-number">167</span> 解释: nums = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>] --&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>] --&gt;   [<span class="hljs-number">3</span>,<span class="hljs-number">8</span>]   --&gt;  [<span class="hljs-number">8</span>]  --&gt; []     coins =  <span class="hljs-number">3</span>*<span class="hljs-number">1</span>*<span class="hljs-number">5</span>      +  <span class="hljs-number">3</span>*<span class="hljs-number">5</span>*<span class="hljs-number">8</span>    +  <span class="hljs-number">1</span>*<span class="hljs-number">3</span>*<span class="hljs-number">8</span>      + <span class="hljs-number">1</span>*<span class="hljs-number">8</span>*<span class="hljs-number">1</span>   = <span class="hljs-number">167</span></code></pre><hr><p>总的戳破气球操作数一定为<code>n</code>。我们可以倒过来看这些操作，每一次添加一个气球。</p><p>我们定义方法$solve(i,j)$表示将区间$(i,j)$全部填满所能得到的最多的硬币数。这里是一个开区间。当</p><ul><li><p>$i\ge j-1$，$solve(i,j)=0$</p></li><li><p>否则，我们枚举开区间$(i,j)$内的全部位置$mid$，令$mid$为当前区间第一个添加的气球，该操作所能得到的硬币数为  </p></li><li><script type="math/tex; mode=display">nums[mid-1]*nums[mid]*nums[mid+1] ​</script></li><li><p>同时我们递归的计算出分割的两区间对$solve(i,j)$的贡献，这三项最大值，即为$solve(i,j)$的值。这样问题可以转换为求$solve(i,mid)$与$solve(mid,j)$之和。</p></li></ul><p>状态转移方程：</p><script type="math/tex; mode=display">solve(i,j)= \left\{\begin{array}{rrr}0,i \ge j-1\\solve(i,mid)+\\ \max \limits_{i\lt mid \lt j}(nums[mid-1]*nums[mid]*nums[mid+1])+\\ solve(mid,j), otherwise\\\end{array}\right.</script><p>然后我们再看边界条件：</p><blockquote><p>$solve(0,0)=0$</p></blockquote><p>为了避免重复计算，我们存储<code>solve</code>的中间结果。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> n;     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; memo;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//开区间(i,j)内积分最大值,先加mid，再计算最大值</span>                <span class="hljs-keyword">if</span>(i &gt;= j<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span>(memo[i][j]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> memo[i][j];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mid = i+<span class="hljs-number">1</span>; mid &lt; j; mid++)        &#123;            memo[i][j] = max(memo[i][j], nums[i]*nums[mid]*nums[j]+solve(i,mid)+solve(mid,j) );        &#125;        <span class="hljs-keyword">return</span> memo[i][j];    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//这一题和移除盒子是同类型题，要靠JOJO奇妙的动态规划来解决</span>        <span class="hljs-comment">//我们要让尽可能大的气球相邻</span>        n = nums.size();        nums.insert(nums.begin(),<span class="hljs-number">1</span>);        nums.emplace_back(<span class="hljs-number">1</span>);        <span class="hljs-keyword">this</span>-&gt;nums = nums;        memo.resize(n+<span class="hljs-number">2</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>));        <span class="hljs-keyword">return</span> solve(<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>);    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(n^3)$，其中 $n$ 是气球数量。区间数为 $n^2$，区间迭代复杂度为 O(n)O(n)，最终复杂度为 $O(n^2 \times n) = O(n^3)$</p></li><li><p>空间复杂度：$O(n^2)$，其中 $n$ 是气球数量。缓存大小为区间的个数。</p></li></ul><p><strong>动态规划代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = nums.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">rec</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>))</span></span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            val[i] = nums[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;                    <span class="hljs-keyword">int</span> sum = val[i] * val[k] * val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = max(rec[i][j], sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];    &#125;&#125;;</code></pre><h2 id="546-移除盒子"><a href="#546-移除盒子" class="headerlink" title="546. 移除盒子"></a>546. 移除盒子</h2><p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。<br>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。<br>当你将所有盒子都去掉之后，求你能获得的最大积分和。</p><p>示例：</p><pre><code class="hljs angelscript">输入：boxes = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-number">23</span>解释：[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span> 分) ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">1</span>*<span class="hljs-number">1</span>=<span class="hljs-number">1</span> 分) ----&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>=<span class="hljs-number">9</span> 分) ----&gt; [] (<span class="hljs-number">2</span>*<span class="hljs-number">2</span>=<span class="hljs-number">4</span> 分)</code></pre><p>提示：</p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= boxes.length &lt;= <span class="hljs-number">100</span><span class="hljs-symbol">1 </span>&lt;= boxes[i] &lt;= <span class="hljs-number">100</span></code></pre><hr><p>这一题的规模比较小，按照官方的尿性，官解的时间复杂度会很大。很神奇的是，这种题目也可以通过动态规划解决。</p><p>用$f(l,r,k)$表示移除区间$[l,r]$加上该区间右边等于$a_r$的$k$个元素组成的序列的最大积分。</p><h2 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h2><hr><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>示例 1：</p> <pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>]输出：False解释：一开始，玩家<span class="hljs-number">1</span>可以从<span class="hljs-number">1</span>和<span class="hljs-number">2</span>中进行选择。如果他选择 <span class="hljs-number">2</span>（或者 <span class="hljs-number">1</span> ），那么玩家 <span class="hljs-number">2</span> 可以从 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）和 <span class="hljs-number">5</span> 中进行选择。如果玩家 <span class="hljs-number">2</span> 选择了 <span class="hljs-number">5</span> ，那么玩家 <span class="hljs-number">1</span> 则只剩下 <span class="hljs-number">1</span>（或者 <span class="hljs-number">2</span> ）可选。所以，玩家 <span class="hljs-number">1</span> 的最终分数为 <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>，而玩家 <span class="hljs-number">2</span> 为 <span class="hljs-number">5</span> 。因此，玩家 <span class="hljs-number">1</span> 永远不会成为赢家，返回 False 。</code></pre><p>示例 2：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">233</span>, <span class="hljs-number">7</span>]输出：True解释：玩家 <span class="hljs-number">1</span> 一开始选择 <span class="hljs-number">1</span> 。然后玩家 <span class="hljs-number">2</span> 必须从 <span class="hljs-number">5</span> 和 <span class="hljs-number">7</span> 中进行选择。无论玩家 <span class="hljs-number">2</span> 选择了哪个，玩家 <span class="hljs-number">1</span> 都可以选择 <span class="hljs-number">233</span> 。     最终，玩家 <span class="hljs-number">1</span>（<span class="hljs-number">234</span> 分）比玩家 <span class="hljs-number">2</span>（<span class="hljs-number">12</span> 分）获得更多的分数，所以返回 True，表示玩家 <span class="hljs-number">1</span> 可以成为赢家。</code></pre><p>提示：</p><ul><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于 10000000 。</li><li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li></ul><hr><p>我们用$dp[l][r]$表示闭区间$[l,r]$内，自己「先手」能获得的分数最大值。那么函数<code>dfs(l,r)</code>返回<code>dp[l][r]</code>。并进行记录。</p><p><strong>记忆化搜索</strong> </p><p>$dp[l][r] = sum(l,r) - min(dp[l+1][r],dp[l][r-1])$</p><blockquote><p> 边界条件 $dp[l][l] = nums[l]$; 返回值：$dfs(nums,0,n-1)*2 &gt;= sum(nums,0,n-1)$</p></blockquote><p>时间复杂度：$O(2^n)$</p><p>空间复杂度: $O(n)$，递归的空间复杂度取决于使用了多少栈空间。</p><p><strong>动态规划</strong>    </p><p>$dp[l][r] = max(-dp[l+1][r] + nums[l],-dp[l][r-1]+nums[r])$</p><p>我们先在$nums[l],nums[r]$中进行选择，同时保证对手的$dp[l+1][r]或者dp[l][r-1]$最小。 </p><blockquote><p>边界条件 $dp[l][l] = nums[l]$, 返回值：$dp[0][n-1]&gt;=0$</p></blockquote><p>使用递归存在大量重复计算，时间复杂度很高，因而采用动态规划是更好的选择。<strong>注意</strong>：$i$的遍历要从$n$开始，即反过来。</p><p>时间复杂度：$O(n^2)$</p><p>空间复杂度: $O(n)$，使用滚动数组优化。</p><p><strong>代码（DFS+记忆化搜索）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> dp[<span class="hljs-number">22</span>][<span class="hljs-number">22</span>];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allsum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//对下标l-r进行求和</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r;i++) sum += nums[i];        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//记忆化搜索，返回l,r使得先手优势最大的值</span>        <span class="hljs-keyword">if</span>(dp[l][r]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[l][r];        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l==r) &#123;dp[l][r]=nums[l];<span class="hljs-keyword">return</span> nums[l];&#125;        dp[l][r] = allsum(nums,l,r) - min(dfs(nums,l+<span class="hljs-number">1</span>,r),dfs(nums,l,r<span class="hljs-number">-1</span>));        <span class="hljs-comment">// printf(&quot;dp[%d][%d]=%d\n&quot;,lr,dp[l][r]);</span>        <span class="hljs-keyword">return</span> dp[l][r];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>&gt;=allsum(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><p><strong>代码（DFS+动态规划）</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-comment">//采用零和博弈的动态规划解法</span>    <span class="hljs-keyword">int</span> n = nums.size();    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>))</span></span>;<span class="hljs-comment">//表示[i,j]区间的最大值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) dp[i][i] = nums[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n;i &gt;= <span class="hljs-number">0</span>;i--)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; n;j++)    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n &amp;&amp; j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)    &#123;        dp[i][j] = max(-dp[i+<span class="hljs-number">1</span>][j]+nums[i], -dp[i][j<span class="hljs-number">-1</span>]+nums[j]);        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;dp[i][j]&lt;&lt;endl;    </span>            &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;    &#125;&#125;;</code></pre><hr><h4 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a><a href="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗</a></h4><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到或超过 100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p><p>给定一个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和另一个整数 <code>desiredTotal</code>（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？</p><p>你可以假设 <code>maxChoosableInteger</code> 不会大于 20， <code>desiredTotal</code> 不会大于 300。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入：</span><span class="hljs-string">maxChoosableInteger</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">desiredTotal</span> <span class="hljs-string">=</span> <span class="hljs-number">11</span><span class="hljs-string">输出：</span><span class="hljs-literal">false</span><span class="hljs-string">解释：</span><span class="hljs-string">无论第一个玩家选择哪个整数，他都会失败。</span><span class="hljs-string">第一个玩家可以选择从</span> <span class="hljs-number">1</span> <span class="hljs-string">到</span> <span class="hljs-number">10</span> <span class="hljs-string">的整数。</span><span class="hljs-string">如果第一个玩家选择</span> <span class="hljs-number">1</span><span class="hljs-string">，那么第二个玩家只能选择从</span> <span class="hljs-number">2</span> <span class="hljs-string">到</span> <span class="hljs-number">10</span> <span class="hljs-string">的整数。</span><span class="hljs-string">第二个玩家可以通过选择整数</span> <span class="hljs-number">10</span><span class="hljs-string">（那么累积和为</span> <span class="hljs-number">11</span> <span class="hljs-string">&gt;=</span> <span class="hljs-string">desiredTotal），从而取得胜利.</span><span class="hljs-string">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span></code></pre><hr><blockquote><p>首先我们弄清稳赢的含义，也就是说在某一个回合，A走完一步后，B发现他无论下哪一步都会输，或者A发现自己无论下哪一步都会赢。这两者都表示A会赢。</p></blockquote><p>这道题目，是和博弈论相关的「先手」，很容易想到的做法是动态规划，但是因为回合数不确定，很难直接写出状态转移方程，这个时候我们可以，另辟蹊径，采用「<strong>记忆化搜索</strong>」，定义一个<code>helper</code>函数，参数分别为记忆化搜索范围<code>int maxChoosableIntegerx</code>，目标<code>int target</code>,状态转移方程组<code>boolean[] dp</code>, 还有状态<code>int state</code>，框架在两分钟内就可以搭好。</p><pre><code class="hljs cpp">state|(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>));<span class="hljs-comment">//表示对state第i位置1</span>state &amp; <span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>);<span class="hljs-comment">//判断state第i位是否为1</span></code></pre><p>我们思考状态压缩，因为最大整数不超过20，这就提示我们可以采用「<strong>状态压缩</strong>」。用$N$位二进制来表示状态，1表示选择，0表示未选，例如<code>1000_010</code>表示选择2和7。这里dp作用是<u>记忆状态</u>，如果在递归时，我们发现<code>dp[state]!=null</code>就可以直接返回<code>dp[state]</code>。</p><p><strong>算法</strong></p><p>我们实际考虑每个回合，先手能否稳赢，这里先手指各个回合。设<code>i</code>为选择的数，如果这个回合<code>target - i &lt;= 0</code>或者下一个回合 <code>helper(N, target - i, dp, state|cur) == false</code> 则表明先手获胜<code>dp[state] = true</code>并返回。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Boolean[] b;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canIWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxChoosableInteger, <span class="hljs-keyword">int</span> desiredTotal)</span> </span>&#123;        <span class="hljs-comment">//这个题属于经典零和博弈问题，要判断先手的玩家能否赢</span>        <span class="hljs-comment">//如果最大整数小于等于目标整数，那么先手玩家一定会赢</span>        <span class="hljs-comment">//记忆化搜索+状态压缩</span>        <span class="hljs-keyword">if</span>(maxChoosableInteger &gt;= desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>+maxChoosableInteger)*maxChoosableInteger &lt; <span class="hljs-number">2</span>*desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        b = <span class="hljs-keyword">new</span> Boolean[<span class="hljs-number">1</span> &lt;&lt; maxChoosableInteger];        <span class="hljs-keyword">return</span> helper(desiredTotal, <span class="hljs-number">0</span>, b , maxChoosableInteger);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> state, Boolean[] dp,<span class="hljs-keyword">int</span> N)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//dp[i]表示选择第i位后的状态</span>        <span class="hljs-keyword">if</span>(dp[state] != <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> dp[state];<span class="hljs-comment">//用类类型代替封装</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = N;i &gt;= <span class="hljs-number">1</span>;i--)        &#123;            <span class="hljs-keyword">if</span>((state &amp; <span class="hljs-number">1</span>&lt;&lt;(i-<span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) <span class="hljs-comment">//说明第i位还没用过</span>            &#123;                <span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>&lt;&lt;(i-<span class="hljs-number">1</span>);<span class="hljs-comment">//将第i位置1</span>                <span class="hljs-keyword">if</span>( target &lt;= i || (helper(target - i, state|cur, dp, N) == <span class="hljs-keyword">false</span>)) &#123;                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度：$O(N!)$</p><p>空间复杂度：$ O(1&lt;&lt;m)$，$m$为最大可选择整数。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论之求解欧拉通路</title>
    <link href="/2020/08/27/2020-8-27-some_tricks/"/>
    <url>/2020/08/27/2020-8-27-some_tricks/</url>
    
    <content type="html"><![CDATA[<h1 id="图论：求解欧拉通路问题"><a href="#图论：求解欧拉通路问题" class="headerlink" title="图论：求解欧拉通路问题"></a>图论：求解欧拉通路问题</h1><ul><li>753.<a href="https://leetcode-cn.com/problems/cracking-the-safe/">破解保险箱</a>(Hard)</li><li>332.<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a>(Medium)</li></ul><p>这类问题在实际生活中经常出现，大致可以抽象为：</p><blockquote><p>给定一个 <em>n</em> 个点 <em>m</em> 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。</p></blockquote><p>这种「一笔画」问题与欧拉图或者半欧拉图有着紧密的联系，下面给出定义：</p><ul><li><p>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</p></li><li><p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</p></li><li><p>具有欧拉回路的无向图称为欧拉图。</p></li></ul><p>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</p><hr><h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.<a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a></h3><p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p><p>说明:</p><p>如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前<br>所有的机场都用三个大写字母表示（机场代码）。<br>假定所有机票至少存在一种合理的行程。<br>示例 1:</p><pre><code class="hljs prolog">输入: [[<span class="hljs-string">&quot;MUC&quot;</span>, <span class="hljs-string">&quot;LHR&quot;</span>], [<span class="hljs-string">&quot;JFK&quot;</span>, <span class="hljs-string">&quot;MUC&quot;</span>], [<span class="hljs-string">&quot;SFO&quot;</span>, <span class="hljs-string">&quot;SJC&quot;</span>], [<span class="hljs-string">&quot;LHR&quot;</span>, <span class="hljs-string">&quot;SFO&quot;</span>]]输出: [<span class="hljs-string">&quot;JFK&quot;</span>, <span class="hljs-string">&quot;MUC&quot;</span>, <span class="hljs-string">&quot;LHR&quot;</span>, <span class="hljs-string">&quot;SFO&quot;</span>, <span class="hljs-string">&quot;SJC&quot;</span>]</code></pre><p>示例 2:</p><pre><code class="hljs prolog">输入: [[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>],[<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>],[<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>],[<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>],[<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]]输出: [<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]解释: 另一种有效的行程是 [<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-string">&quot;ATL&quot;</span>,<span class="hljs-string">&quot;SFO&quot;</span>]。但是它自然排序更大更靠后。</code></pre><hr><p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。</p><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><p>对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p><p>对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</p><p>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p><p>对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且</p><ul><li>恰有一个顶点的出度与入度差为 1；</li><li>恰有一个顶点的入度与出度差为 1；</li><li>所有其他顶点的入度和出度相同。</li></ul><p>让我们考虑下面的这张图：</p><p><img src="https://assets.leetcode-cn.com/solution-static/332/332_fig1.png" alt="Graph1" style="zoom:50%;" /></p><p>我们从起点 \text{JFK}JFK 出发，合法路径有两条：</p><script type="math/tex; mode=display">JFK→AAA→JFK→BBB→JFK\\JFK→BBB→JFK→AAA→JFK</script><p>既然要求字典序最小，那么我们每次应该贪心地选择当前节点所连的节点中字典序最小的那一个，并将其入栈。最后栈中就保存了我们遍历的顺序。</p><p>为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点，每次我们 $O(1) $地找到最小字典序的节点，并 $O(\log m)$ 地删除它。</p><p>然后我们考虑一种特殊情况：</p><p><img src="https://assets.leetcode-cn.com/solution-static/332/332_fig2.png" alt="Graph2"></p><p>当我们先访问 $AAA$时，我们无法回到 $JFK$，这样我们就无法访问剩余的边了。</p><p>也就是说，当我们贪心地选择字典序最小的节点前进时，我们可能先走入「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。</p><hr><h2 id="方法一：-Hierholzer-算法"><a href="#方法一：-Hierholzer-算法" class="headerlink" title="方法一：$Hierholzer$算法"></a>方法一：$Hierholzer$算法</h2><p>寻找欧拉路径的流程:</p><ol><li><p>从起点出发，进行深度优先搜索。</p></li><li><p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</p></li><li><p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p></li></ol><p>当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。</p><p>不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</p><p>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</p><p>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;,<span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-built_in">string</span>&gt;&gt;&gt; node;<span class="hljs-comment">//出发地，目的地</span>    <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> cur)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//先遍历完一个节点，再将节点入栈</span>        <span class="hljs-keyword">while</span>(node.count(cur)&amp;&amp;node[cur].size()&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">string</span> next = node[cur].top();            node[cur].pop();            dfs(next);        &#125;        res.emplace_back(cur);    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!tickets.size()) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-comment">//问题可以变为：遍历一个图所有节点，返回自然排序最小的遍历方式</span>        <span class="hljs-comment">//这意味着我们必须找到所有的组合，并且逐个进行比较</span>        <span class="hljs-comment">//遍历方式，DFS</span>        n = tickets.size();        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:tickets ) node[t[<span class="hljs-number">0</span>]].emplace(t[<span class="hljs-number">1</span>]);                dfs(<span class="hljs-string">&quot;JFK&quot;</span>);        reverse(res.begin(),res.end());        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p><strong>复杂度分析</strong></p><ul><li><p><strong>时间复杂度</strong>：$O(m \log m)$，其中 $m$ 是边的数量。对于每一条边我们需要 $O(\log m)$ 地删除它，最终的答案序列长度为 $m+1$，而与 $n$ 无关。</p></li><li><p><strong>空间复杂度</strong>：$O(m)$，其中 $m$ 是边的数量。我们需要存储每一条边</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>求解欧拉通路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买股票问题</title>
    <link href="/2020/08/26/2020-8-26-lotus/"/>
    <url>/2020/08/26/2020-8-26-lotus/</url>
    
    <content type="html"><![CDATA[<h1 id="股票系列问题"><a href="#股票系列问题" class="headerlink" title="股票系列问题"></a>股票系列问题</h1><ol><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>(Easy)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a>(Easy)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a>(Hard)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a>(Hard)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">最佳买卖股票时机含冷冻期</a>(Medium)</p></li><li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a>(Medium)</p></li></ol><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a>(Medium)</p><p>一种常用的方法是将「买入」和「卖出」分开进行考虑：「买入」为负收益，而「卖出」为正收益。在初入股市时，你只有「买入」的权利，只能获得负收益。而当你「买入」之后，你就有了「卖出」的权利，可以获得正收益。显然，我们需要尽可能地降低负收益而提高正收益，因此我们的目标总是将收益值最大化。因此，我们可以使用动态规划的方法，维护在股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p><hr><h3 id="1-最佳买卖股票时机含冷冻期-Medium"><a href="#1-最佳买卖股票时机含冷冻期-Medium" class="headerlink" title="1.最佳买卖股票时机含冷冻期(Medium)"></a><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">1.最佳买卖股票时机含冷冻期</a>(Medium)</strong></h3><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</li></ul><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><hr><ol><li><strong>动态规划</strong></li></ol><p>由于题目规定不能同时进行多笔交易，那么我们便能通过动态规划进行求解：</p><p>我们用$f[i]$表示<strong>第$i$天结束后的「累计最大收益」</strong>，我们会有三种可能的状态：</p><ol><li>第$i$天，处于可以买入状态的最大收益， 记为$f[i][0]$</li><li>买入了一只股票，记为$f[i][1]$</li><li>卖出了一只股票，处于冷冻期，记为$f[i][2]$</li></ol><blockquote><p><strong>这里的「处于冷冻期」指的是在第 i天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</strong></p></blockquote><p>我们分别对三种状态进行分析</p><p><img src="\img\lotus.png" alt="image-20200827124158917"></p><p>状态转移方程为</p><script type="math/tex; mode=display">dp[i][0]=\max(dp[i-1][0],dp[i-1][2])\\dp[i][1]=\max(dp[i-1][0]-price[i-1],dp[i-1][1])\\dp[i][2]=dp[i-1][1]+price[i-1]</script><p>这里需要理解的是，在卖出一只股票后，一定处于冷冻状态，这时候最大利润一定是前一个卖出的状态加上卖出的价格。</p><blockquote><p>边界条件，千万要思考清楚，第二种状态初始值应该为INT_MIN。因为这种状态在逻辑上是不存在的！</p></blockquote><script type="math/tex; mode=display">\begin{array}{lcc}dp[0][0] = 0;\\dp[0][1] = INT\_MIN;\\dp[0][2] = 0;\end{array}</script><p><strong>代码</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!prices.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//要获得最大利润，利润=\sum（卖出价格-买入价格）</span>        <span class="hljs-keyword">int</span> n = prices.size();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>,INT_MIN))</span></span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = INT_MIN;        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ;i++)        &#123;            dp[i][<span class="hljs-number">0</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);            dp[i][<span class="hljs-number">1</span>] = max(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);            dp[i][<span class="hljs-number">2</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i<span class="hljs-number">-1</span>];                    <span class="hljs-comment">//printf(&quot;%d,%d,%d,%d\n&quot;,i,dp[i][0],dp[i][1],dp[i][2]);</span>        &#125;        <span class="hljs-keyword">return</span> max(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">2</span>]);    &#125;&#125;;</code></pre><p><strong>优化</strong></p><p>滚动数组【略】</p><ol><li><strong>有限状态自动机解法</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode经典</tag>
      
      <tag>动态规划</tag>
      
      <tag>有限自动状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习I 线性模型</title>
    <link href="/2020/08/23/2020-08-23-ML3/"/>
    <url>/2020/08/23/2020-08-23-ML3/</url>
    
    <content type="html"><![CDATA[<h1 id="三、线性模型"><a href="#三、线性模型" class="headerlink" title="三、线性模型"></a>三、线性模型</h1><p>一元线性模型用向量表示为</p><script type="math/tex; mode=display">f(x)=w^Tx+b</script><p>其中$w$称为权重向量，$b$称为偏置。我们可以利用均方误差，来求得$w$与$b$.</p><script type="math/tex; mode=display">(w^*,b^*)=\arg \min\sum\limits_{i=1}^{m}(f(x_i)-y_i)^2</script><p>均方误差对应于几何中欧氏距离($Euclidean Distance$)。该方法被称为「<strong>最小二乘法</strong>」($least square method$)。</p><p>当然有更一般的形式“多元线性回归”。</p><script type="math/tex; mode=display">f(x_i)=\bf{w}^Tx_i+b</script><p>我们把数据集表示为矩阵$X$</p><script type="math/tex; mode=display">X= \left(\begin{array}{ccc}    x_1^T & 1\\x_2^T &1\\ \quad  ...    \\x_n^T &1    \end{array}\right)</script><p>则：</p><script type="math/tex; mode=display">\hat{\bf{w}}=\arg \min(\bf{y-X\hat{w}})^T(\bf{y-X\hat{w}})</script><p>令$E=(\bf{y-X\hat{w}})^T(\bf{y-X\hat{w}})$，对$w$求导得：</p><script type="math/tex; mode=display">\frac{\partial{E}}{\partial{\bf{w}}}=2\bf{X}^T(X\hat{w}-y)</script><p>当$X^TX$为满秩矩阵时，令$(6)$为$0$得:</p><script type="math/tex; mode=display">\hat{w}^*=\bf(X^TX)^{-1}X^Ty</script><p>然而现实任务中我们遇到的往往是非满秩矩阵，可以解出多个$\hat{w}$,选择哪一个解作为输出，由机器学习算法的归纳偏好决定，一般会引入正则化项($regularization$)。</p><p>为了更方便表示，我们引入“对数线性逻辑回归”：</p><script type="math/tex; mode=display">\ln y = w^Tx+b</script><p>这里的对数值其实是让线性回归模型的预测值与真实标记联系起来的作用。</p><p>一般地，我们考虑单调可微函数$g(.)$</p><script type="math/tex; mode=display">y = g^{-1}(w^Tx+b)</script><p>这里的$g(.)$我们称为联系函数。</p><p><strong>对数几率回归</strong></p><p><img src="\img\sigmoid.jpg" alt="img"></p><script type="math/tex; mode=display">y = \frac{1}{1+e^{-z}}</script><p>我们称之为Sigmoid函数。我们将其作为联系函数则：</p><script type="math/tex; mode=display">y= 1/(1+e\wedge (-w^Tx+b))</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念与公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一句能打败99.99999%的程序员的位操作代码</title>
    <link href="/2020/08/23/2020-8-23-bitoperation/"/>
    <url>/2020/08/23/2020-8-23-bitoperation/</url>
    
    <content type="html"><![CDATA[<h1 id="专题：位操作"><a href="#专题：位操作" class="headerlink" title="专题：位操作"></a>专题：位操作</h1><blockquote><p>位操作是一种很神奇的操作，真的很神奇————Tiancheng Lou</p></blockquote><p>位操作包括：</p><ul><li><p>¬ 取反（NOT）</p></li><li><p>∩ 按位或（OR）</p></li><li><p>⊕ 按位异或（XOR）</p></li><li><p>∪ 按位与（AND）</p></li><li><p><strong>移位</strong></p><ul><li><p>移位是一个二元运算符，用来将一个二进制数中的每一位全部都向一个方向移动指定位，溢出的部分将被舍弃，而空缺的部分填入一定的值。移位又分为</p><ul><li><p>算术移位：在位移运算符之前的数是<u><strong>有符号</strong></u>数，编译产生的汇编指令是算术位移，<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。</p></li><li><p>逻辑移位：在位移运算符（&gt;&gt;和&lt;&lt;）之前的数是<strong><u>无符号</u></strong>数，编译产生的汇编指令是逻辑位移，<code>&gt;&gt;&gt;</code>及<code>&lt;&lt;&lt;</code>。</p></li></ul></li></ul></li></ul><hr><p><strong>题目</strong></p><p>201 <a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/">数字范围按位与</a></p><p>461 <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></p><p>338 <a href="https://leetcode-cn.com/problems/counting-bits">比特位计数</a>（Medium）</p><ol><li>解数独</li></ol><p>树状数组 的LowBit操作</p><p>….</p><hr><p>我们使用长度为9的数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一个整数表示每个数字是否出现过。</p><p>具体地，数$b$ 的二进制表示的第$i$位（从低到高，最低位为第$0$位），当且仅当数字$i+1$已经出现过。例如当 b 的二进制表示为 $(011000100)_2$ 时，就表示数字 3，7，8 已经出现过。</p><p>位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：</p><ul><li><p>某个数中第$k$位为1，表示该位置不能填入数字$k+1$.我们先与上$(11111111)_2=(1FF)_{16}$消除高位的影响，然后对其取反，然后枚举。因为是需要9个bit状态，所以是左移九位。</p></li><li><p>我们可以使用按位异或运算$ \wedge$, 与 $1&lt;&lt;i$异或即可。</p></li><li><p>我们可以用 $b \&amp; (−b) $得到 b 二进制表示中最低位的 1，这是因为 $(−b)$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 如果和 $∼b$ 进行按位与运算，那么会得到 0，但是当 $\sim b$ 增加 1 之后，最低位的连续的 1 都变为 0，而最低位的 0 变为 1，对应到 $b$ 中即为最低位的 1，因此当 $b$ 和 $∼b+1$ 进行按位与运算时，只有最低位的 1 会被保留；</p></li><li><p>我们可以用$b$与最低位的1按位异或，就可以将其从$b$中去除，这样就可以枚举下一个1。同样的，我们可以用$b\&amp;(b-1)$达到同样的效果，这被称为<strong>Brian kernighan算法</strong>。</p><p>具体应用见$\lfloor$回溯算法$\rceil$    </p></li></ul><hr><p>大多数编程语言中，都存在各种内置计算等于 1 的位数函数。如果这是一个项目中的问题，应该直接使用内置函数，而不是重复造轮子。</p><pre><code class="hljs python">bin(x ^ y).count(<span class="hljs-string">&#x27;1&#x27;</span>)</code></pre><pre><code class="hljs C++">binset&lt;<span class="hljs-number">32</span>&gt;(x^y).count();</code></pre><pre><code class="hljs java">Integer.bitCount(x ^ y);</code></pre><p><strong>Brian kernighan算法</strong></p><p>该算法的关键在于我们每次对$number$和$number-1$之间进行按位与操作后，$number$中最右边的1会变成0。</p><script type="math/tex; mode=display">n\&(n-1)</script><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log n)$。和位移方法类似，算法的时间复杂度取决于 $m$ 和 $n$ 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。</li><li>空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。</li></ul><p><strong>Hamming距离</strong></p><blockquote><p>461 <a href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></p></blockquote><p>汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。</p><p>两个整数之间的汉明距离是对应位置上数字不同的位数。</p><p><img src="\img\hamming.png" alt="img"></p><p>根据以上定义，提出一种 XOR 的位运算，当且仅当输入位不同时输出为 1。</p><blockquote><p> 计算 x 和 y 之间的汉明距离，可以先计算 x XOR y，然后统计结果中等于 1 的位数。</p></blockquote><p>现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。</p><p><strong>布赖恩·克尼根算法</strong><br>思路</p><blockquote><p> 是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：10001000。</p></blockquote><p>上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。</p><p>这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p><blockquote><p> 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。</p></blockquote><p>基于以上思路，通过 2 次迭代就可以知道 10001000 中 1 的位数，而不需要 8 次。</p><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingDistance</span>(<span class="hljs-params">self, x, y</span>):</span>        xor = x ^ y        distance = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> xor:            distance += <span class="hljs-number">1</span>            <span class="hljs-comment"># remove the rightmost bit of &#x27;1&#x27;</span>​            xor = xor &amp; (xor - <span class="hljs-number">1</span>)​        <span class="hljs-keyword">return</span> distance</code></pre><p>注意：该算法发布在 1988 年 《C 语言编程第二版》的练习中（由 Brian W. Kernighan 和 Dennis M. Ritchie 编写），但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。顺便说一句，可以在上述书籍中找到更多位操作的技巧。</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(1)$。与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。但是该方法需要的迭代操作更少。</p></li><li><p>空间复杂度：$O(1)$，与输入无关，使用恒定大小的空间。</p></li></ul><p><strong>动态规划</strong>+<strong>最高有效位</strong></p><p>有一些位操作题目用动态规划解也十分方便和快速。</p><p>比如 338 <a href="https://leetcode-cn.com/problems/counting-bits">比特位计数</a>（Medium）</p><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><p>假设有一个整数：</p><p>$x = (1001011101)_2 = (605)_{10}<br>    $</p><p>我们已经计算了从 $0$到 $x - 1$ 的全部结果。</p><p>我们知道，$x$与 我们计算过的一个数只有一位之差:</p><p>$x’ = (1011101)_2 = (93)_{10}$<br>它们只在最高有效位上不同。</p><p>让我们以二进制形式检查 $[0, 3]$ 的范围：</p><script type="math/tex; mode=display">0 = (00)\\1 = (01)\\2 = (10)\\3 = (11)</script><p>可以看出， 2 和 3 的二进制形式可以通过给 0 和 1 的二进制形式在前面加上 1 来得到。因此，它们的 pop_count 只相差 1。</p><p>类似的，我们可以使用 $[0, 3]$ 作为蓝本来得到 $[4, 7]$。</p><p>总之，对于pop count $P(x)$，我们有以下的状态转移函数：</p><script type="math/tex; mode=display">P(x + b) = P(x) + 1, b = 2^m > x</script><p>有了状态转移函数，我们可以利用动态规划从 0 开始生成所有结果。</p><p><strong>动态规划 + 最低有效位</strong></p><p>遵循上一方法的相同原则，我们还可以通过最低有效位来获得状态转移函数。</p><p>观察$x$ 和 $x’ = x / 2$的关系：</p><p>$x = (1001011101)_2 = (605)_{10}$</p><p>$x’ = (100101110)_2 = (302)_{10}$<br>可以发现 $x’$与 $x$ 只有一位不同，这是因为$x’$  可以看做 xx 移除最低有效位的结果。</p><p>这样，我们就有了下面的状态转移函数：</p><script type="math/tex; mode=display">P(x) = P(x >> 1) + (x \mod 2)</script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅而巧妙的并查集</title>
    <link href="/2020/08/14/2020-8-14-what-is-UnionSet/"/>
    <url>/2020/08/14/2020-8-14-what-is-UnionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是并查集（UnionSet）"><a href="#什么是并查集（UnionSet）" class="headerlink" title="什么是并查集（UnionSet）"></a>什么是并查集（UnionSet）</h1><ol><li><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></p></li><li><p><a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿的数量</a></p></li><li><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">二维网格中探测环</a></p></li><li><p><a href="https://leetcode-cn.com/problems/evaluate-division/">除法求值</a>（带权值）            </p></li><li><p><a href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a>（无向图）</p></li><li><p><a href="https://leetcode-cn.com/problems/redundant-connection-ii">冗余连接II</a>(Hard)（有向图）</p></li><li><p><a href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a>(DFS,BFS,UnionSet均可以做,DFS,BFS更优)</p></li><li><p><del>句子相似性2(VIP)</del></p></li><li><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">等式方程可满足性</a></p></li><li><p><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">连通网络操作次数</a></p></li><li><p><a href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/">按公因数计算最大组件大小</a>（hard）</p></li><li><p><a href="https://leetcode-cn.com/problems/couples-holding-hands/">情侣牵手</a>（Hard）</p></li><li><a href="https://leetcode-cn.com/problems/accounts-merge/">账户合并</a></li></ol><blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/93647900">知乎传送门</a></p></blockquote><p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合之中</li></ul><p>在连通性问题中（如岛屿问题），并查集很有作用。<strong>核心思想</strong>是连通区域内所有点的根节点其实是同一个。将每个点映射为一个数字。先假设每个点的根节点就是它们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋给另一个点的根节点，这样两个点所在的连通区域又相互连通了。</p><p>好的我们一步一步来画板子（ddrdd）：</p><p>并查集的主要操作有：</p><ul><li><code>find(int m)</code> :查找$m$的根节点</li><li><code>isConnected(int m, int n)</code>：判断$m,n$两个点是否在同一个连通区域。</li><li><code>Union(int m, int n)</code>:合并$m,n$两个点所在的连通区域。</li></ul><p><strong>初始化</strong></p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> fa[MAXN];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n )</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;i++)        fa[i] = i;&#125;</code></pre><p><strong>查询</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(fa[x]==x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">return</span> find(fa[x]);&#125;</code></pre><p>一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><p><strong>合并</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;fa[find(i)] = find(j);&#125;</code></pre><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者.</p><p><strong>更新</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<span class="hljs-keyword">if</span>(fa[i] != i) fa[i] = find(fa[i]);&#125;</code></pre><p>一般在对所有节点merge之后需要整体更新，避免漏掉连通分支。</p><hr><p>初级并查集效率较低，我们需要进行<strong>路径压缩</strong>。</p><p>我们添加元素可能会形成长链，想要从底部寻找根节点会越来越难。路径压缩是这样一种算法，每个元素到根节点的路径尽可能短。</p><p>我们可以在查找的过程中，<u>把沿途每个节点的父节点都设为根节点</u>。</p><p><strong>路径压缩后合并</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x==find(x)? x : (fa[x] = find(fa[x]));&#125;</code></pre><p>我们得到的并查集是这样的，很像一棵二叉树。</p><p><strong>按秩合并</strong></p><p>按路径压缩后的并查集结构仍是毕竟复杂的，比如现在我们有一棵较复杂的树，与一个单元素进行合并：</p><p><img src="/img/dsu_1.jpg" alt=""></p><p>那么是把7作为8的父节点好呢，还是8作为7父节点好呢：</p><p>当然是前者，因为后者会使树的深度加深。所以要<strong>把简单树往复杂树上合并。</strong></p><p>我们用于一个数组<code>rank[]</code>记录每个根节点对应树的深度。一开始，所有节点的秩设为1.合并时比较两个根节点，把秩小的往秩的根节点合并。</p><p><strong>初始化（按秩合并）</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)     &#123;        fa[i] = i;        rank[i] = <span class="hljs-number">1</span>;    &#125; &#125;</code></pre><p><strong>合并（按秩合并）</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = find(i),y = find(j);    <span class="hljs-keyword">if</span>(rank[x] &lt;= rank[y])         fa[x] = y;    <span class="hljs-keyword">else</span>         fa[y] = x;    <span class="hljs-keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)    &#123;<span class="hljs-comment">//如果秩相同，则新节点深度++</span>        rank[y]++;    &#125;   &#125;</code></pre><p>为什么根秩相同，深度要加1呢，如下图，我们有两个秩均为2 的树，现在要合并。</p><p><img src="/img/dsu_2.png" alt="img" style="zoom:67%;" /></p><p>我们把2的父节点设为5，这里深度加1，同样另一种合并方式也会使深度加1.</p><p><img src="\img\dsu_3.png" alt="img" style="zoom:67%;" /></p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；</p><p>2、代表元法：采用 parent 数组实现，以每个结点的根结点作为代表元；</p><p>3、并查集的优化有两种策略：</p><p>（1）<strong>路径压缩</strong>；</p><p>有「隔代压缩」与「完全压缩」。</p><ul><li>「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。</li><li>「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。</li></ul><p><img src="\img\dsu_3.jpg" alt="image.png"></p><p>（2）按秩合并。</p><p>秩也有两种含义：</p><p>秩表示以当前结点为根结点的子树结点总数，即这里的「秩」表示 size 含义；<br>秩表示以当前结点为根结点的子树的高度，即这里的「秩」表示 rank 含义（更合理，因为查询时候的时间性能主要决定于树的高度）。<br>4、如果同时使用「路径压缩」与「按秩合并」，这里的「秩」就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的「参考」。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近 $O(1)$。</p><p><a href="https://www.zhihu.com/question/35090745">为什么并查集在路径压缩之后的时间复杂度是阿克曼函数?</a></p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1559-二维网格图中探测环"><a href="#1559-二维网格图中探测环" class="headerlink" title="1559. 二维网格图中探测环"></a><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">1559. 二维网格图中探测环</a></h4><p>给你一个二维字符网格数组 <code>grid</code> ，大小为 <code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 <strong>相同值</strong> 形成的环。</p><p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值</strong> 。</p><p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> 是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p><p>如果 <code>grid</code> 中有相同值形成的环，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="\img\5482e1.png" alt="img"></p><pre><code class="hljs smalltalk">输入：grid = [[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>]]输出：<span class="hljs-keyword">true</span>解释：如下图所示，有 <span class="hljs-number">2</span> 个用不同颜色标出来的环：</code></pre><p><img src="\img\5482e11.png" alt="img"> </p><hr><p>利用并查集的思想，相同的字母可以形成一个连通区域，从左上角开始，遇到相同字母则进行合并，合并时若发现$x$和$y$与$parent$相同，即形成环。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">250100</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> p[N];    <span class="hljs-keyword">int</span> cnt[N];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (p[x] != x) &#123;            x = find(p[x]);        &#125;        <span class="hljs-keyword">return</span> p[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;            cnt[find(b)] += cnt[find(a)];            p[find(a)] = find(b);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;            p[i] = i;            cnt[i] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsCycle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = grid.size();        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].size();        init();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>&lt; n &amp;&amp; grid[i][j] == grid[i + <span class="hljs-number">1</span>][j]) &#123;                    <span class="hljs-keyword">if</span> (find(i * m + j) == find((i + <span class="hljs-number">1</span>) * m + j)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        p[find(i * m + j)] = find((i + <span class="hljs-number">1</span>) * m + j);                    &#125;                &#125;                <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i][j] == grid[i][j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">if</span> (find(i * m + j) == find(i * m + j + <span class="hljs-number">1</span>)) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        p[find(i * m + j)] = find(i * m + j + <span class="hljs-number">1</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h2 id="685-冗余连接II"><a href="#685-冗余连接II" class="headerlink" title="685. 冗余连接II"></a>685. 冗余连接II</h2><p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N-1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</p><p>树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：</p><ul><li><p>附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；</p></li><li><p>附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。</p></li></ul><blockquote><p><code>parent</code>用于保存上一个指向它的节点，仅此而已。</p></blockquote><p>在遍历图中的所有边之后，根据是否存在导致冲突的边和导致环路出现的边，得到附加的边。</p><ul><li><p>如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。</p></li><li><p>如果有导致冲突的边，记这条边为 $[u,v]$，则有两条边指向 v，另一条边为 $[\textit{parent}[v],v]$需要通过判断是否有导致环路的边决定哪条边是附加的边。</p></li><li><p>如果有导致环路的边，则附加的边不可能是 $[u,v]$（因为 $[u,v] $已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 $[\textit{parent}[v],v]$。</p></li><li><p>如果没有导致环路的边，则附加的边是后被访问到的指向 v 的边，因此附加的边是 $[u,v]$。</p></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;    <span class="hljs-keyword">int</span> conflict;<span class="hljs-comment">//记录具有多个父节点的边编号</span>    <span class="hljs-keyword">int</span> loop;<span class="hljs-comment">//记录生成环路的边编号</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            fa.emplace_back(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>( x == fa[x])        &#123;            <span class="hljs-keyword">return</span> x;        &#125;        fa[x] = find(fa[x]);        <span class="hljs-keyword">return</span> fa[x];    &#125;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;        <span class="hljs-comment">//思路：并查集</span>        <span class="hljs-comment">//此题与全连接I的区别是，无向图变为有向图</span>        <span class="hljs-keyword">int</span> n = edges.size();        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//专门用于保存父节点，与并查集无关</span>        init(n+<span class="hljs-number">1</span>);        conflict = loop = <span class="hljs-number">-1</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        &#123;<span class="hljs-comment">//u -&gt; v</span>            <span class="hljs-keyword">int</span> u = edges[i][<span class="hljs-number">0</span>], v = edges[i][<span class="hljs-number">1</span>];             <span class="hljs-keyword">int</span> pu = find(u), pv = find(v);                        <span class="hljs-keyword">if</span>(pv!=v) <span class="hljs-comment">// 说明 e[1]已经有父节点，存在冲突</span>                conflict = i;            <span class="hljs-keyword">else</span>             &#123;                parent[v] = u;                <span class="hljs-keyword">if</span>(pv == pu)<span class="hljs-comment">//表示有环</span>                &#123;                    loop = i;                &#125;                <span class="hljs-keyword">else</span> fa[pv] = pu;                        &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conf:%d,loop:%d\n&quot;</span>,conflict,loop);        <span class="hljs-comment">//接下来需要判断哪个边导致了冗余</span>        <span class="hljs-keyword">if</span>(conflict&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//说明没有冲突，附加的边为环路最后出现的边</span>        &#123;            <span class="hljs-keyword">return</span> edges[loop];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若存在冲突，</span>        &#123;            <span class="hljs-keyword">if</span>(loop &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//没有环</span>            <span class="hljs-keyword">return</span> edges[conflict];            <span class="hljs-keyword">else</span> <span class="hljs-comment">//既有冲突也有环，则不可能是冲突的那一条边</span>            <span class="hljs-keyword">return</span> &#123;parent[edges[conflict][<span class="hljs-number">1</span>]],edges[conflict][<span class="hljs-number">1</span>]&#125;;        &#125;        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;    &#125;&#125;;</code></pre><p>时间复杂度: $O(N \log N)$</p><p>空间复杂度：$O(N)$</p><hr><h2 id="952-按公因式计算最大组件的大小"><a href="#952-按公因式计算最大组件的大小" class="headerlink" title="952.按公因式计算最大组件的大小"></a>952.按公因式计算最大组件的大小</h2><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：</p><p>有 <code>A.length</code> 个节点，按从 <code>A[0]</code>到 <code>A[A.length - 1]</code> 标记；<br>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j]</code>之间才有一条边。<br>返回图中最大连通组件的大小。</p><p>示例 1：</p><p>输入：[4,6,15,35]<br>输出：4</p><p><img src="\img\ex1.png" alt="img" style="zoom:33%;" /></p><p>示例 2：</p><p>输入：[20,50,9,63]<br>输出：2</p><p><img src="\img\ex2.png" alt="img" style="zoom:33%;" /></p><p>示例 3：</p><p>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p><p><img src="\img\ex3.png" alt="img" style="zoom:33%;" /></p><p>提示：</p><p><code>1 &lt;= A.length &lt;= 200001 &lt;= A[i] &lt;= 100000</code></p><hr><p>按照并查集的思路求解</p><p>设$W = max(A[i]), R = \sqrt{W}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+A.length$个不同的质因数。质因数为本身的最多$A.length$个，非本身的质因数一定比$R$小，最多$R$个。</p><p>我们可以提取$A$中每个数的质因数，对每个质因数建立索引，然后利用并查集。</p><p><img src="\img\dsu_4.png" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;    <span class="hljs-keyword">int</span> res;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            fa.emplace_back(i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//路径压缩</span>        <span class="hljs-keyword">while</span>(x != fa[x])        &#123;            fa[x] = fa[fa[x]];            x = fa[x];        &#125;        <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> x = find(i), y = find(j);        fa[x] = y;    &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestComponentSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = A.size();    <span class="hljs-comment">//这题是并查集的经典应用</span>    <span class="hljs-comment">//因为A的长度很大，不能采用双重循环遍历</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; factor[n];<span class="hljs-comment">//质因数索引</span>    <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a :A) maxVal = max(maxVal,a);    init(maxVal+<span class="hljs-number">1</span>);    res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:A)    &#123;        <span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)        <span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>)         &#123;            merge(a,i);            merge(a,a/i);        &#125;    &#125;    <span class="hljs-comment">//将A中的数映射为代表元,看那一些出现过</span>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(maxVal+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)    &#123;        cnt [find(A[i])]++;        res = max(res, cnt [find(A[i])]);    &#125;    <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><p>时间复杂度：$O(N \sqrt{W})$，其中 $N$ 是 A 的长度，$W = \max(A[i])$。</p><p>空间复杂度： $O(M)$, 分别用了$fa$和$cnt$数组，$M$表示数组最大值。</p><hr><h2 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a>765. 情侣牵手</h2><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p><p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p><p><strong>示例 1:</strong></p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]输出: <span class="hljs-number">1</span>解释: 我们只需要交换row[<span class="hljs-number">1</span>]和row[<span class="hljs-number">2</span>]的位置即可。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]输出: <span class="hljs-number">0</span>解释: 无需交换座位，所有的情侣都已经可以手牵手了。</code></pre><p><strong>说明:</strong></p><ol><li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li><li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li></ol><hr><ol><li><strong>贪心解法</strong></li></ol><p>我们考虑每队情侣都由奇数编号和偶数编号组成，因为情侣数量有限，我们可以遍历所有情侣中编号为偶数的<code>1,2,4,6...2*N</code>， 对相应的奇数情侣交换，每交换一次则<code>res++</code>。具体地，如果偶数情侣位于偶数位置$i$，则奇数情侣位置一定是$i+1$, 否则，奇数情侣位置为$i-1$。</p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span>  Map&lt;Integer,Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="hljs-comment">//记录数字的位置</span>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> direct)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> temp, temp2;        temp = memo.get(i+<span class="hljs-number">1</span>);        memo.put(row[memo.get(i)+direct],temp);        memo.put(i+<span class="hljs-number">1</span>,memo.get(i)+direct);        temp2 = row[temp];        row[temp] = row[memo.get(i)+direct] ;        row[memo.get(i)+direct] = temp2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = row.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) memo.put(row[i],i);        <span class="hljs-comment">//我们只移动奇数，如果偶数位置是偶数，那么相邻奇数位置在右边，否则在左边</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i += <span class="hljs-number">2</span>)        &#123;            <span class="hljs-keyword">if</span>(memo.get(i) %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                swap(row,i,<span class="hljs-number">1</span>);                res ++;            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)-<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                swap(row,i,-<span class="hljs-number">1</span>);                res ++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p><strong>时间复杂度</strong>:$O(N)$.</p><p>空间复杂度:$O(N)$,使用了一个长度为$N$哈希表。</p><ol><li><strong>并查集</strong></li></ol><p>我们重点放在并查集解法上。</p><p>我们设想一下加入有两对情侣互相坐错了位置，我们至多只需要换一次。<br>如果3对情侣相互坐错了位置，$A1+B2,B1+C2,C1+A2$。他们三个之间形成了一个连通图，我们只需要交换两次。<br>如果4对情侣相互坐错了位置，即这4对情侣不与其他情侣坐在一起，$A1+B2,B1+C2,C1+D2,D1+A2$.他们四个之间形成了一个连通图，他们只需要交换三次并且不用和其他情侣交换，就可以将这四对情侣交换好，<br>以此类推，其实就是假设k对情侣形成一个环状的错误链，我们<strong>最少</strong>需要交换k - 1次就可以将这k对情侣的位置排好。</p><blockquote><p>所以问题转化成$N$对情侣中，有几个这样的错误环。我们可以使用并查集来处理，每次遍历相邻的两个位置，如果他们本来就是情侣，他们处于大小为1的错误环中，只需要交换0次。如果不是情侣，说明他们两对处在同一个错误环中，我们将他们合并（union），将所有的错坐情侣合并和后，答案就是情侣对 - 环个数。<br>这也说明，最差的情况就是所有N对情侣都在一个环中，这时候我们需要$N - 1$调换。<br>最好情况每对情侣已经坐好了，已经有N个大小为1的环，这时候我们需要$N - N$次调换。</p></blockquote><p><strong>代码</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa,rank;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(x != fa[x]) fa[x] = getfa(fa[x]);        <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> fx = getfa(x),fy = getfa(y);        <span class="hljs-keyword">if</span>(fx != fy)        &#123;            <span class="hljs-keyword">if</span>(rank[fx] &lt; rank[fy])            &#123;                fa[fx] = fy;                rank[fy] += rank[fx];            &#125;<span class="hljs-keyword">else</span>            &#123;                fa[fy] = fx;                rank[fx] += rank[fy];            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; row)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = row.size(),m = n / <span class="hljs-number">2</span>,res = <span class="hljs-number">0</span>,circle = <span class="hljs-number">0</span>;        fa = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>),rank = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++) fa[i] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i += <span class="hljs-number">2</span>)            uni(row[i] / <span class="hljs-number">2</span>,row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>);<span class="hljs-comment">//本来是情侣的话，两者肯定相等，不会合并</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i ++)            <span class="hljs-keyword">if</span>(i == getfa(i))                circle ++;        <span class="hljs-keyword">return</span> m - circle;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专题:DFS&amp;BFS</title>
    <link href="/2020/08/10/2020-9-12-minimal-Spanning-tree/"/>
    <url>/2020/08/10/2020-9-12-minimal-Spanning-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树的两种方法（Kruskal算法和Prim算法）"><a href="#最小生成树的两种方法（Kruskal算法和Prim算法）" class="headerlink" title="最小生成树的两种方法（Kruskal算法和Prim算法）"></a>最小生成树的两种方法（Kruskal算法和Prim算法）</h1><hr><ul><li><ol><li><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点最小费用</a></li></ol></li></ul><blockquote><p>最小生成树（$Minimal  Spanning  Tree,MST$）：有 n 个结点的<a href="https://baike.baidu.com/item/连通图/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。比较常用的有两种算法：$Kruskal$算法和$Prim$算法。</p></blockquote><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>被称为“加边法”，初始最小生成树的边数是0，每迭代一次就寻找满足条件的最小代价边，加入到最小生成树集合中去。</p><ol><li>把图中所有边按照<strong>从小到大</strong>的顺序排序。</li><li>把图中$n$个顶点看成独立的$n$棵树组成的森林。</li><li>按权值从小到大选择边，所选的边连接的两个顶点$u_i,v_i$应该属于两个不同的树（否则会形成环），则称为最小生成树的一条边，并将这两棵树作为一棵树。</li><li>重复<code>3.</code>。直到所有的顶点都在一棵树内，或者有$n-1$条边为止。</li></ol><p><img src="\img\kruskal.jpg" alt="MST示意图"></p><p>和并查集的概念非常相似。Kruskal算法可以看成是基于并查集的贪心算法。    </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> res,n;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;<span class="hljs-keyword">public</span>:    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">int</span> e1, e2;<span class="hljs-comment">//两个端点的编号</span>        <span class="hljs-keyword">int</span> Mahattan_dis;<span class="hljs-comment">//曼哈顿距离</span>        edge(<span class="hljs-keyword">int</span> e1,<span class="hljs-keyword">int</span> e2, <span class="hljs-keyword">int</span> m):e1(e1),e2(e2),Mahattan_dis(m)&#123;&#125;        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> edge&amp; other) <span class="hljs-keyword">const</span>        &#123;            <span class="hljs-keyword">return</span> Mahattan_dis &lt; other.Mahattan_dis;        &#125;    &#125;;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mahattan</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);    &#125;            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = points.size();    init(n);    <span class="hljs-built_in">vector</span>&lt;edge&gt; edges;    res  = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n;j++)    &#123;        edges.emplace_back(i,j,Mahattan(points,i,j));     &#125;       sort(edges.begin(),edges.end());<span class="hljs-comment">//按从小到大排序</span>    <span class="hljs-keyword">int</span> num = n;<span class="hljs-comment">//独立的子树的个数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)    &#123;        <span class="hljs-keyword">if</span>(merge(e.e1,e.e2))        &#123;            res += e.Mahattan_dis;            num--;        &#125;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//最后只有一个连通图则返回</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)             fa.emplace_back(i);     &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(fa[x] == x)             <span class="hljs-keyword">return</span> x;        fa[x] = find(fa[x]);         <span class="hljs-keyword">return</span> fa[x];    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;<span class="hljs-comment">//合并的两条边必须是不同子树</span>        <span class="hljs-keyword">int</span> x = find(i),y = find(j);        <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        fa[x] = y;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre><blockquote><p>细节：为了使得自定义结构体edge能够进行排序操作，我们不能把数组edges写成<code>vector&lt;edge*&gt; edges</code>这样的话是对指针指向的地址进行排序，而不是对曼哈顿距离排序。</p></blockquote><p>时间复杂度：$O(V^2)$,$V$为边的个数，等于$N-1$。</p><p>空间复杂度：$O(N)$, 包括并查集用的父数组和自定义数据结构edge。</p><hr><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>此算法又被称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树之中，算法从某一个顶点开始，逐渐扩散覆盖整个网络。比较适合<strong>稠密网络</strong>。</p><ol><li>图的所有顶点集合为V；初始令集合$u=s,v=V-u$.</li><li>在两个集合$u,v$所构成的边中，选择一条代价最小的边。</li><li>重复上述步骤，直到最小生成树有$n-1$条边，或者只有一棵树为止。</li></ol><p><img src="\img\prim.jpg" alt="这里写图片描述"></p><p>我们注意到我们每次添加的都是最小边，因此可以用小顶堆来存储。 Prim算法更像是Dijkstra算法。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> res,n;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Mahattan</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; data;    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp;left, T <span class="hljs-keyword">const</span> &amp;right)</span></span><span class="hljs-function">        </span>&#123;        <span class="hljs-comment">// 以y比较。输出结果为y较大的在前y相同时，先进入队列的元素在前。</span>            <span class="hljs-keyword">return</span> (left.second &gt; right.second); <span class="hljs-comment">// left.first在后面，顶部元素first最大</span>        &#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;    <span class="hljs-comment">//Prim 算法又被称为加点法</span>    <span class="hljs-keyword">int</span> n = points.size();    res = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//任选一个点作为起始点，没有必要构建边，</span>    <span class="hljs-comment">//遍历小顶堆，每次从中取出代价最小的边，（需判断点是否已经取过，需要标记列表）</span>    <span class="hljs-comment">//若最后只有一个树，或者 小顶堆为空，说明已构建完MST</span>    <span class="hljs-built_in">priority_queue</span>&lt;data,<span class="hljs-built_in">vector</span>&lt;data&gt;,cmp&lt;data&gt;&gt; lheap;<span class="hljs-comment">//p1:点序号，p2:Mahattan距离，</span>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, edge = <span class="hljs-number">0</span>;    lheap.push(data(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span>(!lheap.empty() )    &#123;        <span class="hljs-keyword">int</span> next = lheap.top().first;        <span class="hljs-keyword">if</span>(vis[next]) &#123;lheap.pop();<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//如果访问过则直接跳过</span>        vis[next] = <span class="hljs-literal">true</span>; edge+=<span class="hljs-number">1</span>;        res += lheap.top().second;        lheap.pop();        <span class="hljs-keyword">if</span>(edge == n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果边的数量达到n则break</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            lheap.push(data(i,Mahattan(points,i,next)));        &#125;              &#125;    <span class="hljs-keyword">return</span> res;      &#125;   &#125;;</code></pre><p>时间复杂度：$O(N^2)$, N为点的个数。</p><p>空间复杂度：$O(N)$,需要一个优先队列来存储所有的可能边。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习I 基本概念</title>
    <link href="/2020/08/04/2020-05-10-ML1/"/>
    <url>/2020/08/04/2020-05-10-ML1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学完算法，还想更深入一步，那么接触一下机器学习，是很有必要的，你需要知道当下为什么ML这么火，包括自动驾驶，人脸识别等都与之相关。有些甚至基本算法理论无法解释。</p><p>参考周志华《机器学习》</p></blockquote><p><strong>任务：</strong></p><p><strong>分类</strong>（classification）: 预测离散值。</p><p><strong>回归</strong>（regression）:预测连续值。</p><p>一般地，我们对训练集${(x_1,y_1),···,(x_m,y_m)}$进行学习，建立一个从输入空间$\chi$到输出空间$\Upsilon$的映射，对于二分类任务，通常$\Upsilon=\{-1,+1\}或\{0,1\}$；对于多分类任务，$|\Upsilon|&gt;2$,对于回归任务，$\Upsilon=\R,\R$为实数集。</p><p>学习完之后需要进行预测（testing）。</p><p>我们还可以进行<strong>聚类</strong>（clustering）操作，将训练集中数据分成若干组，每组称为一个<strong>簇</strong>（cluster），这些自动形成的簇可能对应一些潜在的概念划分。</p><p>根据训练数据是否有标记，学习任务可以大致分为两类：“<strong>监督学习</strong>”（supervised learning）和 “<strong>无监督学习</strong>”（unsupervised learning），分类和回归属于前者，而聚类属于后者。</p><p><strong>泛化</strong>（generalization），指模型适应新样本的能力。我们可以把学习过程看作是在<code>所有假设</code>（hypothesis）组成的空间中进行搜索的过程，搜索目标是找到与训练集“匹配”的假设。</p><p>书中介绍了NFL定理，即“天下没有免费午餐的定理”。不同的学习算法期望相同。</p><p>最后让我们一睹顶会的风采。</p><p>$ICML$：国际机器学习会议；</p><p>$NIPS$：国际神经信息处理系统会议；</p><p>$COLT$：国际学习理论会议；</p><p>$ECML$：欧洲机器学习会议；</p><p>$ACML$：亚洲机器学习会议；</p><p>然后是<em>顶级</em>期刊：</p><p>$JMLR$: Journal of Machine Learning Research;</p><p>$ML$: Machine Learning;</p><p>$IJCAI$:International Joint Conference on Artificial Intelligence</p><p>$AAAI$：（就是这么AI） Association for the Advance of Artificial Intelligence</p><p>$AI$，$JAIR$,$KDD$,$ICDM$,$CVPR$,以及IEEE一些期刊。</p><blockquote><p>如果能投给一篇，cs人生也算圆满了</p></blockquote><p>第二章：模型评估与选择。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念和公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习II 模型评估与选择</title>
    <link href="/2020/08/04/2020-08-4-ML2/"/>
    <url>/2020/08/04/2020-08-4-ML2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-经验误差与过拟合"><a href="#1-经验误差与过拟合" class="headerlink" title="1. 经验误差与过拟合"></a>1. 经验误差与过拟合</h2><p>学习在训练集上的误差称为“训练误差”，而在新样本上误差称为“泛化误差”。</p><p>实际上，我们通常得不到泛化性能很好的模型，原有有两种：</p><ul><li><strong>过拟合</strong>（overfitting）: 学习能力过于优秀，学到一些非一般的特性。</li><li><strong>欠拟合</strong>（underfitting）：对训练样本的一般性质尚未学好。</li></ul><p>机器学习面临的问题一般是$NP$难问题(<a href="https://blog.csdn.net/qq_21768483/article/details/80430590">什么是NP</a>)，因此只要相信$NP\ne P$那么过拟合将无法避免。</p><p>下面简单介绍从训练集得到测试集的方法：</p><ol><li><strong>留出法</strong>，按照比例从原始数据集分出训练和测试集；</li><li><strong>交叉验证</strong>（cross validation） ：先将数据集$D$划分为$k$个大小相似的互斥子集，即$D=D_1\cup D_2 \cup ···\cup D_j , D_i \cup D_j\ne \oslash$,每个子集$D_i$都尽可能保持数据分布的一致性，即从$D$中通过分层采样得到，然后每次用$k-1$给子集的并集作为训练集，余下的那个子集作为测试集；这样就可以得到$k$组训练/测试集。</li><li><strong>自助法</strong>（bootstrapping）减少训练集规模不同造成的误差。给定包含$m$个样本的数据集$D$，我们对它采样，产生数据集$D’$：每次随机从$D$中挑选一个样本，将其拷贝放入$D’$，然后再将该样本放回初始数据集$D$，这个过程重复$m$次后，我们得到大小为$m$的数据集$D’$，通过自助采样，约有$36.8\%$的样本未出现在采样数据集中，于是我能将$D’$用作训练集，而$D/D’$作为测试集，这适合数据小，难以划分的场景。</li></ol><h2 id="2-调参与最终模型"><a href="#2-调参与最终模型" class="headerlink" title="2. 调参与最终模型"></a>2. 调参与最终模型</h2><p>我们常把学得模型在实际使用中遇到的数据称为<strong>测试数据</strong>。</p><p>模型评估与选择中的数据集称为<strong>验证集</strong>。</p><ul><li><strong>性能度量</strong></li></ul><p>回归任务，最常使用的是均方误差（Mean Squared Error, MSE）.</p><pre><code>                                                             $ E(f;D)=\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;(f(x_i)-y_i)^2$</code></pre><ul><li><strong>错误率与精度</strong></li></ul><p>错误率是分类错误的样本数占样本总数的比例，精度$acc$则是正确的样本数占样本总数的比例。</p><blockquote><p>术语: FP:真正例 FN:假反例 FP:假正例 TN:真反例</p></blockquote><p>查准率$P=\frac{TP}{TP+FP}$，查全率：$R =\frac{TP}{TP+FN}$.</p><p>一般我们采用P-R图像来评价机器学习模型的优劣。若一个曲线包住另一个曲线，则证明前者性能好于后者。“平衡点”（BEP）就是查准率等于查全率的点。</p><p>更常用的是$F1$度量（调和平均）：$F1=\frac{2×P×R}{P+R}$，其原型是加权调和平均$F_\beta=\frac{(1+\beta^2)×P×R}{\beta^2×P+R}$,$\beta$度量了查全率对查准率的相对重要性。为了更好描述不同错误造成影响的大小，我们引入代价敏感 ，$cost_{01}$表示$TN$的代价,$cost_{10}$表示$FP$的代价。正例代价。</p><script type="math/tex; mode=display">P(+)=\frac{p×cost_{01}}{p×cost_{01}+(1-p)×cost_{10}}</script><p>泛化错误率为$\epsilon$,而测试错误率$\hat{\epsilon}$意味着在$m$给测试样本中恰有$\hat{\epsilon}×m$个错误数据。</p><ul><li><p><strong>比较检验</strong></p><ul><li>假设检验</li></ul><p>我们在实际任务中不知道学习器的泛化错误率，但是可以根据测试错误率推出泛化错误率的分布。泛化错误率为$\epsilon$，测试错误率$\hat{\epsilon}$，对于m个测试样本，根据概率论知识，我们知道 学习器测得测试错误率为$\hat{\epsilon}$的概率是</p><script type="math/tex; mode=display">P(\hat{\epsilon};\epsilon)=\binom{m}{\hat{\epsilon}×m}\epsilon^{\hat{\epsilon}×m}(1-\epsilon)^{\hat{\epsilon}(1-m)}</script><p>对$P$求导可知，在$\epsilon=\hat{\epsilon}$时最大，符合二项分布。</p><p><img src="\img\t_test.jpg" alt="n=6、p=0.5时的二项分布及正态近似"></p></li></ul><p>我们可使用“二项检验”($binomial  test$)来对 “$\epsilon\lt \epsilon_0$”进行检验，则在$1-\alpha$（置信度$confidence$）的概率内所能观测到的最大错误概率。若测试错误率$\hat{\epsilon}&lt;{\epsilon}$,即能以$1-\alpha$的置信度认为，学习器错误率不大于$\epsilon_0$</p><ul><li>t 检验</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念和公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抛砖引玉析回溯</title>
    <link href="/2020/08/02/2020-8-2-trackback-demo/"/>
    <url>/2020/08/02/2020-8-2-trackback-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析回溯法"><a href="#浅析回溯法" class="headerlink" title="浅析回溯法"></a>浅析回溯法</h1><blockquote><p>想必大家都玩过一些智力游戏，比如解数独，华容道，魔方，甚至围棋这些。 让我们用计算机去解决这些问题，并且使得时间尽可能短，一种可能的方法是<strong>回溯法</strong>，现在已经有用机器学习中的对抗学习(GAN)以及强化学习(RL)，著名的有AlphaGo以及OpenAI,后者甚至可以在最难的MOBA类游戏战胜人类。</p><p><strong>推荐阅读</strong>Liweiwei1419大佬的「<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级讲解</a>」</p></blockquote><ul><li><ol><li><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a></p></li><li><p><a href="https://leetcode-cn.com/problems/24-game/">24点游戏</a></p></li></ol></li><li><ol><li><a href="https://leetcode-cn.com/problems/n-queens/">N皇后</a></li></ol></li><li><ol><li><a href="">扫雷游戏</a></li></ol></li><li><ol><li><a href="">祖玛游戏</a></li></ol></li></ul><h2 id="679-24点游戏"><a href="#679-24点游戏" class="headerlink" title="679. 24点游戏"></a>679. 24点游戏</h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]输出: True解释: (<span class="hljs-number">8</span><span class="hljs-number">-4</span>) * (<span class="hljs-number">7</span><span class="hljs-number">-1</span>) = <span class="hljs-number">24</span></code></pre><p>示例 2:</p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<span class="hljs-string">输出:</span> <span class="hljs-literal">False</span></code></pre><p>注意:</p><p>`1. 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</p><ol><li>每个运算符对两个数进行运