

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="博主：来自华中科技大学国家光电研究中心的">
  <meta name="author" content="Durant">
  <meta name="keywords" content="">
  <title>妈妈终于不用担心我分不清楚红黑树和树状数组了！ - Durant Thorvalds 的米奇妙妙屋</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-17 00:00" pubdate>
        星期五, 七月 17日 2020, 12:00 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      48
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">妈妈终于不用担心我分不清楚红黑树和树状数组了！</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="线段树和树状数组"><a href="#线段树和树状数组" class="headerlink" title="线段树和树状数组"></a>线段树和树状数组</h1><blockquote>
<p>“树状数组和线段树都是用于维护数列信息的数据结构，支持单点/区间修改，单点/区间询问信息。以增加权值与询问区间权值和为例，其余的信息需要维护也都类似。时间复杂度均为$O(logn)$。 ”</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/191524460">详细的数学证明</a></p>
</blockquote>
<ul>
<li>练习题目<ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/">计算右侧小于当前元素的个数</a></li>
</ol>
</li>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/">最大子序和</a></li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="I-树状数组"><a href="#I-树状数组" class="headerlink" title="I. 树状数组"></a>I. 树状数组</h1><h2 id="Fenwick-Tree"><a href="#Fenwick-Tree" class="headerlink" title="Fenwick Tree"></a>Fenwick Tree</h2><p>地中海的程序猿们研究数组，时候遇到这样一个问题: 有一个数组$S$从$0 - n-1$，现在要在$O(logn)$ 的时间复杂度内，搜索一个确定的值（或修改）$w$并且对区间 $[a,b]$ 求和。空间复杂度必须严格限制在$O(n)$.</p>
<p>他们想到了二叉搜索树(BST)，对于平衡二叉树其插入和删除的时间复杂度都是$O(logn)$，因为树是类似于嵌套列表的思想，进而可以想到二叉堆，这是一种非嵌套列表，也可以实现$O(logn)$。于是有了下面这张图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vQUtNZXIvMTIyODU5OS9vX1RyZWVBcnJheS5qcGc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="FenwickTree"></p>
<blockquote>
<p>解释一下，编号为$x$的节点上统计着$[x-lowbit(x)+1,x]$这一段区间的信息，$x$的父亲就是$x+lowbit(x)$,我们要维护数组$C$上的信息，存储在数组$A$中。</p>
</blockquote>
<p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的$f[i]$的个数也是2的幂。</p>
<h2 id="1-Lowbit函数"><a href="#1-Lowbit函数" class="headerlink" title="1. Lowbit函数"></a>1. Lowbit函数</h2><blockquote>
<p>返回参数转换为二进制后，最后一个1的位置所代表的数值。</p>
</blockquote>
<p>比如34转换为二进制就是0010 0010, Lowbit(34)返回2. 程序上 我们可以用<code>((Not I)+1) AND I</code>, 比如NOT(0010 0010) = 1101 1101, 加1之后为 1101 1110，再与上I,为0000 0010(2)。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> x&amp;(-x);
&#125;</code></pre>
<h2 id="2-新建数组"><a href="#2-新建数组" class="headerlink" title="2. 新建数组"></a>2. 新建数组</h2><p>我们定义一个数组BIT，用以维护A的前缀和，</p>
<script type="math/tex; mode=display">
BIT_i = \sum\limits_{j=i-lowbit(i)+1}^{i} A_{j}</script><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123; 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_N; i++)
    &#123;
        BIT[i] = A[i - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">2</span>; j &gt;= i - lowbit(i); j--)
            BIT[i] += A[j];
    &#125;
&#125;</code></pre>
<h2 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h2><p>假设现在要在$A[i]$的值增加$\delta$, 那么需要将$BIT$在所有含$A[i]$的区间都加上一个数，<br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> w)</span></span>
<span class="hljs-function">    </span>&#123;<span class="hljs-comment">// 在下标k、加上w</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&lt; tr.size();j+=low_bit(j)) tr[j]+=w;
    &#125;
</code></pre></p>
<h2 id="4-区间求和"><a href="#4-区间求和" class="headerlink" title="4. 区间求和"></a>4. 区间求和</h2><p>假设我们需要计算$\sum\limits_{i=1}^kA_i$的值。</p>
<ol>
<li>首先，将$ans$初始化为$k$</li>
<li>将$ans$的值加上$BIT[i]$</li>
<li>将$i$的值减去$Lowbit(i)$</li>
<li>重复2 . 3 步骤直到$i$的值变为0.</li>
</ol>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i -= lowbit(i))
        ans += BIT[i];
    <span class="hljs-keyword">return</span> ans;
&#125;</code></pre>
<p>应用：求<a target="_blank" rel="noopener" href="https://blog.csdn.net/cattycat/article/details/5640838">逆序数</a></p>
<blockquote>
<p>练习 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">LC315. 计算右侧小于当前元素的个数</a></p>
</blockquote>
<h1 id="II-线段树"><a href="#II-线段树" class="headerlink" title="II. 线段树"></a>II. 线段树</h1><h2 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h2><blockquote>
<p>使用线段树可以快速查找某一个节点在若干线段中出现的次数，时间复杂度为$O(logN)$，而未优化的空间复杂度为$2N$，一般要开$4N$的数组防止越界。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvYmQzZWIxMzUzM2ZhODI4YmNiNWZlODVmZmUxZjQxMzQ5NzBhNWEwOQ?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="线段树"></p>
<p>除了叶子节点外，对于$[a,b]$线段节点，其有两个子节点, 左子节点$[a,(a+b)/2]$和右子节点$[(a+b)/2+1,b]$。由于线段树在程序竞赛中被广泛应用，这种结构被$ACMer$和$OIer$戏谑为必须掌握的数据结构。一般地，我们先定义一个线段树节点结构体:</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentNode</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> start;<span class="hljs-comment">//线段左节点</span>
    <span class="hljs-keyword">int</span> end;<span class="hljs-comment">//线段右节点</span>
    <span class="hljs-keyword">int</span> sum;<span class="hljs-comment">//线段对应的和</span>
    <span class="hljs-keyword">int</span> lazytag;<span class="hljs-comment">//懒标记</span>
    SegmentNode *left;
    SegmentNode *right;
    SegmentNode():start(<span class="hljs-number">0</span>),end(<span class="hljs-number">0</span>),sum(<span class="hljs-number">0</span>)&#123;&#125;
&#125;;</code></pre>
<p>请务必熟悉理解<code>上述</code>结构！</p>
<h2 id="1-建立树"><a href="#1-建立树" class="headerlink" title="1. 建立树"></a>1. 建立树</h2><p>我们对区间$[l,r]$建立线段树，是一个自上而下过程。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;
        self-&gt;start = l;self-&gt;end = r;
        <span class="hljs-keyword">if</span>(l==r)
        &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;
        self-&gt;left = <span class="hljs-keyword">new</span> SegmentNode();
        build(self-&gt;left,l,mid);
        self-&gt;right = <span class="hljs-keyword">new</span> SegmentNode();
        build(self-&gt;right,mid+<span class="hljs-number">1</span>,r);
    &#125;</code></pre>
<h2 id="2-单点修改"><a href="#2-单点修改" class="headerlink" title="2. 单点修改"></a>2. 单点修改</h2><p>从根节点开始,以递归的方式不断更新sum值，直到叶子节点即<code>区间长度为1</code>，每个区间的sum值等于左子区间的sum值，加上右子区间的sum值。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(pos&lt;self-&gt;start||pos&gt;self-&gt;end) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(self-&gt;start == self-&gt;end)
    &#123;
        self-&gt;sum += k;
        <span class="hljs-keyword">return</span>; 
    &#125;
    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&gt;pos) add(self-&gt;left,pos,k);
    <span class="hljs-keyword">else</span> add(self-&gt;right,pos,k);
    self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;
&#125;</code></pre>
<h2 id="3-区间查询"><a href="#3-区间查询" class="headerlink" title="3. 区间查询"></a>3. 区间查询</h2><ul>
<li>第一种情况是当前的区间范围完全在$[l,r]$内，这个时候把当前区间的$sum$值返回即可，</li>
<li>第二张情况是当前节点的<code>左子节点</code>的<code>右端点</code>和$[l,r]$有交集。这个时候就搜索左子节点。</li>
<li>第三张情况是当前节点的<code>右子节点</code>的<code>左端点</code>和$[l,r]$有交集。这个时候就搜索右子节点。<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>
<span class="hljs-function"></span>&#123;<span class="hljs-comment">//这里的i,j分别代表要搜索的区间</span>
    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(i&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=j)
    &#123;
        <span class="hljs-keyword">return</span> self-&gt;sum; 
    &#125;
    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j);
    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j);
    <span class="hljs-keyword">return</span> s;
&#125;</code></pre>
<h2 id="4-延迟标记"><a href="#4-延迟标记" class="headerlink" title="4. 延迟标记"></a>4. 延迟标记</h2></li>
</ul>
<p>对于区间修改，这里会遇到一个问题：为了使所有sum值都保持正确，每一次插入操作可能要更新$O(N)$个sum值，从而使时间复杂度退化为$O(N)$。所以就有了Lazytag，如果一个节点有延迟标记，那么表明这个节点已经被修改过了。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_tag</span><span class="hljs-params">(SegmentNode *self,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span> </span>&#123;
    self-&gt;sum += (r-l+<span class="hljs-number">1</span>)*v;self-&gt;lazytag+=v;<span class="hljs-comment">//标记只对儿子有影响，自己在打标记的同时一起把统计信息更改了。</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(SegmentNode *self,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
    add_tag(self-&gt;left,l,mid,self-&gt;lazytag);
    add_tag(self-&gt;right,mid+<span class="hljs-number">1</span>,r,self-&gt;lazytag);
    self-&gt;lazytag = <span class="hljs-number">0</span>;<span class="hljs-comment">//把当前标记分别传给两个儿子然后清空</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-comment">//[l,r]为当前区间,[L,R]为要修改的区间</span>
    <span class="hljs-keyword">if</span>(l&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=r) &#123;
        add_tag(self,l,r,v);<span class="hljs-comment">//打标记</span>
        <span class="hljs-keyword">return</span>;
	&#125;
    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;
    push_down(self,l,r);<span class="hljs-comment">//下传标记</span>
    <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j,v);
    <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j,v);
    <span class="hljs-keyword">return</span> s;
&#125;</code></pre>
<h1 id="III-树状数组和线段树比较"><a href="#III-树状数组和线段树比较" class="headerlink" title="III. 树状数组和线段树比较"></a>III. 树状数组和线段树比较</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据结构</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">适用特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">线段树</td>
<td style="text-align:center">$O(logN)$</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">树状数组</td>
<td style="text-align:center">$O(logN)$</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">空间复杂度略低，容易扩展到多维，适用范围较线段树小</td>
</tr>
</tbody>
</table>
</div>
<p>下面看一些经典题目吧</p>
<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/">最大子序和</a></h1><p>其实这题除了用动态规划，还可以用线段树做。</p>
<p><strong>这个分治方法类似于「线段树求解 LCIS 问题」的 pushUp 操作</strong>。 当然，如果读者有兴趣的话，推荐看一看线段树区间合并法解决 <code>多次询问</code> 的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p>
<p>我们定义一个操作<code>get(a,l,r)</code>表示查询a序列$[l,r]区$间内的最大字段和。对于一个区间，我们取$m = [\frac{l+r}{2}]$,然后<code>逐层递归</code>。最关键的问题是：</p>
<ul>
<li><p>我们要维护区间什么信息？</p>
</li>
<li><p>我们如何合并这些信息？</p>
</li>
</ul>
<p>  对于一个区间$[l,r]$，<code>lSum</code>表示$[l,r]$以$l$为左端点的最大子段和；<code>rSum</code>表示$[l,r]$以$r$为右端点的最大子段和，<code>mSum</code>表示$[l,r]$</p>
<p>  内的最大子段和。<code>iSum</code>表示$[l,r]$的区间和。</p>
<ul>
<li><code>iSum</code>是左右区间的子段和的和。</li>
<li>对于 $[l, r]$ 的 <code>lSum</code>，存在两种可能，它要么等于「左子区间」的 <code>lSum</code>，要么等于「左子区间」的 <code>iSum</code> 加上「右子区间」的 <code>lSum</code>，二者取大。</li>
<li>对于 $[l, r]$ 的 <code>rSum</code>，存在两种可能，它要么等于「右子区间」的 <code>rSum</code>，要么等于「右子区间」的 <code>iSum</code> 加上「左子区间」的 <code>rSum</code>，二者取大。</li>
<li>对于<code>mSum</code>，存在三种可能，要么完全在左区间，要么完全在中间，要么两边都有，我想你已经猜到了，就是左区间的<code>rSum</code>加上右区间的<code>lSum</code>。</li>
</ul>
<p>好的已经可以开始写代码了</p>
<hr>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Status</span></span>
<span class="hljs-class">    &#123;</span>
        <span class="hljs-keyword">int</span> lSum, rSum, mSum, iSum;
        <span class="hljs-comment">// 分别表示，以l为左端点的最大子序和，以r为右端点的最大子序和，</span>
        <span class="hljs-comment">// mSum表示区间[l,r]最大子序和</span>
        <span class="hljs-comment">//iSum表示区间和</span>
    &#125;;

    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums,<span class="hljs-keyword">int</span>  l,<span class="hljs-keyword">int</span>  r)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> (Status)&#123;nums[l],nums[l],nums[l],nums[l]&#125;;
        <span class="hljs-keyword">int</span> m = (l+r)&gt;&gt;<span class="hljs-number">1</span>;
        Status lpus = get(nums,l,m);
        Status rpus = get(nums,m+<span class="hljs-number">1</span>,r);
        <span class="hljs-keyword">int</span> lSum = max(lpus.lSum, lpus.iSum + rpus.lSum);
        <span class="hljs-keyword">int</span> rSum = max(rpus.rSum, rpus.iSum + lpus.rSum);
        <span class="hljs-keyword">int</span> iSum = lpus.iSum + rpus.iSum;
        <span class="hljs-keyword">int</span> mSum = max(lpus.rSum+ rpus.lSum,max(lpus.mSum, rpus.mSum));
        <span class="hljs-keyword">return</span> (Status)&#123;lSum,rSum,mSum,iSum&#125;; 

    &#125;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> get(nums, <span class="hljs-number">0</span> , nums.size()<span class="hljs-number">-1</span>).mSum;
    &#125;


</code></pre>
<p>然后我们分析一下时间和空间复杂度。</p>
<p>时间复杂度：$O(n)$，我们把递归过程看成二叉树的先序遍历，那么这颗二叉树时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 $O(\log n)$，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i = 1}^{\log n} 2^{i - 1}) = O(n)$，故渐进时间复杂度为 $O(n)$。<br>空间复杂度：递归会使用 O(\log n)O(logn) 的栈空间，故渐进空间复杂度为 $O(logn)$。 </p>
<hr>
<h1 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a>315. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a></h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例：</p>
<pre><code class="hljs angelscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>]
输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 
解释：
<span class="hljs-number">5</span> 的右侧有 <span class="hljs-number">2</span> 个更小的元素 (<span class="hljs-number">2</span> 和 <span class="hljs-number">1</span>)
<span class="hljs-number">2</span> 的右侧仅有 <span class="hljs-number">1</span> 个更小的元素 (<span class="hljs-number">1</span>)
<span class="hljs-number">6</span> 的右侧有 <span class="hljs-number">1</span> 个更小的元素 (<span class="hljs-number">1</span>)
<span class="hljs-number">1</span> 的右侧有 <span class="hljs-number">0</span> 个更小的元素</code></pre>
<hr>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentNode</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> start;
    <span class="hljs-keyword">int</span> end;
    <span class="hljs-keyword">int</span> sum;
    SegmentNode *left;
    SegmentNode *right;
    SegmentNode():start(<span class="hljs-number">0</span>),end(<span class="hljs-number">0</span>),sum(<span class="hljs-number">0</span>)&#123;&#125;
&#125;;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span>
    <span class="hljs-keyword">public</span>:
<span class="hljs-comment">//---------------------------Segment tree solution----------------------------</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;
        self-&gt;start = l;self-&gt;end = r;
        <span class="hljs-keyword">if</span>(l==r)
        &#123;
            <span class="hljs-comment">// self-&gt;sum = l;</span>
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;
        self-&gt;left = <span class="hljs-keyword">new</span> SegmentNode();
        build(self-&gt;left,l,mid);
        self-&gt;right = <span class="hljs-keyword">new</span> SegmentNode();
        build(self-&gt;right,mid+<span class="hljs-number">1</span>,r);
        <span class="hljs-comment">// self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;</span>
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> k)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(pos&lt;self-&gt;start||pos&gt;self-&gt;end) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span>(self-&gt;start == self-&gt;end)
        &#123;
            self-&gt;sum += k;
            <span class="hljs-keyword">return</span>; 
        &#125;
        <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&gt;pos) add(self-&gt;left,pos,k);
        <span class="hljs-keyword">else</span> add(self-&gt;right,pos,k);
        self-&gt;sum = self-&gt;left-&gt;sum + self-&gt;right-&gt;sum;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(SegmentNode *self, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(i&lt;=self-&gt;start &amp;&amp; self-&gt;end&lt;=j)
        &#123;
            <span class="hljs-keyword">return</span> self-&gt;sum; 
        &#125;
        <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(self-&gt;left-&gt;end&gt;=i) s+=search(self-&gt;left,i,j);
        <span class="hljs-keyword">if</span>(self-&gt;right-&gt;start&lt;=j) s+=search(self-&gt;right,i,j);
        <span class="hljs-keyword">return</span> s;
    &#125;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller_SegmentTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> nums;
        SegmentNode *root = <span class="hljs-keyword">new</span> SegmentNode();
        <span class="hljs-comment">//find the min and max val in nums</span>
        <span class="hljs-keyword">int</span> min_val = INT_MAX, max_val = INT_MIN;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums)&#123;min_val=min(min_val,c);max_val = max(max_val,c);&#125;
        build(root,min_val,max_val);
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size())</span></span>;
        <span class="hljs-comment">// for(auto &amp;c:nums) </span>
        <span class="hljs-comment">//     add(root,c,1);//All sub interval adds 1</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.size()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>;i--)
        &#123;
            add(root,nums[i],<span class="hljs-number">1</span>);
            res[i] = search(root,min_val,nums[i]<span class="hljs-number">-1</span>);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
<span class="hljs-comment">//------------------------------Fenwick Tree Solution----------------------------------</span>
<span class="hljs-comment">//Due to the uncertainty of scale of data, we discretize the array</span>
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tr;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function">    </span>&#123;<span class="hljs-comment">//pow(2,x)</span>
        <span class="hljs-keyword">return</span> (x&amp;(-x));
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&gt;<span class="hljs-number">0</span>; j-=low_bit(j)) res+=tr[j];
        <span class="hljs-keyword">return</span> res;
    &#125;
   
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> w)</span></span>
<span class="hljs-function">    </span>&#123;<span class="hljs-comment">// add k to node w</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = k; j&lt; tr.size();j+=low_bit(j)) tr[j]+=w;
    &#125;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller_Fenwick</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> &#123;&#125;;
        <span class="hljs-keyword">int</span> n = nums.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;
        <span class="hljs-comment">//First, we discretize the vector and delete the repeated nums</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp = nums;
        sort(tmp.begin(),tmp.end());
        <span class="hljs-keyword">auto</span> c = unique(tmp.begin(),tmp.end());
        tmp.erase(c,tmp.end());
        <span class="hljs-keyword">int</span> new_len = c - tmp.begin();
        <span class="hljs-comment">// we define a unordered-map to count the number of tmp</span>
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; ump;
        tr = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(new_len + <span class="hljs-number">1</span>);<span class="hljs-comment">//redefine the tr to (new_len+1) default value</span>
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;new_len;i++)
            ump[tmp[i]] = count++;<span class="hljs-comment">//redefine the discretized values into serialized values using hashmap</span>
        <span class="hljs-comment">//we build the Fenwick tree and do summation and addition</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = nums.size()<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--)
        &#123;
            count = ump[nums[k]];<span class="hljs-comment">// count of number</span>
            res[k] = sum(count<span class="hljs-number">-1</span>);
            add(count,<span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-keyword">return</span> res;

    &#125;
&#125;;</code></pre>
<blockquote>
<p>感谢！有任何问题请在评论区提出，笔者看到会及时回答！</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">树状数组</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/19/2020-07-19-damn_blog/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Durant终于有个家写写东西了</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/25/2020-06-25-C++memory_management/">
                        <span class="hidden-mobile">C++ 内存手动管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "妈妈终于不用担心我分不清楚红黑树和树状数组了！&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
