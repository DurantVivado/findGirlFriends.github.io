

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="博主：来自华中科技大学国家光电研究中心的">
  <meta name="author" content="Durant">
  <meta name="keywords" content="">
  <title>做一只可爱的小🐖背包 Cover「背包九讲」 - Durant Thorvalds 的米奇妙妙屋</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-25 00:00" pubdate>
        2020年7月25日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      65
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">做一只可爱的小🐖背包 Cover「背包九讲」</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="做一只可爱的小🐖背包"><a href="#做一只可爱的小🐖背包" class="headerlink" title="做一只可爱的小🐖背包"></a>做一只可爱的小🐖背包</h1><blockquote>
<p>  推荐观看dd大牛：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲的传送门</a>, <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av33930433">「背包九讲」视频教程</a></p>
<p>  0-1 背包    </p>
<blockquote>
<p> 完全背包</p>
<blockquote>
<p>多重背包 I II III</p>
</blockquote>
<p>混合背包问题</p>
<blockquote>
<p>二维费用的背包问题</p>
</blockquote>
<p>分组背包问题</p>
<blockquote>
<p>背包问题求解方案数</p>
</blockquote>
<p>求背包问题的方案</p>
<blockquote>
<p>有依赖的背包问题</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="I-0-1背包问题"><a href="#I-0-1背包问题" class="headerlink" title="I. 0-1背包问题"></a>I. 0-1背包问题</h2><blockquote>
<p><u><strong>注意</strong>解空间极大问题有时可以转化0-1背包,从而避免TLE!</u></p>
</blockquote>
<p>题目：有一个容量为 V 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。</p>
<p>例子</p>
<pre><code class="hljs angelscript">背包最大容量：<span class="hljs-number">50</span>
物品重量为：&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>&#125;
物品价值为：&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;
输出：<span class="hljs-number">8</span>
解释：当选择物品重量为<span class="hljs-number">20</span>，<span class="hljs-number">30</span>或者<span class="hljs-number">10</span>，<span class="hljs-number">40</span>对应的价值最大。</code></pre>
<p>我们适当作一些约定：$dp[i][j]或dp[j]$表示最大价值，$i$为具体问题下物品编号或组编号，$j$为体积。$W_i$为价值数组，$V_i$为体积数组。</p>
<p>$N$表示物品数量，$C$表示背包容积，$Q$表示背包最大重量。</p>
<p>0-1 背包问题中，物品只有两种状态，装载或者不装载，因此被称为<strong>0-1背包</strong>。除此之外还有<strong>完全背包</strong>和<strong>多重背包</strong>。</p>
<ol>
<li><strong>找子问题</strong>，第一，包的当前容量比物品小，装不下，这时的最大价值和前<script type="math/tex">i-1</script>个物品的最大价值是一样的。我们令<script type="math/tex">dp[i][j]</script>表示前<script type="math/tex">i</script>个物品在背包容量为<script type="math/tex">j</script>所能达到的最大价值。第二，包的当前可用容量比物品大，这个时候要决定是否添加下一个物品，因为在体积相同的情况下，总价值不一定更大。</li>
<li>找到<strong>状态转移方程</strong>，我们用辅助函数$sumWeight(i)$表示当前物品的总重量。</li>
</ol>
<script type="math/tex; mode=display">
dp[i][j]=\begin{cases}
dp[i-1][j],\ sumWeight(i-1)+w[i-1]>j
\\
\max(dp[i-1][j-w[i-1]]+v[i-1], dp[i-1][j])，otherwise
\end{cases}</script><ol>
<li><p>确定<strong>边界条件</strong>：</p>
<p><script type="math/tex">dp[0][j]=0</script>，不装物品时最大价值为0.，同理<script type="math/tex">dp[i][0]=0</script>，即背包容量为0时，最大价值也为0. </p>
</li>
</ol>
<p>时间复杂度：<script type="math/tex">O(V*N)</script>，状态数量为V*N, V为背包容量，N为物品数目，状态转移复杂度为<script type="math/tex">O(1)</script>。</p>
<p>空间复杂度：<script type="math/tex">O(V*N)</script>, 为dp数组大小。</p>
<blockquote>
<p>变式：要求完全装满背包。</p>
</blockquote>
<p>我们令<script type="math/tex">dp[0][j]=0</script>，不装物品时最大价值为0.，<script type="math/tex">dp[0][j]=-\infin</script>，这样的话，在<script type="math/tex">dp[n][V]</script>刚好大于0.</p>
<blockquote>
<p>优化：用一维数组表示</p>
</blockquote>
<p>因为dp的物品数量维度i，仅与前一项有关，因此可以优化。<u>为保证每个物品只能使用一次，我们倒序遍历所有的值，类似于贪心的思路，而反过来就变成了<strong>完全背包</strong>问题。想想为什么？</u></p>
<script type="math/tex; mode=display">
dp[j] = \max(dp[j-w[i-1]]+v[i-1],dp[j])</script><p>注意后面的dp[j]其实是上一次的结果，这相当于滚动数组。优化后空间复杂度为<script type="math/tex">O(V)</script>。</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">backpack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;val, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight)</span></span>
<span class="hljs-function"></span>&#123;<span class="hljs-comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span>
    <span class="hljs-keyword">int</span> N = val.size();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//dp[j]表示容量为j的最大价值</span>
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V;i++) dp[i] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++)
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = V; j &gt;= weight[i<span class="hljs-number">-1</span>];j--)
        dp[j] = max(dp[j],dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]);
    &#125;
    <span class="hljs-keyword">return</span> dp[V];
&#125;</code></pre>
<hr>
<h2 id="II-完全背包问题"><a href="#II-完全背包问题" class="headerlink" title="II. 完全背包问题"></a>II. 完全背包问题</h2><p>我们让每种物品数量可以无限<script type="math/tex">0-\infty</script>。</p>
<p>例子</p>
<pre><code class="hljs angelscript">背包最大容量：<span class="hljs-number">60</span>
物品重量为：&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>&#125;
物品价值为：&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;
输出：<span class="hljs-number">10</span>
解释：当选择物品重量为两个<span class="hljs-number">30</span>对应的价值最大。</code></pre>
<p>我们将上述优化算法由<strong>倒序遍历</strong>J变为<strong>正序遍历</strong>J即可实现。</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">backpack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;val, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight)</span></span>
<span class="hljs-function"></span>&#123;<span class="hljs-comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span>
    <span class="hljs-keyword">int</span> N = val.size();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(V+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//dp[j]表示容量为j的最大价值</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = weight[i<span class="hljs-number">-1</span>]; j &lt;= V;j++)
    <span class="hljs-keyword">if</span>(dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]&gt;dp[j])
    dp[j] = dp[j-weight[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>];
    <span class="hljs-keyword">return</span> dp[V];
&#125;</code></pre>
<hr>
<h2 id="III-多重背包问题"><a href="#III-多重背包问题" class="headerlink" title="III. 多重背包问题"></a>III. 多重背包问题</h2><p>多重背包问题介于0-1背包和完全背包之间。</p>
<p>我们除了给出背包的最大容量，物品的体积V和价值W，还给出物品的最大数量S。</p>
<p><u>我们可以将多重背包问题转化为0-1背包，即将每种物品视为k种不同的物品</u>，这样的时间复杂度为<script type="math/tex">O(s×\sum k_i)</script>，由此可见，降低每件物品的数量可以大大降低其时间复杂度。我们运用一些tricky技巧，将原来数量为k的物品拆分为若干组，每组物品看成一件物品，其价值和重量为该组所有物品之和。$\color{red}{每组物品包含原物品数目分别为: 1,2,4···k-2^c+1}，其中k为使得k-2^c+1大于0的最大整数$.得到新的时间复杂度为<script type="math/tex">O(s×\sum \log k_i)</script>。</p>
<p><strong>二进制优化</strong></p>
<pre><code class="hljs Cpp"><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//分别表示物品数量和背包容量</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> w,v;<span class="hljs-comment">//用于分组</span>
&#125;;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">vector</span>&lt;object&gt; objects;
    <span class="hljs-keyword">int</span> a,b,s,line = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;s)
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s;k*=<span class="hljs-number">2</span>)
        &#123;<span class="hljs-comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span>
            s -= k;
            objects.push_back(&#123;k*b,k*a&#125;);
        &#125;
        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) objects.push_back(&#123;s*b,s*a&#125;);
        line ++;
    &#125;
    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span>
    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;object:objects)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= object.v;k--)
    &#123;
        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>
        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span>
    &#125;
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p><strong>单调队列优化(Hard)</strong></p>
<p><code>0&lt;N≤10000&lt;N≤1000
0&lt;V≤200000&lt;V≤20000
0&lt;vi,wi,si≤20000</code></p>
<p>当数据范围变得极大，使用二进制将<code>TLE</code>，我们必须优化，这里有一种优化方式是单调队列优化。</p>
<p>因为我们需要的是${ dp[j], dp[v+j], dp[2<em>v+j], dp[3</em>v+j], … , dp[k*v+j] }$ 中的最大值，我们通过维护一个单调队列来维护这些数中最大值。</p>
<p>单调队列问题，最重要的两点<br>1）维护队列元素的个数，如果不能继续入队，弹出队头元素<br>2）维护队列的单调性，即：$尾值 &gt;= dp[j + k<em>v] - k</em>w$</p>
<p>本题中，队列中元素的个数应该为 $s+1$ 个，即 $0 - s $个物品 $i$. 为了方便大家理解，我举例进行说明。</p>
<pre><code class="hljs cpp">
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">20010</span>;
<span class="hljs-keyword">int</span> dp[N_MAX],pre[N_MAX],Q[N_MAX];<span class="hljs-comment">//分别表示物品数量和背包容量</span>
<span class="hljs-comment">//单调队列存的是体积，末尾存储最大价值。</span>
<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和背包容量</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> v,w,s,l=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)
    &#123;
        <span class="hljs-built_in">memcpy</span>(pre,dp,<span class="hljs-keyword">sizeof</span> dp);<span class="hljs-comment">//copy dp-&gt;pre</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; v;j++)
        &#123;<span class="hljs-comment">//j是余数，即C%k</span>
            <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队列头部和尾部</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = j;k &lt;= C;k += v)
            &#123;<span class="hljs-comment">// j+n*k==C</span>
                <span class="hljs-keyword">if</span>(head&lt;=tail)
                &#123;<span class="hljs-comment">//如果容量超过了S,则单调队列应该缩小 head++</span>
                <span class="hljs-keyword">if</span>((k-s*v) &gt; Q[head]) head++;
                <span class="hljs-comment">//如果k对应价值大于头部价值，那么不断，相当于把体积插入到使得队列单增的位置，tail--</span>
                <span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;(pre[k] - (k - j)/v*w) &gt;= (pre[Q[tail]] - (Q[tail] - j)/v*w)) tail--;
                dp[k] = max(dp[k],pre[Q[head]] + (k-Q[head])/v*w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>
                &#125;
                Q[++tail] =  k;
            &#125;
        &#125;
    &#125;
    
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>说实话，笔者单调队列这里也不是很明白，需要再仔细讲究一下。</p>
<hr>
<h2 id="IV-混合背包"><a href="#IV-混合背包" class="headerlink" title="IV. 混合背包"></a>IV. 混合背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<ul>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 $s_i$ 次（多重背包）；</li>
</ul>
<p>每种体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 NN 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。</p>
<ul>
<li>$si=−1$ 表示第 $i$ 种物品只能用1次；</li>
<li>$si=0$ 表示第 $i$ 种物品可以用无限次；</li>
<li>$si&gt;0$ 表示第 $i$ 种物品可以使用 $si$ 次；</li>
</ul>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000<br>−1≤si≤1000$</p>
<blockquote>
<hr>
</blockquote>
<p>我们直接分类讨论，状态转移直接分为<strong>无限个</strong>和<strong>非无限</strong>即可。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//分别表示物品数量和背包容量</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> kind;
    <span class="hljs-keyword">int</span> w,v;<span class="hljs-comment">//用于分组</span>
&#125;;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">vector</span>&lt;object&gt; objects;
    <span class="hljs-keyword">int</span> v,w,s;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)
    &#123;
        <span class="hljs-keyword">if</span>(s == <span class="hljs-number">-1</span>) objects.push_back(&#123;<span class="hljs-number">-1</span>,w,v&#125;);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) objects.push_back(&#123;<span class="hljs-number">0</span>,w,v&#125;);
        <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= s;k*=<span class="hljs-number">2</span>)
        &#123;<span class="hljs-comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span>
            s -= k;
            objects.push_back(&#123;<span class="hljs-number">1</span>,k*w,k*v&#125;);
        &#125;
        <span class="hljs-keyword">if</span>(s&gt;<span class="hljs-number">0</span>) objects.push_back(&#123;<span class="hljs-number">1</span>,s*w,s*v&#125;);
    &#125;
    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span>
    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;object:objects)
    <span class="hljs-keyword">if</span>(object.kind == <span class="hljs-number">0</span>)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = object.v;k &lt;= C;k++)
    &#123;
        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>
    &#125;
    <span class="hljs-keyword">else</span>     
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= object.v;k--)
    &#123;
        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>
    &#125;
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="V-二维费用的背包问题"><a href="#V-二维费用的背包问题" class="headerlink" title="V. 二维费用的背包问题"></a>V. 二维费用的背包问题</h2><p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p>
<p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N≤1000\\<br>0&lt;V,M≤100\\0&lt;v_i,m_i≤100\\<br>0&lt;w_i≤1000$</p>
<p>其实非常容易进行扩展，将数组维度扩大，再加一层循环即可。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,Q;<span class="hljs-comment">//分别表示物品数量，背包体积容量，背包最大重量</span>
<span class="hljs-keyword">int</span> V[<span class="hljs-number">1001</span>],W[<span class="hljs-number">1001</span>],M[<span class="hljs-number">1001</span>];<span class="hljs-comment">//体积，价值和重量</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> v,w,m,line = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C&gt;&gt;Q;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;m&gt;&gt;w)
    &#123;
        V[line] = v;
        M[line] = m;
        W[line] = w;
        
        line ++;
    &#125;
    <span class="hljs-keyword">int</span> dp[C+<span class="hljs-number">1</span>][Q+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= V[i<span class="hljs-number">-1</span>];k--)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = Q;j &gt;= M[i<span class="hljs-number">-1</span>];j--)
    &#123;
        dp[k][j] = max(dp[k][j],dp[k - V[i<span class="hljs-number">-1</span>]][j - M[i<span class="hljs-number">-1</span>]] + W[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>
        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k][j]);</span>
    &#125;
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C][Q];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="VI-分组背包问题"><a href="#VI-分组背包问题" class="headerlink" title="VI. 分组背包问题"></a>VI. 分组背包问题</h2><p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$用空格隔开，分别表示物品组数和背包容量。</p>
<p>接下来有 $N$ 组数据：</p>
<ul>
<li>每组数据第一行有一个整数 $S_i$，表示第 $i $个物品组的物品数量；</li>
<li>每组数据接下来有 $Si$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；</li>
</ul>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0&lt;N,V≤100
0&lt;Si≤100
0&lt;vij,wij≤100</code></p>
<blockquote>
<hr>
</blockquote>
<p>我们只需要对每组每一个物品进行讨论。求每组的dp是并列的关系，注意循环之间位置关系。枚举体积的循环在外面，而枚举组内物品循环在里面。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,v,w;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">101</span>;
<span class="hljs-keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    
    <span class="hljs-comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span>
    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//每组物品的数量</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)
    &#123;
    <span class="hljs-built_in">cin</span>&gt;&gt; num;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; num; j++)
    &#123;
        <span class="hljs-built_in">cin</span>&gt;&gt;V[j]&gt;&gt;W[j];
    &#125; 
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= <span class="hljs-number">0</span>;k--)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;s &lt; num; s++)
    <span class="hljs-keyword">if</span>(k &gt;= V[s])
    &#123;
        dp[k] = max(dp[k],dp[k - V[s]] + W[s]);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品</span>
        <span class="hljs-comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span>
    &#125;
        
    &#125;
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[C];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="VII-有依赖的背包问题（hard）-树形dp"><a href="#VII-有依赖的背包问题（hard）-树形dp" class="headerlink" title="VII. 有依赖的背包问题（hard）[树形dp]"></a>VII. 有依赖的背包问题（hard）[树形dp]</h2><p>有 $N$ 个物品和一个容量是 $V$ 的背包。</p>
<p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p>
<p>如下图所示：<br><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" srcset="/img/loading.gif" alt="QQ图片20181018170337.png"></p>
<p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p>
<p>每件物品的编号是 $i$，体积是 $vi$，价值是 $wi$，依赖的父节点编号是 $pi$。物品的下标范围是 $1…N$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。</p>
<p>接下来有 $N$ 行数据，每行数据表示一个物品。<br>第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>如果 $p_i=−1$，表示根节点。 <strong>数据保证所有物品构成一棵树。</strong></p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N,V≤100\\1≤v_i,w_i≤100$</p>
<p>父节点编号范围：</p>
<ul>
<li>内部结点：$1≤p_i≤N$;</li>
<li>根节点 $pi=−1$;</li>
</ul>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">7</span>
<span class="hljs-symbol">2 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span>
<span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span>
<span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span>
<span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span></code></pre>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="hljs angelscript"><span class="hljs-number">11</span></code></pre>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><pre><code class="hljs angelscript">我们选择根节点,价值为&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;，
编号为<span class="hljs-number">1</span>的叶节点，我们选择&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;或&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;。
编号为<span class="hljs-number">2</span>的叶节点，我们选择&#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>&#125;或&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;。 
最大容积<span class="hljs-number">7</span>， 我们选择&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;和&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;,这样总体积就是<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span> = <span class="hljs-number">7.</span> 总价值为 <span class="hljs-number">2</span>+<span class="hljs-number">6</span>+<span class="hljs-number">3</span>=<span class="hljs-number">11.</span></code></pre>
<blockquote>
<hr>
</blockquote>
<p>这道题其实是分组背包和<u>树形dp</u>的结合。先考虑节点的数据表示我们用<code>vector&lt;int&gt; g[N_MAX]</code>表示二叉树。$dp[i][j]$表示，<strong>我们选择节点$i$为根节点，并且体积为$j$的最大价值。</strong></p>
<p>既然是树，我们就需要深度优先搜索（DFS）。由于子节点依赖于根节点，那么根节点必定占据一定空间，且初始价值应该等于根节点。</p>
<blockquote>
<p>初始条件：$ dp[root][j] = W_{root}, V_{root} \le j \le C$ , $C$表示背包容积。</p>
</blockquote>
<p>按照0-1背包思路，我们在$k \in[V_{root},C]$区间内逆向遍历，那么子节点的可用空间为$m \in [0,k-V_{root}]$. 可以类比分组背包的$k\in[0,C],s \in [0,num],where  k &gt; V_s$, $num$为组号。之后我们将每个子节点分别进行搜索，对$dp[root][k]$进行更新。</p>
<script type="math/tex; mode=display">
dp[root][k] = \max(dp[root][k],dp[root][k-m]+dp[son][m])</script><blockquote>
<p>返回值：$dp[root][C]$</p>
</blockquote>
<p>弄清楚这一层写代码就不难了。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> N,C,p;<span class="hljs-comment">//物品数量，背包容积，父节点</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">101</span>;
<span class="hljs-keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX][N_MAX];<span class="hljs-comment">//体积数组，价值数组，dp[i][j]选择第i个节点为根节点在体积为j对应最大价值</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[N_MAX];<span class="hljs-comment">//保存子节点</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span></span>
<span class="hljs-function"></span>&#123;<span class="hljs-comment">//cap表示容量，no表示节点编号</span>
    <span class="hljs-comment">//root必选，所以我们初始化dp[root][V[root]~C] 为 W[root]</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = V[root];j &lt;= C;i++) dp[root][j] = W[root];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;son:g[root]) 
    &#123;
        dfs(son);<span class="hljs-comment">//遍历子节点</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C; k &gt;= V[root]; k--)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt;= (k-V[root]);m++)<span class="hljs-comment">//分配给子树的空间不能大于C-V[son]</span>
        &#123;
            dp[root][k] = max(dp[root][k], dp[root][k-m] + dp[son][m]);<span class="hljs-comment">//根据不同的子节点更新父节点的值</span>
            <span class="hljs-comment">// if(dp[root][k]) printf(&quot;rt:%d,sn:%d,dp[%d]:%d\n&quot;,root,son,k,dp[root][k]);</span>
            
        &#125;
    &#125;
    
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    <span class="hljs-comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span>
    <span class="hljs-keyword">int</span> root;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++)
    &#123;
        <span class="hljs-built_in">cin</span>&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;p;
        <span class="hljs-keyword">if</span>(~p) g[p].emplace_back(i);
        <span class="hljs-keyword">else</span> root = i;
    &#125;
    dfs(root);
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[root][C];
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="VIII-背包求解方案数"><a href="#VIII-背包求解方案数" class="headerlink" title="VIII.背包求解方案数"></a>VIII.背包求解方案数</h2><p>有 $N$件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$, 用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <strong>方案数</strong> 模 $10^9+7$ 的结果。</p>
<h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\\<br>0&lt;v_i,w_i≤1000$</p>
<blockquote>
<p>我们除了需要对价值$dp[j]$进行状态转移（同0-1背包），还需要对方案数进行转移，设$M[j]$表示物品总体积为$j$对应的方案数。</p>
<p>那么有：</p>
<script type="math/tex; mode=display">
M[j] = \begin{cases}
        M[j], M[j]>M[j-v_i]\\
        M[j-v_i], M[j]<M[j-v_i]\\
        M[j]+M[j-v_i], M[j]=M[j-v_i]\\
        \end{cases}.</script><p>初始条件： $M[0] = 1$， 背包为空只有一种方案。</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">1010</span>, MOD = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;
<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和容积</span>
<span class="hljs-keyword">int</span> dp[N_MAX],M[N_MAX];<span class="hljs-comment">//方案数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> v,w,line = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    <span class="hljs-built_in">memset</span>(dp,INT_MIN,<span class="hljs-keyword">sizeof</span>(dp));<span class="hljs-comment">//为了使价值从0开始计数，我们把dp数组初始化为-inf</span>
    M[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//价值为0的方案为1，即全不放</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++)
    &#123;
        <span class="hljs-built_in">cin</span>&gt;&gt;v&gt;&gt;w;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = C;k &gt;= v;k--)
        &#123;   
            <span class="hljs-keyword">int</span> t  = max(dp[k],dp[k - v] + w);<span class="hljs-comment">//考虑选第i件物品和不选第i件物品，注意它们价值可能相同</span>
            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<span class="hljs-comment">// 不是M[k]，否则三种方案叠加</span>
            <span class="hljs-keyword">if</span>(t == dp[k-v]+w) s += M[k-v];
            <span class="hljs-keyword">if</span>(t == dp[k]) s += M[k];<span class="hljs-comment">//这里不能写成else if ，两种路径分开考虑，求的是总方案数</span>
            dp[k] = t;
            M[k] =s%MOD;
            <span class="hljs-comment">// printf(&quot;i:%d,k:%d,dp:%d,M:%d\n&quot;,i,k,dp[k],M[k]);</span>
            
        &#125;
    &#125;
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, maxw = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= C;j++)
    &#123;
        <span class="hljs-comment">// cout&lt;&lt;dp[j]&lt;&lt;&quot;,&quot;&lt;&lt;M[j]&lt;&lt;endl;</span>
        <span class="hljs-keyword">if</span>(dp[j] == dp[C])
        &#123;
            res += M[j];
            res %= MOD;
        &#125;
    &#125;
    
    
    <span class="hljs-built_in">cout</span>&lt;&lt;res;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="IX-背包问题求具体方案"><a href="#IX-背包问题求具体方案" class="headerlink" title="IX. 背包问题求具体方案"></a>IX. 背包问题求具体方案</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p>
<p>物品编号范围是 $1…N$。</p>
<h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\\<br>0&lt;v_i,w_i≤1000$</p>
<blockquote>
<hr>
</blockquote>
<p>我们用一个二维dp数组$dp[i][j]$表示选取$i$个物品，体积为$j$对应的最大价值。这里的$i$是用来反推具体方案的。我们思考如何反推。</p>
<p>$dp[i][j] == dp[i-1][j]$说明不选第$i$个物品就能得到最大价值。</p>
<p>$dp[i][j]==dp[i-1][j-v[i-1]]+w[i-1]$表示选择第$i$个物品得到最大价值。</p>
<p>为了得到最小的字典序，我们可以采用贪心的策略。在进行状态转移的时候，我们按编号从大到小进行遍历。为了更直观的理解，我们举例：</p>
<p>设物品数4，背包容积5.  物品的体积$v_i$和价值$w_i$分别为: $[1,2],[2,4],[3,4],[4,6]$.  编号$i$的范围$[1,4]$</p>
<p>从$i=4$开始，我们从体积为0开始进行状态转移。最后的结果一定是最大价值。如下图所示：</p>
<pre><code class="hljs angelscript">i:<span class="hljs-number">4</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span> ←
i:<span class="hljs-number">4</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">4</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">4</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">4</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span>
i:<span class="hljs-number">4</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">6</span>
i:<span class="hljs-number">3</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">3</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">3</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">3</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">4</span>
i:<span class="hljs-number">3</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span> ←
i:<span class="hljs-number">3</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">6</span>
i:<span class="hljs-number">2</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">2</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">2</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">4</span>
i:<span class="hljs-number">2</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">4</span>
i:<span class="hljs-number">2</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span> ←
i:<span class="hljs-number">2</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">8</span>
i:<span class="hljs-number">1</span>,k:<span class="hljs-number">0</span>,dp:<span class="hljs-number">0</span>
i:<span class="hljs-number">1</span>,k:<span class="hljs-number">1</span>,dp:<span class="hljs-number">2</span>
i:<span class="hljs-number">1</span>,k:<span class="hljs-number">2</span>,dp:<span class="hljs-number">4</span>
i:<span class="hljs-number">1</span>,k:<span class="hljs-number">3</span>,dp:<span class="hljs-number">6</span>
i:<span class="hljs-number">1</span>,k:<span class="hljs-number">4</span>,dp:<span class="hljs-number">6</span>
i:<span class="hljs-number">1</span>,k:<span class="hljs-number">5</span>,dp:<span class="hljs-number">8</span>  ←</code></pre>
<p>用$sum$表示剩余体积，开始$sum=5. $然后我们考虑 $dp[i][sum]==dp[i-1][sum-v[i]]+w[i]$ ，如果为True则选择第i个。</p>
<script type="math/tex; mode=display">
dp[1][5]=8→dp[2][4]=6→dp[3][4]=6→dp[4][0]=0.</script><p>最后$sum==0$，表示找到字典序最小的方案。</p>
<p><strong>代码</strong></p>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_MAX = <span class="hljs-number">1010</span>;
<span class="hljs-keyword">int</span> N,C;<span class="hljs-comment">//物品数量和容积</span>
<span class="hljs-keyword">int</span> dp[N_MAX][N_MAX];<span class="hljs-comment">//方案数</span>
<span class="hljs-keyword">int</span> v[N_MAX], w[N_MAX];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">cin</span>&gt;&gt;N&gt;&gt;C;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N;i++) <span class="hljs-built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]; 
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = N;i &gt;= <span class="hljs-number">1</span> ;i--)
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt;= C;k++)
        &#123; 
            dp[i][k] = dp[i+<span class="hljs-number">1</span>][k];    <span class="hljs-comment">//这句话作用是使得k&lt;v[i]仍可进行反推</span>
            <span class="hljs-keyword">if</span>(k &gt;= v[i]) 
            dp[i][k]  = max(dp[i][k],dp[i+<span class="hljs-number">1</span>][k - v[i]] + w[i]);<span class="hljs-comment">//如果选和不选价值相同，那么我们贪心的进行选择</span>
            <span class="hljs-comment">// printf(&quot;i:%d,k:%d,dp:%d\n&quot;,i,k,dp[i][k]);</span>
        &#125;
    &#125;
    <span class="hljs-comment">// 根据结果反推具体方案</span>
    <span class="hljs-keyword">int</span> sum = C;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= N; i++)
    &#123;
        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][sum]&lt;&lt;endl;</span>
        <span class="hljs-keyword">if</span>(sum &gt;= v[i]&amp;&amp;dp[i][sum]==(dp[i+<span class="hljs-number">1</span>][sum-v[i]]+w[i]))
        &#123;
            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
            sum -= v[i];
        &#125;
    &#125;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="经典题目分析、"><a href="#经典题目分析、" class="headerlink" title="经典题目分析、"></a>经典题目分析、</h2><p><strong>例题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</li>
</ul>
<hr>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</strong></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<pre><code class="hljs angelscript">输入：nums: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], S: <span class="hljs-number">3</span>
输出：<span class="hljs-number">5</span>
解释：

<span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>
+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>
+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>
+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span>+<span class="hljs-number">1</span> = <span class="hljs-number">3</span>
+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><span class="hljs-number">-1</span> = <span class="hljs-number">3</span>

一共有<span class="hljs-number">5</span>种方法让最终目标和为<span class="hljs-number">3</span>。</code></pre>
<p>提示：</p>
<ul>
<li>数组非空，且长度不会超过 20 。</li>
<li>初始的数组的和不会超过 1000 。</li>
<li>保证返回的最终结果能被 32 位整数存下。</li>
</ul>
<blockquote>
<p>这道题看起来简单,实际上非常<code>Disgusting</code>.因为它给了三个提示,每一条都杀人诛心. </p>
</blockquote>
<p>这一次,我们每一个”物品”都必须选. <strong>我们考虑$dp[i][j]$表示$0-i$区间内组成$j$的方案数</strong>. 那么相应的状态方程为:</p>
<script type="math/tex; mode=display">
dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</script><p>很多时候我们会因为惯性思维写成<code>nums[i-1]</code>但这是不对的,因为我们定义区间<code>[0,i]</code>.</p>
<p>然后很糟糕的是, 或者更糟糕的是, 中间可能产生负数目标的情况,为了避免数组越界,我们需要将数组整体搬移, 这时候第二个提示发挥作用.我们设这个$offset=1000$. </p>
<p>关于边界条件. 一开始我们很容易写成:</p>
<script type="math/tex; mode=display">
dp[0][nums[0]+sum] = 1;         \\
            dp[0][-nums[0]+sum] = 1;</script><p>第一个数可能为负或者正嘛. 但是如果第一个数为$0$.那么上面的式子将失效, 0 的相反数是其自身. 所以边界条件应该为:</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{cr}
\begin{cases}dp[0][nums[0]+sum] = 1;\\         
dp[0][-nums[0]+sum] = 1;\\
\end{cases},nums[0]!=0
\\
2,otherwise
\end{array}
\right.</script><p>然后,你这样就以为大功告成了就大错特错了.</p>
<p>在双重循环中,我们必须要考虑$j$的范围,即$dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]$的适用条件. 并不是所有情况都可以用这个式子表示.</p>
<p>经过很长时间的摸索, $-sum \le j \le sum$, $sum$表示数组和,为了节省空间,我们也可以把1000改为$sum$:</p>
<script type="math/tex; mode=display">
dp[i][j] =\left\{ \begin{array}{lcc}
dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]],sum-nums[i] >=j>=nums[i]-sum\\
dp[i-1][j-nums[i]],j>nums[i]-sum\\
dp[i-1][j+nums[i]],j<sum-nums[i]
\end{array}
\right.</script><p>做完此题,深感出题人的恐怖.</p>
<p><strong>代码</strong></p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1000</span>;
<span class="hljs-keyword">public</span>:
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;
        <span class="hljs-comment">//子集问题，转换为0-1背包，动态规划解决。</span>
        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = nums.size();
        <span class="hljs-comment">//我们用dp[i][j]表示 0-i区间内组成j的方案数</span>
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:nums) sum+= c;
        S = S&gt;=<span class="hljs-number">0</span>?S:-S;
        <span class="hljs-keyword">if</span>(S&gt;sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">//为了使得负数也能被索引，我们必须加上它自身的绝对值</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>*sum+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))</span></span>;
        <span class="hljs-keyword">if</span>(!nums[<span class="hljs-number">0</span>]) dp[<span class="hljs-number">0</span>][sum] = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">else</span> &#123;
            dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]+sum] = <span class="hljs-number">1</span>;         
            dp[<span class="hljs-number">0</span>][-nums[<span class="hljs-number">0</span>]+sum] = <span class="hljs-number">1</span>;        
        &#125; 
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = -sum;j &lt;= sum;j++)
        &#123;
           <span class="hljs-keyword">if</span>(j+nums[i] &lt;= sum &amp;&amp; j-nums[i]&gt;=-sum)
                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j-nums[i]+sum] + dp[i<span class="hljs-number">-1</span>][j+nums[i]+sum];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j-nums[i]&gt;=-sum)
                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j-nums[i]+sum];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j+nums[i]&lt;=sum)
                dp[i][j+sum] = dp[i<span class="hljs-number">-1</span>][j+nums[i]+sum];
            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j+sum]&lt;&lt;endl;</span>
        &#125;
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][S+sum];
    &#125;
&#125;;</code></pre>
<p>时间复杂度:$O(1)$, 因为题目已经告诉了具体范围不超过$O(20*2000)=O(40000)$,所以时间复杂度是常数.</p>
<p>空间复杂度:$O(N(2sum+1))$, 这里的$N$表示数组大小, $sum$表示数组之和. </p>
<p>同类题目还有416. 分割等和子数组.</p>
<hr>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/25/2020-07-25-how-Unordered_map-support-pair-as-key/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++ 如何让Unordered_map支持pair作为键值</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/21/2020-08-1-representation_of_graph/">
                        <span class="hidden-mobile">爸爸再也不想做图类题目了</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "做一只可爱的小🐖背包 Cover「背包九讲」&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
