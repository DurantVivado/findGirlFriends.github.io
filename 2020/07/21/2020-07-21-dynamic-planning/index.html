

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="博主：来自华中科技大学国家光电研究中心的">
  <meta name="author" content="Durant">
  <meta name="keywords" content="">
  <title>动态规划 - Durant Thorvalds 的米奇妙妙屋</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-21 00:00" pubdate>
        星期二, 七月 21日 2020, 12:00 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      103
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">动态规划</h1>
            
            <div class="markdown-body" id="post-body">
              <blockquote>
<p>动态规划(DP)的重要性我就不用说了，<code>LeetCode</code> 上DP问题多达228道，仅次于数组301题。</p>
<p>个人感觉，DP问题就像斐波那契数列一样，你需要找到能够递归的通式子，我们把这个式子称作<strong>状态转移方程</strong>（$transfer  eqution$）。本文采取题目加讲解的方式，中等题目强调找出状态转移方程，难题则附加代码研究细节，此篇可作为你刷DP类问题的指南。</p>
</blockquote>
<p>然后，现在我们干一件事情，把DP题目罗列出来，找到共同点，未来我们要做到看一眼题目就知道用什么方法。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a> (Easy)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a> (Easy)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a>(Easy)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径2</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的搜索二叉树</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a>(medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">最大字序和</a>(Easy)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/solution/">单词拆分</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares">完全平方数</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大和</a>(Hard)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a>(Hard)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a>(Hard)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a>(Hard)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-boxes">移除盒子</a>(Hard)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-all-possible-routes/">统计所有可能路径</a>(Hard)</li>
</ol>
<p>配合<a target="_blank" rel="noopener" href="http://zxi.mytechroad.com/blog/leetcode-problem-categories/?from=singlemessage">Huahua’s problem set</a>. 食用更佳！</p>
<hr>
<p>下面结合实例分析</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h2><p>非常经典！</p>
<p>用$dp[i]$表示爬上第i个梯子的方法数。那么<br>状态转移方程 </p>
<script type="math/tex; mode=display">
dp[i] = dp[i-1] + dp[i-2];</script><p>边界条件: $dp[0] = 1, dp[1]=1$</p>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>用$dp[i]$表示爬上第i个梯子的<code>最小</code>消耗。那么<br>状态转移方程 </p>
<script type="math/tex; mode=display">
dp[i] = min{dp[i-1] + cost[i-1], dp[i-2] + cost[i-1]};</script><p>边界条件: $dp[0] = 0, dp[1]=0$</p>
<p><strong>总结，这两题能这么做是因为，它们相邻两项的间距是恒定的要么为1，要么为2.</strong></p>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h2><blockquote>
<p>老dp了，还贪讷</p>
</blockquote>
<p>一眼看上去以为是跳跃游戏类似的贪心算法，没想到是老dp换了层皮。</p>
<p>以$dp[i]$表示前ii个元素中最大金额。<br>我们这样想，第$i-1$个元素$nums[i-1]$是否取到取决于前面一个元素是否取，如果前一个元素不取就是$dp[i-2]+nums[i-1]$，如果前一个元素取到就是$dp[i-1]$。</p>
<p>边值条件$dp[0]=0,dp[1]=nums[0]$，注意下标对应关系。</p>
<hr>
<p>再看跟路径有关的问题</p>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h2><p>用$dp[i][j]$表示从原点到达(m,n)的<code>最小</code>路径和。那么<br>状态转移方程 </p>
<script type="math/tex; mode=display">
dp[i][j] = min(dp[i][j-1], dp[i-1][j])+grid[i][j];</script><p>边界条件: </p>
<script type="math/tex; mode=display">
dp[0][i] = dp[0][i-1] + grid[0][i](0 \le{i}\le{m}), 
\\
dp[j][0] = dp[j-1][0] + grid[j][0](0 \le{j}\le{n})</script><p>这题很特殊的地方是，先求完边界条件才能进行DP操作。</p>
<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h2><p>这题和上一题的区别是，不用管路径开销，这样的话我们可以把路径都设为1。</p>
<p>用$dp[i][j]$表示从原点到达(m,n)的<code>不同</code>路径数目。那么<br>状态转移方程 </p>
<script type="math/tex; mode=display">
dp[i][j] = dp[i][j-1]+ dp[i-1][j];</script><p>边界条件: </p>
<script type="math/tex; mode=display">
dp[0][i] = 1(0 \le{i}\le{m}), 
\\
dp[j][0] = 1(0 \le{j}\le{n})</script><h2 id="63-不同路径2"><a href="#63-不同路径2" class="headerlink" title="63. 不同路径2"></a>63. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径2</a></h2><p>用$dp[i][j]$表示从<code>原点</code>到$(i,j)$的路径总数，只不过这题玩了一点花样，加入障碍物，和<code>62</code>异曲同工。上一题我们把边界，包括上边界和左边界，都设为1。这一题，我们想如果遇到障碍物在$(i,j)$，那么肯定$dp[i][j]=0$对吧？然后对于边界，一旦$dp[0][j]==0或dp[i][0]==0$表明，之后的全到不了，因为上左边界分别只有一条路径。</p>
<script type="math/tex; mode=display">
dp[i][j]=\left\{
\begin{array}{lcl}
dp[i-1][j]+dp[i][j-1],       & {obstacleGrid[i][j]!=1}\\
0,     & {obstacleGrid[i][j]==1}\\
\end{array} \right.</script><blockquote>
<p>边界</p>
<script type="math/tex; mode=display">
dp[0][j] =\left\{ 
\begin{array}{lcr}
 0, dp[0][j-1]!=0||obstacleGrid[0][j]==0\\
1, {dp[0][j-1]!=0}\\
\end{array} \right.\\
,
\\
dp[i][0] =\left\{ 
\begin{array}{lcr}
 0, {dp[i-1][0]==0||obstacleGrid[i][0]==0}\\
1, {dp[i-1][0]!=0}\\
\end{array} \right.</script></blockquote>
<p><strong>总结，因为路径问题只能向下或向右走和爬楼梯的只能走一步或者两步都是异曲同工的，把状态转移方程和边界条件想出来有助于快速解决问题</strong></p>
<hr>
<blockquote>
<p>此外，涉及到求规律的问题，一般先列出几项再使用dp</p>
</blockquote>
<h2 id="96-不同的搜索二叉树"><a href="#96-不同的搜索二叉树" class="headerlink" title="96. 不同的搜索二叉树"></a>96. 不同的搜索二叉树</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<pre><code class="hljs angelscript">输入: <span class="hljs-number">3</span>
输出: <span class="hljs-number">5</span>
解释:
给定 n = <span class="hljs-number">3</span>, 一共有 <span class="hljs-number">5</span> 种不同结构的二叉搜索树:

   <span class="hljs-number">1</span>         <span class="hljs-number">3</span>     <span class="hljs-number">3</span>      <span class="hljs-number">2</span>      <span class="hljs-number">1</span>
    \       /     /      / \      \
     <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     <span class="hljs-number">1</span>      <span class="hljs-number">1</span>   <span class="hljs-number">3</span>      <span class="hljs-number">2</span>
    /     /       \                 \
   <span class="hljs-number">2</span>     <span class="hljs-number">1</span>         <span class="hljs-number">2</span>                 <span class="hljs-number">3</span></code></pre>
<script type="math/tex; mode=display">
f[i] = \begin{cases}
2×(f[i-1]+···+f[(i-1)/2])+f[i/2]^2,i\%2!=0\\
2×(f[i-1]+···+f[(i-1)/2])，otherwise\\
\end{cases}</script><hr>
<p>事实上我们在方法一中推导出的 $G(n)$函数的值在数学上被称为卡塔兰数 $C_n $</p>
<p> 。卡塔兰数更便于计算的定义如下:$C_0 = 1, \qquad C_{n+1} = {2(2n+1)}/{n+2}C_n$,证明过程可以参考上述文献，此处不再赘述。</p>
<blockquote>
<p>下面我们看一些富有技巧而实际很简单 的dp问题</p>
</blockquote>
<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<pre><code class="hljs angelscript">输入: 
<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>
<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>
<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>
<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>
输出: <span class="hljs-number">4</span></code></pre>
<hr>
<p>可以使用动态规划降低时间复杂度。我们用 $dp(i, j)$ 表示以 $(i, j)$ 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 $dp(i, j)$的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>
<p>那么如何计算 dp 中的每个元素值呢？对于每个位置$(i, j)$,检查在矩阵中该位置的值：</p>
<p>如果该位置的值是 0，则 $dp(i,j)=0$，因为当前位置不可能在由 1 组成的正方形中；</p>
<p>如果该位置的值是 1，则 $dp(i, j)$ 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>
<script type="math/tex; mode=display">
dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</script><p>形子矩阵的官方题解，其中给出了详细的证明。</p>
<p>此外，还需要考虑边界条件。如果 $i$ 和 $j$ 中至少有一个为 $0$，则以位置 $(i,j)$ 为右下角的最大正方形的边长只能是 1，因此 $dp(i, j) = 1$。</p>
<blockquote>
<p>扩展85.最大矩形(Hard)<br>1277.统计全为1的正方形子矩阵</p>
</blockquote>
<hr>
<h2 id="53-最大字序和"><a href="#53-最大字序和" class="headerlink" title="53. 最大字序和"></a>53. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">最大字序和</a></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code class="hljs angelscript">示例:

输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]
输出: <span class="hljs-number">6</span>
解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。</code></pre>
<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<hr>
<p>一般人思路是暴力法，我承认，这的确很舒服，但是告诉你有$O(n)$的方法，你会怎么想呢。</p>
<p>用$dp[i]$，如何表示才具有可行性。刚开始想的是序号从$0-n-1$的最大字序和。后来发现存在$dp[i-1]与nums[i-1]$断开的情况，而且中间的和一定不大于0. 官解给的是 <em>以第i个数结尾的连续数组最大和。</em>也就是不存在断开的情况。妙，实在是妙！</p>
<script type="math/tex; mode=display">
dp[i] = max(dp[i-1]+nums[i-1],num[i-1])</script><p>max里面前者表示存在新的后续元素使之更大，后者是新元素比原来的和更大。</p>
<blockquote>
<p> 边界条件：</p>
</blockquote>
<p>$dp[0] = 0$</p>
<p>此外还可以用滚动数组降低空间复杂度。</p>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p>
<pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]
输出: <span class="hljs-literal">true</span>
解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。</code></pre>
<hr>
<p>这一题可以正好填补一些我们思路上的空白。即，动态规划的迭代并不一定是连续的，很有可能存在跳跃。</p>
<p>用$dp[i]$表示s前i个字符能否由字典中单词组成。那么$dp[i]=dp[j] \text{and}  dict.check(s.substr(j,i-j));$，check在这里检查$s[j:i-1]$与字典中某一个单词匹配。初始条件为$dp[0]=true$空字符一定匹配，实际上，dp中大部分元素都是$false$。</p>
<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">4</span>]
输出: <span class="hljs-number">6</span>
解释: 子数组 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 有最大乘积 <span class="hljs-number">6</span>。
</code></pre>
<p>示例 2:</p>
<pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>]
输出: <span class="hljs-number">0</span>
解释: 结果不能为 <span class="hljs-number">2</span>, 因为 [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>] 不是子数组。</code></pre>
<hr>
<p>这道题我们很容易陷入惯性思维，与最大子序和相似，我们可以设定$dp[i]$为以$nums[i-1]$为末尾的最大乘积，很容易知道 </p>
<script type="math/tex; mode=display">
dp[i]=max\{dp[i-1]*nums[i-1],nums[i-1]\}</script><p>但是这一题与53不同的是，负负得正，比如$[-9,1,-8]$得到最大和是72而不是1. 所以我们需要分类讨论，$num[i-1]$正负性，还要设计一个求最小积的$mdp[i]$，与求最大积$Mdp[i]$相对，具体如下：</p>
<script type="math/tex; mode=display">
Mdp=\begin{cases}
    \max\{Mdp[i-1]*nums[i-1],nums[i-1]\},nums[i-1]>0\\
    \max\{mdp[i-1]*nums[i-1],nums[i-1]\},otherwise\\
    \end{cases}\\
    \\
    \\

    \\
mdp=\begin{cases}
    \min\{mdp[i-1]*nums[i-1],nums[i-1]\},nums[i-1]>0\\
    \min\{Mdp[i-1]*nums[i-1],nums[i-1]\},otherwise\\
    \end{cases}</script><p>初始条件$mdp[1]=nums[0],Mdp[1]=nums[0].$</p>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<pre><code class="hljs angelscript">输入: n = <span class="hljs-number">12</span>
输出: <span class="hljs-number">3</span> 
解释: <span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4.</span>
</code></pre>
<p>示例 2:</p>
<pre><code class="hljs angelscript">输入: n = <span class="hljs-number">13</span>
输出: <span class="hljs-number">2</span>
解释: <span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9.</span></code></pre>
<hr>
<p>这个例子表明dp算法可以和其它算法结合在一起，比如贪心算法。</p>
<p>我们设$minSquare(i)$表示数字$i$对应的最小完全平方数数目，那么：</p>
<script type="math/tex; mode=display">
minSquare(i) = \min\limits_{1\le k < i}(minSqaure(i-k)+1)</script><p>但其实我们并不需要全部计算出$minSquare(i-k)$的值，因为中间结果可能出现$minSquare(i-k)$，因此我们可以采用哈希表加速。</p>
<blockquote>
<p>边界条件：minSquare(0)=0; // 注意这个条件是虚构的</p>
</blockquote>
<p>我们先找到小于n的所有完全平方数然后从1开始到n，找到最小数。</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$\mathcal{O}(n\cdot\sqrt{n})$，在主步骤中，我们有一个嵌套循环，其中外部循环是 $n$ 次迭代，而内部循环最多需要 $\sqrt{n}$ 迭代。</li>
<li>空间复杂度：$\mathcal{O}(n)$，使用了一个一维数组 dp。</li>
</ul>
<hr>
<blockquote>
<p>下面我们看一些复杂的DP问题。</p>
</blockquote>
<h2 id="410-分割数组的最大和"><a href="#410-分割数组的最大和" class="headerlink" title="410. 分割数组的最大和"></a>410. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大和</a></h2><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p>
<p>注意:<br>数组长度 n 满足以下条件:</p>
<ul>
<li>1 ≤ n ≤ 1000</li>
<li>1 ≤ m ≤ min(50, n)</li>
</ul>
<p>示例:<br><pre><code class="hljs angelscript">输入:
nums = [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]
m = <span class="hljs-number">2</span>

输出:
<span class="hljs-number">18</span>

解释:
一共有四种方法将nums分割为<span class="hljs-number">2</span>个子数组。
其中最好的方式是将其分为[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] 和 [<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]，
因为此时这两个子数组各自的和的最大值为<span class="hljs-number">18</span>，在所有情况中最小。</code></pre></p>
<hr>
<p><code>将数组分割为m段，求...</code>是动态规划的常见问法。</p>
<p>我们可以令$dp[i][j]$表示数组前$i$个数分割为$j$段，所能得到最大连续子数组和的最小值，我们可以考虑第$j$段的具体范围，即我们可以枚举$k$，将前$k$个数分割为$j-1$段，而第$k+1$到第$i$个数为第$j$段，此时，这$j$段数组中和的最大值等于$dp[k][j-1]$与$sum(k+1,i)$中和的较大值，其中$sum(a,b)$表示$nums[i]在[a,b]$的范围和。</p>
<p>状态转移方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=\min\limits_{k=0}^{i-1}(\max(dp[k][j-1],\sum\limits_{k+1}^i{nums[i]})</script><p>边界条件:</p>
<script type="math/tex; mode=display">
dp[0][0] = 0;</script><p>时间复杂度: $O(n^2m)$,其中$n$是数组长度，$m$是分成非空的连续子数组个数，总状态数$O(n×m)$,状态转移时间$O(n)$。<br>空间复杂度：$O(n×m)$为动态规划数组开销。</p>
<blockquote>
<p>“我🤮饱了，后面还有吗” </p>
<p>“当然”</p>
</blockquote>
<p>下面介绍一下字符串中的dp解法，比如10. 正则表达式匹配 和 44. 通配符匹配。 都是很经典的dp。 寥寥几句足以把超复杂的可能性涵盖其中，真让人不尽感叹造物主的鬼斧神工。</p>
<h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<pre><code class="hljs 1c">&#x27;.&#x27; 匹配任意单个字符
&#x27;*&#x27; 匹配零个或多个前面的那一个元素</code></pre>
<p>所谓匹配，是要涵盖 整个字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>
<pre><code class="hljs makefile"><span class="hljs-section">输入:</span>
s = <span class="hljs-string">&quot;aa&quot;</span>
p = <span class="hljs-string">&quot;a&quot;</span>
<span class="hljs-section">输出: false</span>
<span class="hljs-section">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span></code></pre>
<p>示例 2:</p>
<pre><code class="hljs smalltalk">输入:
s = <span class="hljs-comment">&quot;aa&quot;</span>
p = <span class="hljs-comment">&quot;a*&quot;</span>
输出: <span class="hljs-keyword">true</span>
解释: 因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-comment">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。</code></pre>
<p>示例 3:</p>
<pre><code class="hljs makefile"><span class="hljs-section">输入:</span>
s = <span class="hljs-string">&quot;ab&quot;</span>
p = <span class="hljs-string">&quot;.*&quot;</span>
<span class="hljs-section">输出: true</span>
<span class="hljs-section">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span></code></pre>
<p>示例 4:</p>
<pre><code class="hljs smalltalk">输入:
s = <span class="hljs-comment">&quot;aab&quot;</span>
p = <span class="hljs-comment">&quot;c*a*b&quot;</span>
输出: <span class="hljs-keyword">true</span>
解释: 因为 <span class="hljs-string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="hljs-string">&#x27;c&#x27;</span> 为 <span class="hljs-number">0</span> 个, <span class="hljs-string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="hljs-comment">&quot;aab&quot;</span>。</code></pre>
<p>示例5<br><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>
s = <span class="hljs-string">&quot;mississippi&quot;</span>
p = <span class="hljs-string">&quot;mis*is*p*.&quot;</span>
<span class="hljs-section">输出: false</span></code></pre></p>
<hr>
<p>我们用 $dp[i][j]$ 表示 s 的前 i 个字符与 pp 中的前 j 个字符是否能够匹配。在进行状态转移时，我们考虑 pp 的第 jj 个字符的匹配情况：</p>
<ul>
<li>如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s 中匹配一个相同的小写字母，即<script type="math/tex; mode=display">
dp[i][j] =  (s[i-1]==p[j-1] \&\& dp[i-1][j-1]</script></li>
</ul>
<p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 ss 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p>
<ul>
<li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</p>
</li>
<li><p>不匹配字符，将该组合扔掉，不再进行匹配。</p>
</li>
</ul>
<p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=\left\{
\begin{array}{lcr}
dp[i-1][j]||dp[i][j-2],\ s[i]==p[j-1]
\\
dp[i][j-2],\ s[i]\ne p[j-1]
\end{array}
\right.</script><ul>
<li>在任意情况下，只要 $p[j]$ 是<code>.</code>，那么 $p[j]$ 一定成功匹配 ss 中的任意一个小写字母。</li>
</ul>
<p>最终的状态转移方程如下：</p>
<script type="math/tex; mode=display">
dp[i][j] = 
\begin{cases}
\text{if}\ (p[j]\ne '*')=\begin{cases}
dp[i-1][j-1], matches(s[i],p[j]) \\
false, \ otherwise
\end{cases}
\\
\\
otherwise = \begin{cases}
dp[i-1][j]\ || \ dp[i][j-2], matches(s[i],p[j-1])
\\
dp[i][j-2], otherwise
\end{cases}
\end{cases}</script><p>其中$\textit{matches}(x, y)$ 判断两个字符是否匹配的辅助函数。只有当 y 是 <code>.</code> 或者 x 和 y 本身相同时，这两个字符才会匹配。</p>
<blockquote>
<p> 细节</p>
</blockquote>
<p>动态规划的边界条件为 $ dp[0][0] = true $，即两个空字符串是可以匹配的。最终的答案即为 $dp[m][n]$，其中 m和 n 分别是字符串 s 和 p 的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。</p>
<p>在上面的状态转移方程中，如果字符串 p 中包含一个字符+星号的组合（例如 $a<em>$），那么在进行状态转移时，会先将 a 进行匹配（当 $p[j]$ 为 a 时），再将 a</em> 作为整体进行匹配（当 $p[j]$ 为 <em> 时）。然而，在题目描述中，我们必须将 a</em> 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。</p>
<p>C++代码</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>&#123;
        <span class="hljs-keyword">int</span> m = s.size();
        <span class="hljs-keyword">int</span> n = p.size();

        <span class="hljs-keyword">auto</span> matches = [&amp;](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123;
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
            <span class="hljs-keyword">return</span> s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>];
        &#125;;

        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;
        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;
                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;
                    f[i][j] |= f[i][j - <span class="hljs-number">2</span>];
                    <span class="hljs-keyword">if</span> (matches(i, j - <span class="hljs-number">1</span>)) &#123;
                        f[i][j] |= f[i - <span class="hljs-number">1</span>][j];
                    &#125;
                &#125;
                <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">if</span> (matches(i, j)) &#123;
                        f[i][j] |= f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> f[m][n];
    &#125;
&#125;;
</code></pre>
<hr>
<h1 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a>44. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h1><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<pre><code class="hljs C++"><span class="hljs-string">&#x27;?&#x27;</span> 可以匹配任何单个字符。
<span class="hljs-string">&#x27;*&#x27;</span> 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。</code></pre>
<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ul>
<hr>
<p>我们用$dp[i][j]$表示s的第$i$个字符与p的第$j$个字符是否匹配。</p>
<ul>
<li><p>第一种情况是字母与字母匹配，即</p>
<script type="math/tex; mode=display">
dp[i][j] =  (s[i-1]==p[j-1] \&\& dp[i-1][j-1])</script></li>
<li><p>第二种情况是$p[j]$是问好，则对$s[i]$没有任何要求</p>
<script type="math/tex; mode=display">
dp[i][j] = (p[j-1]=='?'\&\&dp[i-1][j-1])</script></li>
<li><p>第三种情况，是遇到$’’*’’$，这种情况最为复杂，因为不知道星号要匹配多少个字符，这里很容易想到<code>回溯</code>方法，但是回溯一般会超时，著名的KMP算法是因为了避免回溯才会那么快。</p>
<p>所以我们想这个星号可以使用多次，也可以一次都不使用。</p>
<script type="math/tex; mode=display">
dp[i][j] = dp[i-1][j]||dp[i][j-1]</script><p>后面一项表示不使用星号，前面一项表示使用星号。</p>
<p>总结一下：</p>
<script type="math/tex; mode=display">
dp[i][j]=\left\{
\begin{array}{lcr}
s[i-1]==p[j-1] \&\& dp[i-1][j-1]，'a-z'
\\
p[j-1]=='?'\&\&dp[i-1][j-1],'?'
\\
dp[i-1][j]||dp[i][j-1], '*'
\end{array}
\right.</script></li>
</ul>
<blockquote>
<p>边界条件：</p>
<p>也就是$dp[0][0]$，我们不能单纯认为开始两个字符相等就是$dp[0][0]==True$。因为$p$有星号和问号开头的情况。<br>$dp[0][0]=(s[0]==p[0])||(p[0]==’?’)||(p[0]==’*’)$</p>
</blockquote>
<ol>
<li><p>若两个字符串为空，$dp[0][0]$也为True.</p>
<script type="math/tex; mode=display">dp[i][0]=!s.size()</script><p>即空字符串无法匹配非空字符串。</p>
</li>
<li><p>若s为空，p全为”*”，才能完成匹配。</p>
<script type="math/tex; mode=display">
dp[0][j] = (p[j]=='*')\&\&dp[0][j-1]</script></li>
</ol>
<p>我们可以发现，$dp[i][0]$的值恒为假，$dp[0][j]$ 在 $j$ 大于模式 $p$ 的开头出现的星号字符个数之后，值也恒为假，而 $dp[i][j]$ 的默认值（其它情况）也为假，因此在对动态规划的数组初始化时，我们就可以将所有的状态初始化为 False，减少状态转移的代码编写难度。</p>
<p>此外还要考虑字符串的硬边界。此外，<strong>注意</strong>下标对$dp[i][j]$表示$s[i-1]$与$p[j-1]$匹配，因为下标是从0开始的。</p>
<p>Python 实现：</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">self, s: str, p: str</span>) -&gt; bool:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> s: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> p: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> 
        
    m = len(s); n = len(p)
    dp = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>) ]
    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>) <span class="hljs-keyword">or</span> (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">or</span> (s <span class="hljs-keyword">and</span> s[<span class="hljs-number">0</span>]==p[<span class="hljs-number">0</span>]) 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):
        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">not</span> len(s)
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):
        dp[<span class="hljs-number">0</span>][j] = (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">and</span> dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):
            dp[i][j] = (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> \
                        (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">and</span> dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) <span class="hljs-keyword">or</span> \
                        (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-keyword">and</span> (dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-keyword">or</span> dp[i][j<span class="hljs-number">-1</span>]))
            print(<span class="hljs-string">&quot;(%d,%d):&quot;</span>%(i,j),dp[i][j])
    <span class="hljs-keyword">return</span> dp[m][n]</code></pre>
<p>C++实现：</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span> (!p.size() &amp;&amp; s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (!s.size() &amp;&amp; !p.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">int</span> m = s.size(), n = p.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>))</span></span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)||(p[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;*&#x27;</span>)||(s.size()&amp;&amp;s[<span class="hljs-number">0</span>]==p[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++) dp[i][<span class="hljs-number">0</span>] = !s.size();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++) dp[<span class="hljs-number">0</span>][j] = (p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;*&#x27;</span>) &amp;&amp; dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m+<span class="hljs-number">1</span>; i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; j++)
        dp[i][j] = (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) || \
                            (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) || \
                            (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; (dp[i<span class="hljs-number">-1</span>][j] || dp[i][j<span class="hljs-number">-1</span>]));
        <span class="hljs-keyword">return</span> dp[m][n];            
    &#125;
&#125;;</code></pre>
<p>明显是C++要快些()，嘻嘻😂，而且内存占用要小些</p>
<p>老规矩，下面分析时间复杂度和空间复杂度.</p>
<p>时间复杂度：$O(MN)$</p>
<p>空间复杂度:$O(NM)$ $N和M$分别表示目标串和模式串的长度。我们可以使用<code>滚动数组</code>对空间进行优化，即用两个长度为 $n+1$ 的一维数组代替整个二维数组进行状态转移，空间复杂度为$ O(n)$。</p>
<p>当然这题也有贪心解法，有兴趣的小伙伴可以研究一下。</p>
<hr>
<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h1><p>这一题在LC上属于难题分类，但实际上通过率高达59.6%，是一道名副其实的<code>Easy</code>题。</p>
<p>但是我们想说的dp千变万化，不离其宗。题目做多了自然就有想法了。</p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<hr>
<p>我们用$dp[i][j]$表示word1前i个字符转换为word2前j个字符所需的<code>最小</code>操作数。 </p>
<p>然后在word1插入一个字符相当于$dp[i][j]=dp[i-1][j]+1$，一定会多出来一个步骤。</p>
<p>然后在word1删除一个字符相当于$dp[i][j]=dp[i][j-1]+1$，也一定会多出来一个步骤。</p>
<p>如果word1最后一个字符通过替换得到word2，那么要分情况，如果最后一个字符相同，那么$dp[i][j]=dp[i-1][j-1]$，否则$dp[i][j]=dp[i-1][j-1]+1$.</p>
<blockquote>
<p>边界条件 $dp[0][j] = j,dp[i][0]=i$</p>
</blockquote>
<p>就是完全的删除或者完全插入。</p>
<p><strong>代码</strong></p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">string</span> word2)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!word1.size()) <span class="hljs-keyword">return</span> word2.size();
        <span class="hljs-keyword">if</span>(!word2.size()) <span class="hljs-keyword">return</span> word1.size();
        <span class="hljs-comment">//dp[i][j]表示word1的前i位替换为word2前i位所需的最小步数</span>
        <span class="hljs-keyword">int</span> m = word1.size(), n = word2.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>))</span></span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (word1[<span class="hljs-number">0</span>]==word2[<span class="hljs-number">0</span>])? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=m ;i++) dp[i][<span class="hljs-number">0</span>] = i;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ;j++) dp[<span class="hljs-number">0</span>][j] = j;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=m; i++ )
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++ )
        &#123;
            <span class="hljs-keyword">int</span> exchange = (word1[i<span class="hljs-number">-1</span>]==word2[j<span class="hljs-number">-1</span>])?dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]:dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;
            dp[i][j] = min(exchange, min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>));
        &#125;
        <span class="hljs-keyword">return</span> dp[m][n];
    &#125;
&#125;;</code></pre>
<blockquote>
<p>小伙伴如果有收获，请点赞留言哦Σ(っ °Д °;)っ</p>
</blockquote>
<hr>
<h4 id="5494-统计所有可行路径"><a href="#5494-统计所有可行路径" class="headerlink" title="5494. 统计所有可行路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-all-possible-routes/">5494. 统计所有可行路径</a></h4><p>给你一个 互不相同 的整数数组，其中 locations[i] 表示第 i 个城市的位置。同时给你 start，finish 和 fuel 分别表示出发城市、目的地城市和你初始拥有的汽油总量</p>
<p>每一步中，如果你在城市 i ，你可以选择任意一个城市 j ，满足  j != i 且 0 &lt;= j &lt; locations.length ，并移动到城市 j 。从城市 i 移动到 j 消耗的汽油量为 |locations[i] - locations[j]|，|x| 表示 x 的绝对值。</p>
<p>请注意， fuel 任何时刻都 不能 为负，且你 可以 经过任意城市超过一次（包括 start 和 finish ）。</p>
<p>请你返回从 start 到 finish 所有可能路径的数目。</p>
<p>由于答案可能很大， 请将它对 10^9 + 7 取余后返回。</p>
<p>示例 1：</p>
<pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>], start = <span class="hljs-number">1</span>, finish = <span class="hljs-number">3</span>, fuel = <span class="hljs-number">5</span>
输出：<span class="hljs-number">4</span>
解释：以下为所有可能路径，每一条都用了 <span class="hljs-number">5</span> 单位的汽油：
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span>
</code></pre>
<p>示例 2：</p>
<pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], start = <span class="hljs-number">1</span>, finish = <span class="hljs-number">0</span>, fuel = <span class="hljs-number">6</span>
输出：<span class="hljs-number">5</span>
解释：以下为所有可能的路径：
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">1</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">3</span>
<span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span>，使用汽油量为 fuel = <span class="hljs-number">5</span></code></pre>
<p>示例 3：</p>
<pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">2</span>, fuel = <span class="hljs-number">3</span>
输出：<span class="hljs-number">0</span>
解释：没有办法只用 <span class="hljs-number">3</span> 单位的汽油从 <span class="hljs-number">0</span> 到达 <span class="hljs-number">2</span> 。因为最短路径需要 <span class="hljs-number">4</span> 单位的汽油。</code></pre>
<p>示例 4 ：</p>
<pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">0</span>, fuel = <span class="hljs-number">3</span>
输出：<span class="hljs-number">2</span>
解释：总共有两条可行路径，<span class="hljs-number">0</span> 和 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span> 。
</code></pre>
<p>示例 5：</p>
<pre><code class="hljs angelscript">输入：locations = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], start = <span class="hljs-number">0</span>, finish = <span class="hljs-number">2</span>, fuel = <span class="hljs-number">40</span>
输出：<span class="hljs-number">615088286</span>
解释：路径总数为 <span class="hljs-number">2615088300</span> 。将结果对 <span class="hljs-number">10</span>^<span class="hljs-number">9</span> + <span class="hljs-number">7</span> 取余，得到 <span class="hljs-number">615088286</span> 。
</code></pre>
<p>提示：</p>
<ul>
<li><code>2 &lt;= locations.length &lt;= 100
1 &lt;= locations[i] &lt;= 10^9
所有 locations 中的整数 互不相同 。
0 &lt;= start, finish &lt; locations.length
1 &lt;= fuel &lt;= 200</code></li>
</ul>
<hr>
<p>此题乃背包问题的变形。背包内有一些物品，拿相邻两个物品需要时间，这个时间取决于它们的重量差，一共给你<code>fuel</code>时间，问开始拿<code>start</code>物品，最后拿<code>finsih</code>物品有多少种可行方案。</p>
<p>老规矩，<strong>动态规划</strong>和<strong>记忆化搜索</strong>都能做。</p>
<p><strong>动态规划</strong></p>
<p>设$dp[i][f]$表示从起点到达第$i$个城市<strong>刚好消耗f个汽油</strong>的可行路径数。这里强调刚好是把问题变成离散化。刚开始容易想成最多消耗f汽油。这样做的问题是，会产生大量重复解。而刚好消耗则把总的汽油数进行恰当分解，得到结果唯一。</p>
<ul>
<li>状态转移方程：$dp[i][f] = dp[i][f] + dp[j][f-cost[i,j]]$</li>
</ul>
<p>这里的$cost[i,j]$表示从第$i$个城市到第$j$个城市消耗的汽油，即$abs(locations[i]-locations[j])$。</p>
<blockquote>
<p>这里不是max而是+=的形式，想一想为什么。因为我们从起点到$j$城市的路径数知道了，接下来是求$j-&gt;i$的路径数。且保证汽油消耗刚好为$f$。此时$j-&gt;i$路径数是$1$,因为是直达。严格意义上讲，(start-&gt;j-&gt;i)路径数为$1*dp[j][cost[i,j]]$，是相乘的关系。然后可能有别的路径所以把这些相加，即得到总的路径数。</p>
</blockquote>
<ul>
<li><p>初始化条件：$dp[start][0]=1$ ，需要注意的是很容易把从初始到每个城市的路径数初始化为1. 这样做会造成重复。我们在进行状态转移时，就会考虑这些情况。</p>
</li>
<li><p>循环条件：</p>
</li>
</ul>
<p>$i,j$两个城市是并列关系，只要两个城市互不相同就可以访问，且可以重复访问，不管是否到达终点，所以我们<strong>考虑消耗汽油为$f$前提下</strong>，从起点到$i$可行路径数。把汽油数作为最外层循环，否则城市将不能循环访问！</p>
<ul>
<li>求解目标：</li>
</ul>
<p>我们最终求解，$\sum\limits_{i} dp[finish][f_i]$</p>
<ul>
<li><p>细节，由于dp中间结果可能非常大，每做一次状态转移都要取模。</p>
</li>
<li><p>代码实现：</p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
    ll mod = <span class="hljs-number">1E9</span>+<span class="hljs-number">7</span>;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res;
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRoutes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span> </span>&#123;
        
        <span class="hljs-comment">//老思路dp, 不过这里的节点可以反复遍历，直到汽油耗光为止,可以转化为完全背包</span>
        <span class="hljs-keyword">int</span> n = locations.size();
        res = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//dp[i][f]表示从起点到第i城市刚好消耗f燃料的可行路径数。</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &gt;(fuel+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))</span></span>;
        <span class="hljs-comment">//初始条件</span>
        dp[start][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
       	<span class="hljs-comment">//状态转移</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt;= fuel; f++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)
        <span class="hljs-keyword">if</span>(j!=i)
        &#123;
        <span class="hljs-keyword">int</span> cost = <span class="hljs-built_in">abs</span>(locations[i]-locations[j]);
        <span class="hljs-keyword">if</span>(f &gt;= cost) 
        &#123; 
            dp[i][f] +=  dp[j][f-cost] ; 
            dp[i][f] %= mod;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d-&gt;%d,cost:%d,dp:%d\n&quot;</span>,start,j,i,cost,dp[i][f]);
        &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt;= fuel ;f++) 
        <span class="hljs-keyword">if</span>(dp[finish][f])
        &#123;
            res += dp[finish][f];
            res %= mod;
        &#125;
        <span class="hljs-keyword">return</span> res%mod;
    &#125;
&#125;;</code></pre>
<ul>
<li>时间复杂度：$O(N^2*f)$. $N$为城市数，$f$为总汽油量</li>
<li>空间复杂度:   $O(N*f)$.</li>
</ul>
</li>
</ul>
<p><strong>记忆化搜索</strong></p>
<p>根据题目给的数据范围，数组长度不太大,<code>fuel</code>不太大，判断记忆化搜索可行。</p>
<p><code>2 &lt;= locations.length &lt;= 100
1 &lt;= locations[i] &lt;= 10^9
所有 locations 中的整数 互不相同 。
0 &lt;= start, finish &lt; locations.length
1 &lt;= fuel &lt;= 200</code></p>
<pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">205</span>];
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span></span>&#123;
        <span class="hljs-comment">//返回从start到finish的可行路径数</span>
        <span class="hljs-keyword">if</span>(dp[start][fuel] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[start][fuel];
        ll ans = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> len = locations.size();
        <span class="hljs-keyword">if</span>(start == finish) ans++;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;
            <span class="hljs-keyword">int</span> diff = <span class="hljs-built_in">abs</span>(locations[i] - locations[start]);
            <span class="hljs-keyword">if</span>(start == i) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span>(fuel - diff &gt;= <span class="hljs-number">0</span>)&#123;
                ans = (ans + dfs(locations, i, finish, fuel - diff)) % MOD;
            &#125;
        &#125;
        dp[start][fuel] = (ans % MOD);
        <span class="hljs-keyword">return</span> dp[start][fuel];
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRoutes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; locations, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">int</span> fuel)</span> </span>&#123;
        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-keyword">return</span> dfs(locations, start, finish, fuel);
    &#125;
&#125;;
</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/21/2020-8-20-what-is-Trie/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Google划词搜索的秘密</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/19/2020-07-19-damn_blog/">
                        <span class="hidden-mobile">Durant终于有个家写写东西了</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "动态规划&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
