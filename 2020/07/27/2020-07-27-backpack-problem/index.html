<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>背包问题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="做一只可爱的小🐖背包   推荐观看dd大牛：背包九讲的传送门, 「背包九讲」视频教程   0-1 背包       完全背包    多重背包 I II III  混合背包问题  二维费用的背包问题  分组背包问题  背包问题求解方案数  求背包问题的方案  有依赖的背包问题    I. 0-1背包问题 注意解空间极大问题有时可以转化0-1背包,从而避免TLE!  题目：有一个容量为 V 的背包，">
<meta property="og:type" content="article">
<meta property="og:title" content="背包问题">
<meta property="og:url" content="http://example.com/2020/07/27/2020-07-27-backpack-problem/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="做一只可爱的小🐖背包   推荐观看dd大牛：背包九讲的传送门, 「背包九讲」视频教程   0-1 背包       完全背包    多重背包 I II III  混合背包问题  二维费用的背包问题  分组背包问题  背包问题求解方案数  求背包问题的方案  有依赖的背包问题    I. 0-1背包问题 注意解空间极大问题有时可以转化0-1背包,从而避免TLE!  题目：有一个容量为 V 的背包，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png">
<meta property="article:published_time" content="2020-07-26T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-13T03:37:40.530Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2020-07-27-backpack-problem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/2020-07-27-backpack-problem/" class="article-date">
  <time datetime="2020-07-26T16:00:00.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      背包问题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="做一只可爱的小🐖背包"><a href="#做一只可爱的小🐖背包" class="headerlink" title="做一只可爱的小🐖背包"></a>做一只可爱的小🐖背包</h1><blockquote>
<p>  推荐观看dd大牛：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲的传送门</a>, <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av33930433">「背包九讲」视频教程</a></p>
<p>  0-1 背包    </p>
<blockquote>
<p> 完全背包</p>
</blockquote>
<blockquote>
<blockquote>
<p>多重背包 I II III</p>
</blockquote>
<p>混合背包问题</p>
<blockquote>
<p>二维费用的背包问题</p>
</blockquote>
<p>分组背包问题</p>
<blockquote>
<p>背包问题求解方案数</p>
</blockquote>
<p>求背包问题的方案</p>
<blockquote>
<p>有依赖的背包问题</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="I-0-1背包问题"><a href="#I-0-1背包问题" class="headerlink" title="I. 0-1背包问题"></a>I. 0-1背包问题</h2><blockquote>
<p><u><strong>注意</strong>解空间极大问题有时可以转化0-1背包,从而避免TLE!</u></p>
</blockquote>
<p>题目：有一个容量为 V 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">背包最大容量：50</span><br><span class="line">物品重量为：&#123;10,20,30,40,60&#125;</span><br><span class="line">物品价值为：&#123;1,3,5,7,9&#125;</span><br><span class="line">输出：8</span><br><span class="line">解释：当选择物品重量为20，30或者10，40对应的价值最大。</span><br></pre></td></tr></table></figure>

<p>我们适当作一些约定：$dp[i][j]或dp[j]$表示最大价值，$i$为具体问题下物品编号或组编号，$j$为体积。$W_i$为价值数组，$V_i$为体积数组。</p>
<p>$N$表示物品数量，$C$表示背包容积，$Q$表示背包最大重量。</p>
<p>0-1 背包问题中，物品只有两种状态，装载或者不装载，因此被称为<strong>0-1背包</strong>。除此之外还有<strong>完全背包</strong>和<strong>多重背包</strong>。</p>
<ol>
<li><strong>找子问题</strong>，第一，包的当前容量比物品小，装不下，这时的最大价值和前$$i-1$$个物品的最大价值是一样的。我们令$$dp[i][j]$$表示前$$i$$个物品在背包容量为$$j$$所能达到的最大价值。第二，包的当前可用容量比物品大，这个时候要决定是否添加下一个物品，因为在体积相同的情况下，总价值不一定更大。</li>
<li>找到<strong>状态转移方程</strong>，我们用辅助函数$sumWeight(i)$表示当前物品的总重量。</li>
</ol>
<p>$$<br>dp[i][j]=\begin{cases}<br>dp[i-1][j],\ sumWeight(i-1)+w[i-1]&gt;j<br>\<br>\max(dp[i-1][j-w[i-1]]+v[i-1], dp[i-1][j])，otherwise<br>\end{cases}<br>$$</p>
<ol start="3">
<li><p>确定<strong>边界条件</strong>：</p>
<p>$$dp[0][j]=0$$，不装物品时最大价值为0.，同理$$dp[i][0]=0$$，即背包容量为0时，最大价值也为0. </p>
</li>
</ol>
<p>时间复杂度：$$O(V<em>N)$$，状态数量为V</em>N, V为背包容量，N为物品数目，状态转移复杂度为$$O(1)$$。</p>
<p>空间复杂度：$$O(V*N)$$, 为dp数组大小。</p>
<blockquote>
<p>变式：要求完全装满背包。</p>
</blockquote>
<p>我们令$$dp[0][j]=0$$，不装物品时最大价值为0.，$$dp[0][j]=-\infin$$，这样的话，在$$dp[n][V]$$刚好大于0.</p>
<blockquote>
<p>优化：用一维数组表示</p>
</blockquote>
<p>因为dp的物品数量维度i，仅与前一项有关，因此可以优化。<u>为保证每个物品只能使用一次，我们倒序遍历所有的值，类似于贪心的思路，而反过来就变成了<strong>完全背包</strong>问题。想想为什么？</u><br>$$<br>dp[j] = \max(dp[j-w[i-1]]+v[i-1],dp[j])<br>$$<br>注意后面的dp[j]其实是上一次的结果，这相当于滚动数组。优化后空间复杂度为$$O(V)$$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span></span><br><span class="line">    <span class="keyword">int</span> N = val.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(V+<span class="number">1</span>)</span></span>; <span class="comment">//dp[j]表示容量为j的最大价值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= V;i++) dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= weight[i<span class="number">-1</span>];j--)</span><br><span class="line">        dp[j] = max(dp[j],dp[j-weight[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="II-完全背包问题"><a href="#II-完全背包问题" class="headerlink" title="II. 完全背包问题"></a>II. 完全背包问题</h2><p>我们让每种物品数量可以无限$$0-\infty$$。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">背包最大容量：60</span><br><span class="line">物品重量为：&#123;10,20,30,40,60&#125;</span><br><span class="line">物品价值为：&#123;1,2,5,7,8&#125;</span><br><span class="line">输出：10</span><br><span class="line">解释：当选择物品重量为两个30对应的价值最大。</span><br></pre></td></tr></table></figure>

<p>我们将上述优化算法由<strong>倒序遍历</strong>J变为<strong>正序遍历</strong>J即可实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span></span><br><span class="line">    <span class="keyword">int</span> N = val.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(V+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//dp[j]表示容量为j的最大价值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i<span class="number">-1</span>]; j &lt;= V;j++)</span><br><span class="line">    <span class="keyword">if</span>(dp[j-weight[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>]&gt;dp[j])</span><br><span class="line">    dp[j] = dp[j-weight[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="III-多重背包问题"><a href="#III-多重背包问题" class="headerlink" title="III. 多重背包问题"></a>III. 多重背包问题</h2><p>多重背包问题介于0-1背包和完全背包之间。</p>
<p>我们除了给出背包的最大容量，物品的体积V和价值W，还给出物品的最大数量S。</p>
<p><u>我们可以将多重背包问题转化为0-1背包，即将每种物品视为k种不同的物品</u>，这样的时间复杂度为$$O(s×\sum k_i)$$，由此可见，降低每件物品的数量可以大大降低其时间复杂度。我们运用一些tricky技巧，将原来数量为k的物品拆分为若干组，每组物品看成一件物品，其价值和重量为该组所有物品之和。$\color{red}{每组物品包含原物品数目分别为: 1,2,4···k-2^c+1}，其中k为使得k-2^c+1大于0的最大整数$.得到新的时间复杂度为$$O(s×\sum \log k_i)$$。</p>
<p><strong>二进制优化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//分别表示物品数量和背包容量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;<span class="comment">//用于分组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;object&gt; objects;</span><br><span class="line">    <span class="keyword">int</span> a,b,s,line = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k*=<span class="number">2</span>)</span><br><span class="line">        &#123;<span class="comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span></span><br><span class="line">            s -= k;</span><br><span class="line">            objects.push_back(&#123;k*b,k*a&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) objects.push_back(&#123;s*b,s*a&#125;);</span><br><span class="line">        line ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[C+<span class="number">1</span>];<span class="comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;object:objects)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= object.v;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">        <span class="comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单调队列优化(Hard)</strong></p>
<p><code>0&lt;N≤10000&lt;N≤1000 0&lt;V≤200000&lt;V≤20000 0&lt;vi,wi,si≤20000</code></p>
<p>当数据范围变得极大，使用二进制将<code>TLE</code>，我们必须优化，这里有一种优化方式是单调队列优化。</p>
<p>因为我们需要的是${ dp[j], dp[v+j], dp[2<em>v+j], dp[3</em>v+j], … , dp[k*v+j] }$ 中的最大值，我们通过维护一个单调队列来维护这些数中最大值。</p>
<p>单调队列问题，最重要的两点<br>1）维护队列元素的个数，如果不能继续入队，弹出队头元素<br>2）维护队列的单调性，即：$尾值 &gt;= dp[j + k<em>v] - k</em>w$</p>
<p>本题中，队列中元素的个数应该为 $s+1$ 个，即 $0 - s $个物品 $i$. 为了方便大家理解，我举例进行说明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N_MAX],pre[N_MAX],Q[N_MAX];<span class="comment">//分别表示物品数量和背包容量</span></span><br><span class="line"><span class="comment">//单调队列存的是体积，末尾存储最大价值。</span></span><br><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//物品数量和背包容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,s,l=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pre,dp,<span class="keyword">sizeof</span> dp);<span class="comment">//copy dp-&gt;pre</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; v;j++)</span><br><span class="line">        &#123;<span class="comment">//j是余数，即C%k</span></span><br><span class="line">            <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;<span class="comment">//队列头部和尾部</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j;k &lt;= C;k += v)</span><br><span class="line">            &#123;<span class="comment">// j+n*k==C</span></span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)</span><br><span class="line">                &#123;<span class="comment">//如果容量超过了S,则单调队列应该缩小 head++</span></span><br><span class="line">                <span class="keyword">if</span>((k-s*v) &gt; Q[head]) head++;</span><br><span class="line">                <span class="comment">//如果k对应价值大于头部价值，那么不断，相当于把体积插入到使得队列单增的位置，tail--</span></span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;(pre[k] - (k - j)/v*w) &gt;= (pre[Q[tail]] - (Q[tail] - j)/v*w)) tail--;</span><br><span class="line">                dp[k] = max(dp[k],pre[Q[head]] + (k-Q[head])/v*w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">                &#125;</span><br><span class="line">                Q[++tail] =  k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，笔者单调队列这里也不是很明白，需要再仔细讲究一下。</p>
<hr>
<h2 id="IV-混合背包"><a href="#IV-混合背包" class="headerlink" title="IV. 混合背包"></a>IV. 混合背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<ul>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 $s_i$ 次（多重背包）；</li>
</ul>
<p>每种体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 NN 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。</p>
<ul>
<li>$si=−1$ 表示第 $i$ 种物品只能用1次；</li>
<li>$si=0$ 表示第 $i$ 种物品可以用无限次；</li>
<li>$si&gt;0$ 表示第 $i$ 种物品可以使用 $si$ 次；</li>
</ul>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000<br>−1≤si≤1000$</p>
<blockquote>
<hr>
</blockquote>
<p>我们直接分类讨论，状态转移直接分为<strong>无限个</strong>和<strong>非无限</strong>即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//分别表示物品数量和背包容量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> kind;</span><br><span class="line">    <span class="keyword">int</span> w,v;<span class="comment">//用于分组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;object&gt; objects;</span><br><span class="line">    <span class="keyword">int</span> v,w,s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">-1</span>) objects.push_back(&#123;<span class="number">-1</span>,w,v&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>) objects.push_back(&#123;<span class="number">0</span>,w,v&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k*=<span class="number">2</span>)</span><br><span class="line">        &#123;<span class="comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span></span><br><span class="line">            s -= k;</span><br><span class="line">            objects.push_back(&#123;<span class="number">1</span>,k*w,k*v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) objects.push_back(&#123;<span class="number">1</span>,s*w,s*v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[C+<span class="number">1</span>];<span class="comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;object:objects)</span><br><span class="line">    <span class="keyword">if</span>(object.kind == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = object.v;k &lt;= C;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= object.v;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="V-二维费用的背包问题"><a href="#V-二维费用的背包问题" class="headerlink" title="V. 二维费用的背包问题"></a>V. 二维费用的背包问题</h2><p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p>
<p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N≤1000\<br>0&lt;V,M≤100\0&lt;v_i,m_i≤100\<br>0&lt;w_i≤1000$</p>
<p>其实非常容易进行扩展，将数组维度扩大，再加一层循环即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C,Q;<span class="comment">//分别表示物品数量，背包体积容量，背包最大重量</span></span><br><span class="line"><span class="keyword">int</span> V[<span class="number">1001</span>],W[<span class="number">1001</span>],M[<span class="number">1001</span>];<span class="comment">//体积，价值和重量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,m,line = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;m&gt;&gt;w)</span><br><span class="line">    &#123;</span><br><span class="line">        V[line] = v;</span><br><span class="line">        M[line] = m;</span><br><span class="line">        W[line] = w;</span><br><span class="line">        </span><br><span class="line">        line ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[C+<span class="number">1</span>][Q+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= V[i<span class="number">-1</span>];k--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = Q;j &gt;= M[i<span class="number">-1</span>];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k][j] = max(dp[k][j],dp[k - V[i<span class="number">-1</span>]][j - M[i<span class="number">-1</span>]] + W[i<span class="number">-1</span>]);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">        <span class="comment">// printf(&quot;dp:%d\n&quot;,dp[k][j]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C][Q];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="VI-分组背包问题"><a href="#VI-分组背包问题" class="headerlink" title="VI. 分组背包问题"></a>VI. 分组背包问题</h2><p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$用空格隔开，分别表示物品组数和背包容量。</p>
<p>接下来有 $N$ 组数据：</p>
<ul>
<li>每组数据第一行有一个整数 $S_i$，表示第 $i $个物品组的物品数量；</li>
<li>每组数据接下来有 $Si$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；</li>
</ul>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0&lt;N,V≤100 0&lt;Si≤100 0&lt;vij,wij≤100</code></p>
<blockquote>
<hr>
</blockquote>
<p>我们只需要对每组每一个物品进行讨论。求每组的dp是并列的关系，注意循环之间位置关系。枚举体积的循环在外面，而枚举组内物品循环在里面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C,v,w;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//每组物品的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;V[j]&gt;&gt;W[j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= <span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; num; s++)</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= V[s])</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - V[s]] + W[s]);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">        <span class="comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="VII-有依赖的背包问题（hard）-树形dp"><a href="#VII-有依赖的背包问题（hard）-树形dp" class="headerlink" title="VII. 有依赖的背包问题（hard）[树形dp]"></a>VII. 有依赖的背包问题（hard）[树形dp]</h2><p>有 $N$ 个物品和一个容量是 $V$ 的背包。</p>
<p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p>
<p>如下图所示：<br><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt="QQ图片20181018170337.png"></p>
<p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p>
<p>每件物品的编号是 $i$，体积是 $vi$，价值是 $wi$，依赖的父节点编号是 $pi$。物品的下标范围是 $1…N$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。</p>
<p>接下来有 $N$ 行数据，每行数据表示一个物品。<br>第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>如果 $p_i=−1$，表示根节点。 <strong>数据保证所有物品构成一棵树。</strong></p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N,V≤100\1≤v_i,w_i≤100$</p>
<p>父节点编号范围：</p>
<ul>
<li>内部结点：$1≤p_i≤N$;</li>
<li>根节点 $pi=−1$;</li>
</ul>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7</span><br><span class="line">2 3 -1</span><br><span class="line">2 2 1</span><br><span class="line">3 5 1</span><br><span class="line">4 7 2</span><br><span class="line">3 6 2</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们选择根节点,价值为&#123;2,3&#125;，</span><br><span class="line">编号为1的叶节点，我们选择&#123;2,2&#125;或&#123;3,5&#125;。</span><br><span class="line">编号为2的叶节点，我们选择&#123;4,7&#125;或&#123;3,6&#125;。 </span><br><span class="line">最大容积7， 我们选择&#123;2,2&#125;和&#123;3,6&#125;,这样总体积就是2+3+2 &#x3D; 7. 总价值为 2+6+3&#x3D;11.</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
</blockquote>
<p>这道题其实是分组背包和<u>树形dp</u>的结合。先考虑节点的数据表示我们用<code>vector&lt;int&gt; g[N_MAX]</code>表示二叉树。$dp[i][j]$表示，<strong>我们选择节点$i$为根节点，并且体积为$j$的最大价值。</strong></p>
<p>既然是树，我们就需要深度优先搜索（DFS）。由于子节点依赖于根节点，那么根节点必定占据一定空间，且初始价值应该等于根节点。</p>
<blockquote>
<p>初始条件：$ dp[root][j] = W_{root}, V_{root} \le j \le C$ , $C$表示背包容积。</p>
</blockquote>
<p>按照0-1背包思路，我们在$k \in[V_{root},C]$区间内逆向遍历，那么子节点的可用空间为$m \in [0,k-V_{root}]$. 可以类比分组背包的$k\in[0,C],s \in [0,num],where \ k &gt; V_s$, $num$为组号。之后我们将每个子节点分别进行搜索，对$dp[root][k]$进行更新。<br>$$<br>dp[root][k] = \max(dp[root][k],dp[root][k-m]+dp[son][m])<br>$$</p>
<blockquote>
<p>返回值：$dp[root][C]$</p>
</blockquote>
<p>弄清楚这一层写代码就不难了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C,p;<span class="comment">//物品数量，背包容积，父节点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX][N_MAX];<span class="comment">//体积数组，价值数组，dp[i][j]选择第i个节点为根节点在体积为j对应最大价值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N_MAX];<span class="comment">//保存子节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//cap表示容量，no表示节点编号</span></span><br><span class="line">    <span class="comment">//root必选，所以我们初始化dp[root][V[root]~C] 为 W[root]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V[root];j &lt;= C;i++) dp[root][j] = W[root];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;son:g[root]) </span><br><span class="line">    &#123;</span><br><span class="line">        dfs(son);<span class="comment">//遍历子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = C; k &gt;= V[root]; k--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= (k-V[root]);m++)<span class="comment">//分配给子树的空间不能大于C-V[son]</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[root][k] = max(dp[root][k], dp[root][k-m] + dp[son][m]);<span class="comment">//根据不同的子节点更新父节点的值</span></span><br><span class="line">            <span class="comment">// if(dp[root][k]) printf(&quot;rt:%d,sn:%d,dp[%d]:%d\n&quot;,root,son,k,dp[root][k]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(~p) g[p].emplace_back(i);</span><br><span class="line">        <span class="keyword">else</span> root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[root][C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="VIII-背包求解方案数"><a href="#VIII-背包求解方案数" class="headerlink" title="VIII.背包求解方案数"></a>VIII.背包求解方案数</h2><p>有 $N$件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$, 用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <strong>方案数</strong> 模 $10^9+7$ 的结果。</p>
<h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\<br>0&lt;v_i,w_i≤1000$</p>
<blockquote>
<p>我们除了需要对价值$dp[j]$进行状态转移（同0-1背包），还需要对方案数进行转移，设$M[j]$表示物品总体积为$j$对应的方案数。</p>
<p>那么有：<br>$$<br>M[j] = \begin{cases}<br>        M[j], M[j]&gt;M[j-v_i]\<br>        M[j-v_i], M[j]&lt;M[j-v_i]\<br>        M[j]+M[j-v_i], M[j]=M[j-v_i]\<br>        \end{cases}.<br>$$<br>初始条件： $M[0] = 1$， 背包为空只有一种方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">1010</span>, MOD = (<span class="keyword">int</span>)<span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//物品数量和容积</span></span><br><span class="line"><span class="keyword">int</span> dp[N_MAX],M[N_MAX];<span class="comment">//方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,line = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="built_in">memset</span>(dp,INT_MIN,<span class="keyword">sizeof</span>(dp));<span class="comment">//为了使价值从0开始计数，我们把dp数组初始化为-inf</span></span><br><span class="line">    M[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//价值为0的方案为1，即全不放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= v;k--)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> t  = max(dp[k],dp[k - v] + w);<span class="comment">//考虑选第i件物品和不选第i件物品，注意它们价值可能相同</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;<span class="comment">// 不是M[k]，否则三种方案叠加</span></span><br><span class="line">            <span class="keyword">if</span>(t == dp[k-v]+w) s += M[k-v];</span><br><span class="line">            <span class="keyword">if</span>(t == dp[k]) s += M[k];<span class="comment">//这里不能写成else if ，两种路径分开考虑，求的是总方案数</span></span><br><span class="line">            dp[k] = t;</span><br><span class="line">            M[k] =s%MOD;</span><br><span class="line">            <span class="comment">// printf(&quot;i:%d,k:%d,dp:%d,M:%d\n&quot;,i,k,dp[k],M[k]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, maxw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= C;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[j]&lt;&lt;&quot;,&quot;&lt;&lt;M[j]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dp[j] == dp[C])</span><br><span class="line">        &#123;</span><br><span class="line">            res += M[j];</span><br><span class="line">            res %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="IX-背包问题求具体方案"><a href="#IX-背包问题求具体方案" class="headerlink" title="IX. 背包问题求具体方案"></a>IX. 背包问题求具体方案</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p>
<p>物品编号范围是 $1…N$。</p>
<h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\<br>0&lt;v_i,w_i≤1000$</p>
<blockquote>
<hr>
</blockquote>
<p>我们用一个二维dp数组$dp[i][j]$表示选取$i$个物品，体积为$j$对应的最大价值。这里的$i$是用来反推具体方案的。我们思考如何反推。</p>
<p>$dp[i][j] == dp[i-1][j]$说明不选第$i$个物品就能得到最大价值。</p>
<p>$dp[i][j]==dp[i-1][j-v[i-1]]+w[i-1]$表示选择第$i$个物品得到最大价值。</p>
<p>为了得到最小的字典序，我们可以采用贪心的策略。在进行状态转移的时候，我们按编号从大到小进行遍历。为了更直观的理解，我们举例：</p>
<p>设物品数4，背包容积5.  物品的体积$v_i$和价值$w_i$分别为: $[1,2],[2,4],[3,4],[4,6]$.  编号$i$的范围$[1,4]$</p>
<p>从$i=4$开始，我们从体积为0开始进行状态转移。最后的结果一定是最大价值。如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">i:4,k:0,dp:0 ←</span><br><span class="line">i:4,k:1,dp:0</span><br><span class="line">i:4,k:2,dp:0</span><br><span class="line">i:4,k:3,dp:0</span><br><span class="line">i:4,k:4,dp:6</span><br><span class="line">i:4,k:5,dp:6</span><br><span class="line">i:3,k:0,dp:0</span><br><span class="line">i:3,k:1,dp:0</span><br><span class="line">i:3,k:2,dp:0</span><br><span class="line">i:3,k:3,dp:4</span><br><span class="line">i:3,k:4,dp:6 ←</span><br><span class="line">i:3,k:5,dp:6</span><br><span class="line">i:2,k:0,dp:0</span><br><span class="line">i:2,k:1,dp:0</span><br><span class="line">i:2,k:2,dp:4</span><br><span class="line">i:2,k:3,dp:4</span><br><span class="line">i:2,k:4,dp:6 ←</span><br><span class="line">i:2,k:5,dp:8</span><br><span class="line">i:1,k:0,dp:0</span><br><span class="line">i:1,k:1,dp:2</span><br><span class="line">i:1,k:2,dp:4</span><br><span class="line">i:1,k:3,dp:6</span><br><span class="line">i:1,k:4,dp:6</span><br><span class="line">i:1,k:5,dp:8  ←</span><br></pre></td></tr></table></figure>

<p>用$sum$表示剩余体积，开始$sum=5. $然后我们考虑 $dp[i][sum]==dp[i-1][sum-v[i]]+w[i]$ ，如果为True则选择第i个。<br>$$<br>dp[1][5]=8→dp[2][4]=6→dp[3][4]=6→dp[4][0]=0.<br>$$<br>最后$sum==0$，表示找到字典序最小的方案。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//物品数量和容积</span></span><br><span class="line"><span class="keyword">int</span> dp[N_MAX][N_MAX];<span class="comment">//方案数</span></span><br><span class="line"><span class="keyword">int</span> v[N_MAX], w[N_MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;i++) <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N;i &gt;= <span class="number">1</span> ;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= C;k++)</span><br><span class="line">        &#123; </span><br><span class="line">            dp[i][k] = dp[i+<span class="number">1</span>][k];    <span class="comment">//这句话作用是使得k&lt;v[i]仍可进行反推</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt;= v[i]) </span><br><span class="line">            dp[i][k]  = max(dp[i][k],dp[i+<span class="number">1</span>][k - v[i]] + w[i]);<span class="comment">//如果选和不选价值相同，那么我们贪心的进行选择</span></span><br><span class="line">            <span class="comment">// printf(&quot;i:%d,k:%d,dp:%d\n&quot;,i,k,dp[i][k]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据结果反推具体方案</span></span><br><span class="line">    <span class="keyword">int</span> sum = C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][sum]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= v[i]&amp;&amp;dp[i][sum]==(dp[i+<span class="number">1</span>][sum-v[i]]+w[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            sum -= v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="经典题目分析、"><a href="#经典题目分析、" class="headerlink" title="经典题目分析、"></a>经典题目分析、</h2><p><strong>例题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</li>
</ul>
<hr>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</strong></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>数组非空，且长度不会超过 20 。</li>
<li>初始的数组的和不会超过 1000 。</li>
<li>保证返回的最终结果能被 32 位整数存下。</li>
</ul>
<blockquote>
<p>这道题看起来简单,实际上非常<code>Disgusting</code>.因为它给了三个提示,每一条都杀人诛心. </p>
</blockquote>
<p>这一次,我们每一个”物品”都必须选. <strong>我们考虑$dp[i][j]$表示$0-i$区间内组成$j$的方案数</strong>. 那么相应的状态方程为:<br>$$<br>dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]<br>$$<br>很多时候我们会因为惯性思维写成<code>nums[i-1]</code>但这是不对的,因为我们定义区间<code>[0,i]</code>.</p>
<p>然后很糟糕的是, 或者更糟糕的是, 中间可能产生负数目标的情况,为了避免数组越界,我们需要将数组整体搬移, 这时候第二个提示发挥作用.我们设这个$offset=1000$. </p>
<p>关于边界条件. 一开始我们很容易写成:<br>$$<br>dp[0][nums[0]+sum] = 1;         \<br>            dp[0][-nums[0]+sum] = 1;<br>$$<br>第一个数可能为负或者正嘛. 但是如果第一个数为$0$.那么上面的式子将失效, 0 的相反数是其自身. 所以边界条件应该为:<br>$$<br>\left{<br>\begin{array}{cr}<br>\begin{cases}dp[0][nums[0]+sum] = 1;\<br>dp[0][-nums[0]+sum] = 1;\<br>\end{cases},nums[0]!=0<br>\<br>2,otherwise<br>\end{array}<br>\right.<br>$$<br>然后,你这样就以为大功告成了就大错特错了.</p>
<p>在双重循环中,我们必须要考虑$j$的范围,即$dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]$的适用条件. 并不是所有情况都可以用这个式子表示.</p>
<p>经过很长时间的摸索, $-sum \le j \le sum$, $sum$表示数组和,为了节省空间,我们也可以把1000改为$sum$:<br>$$<br>dp[i][j] =\left{ \begin{array}{lcc}<br>dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]],sum-nums[i] &gt;=j&gt;=nums[i]-sum\<br>dp[i-1][j-nums[i]],j&gt;nums[i]-sum\<br>dp[i-1][j+nums[i]],j&lt;sum-nums[i]<br>\end{array}<br>\right.<br>$$<br>做完此题,深感出题人的恐怖.</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//子集问题，转换为0-1背包，动态规划解决。</span></span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">//我们用dp[i][j]表示 0-i区间内组成j的方案数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:nums) sum+= c;</span><br><span class="line">        S = S&gt;=<span class="number">0</span>?S:-S;</span><br><span class="line">        <span class="keyword">if</span>(S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//为了使得负数也能被索引，我们必须加上它自身的绝对值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*sum+<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!nums[<span class="number">0</span>]) dp[<span class="number">0</span>][sum] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>]+sum] = <span class="number">1</span>;         </span><br><span class="line">            dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+sum] = <span class="number">1</span>;        </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = -sum;j &lt;= sum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(j+nums[i] &lt;= sum &amp;&amp; j-nums[i]&gt;=-sum)</span><br><span class="line">                dp[i][j+sum] = dp[i<span class="number">-1</span>][j-nums[i]+sum] + dp[i<span class="number">-1</span>][j+nums[i]+sum];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-nums[i]&gt;=-sum)</span><br><span class="line">                dp[i][j+sum] = dp[i<span class="number">-1</span>][j-nums[i]+sum];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j+nums[i]&lt;=sum)</span><br><span class="line">                dp[i][j+sum] = dp[i<span class="number">-1</span>][j+nums[i]+sum];</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j+sum]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][S+sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:$O(1)$, 因为题目已经告诉了具体范围不超过$O(20*2000)=O(40000)$,所以时间复杂度是常数.</p>
<p>空间复杂度:$O(N(2sum+1))$, 这里的$N$表示数组大小, $sum$表示数组之和. </p>
<p>同类题目还有416. 分割等和子数组.</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/27/2020-07-27-backpack-problem/" data-id="ckfj5lo76001r3osc4y7r212m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/01/2020-8-1-common-way-solve-big-problem/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          解空间极大问题通用策略
        
      </div>
    </a>
  
  
    <a href="/2020/07/21/2020-07-21-dynamic-planning/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">动态规划-自己的一点理解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS-BFS/" rel="tag">DFS&BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/" rel="tag">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E6%A0%91/" rel="tag">前缀树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E6%8C%87%E9%92%88/" rel="tag">多指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E7%94%A8%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="tag">实用用技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%91%E5%90%90%F0%9F%A4%AE%E4%BA%86/" rel="tag">我吐🤮了</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">算法 - 滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">经典数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A2%ABOiers%E8%A7%86%E4%BD%9C%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%97%E6%B3%95/" rel="tag">被Oiers视作优雅的算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/" rel="tag">通用策略</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/" rel="tag">面试基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">高级数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16.67px;">C++</a> <a href="/tags/DFS-BFS/" style="font-size: 10px;">DFS&BFS</a> <a href="/tags/MST/" style="font-size: 10px;">MST</a> <a href="/tags/%E5%89%8D%E7%BC%80%E6%A0%91/" style="font-size: 10px;">前缀树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%A4%9A%E6%8C%87%E9%92%88/" style="font-size: 10px;">多指针</a> <a href="/tags/%E5%AE%9E%E7%94%A8%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">实用用技巧</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="font-size: 13.33px;">平衡树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E6%88%91%E5%90%90%F0%9F%A4%AE%E4%BA%86/" style="font-size: 10px;">我吐🤮了</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 13.33px;">机器学习</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">算法 - 滑动窗口</a> <a href="/tags/%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">经典数据结构</a> <a href="/tags/%E8%A2%ABOiers%E8%A7%86%E4%BD%9C%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%97%E6%B3%95/" style="font-size: 10px;">被Oiers视作优雅的算法</a> <a href="/tags/%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/" style="font-size: 10px;">通用策略</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">面试基础</a> <a href="/tags/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">高级数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/23/2020-8=23-string/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/2020-8-30-prefix_sum/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/2020-9-2-fsm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/Curriculum%20Selection/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/CS_heap_stack/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>