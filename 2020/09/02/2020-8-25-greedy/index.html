

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="博主：来自华中科技大学国家光电研究中心的">
  <meta name="author" content="Durant">
  <meta name="keywords" content="">
  <title>贪婪却巧妙的贪心算法 - Durant Thorvalds 的米奇妙妙屋</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-02 00:00" pubdate>
        2020年9月2日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      43
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">贪婪却巧妙的贪心算法</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="贪心算法及其应用"><a href="#贪心算法及其应用" class="headerlink" title="贪心算法及其应用"></a>贪心算法及其应用</h1><ul>
<li><h4 id="976-三角形的最大周长-排序-贪心-（简单）"><a href="#976-三角形的最大周长-排序-贪心-（简单）" class="headerlink" title="976. 三角形的最大周长(排序+贪心)（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a>(排序+贪心)（简单）</h4></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a>（贪心+额外数组）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-$i$/">45.跳跃游戏I</a>（贪心算法+双指针）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55.跳跃游戏II</a>（贪心算法+双指针）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-valid-matrix-given-row-and-column-sums/">1607.给定行列和求可行矩阵</a> （贪心+线性代数）</p>
</li>
<li><h4 id="763-划分字母区间-贪心算法-双指针）"><a href="#763-划分字母区间-贪心算法-双指针）" class="headerlink" title="763. 划分字母区间 (贪心算法+双指针）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a> (贪心算法+双指针）</h4></li>
<li><h4 id="1024-视频拼接（贪心-额外数组）"><a href="#1024-视频拼接（贪心-额外数组）" class="headerlink" title="1024. 视频拼接（贪心+额外数组）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a>（贪心+额外数组）</h4></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">1642.可以到达的最远建筑</a>（贪心算法+优先队列）</p>
</li>
</ul>
<blockquote>
<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p>
<p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </p>
<p>贪心算法经常和<strong>其它策略</strong>一起考，比如双指针，特殊数组以及优先队列，单调栈等。需要特别注意！</p>
</blockquote>
<hr>
<p>首先我们感受以下贪心可以到什么程度</p>
<h4 id="976-三角形的最大周长"><a href="#976-三角形的最大周长" class="headerlink" title="976. 三角形的最大周长"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a></h4><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p>
<p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs angelscript">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
输出：<span class="hljs-number">5</span></code></pre>
<p><strong>示例 2：</strong></p>
<pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
输出：<span class="hljs-number">0</span></code></pre>
<p><strong>示例 3：</strong></p>
<pre><code class="hljs angelscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
输出：<span class="hljs-number">10</span></code></pre>
<p><strong>示例 4：</strong></p>
<pre><code class="hljs angelscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出：<span class="hljs-number">8</span></code></pre>
<p><strong>提示：</strong></p>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
<hr>
<p>思路，排序+贪心，将A倒序排序，遍历$i\in [0,n-1]$如果开始的三个元素$A[i],A[i+1],A[i+2]$不能组成三角形($A[i]&lt;A[i+1]+A[i+2]$)，那么后面的也肯定无法组成；如果可以组成，那么一定是最大值。</p>
<p>注：该题只能以O(N)通过。</p>
<hr>
<h2 id="贪心-指针"><a href="#贪心-指针" class="headerlink" title="贪心+指针"></a>贪心+指针</h2><h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><p>难度中等</p>
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs lsl">输入：S = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span>
输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]
解释：
划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>, <span class="hljs-string">&quot;defegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span>。
每个字母最多出现在一个片段中。
像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>
<li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li>
</ul>
<hr>
<p>这题我开始想的是并查集，后来看了官方题解，发现贪心+指针也可以做。</p>
<p>而且思路和<strong>跳跃游戏</strong>出奇一致。</p>
<p>我们用两个指针$start$和$end$分别表示某个区间左端点和右端点。同时用数组$last$记录每个字母最后一次出现的位置。</p>
<p>我们遍历整个字符串，更新右端点$end = max(i,last[(int)(S[i]-‘a’)])$</p>
<p>若遍历到右端点了，也就是$end == i$，说明这个时候已经将一个完整区间遍历完了，更新res,$res.push_back(end-start+1)$，同时将start赋值为下一个区间的开头，$start = end+1$</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;
	<span class="hljs-keyword">int</span> last[<span class="hljs-number">26</span>];
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;
    <span class="hljs-keyword">int</span> n = S.size();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
    &#123;
        last[(<span class="hljs-keyword">int</span>)(S[i]-<span class="hljs-string">&#x27;a&#x27;</span>)] = i;
	&#125;
     <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; n;i++)
     &#123;
         end = max(i,last[(<span class="hljs-keyword">int</span>)(S[i]-<span class="hljs-string">&#x27;a&#x27;</span>)]);
         <span class="hljs-keyword">if</span>(i == end)
         &#123;
             res.push_back(end-start+<span class="hljs-number">1</span>);
             end = start+<span class="hljs-number">1</span>;
		&#125;
	&#125;
       <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre>
<hr>
<h4 id="300-最长上升序列"><a href="#300-最长上升序列" class="headerlink" title="300.最长上升序列"></a>300.最长上升序列</h4><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例:</strong></p>
<pre><code class="hljs angelscript">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]
输出: <span class="hljs-number">4</span> 
解释: 最长的上升子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 $O(n^2)$ 。</li>
</ul>
<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p>
<hr>
<p>考虑一个简单的贪心，如果我们要求上升子序列尽可能长，那么要求序列上升的尽可能慢，因此要求每次最后加的数尽可能小。</p>
<p>基于以上思路，我们维护一个数组$d[i]$，表示长度为$i$的上升子序列末尾元素的最小值，用$len$记录目前最长上升长度。起始$d[1]=nums[0]$。</p>
<p>同时我们可以注意到，$d[i]$是关于$i$单调递增的。因为如果$d[j]\ge d[i]$且$j&lt;i$,我们考虑从长度为$i$的最长上升序列的末尾删除$i-j$个元素，那么这个序列的长度变为$j$，且第$j$个元素必然小于$d[i]$，也就小于$d[j]$.那么我们就找到一个长度为$j$的最长上升序列。且末尾元素比$d[j]$小，从而产生矛盾，单调性得证。</p>
<p>我们遍历数组，并更新$d[]$和$len$的值。如果$nums[i]&gt;d[len]$则更新$len+=1$，否则在$d[1…len]$中找到满足$d[i-1]&lt;nums[j]&lt;d[i]$的下标，并更新$d[i]=nums[j]$。</p>
<p>由于$d[]$单调，我们可以采用二分查找的方法，优化算法时间复杂度至$O(N\log N)$。</p>
<ul>
<li>设当前已求得最长上升子序列长度为$len$，初始为1，从前往后遍历数组$nums$，在遍历到$nums[i]$时：<ul>
<li>若$nums[i]&gt;d[len]$，直接加入到d数组末尾，$len+=1$.</li>
<li>否则，在d数组二分查找，找到第一个比$nums[i]$小的数$d[k]$，并更新$d[k+1] = nums[i]。$</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!nums.size()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">//最长子序列长度，可以通过dp</span>
        <span class="hljs-comment">//同时利用哈希表，搜索过的空间就不搜索了</span>
        <span class="hljs-comment">//注意，下一个较大元素可能不选，反而总长度会更长</span>
        <span class="hljs-keyword">int</span> n = nums.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//包含nums[i-1]，且以之为结束的最大子串长度</span>
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;
        d[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)
        &#123;
            <span class="hljs-keyword">if</span>(nums[i] &gt; d[len]) d[++len]=nums[i];
            <span class="hljs-keyword">else</span> <span class="hljs-comment">//在d进行二分查找,找到第一个比nums[i]小的数nums[k]</span>
            &#123;
                <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>,l = <span class="hljs-number">0</span>,r = len;
                <span class="hljs-keyword">while</span>(l&lt;=r)
                &#123;
                    <span class="hljs-keyword">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;
                    <span class="hljs-keyword">if</span>(nums[i] &gt; d[mid])
                    &#123;
                        k = mid;
                        l = mid+<span class="hljs-number">1</span>;
                    &#125; 
                    <span class="hljs-keyword">else</span> r = mid<span class="hljs-number">-1</span>;

                &#125; 
                d[k+<span class="hljs-number">1</span>] = nums[i]; 
            
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> len;
        
        &#125;
&#125;;
</code></pre>
<hr>
<h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a></h4><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>
<p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p>
<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]], T = <span class="hljs-number">10</span>
输出：<span class="hljs-number">3</span>
解释：
我们选中 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>] 再剪辑为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>] + [<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] 。
现在我们手上有 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] + [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>] + [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]，而这些涵盖了整场比赛 [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]。</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]], T = <span class="hljs-number">5</span>
输出：<span class="hljs-number">-1</span>
解释：
我们无法只用 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 覆盖 [<span class="hljs-number">0</span>,<span class="hljs-number">5</span>] 的整个过程。</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]], T = <span class="hljs-number">9</span>
输出：<span class="hljs-number">3</span>
解释： 
我们选取片段 [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">7</span>] 和 [<span class="hljs-number">6</span>,<span class="hljs-number">9</span>] 。</code></pre>
<p><strong>示例 4：</strong></p>
<pre><code class="hljs angelscript">输入：clips = [[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">8</span>]], T = <span class="hljs-number">5</span>
输出：<span class="hljs-number">2</span>
解释：
注意，你可能录制超过比赛结束时间的视频。</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= clips.length &lt;= 100</code></li>
<li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li>
<li><code>0 &lt;= T &lt;= 100</code></li>
</ul>
<hr>
<p>这道题动态规划时间复杂度是$O(TN)$</p>
<p>但是贪心算法往往能做到$O(N)$， 人类的本质是贪婪，所以我们选择贪心算法。</p>
<p>注意到对于所有左端点相同的子区间，其右端点越远越有利。且最佳方案中不可能出现两个左端点相同的子区间。于是我们预处理所有的子区间，对于每一个位置 $i$，我们记录以其为左端点的子区间中最远的右端点，记为 $maxn[i]$。</p>
<p>我们枚举每一个位置，假设当枚举到位置 $i$ 时，记左端点不大于 $i$ 的所有子区间的最远右端点为 $last$。这样 $last$ 就代表了当前能覆盖到的最远的右端点。</p>
<p>每次我们枚举到一个新位置，我们都用$maxn[i]$ 来更新 $last$。如果更新后 $last==i$，那么说明下一个位置无法被覆盖，我们无法完成目标。</p>
<p>同时我们还需要记录上一个被使用的子区间的结束位置为 $pre$，每次我们越过一个被使用的子区间，就说明我们要启用一个新子区间，这个新子区间的结束位置即为当前的 $last$。也就是说，每次我们遇到 $i==pre$，则说明我们用完了一个被使用的子区间。这种情况下我们让答案加 1，并更新 $pre$ 即可。</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; clips, <span class="hljs-keyword">int</span> T)</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxn</span><span class="hljs-params">(T)</span></span>;
        <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; it : clips) &#123;
            <span class="hljs-keyword">if</span> (it[<span class="hljs-number">0</span>] &lt; T) &#123;
                maxn[it[<span class="hljs-number">0</span>]] = max(maxn[it[<span class="hljs-number">0</span>]], it[<span class="hljs-number">1</span>]);<span class="hljs-comment">//更新maxn为保证左端点被覆盖的最远的端点，</span>
            &#125;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;
            last = max(last, maxn[i]); <span class="hljs-comment">//获取最远右端点</span>
            <span class="hljs-keyword">if</span> (i == last) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//i到达最远，无法完成</span>
            &#125;
            <span class="hljs-keyword">if</span> (i == pre) &#123;
                ret++;
                pre = last;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;;
</code></pre>
<p>复杂度分析</p>
<p>时间复杂度：$O(T+N)$，其中 $T $是区间的长度，$N$ 是子区间的数量。我们需要枚举每一个位置，时间复杂度 $O(T)$，同时我们还需要预处理所有的子区间，时间复杂度 $O(N)$。总时间复杂度为 $O(T) + O(N) = O(T + N)$。</p>
<p>空间复杂度：$O(T)$，其中 T 是区间的长度。对于每一个位置，我们需要记录以其为左端点的子区间的最右端点。</p>
<hr>
<h2 id="贪心算法-优先队列"><a href="#贪心算法-优先队列" class="headerlink" title="贪心算法+优先队列"></a>贪心算法+优先队列</h2><h4 id="1642-可以到达的最远建筑"><a href="#1642-可以到达的最远建筑" class="headerlink" title="1642.可以到达的最远建筑"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">1642.可以到达的最远建筑</a></h4><p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>
<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>
<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标 <strong>从 0 开始</strong> ）时：</p>
<ul>
<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>
<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 <strong><code>(h[i+1] - h[i])</code> 个砖块</strong></li>
</ul>
<p>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 <strong>从 0 开始</strong> ）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif" srcset="/img/loading.gif" alt="img"></p>
<pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>], bricks = <span class="hljs-number">5</span>, ladders = <span class="hljs-number">1</span>
输出：<span class="hljs-number">4</span>
解释：从建筑物 <span class="hljs-number">0</span> 出发，你可以按此方案完成旅程：
- 不使用砖块或梯子到达建筑物 <span class="hljs-number">1</span> ，因为 <span class="hljs-number">4</span> &gt;= <span class="hljs-number">2</span>
- 使用 <span class="hljs-number">5</span> 个砖块到达建筑物 <span class="hljs-number">2</span> 。你必须使用砖块或梯子，因为 <span class="hljs-number">2</span> &lt; <span class="hljs-number">7</span>
- 不使用砖块或梯子到达建筑物 <span class="hljs-number">3</span> ，因为 <span class="hljs-number">7</span> &gt;= <span class="hljs-number">6</span>
- 使用唯一的梯子到达建筑物 <span class="hljs-number">4</span> 。你必须使用砖块或梯子，因为 <span class="hljs-number">6</span> &lt; <span class="hljs-number">9</span>
无法越过建筑物 <span class="hljs-number">4</span> ，因为没有更多砖块或梯子。</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>], bricks = <span class="hljs-number">10</span>, ladders = <span class="hljs-number">2</span>
输出：<span class="hljs-number">7</span></code></pre>
<p><strong>示例 3：</strong></p>
<pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">14</span>,<span class="hljs-number">3</span>,<span class="hljs-number">19</span>,<span class="hljs-number">3</span>], bricks = <span class="hljs-number">17</span>, ladders = <span class="hljs-number">0</span>
输出：<span class="hljs-number">3</span></code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= heights.length &lt;= 105</code></li>
<li><code>1 &lt;= heights[i] &lt;= 106</code></li>
<li><code>0 &lt;= bricks &lt;= 109</code></li>
<li><code>0 &lt;= ladders &lt;= heights.length</code></li>
<li></li>
</ul>
<hr>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights, <span class="hljs-keyword">int</span> bricks, <span class="hljs-keyword">int</span> ladders)</span> </span>&#123;
    <span class="hljs-keyword">int</span> len = heights.size();
    <span class="hljs-comment">//我们实时维护一个优先队列，保存从大到小排列的高度差</span>
    <span class="hljs-comment">//前面的l个最大高度可以用绳子解决，后面的高度差之和就是消耗砖块的数量，若在i位置，高度差之和大于砖块位置，且没有绳子可以用，这就是我们能到达的最远位置。</span>
   <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq;
   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>;
<span class="hljs-comment">//    cout&lt;&lt;endl;</span>
   <span class="hljs-keyword">for</span>(;i &lt; len<span class="hljs-number">-1</span>;i++)
   &#123;
       <span class="hljs-keyword">if</span>(heights[i+<span class="hljs-number">1</span>] &lt;= heights[i]) <span class="hljs-keyword">continue</span>;
       pq.push(heights[i+<span class="hljs-number">1</span>] - heights[i]);
       sum += heights[i+<span class="hljs-number">1</span>] - heights[i];
    <span class="hljs-comment">//    printf(&quot;sum:%d\n&quot;,sum);</span>
       <span class="hljs-keyword">if</span>(sum &gt; bricks)
       &#123;<span class="hljs-comment">//如果消耗的砖块超了就改用绳子</span>
            <span class="hljs-keyword">if</span>(ladders == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
            ladders --;
            sum -= pq.top();
            <span class="hljs-comment">// printf(&quot;-=:%d\n&quot;,sum);     </span>
            pq.pop();
       &#125;
       
   &#125;

    <span class="hljs-keyword">return</span> i;
    &#125;
&#125;;</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/02/2020-8-25-math/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数学和线性代数应用于解题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/02/2020-9-2-fsm/">
                        <span class="hidden-mobile">貌似很难懂的DSA是什么？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "8oX7VCxy9tyFQIvF8qwLorP0-gzGzoHsz",
          app_key: "F0939INl4cKXpCw2HgTIUb6B",
          placeholder: "说点什么,（支持Markdown）",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "https://8ox7vcxy.lc-cn-n1-shared.com",
        });
      });
    }
    waitElementVisible('vcomments', loadValine);
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "贪婪却巧妙的贪心算法&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  








  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  

  

  

  

  

  





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
