

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;auto&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="博主：来自华中科技大学国家光电研究中心的">
  <meta name="author" content="Durant">
  <meta name="keywords" content="">
  <title>优雅而巧妙的并查集 - Durant Thorvalds 的米奇妙妙屋</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-08-14 00:00" pubdate>
        星期五, 八月 14日 2020, 12:00 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      59
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">优雅而巧妙的并查集</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="什么是并查集（UnionSet）"><a href="#什么是并查集（UnionSet）" class="headerlink" title="什么是并查集（UnionSet）"></a>什么是并查集（UnionSet）</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">岛屿的数量</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">二维网格中探测环</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-division/">除法求值</a>（带权值）            </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a>（无向图）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection-ii">冗余连接II</a>(Hard)（有向图）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a>(DFS,BFS,UnionSet均可以做,DFS,BFS更优)</p>
</li>
<li><p><del>句子相似性2(VIP)</del></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">等式方程可满足性</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">连通网络操作次数</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/">按公因数计算最大组件大小</a>（hard）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/couples-holding-hands/">情侣牵手</a>（Hard）</p>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/accounts-merge/">账户合并</a></li>
</ol>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">知乎传送门</a></p>
</blockquote>
<p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。</p>
<ul>
<li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合</li>
<li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合之中</li>
</ul>
<p>在连通性问题中（如岛屿问题），并查集很有作用。<strong>核心思想</strong>是连通区域内所有点的根节点其实是同一个。将每个点映射为一个数字。先假设每个点的根节点就是它们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋给另一个点的根节点，这样两个点所在的连通区域又相互连通了。</p>
<p>好的我们一步一步来画板子（ddrdd）：</p>
<p>并查集的主要操作有：</p>
<ul>
<li><code>find(int m)</code> :查找$m$的根节点</li>
<li><code>isConnected(int m, int n)</code>：判断$m,n$两个点是否在同一个连通区域。</li>
<li><code>Union(int m, int n)</code>:合并$m,n$两个点所在的连通区域。</li>
</ul>
<p><strong>初始化</strong></p>
<pre><code class="hljs C++"><span class="hljs-keyword">int</span> fa[MAXN];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n )</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n;i++)
        fa[i] = i;
&#125;</code></pre>
<p><strong>查询</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(fa[x]==x)
        <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">else</span> 
        <span class="hljs-keyword">return</span> find(fa[x]);
&#125;
</code></pre>
<p>一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p>
<p><strong>合并</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>
<span class="hljs-function"></span>&#123;
	fa[find(i)] = find(j);
&#125;</code></pre>
<p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者.</p>
<p><strong>更新</strong></p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
	<span class="hljs-keyword">if</span>(fa[i] != i) fa[i] = find(fa[i]);
&#125;</code></pre>
<p>一般在对所有节点merge之后需要整体更新，避免漏掉连通分支。</p>
<hr>
<p>初级并查集效率较低，我们需要进行<strong>路径压缩</strong>。</p>
<p>我们添加元素可能会形成长链，想要从底部寻找根节点会越来越难。路径压缩是这样一种算法，每个元素到根节点的路径尽可能短。</p>
<p>我们可以在查找的过程中，<u>把沿途每个节点的父节点都设为根节点</u>。</p>
<p><strong>路径压缩后合并</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> x==find(x)? x : (fa[x] = find(fa[x]));
&#125;</code></pre>
<p>我们得到的并查集是这样的，很像一棵二叉树。</p>
<p><strong>按秩合并</strong></p>
<p>按路径压缩后的并查集结构仍是毕竟复杂的，比如现在我们有一棵较复杂的树，与一个单元素进行合并：</p>
<p><img src="/img/dsu_1.jpg" srcset="/img/loading.gif" alt=""></p>
<p>那么是把7作为8的父节点好呢，还是8作为7父节点好呢：</p>
<p>当然是前者，因为后者会使树的深度加深。所以要<strong>把简单树往复杂树上合并。</strong></p>
<p>我们用于一个数组<code>rank[]</code>记录每个根节点对应树的深度。一开始，所有节点的秩设为1.合并时比较两个根节点，把秩小的往秩的根节点合并。</p>
<p><strong>初始化（按秩合并）</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++) 
    &#123;
        fa[i] = i;
        rank[i] = <span class="hljs-number">1</span>;
    &#125; 
&#125;</code></pre>
<p><strong>合并（按秩合并）</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> x = find(i),y = find(j);
    <span class="hljs-keyword">if</span>(rank[x] &lt;= rank[y]) 
        fa[x] = y;
    <span class="hljs-keyword">else</span> 
        fa[y] = x;
    <span class="hljs-keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)
    &#123;<span class="hljs-comment">//如果秩相同，则新节点深度++</span>
        rank[y]++;
    &#125;   
&#125;</code></pre>
<p>为什么根秩相同，深度要加1呢，如下图，我们有两个秩均为2 的树，现在要合并。</p>
<p><img src="/img/dsu_2.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;" /></p>
<p>我们把2的父节点设为5，这里深度加1，同样另一种合并方式也会使深度加1.</p>
<p><img src="\img\dsu_3.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;" /></p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；</p>
<p>2、代表元法：采用 parent 数组实现，以每个结点的根结点作为代表元；</p>
<p>3、并查集的优化有两种策略：</p>
<p>（1）<strong>路径压缩</strong>；</p>
<p>有「隔代压缩」与「完全压缩」。</p>
<ul>
<li>「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。</li>
<li>「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。</li>
</ul>
<p><img src="\img\dsu_3.jpg" srcset="/img/loading.gif" alt="image.png"></p>
<p>（2）按秩合并。</p>
<p>秩也有两种含义：</p>
<p>秩表示以当前结点为根结点的子树结点总数，即这里的「秩」表示 size 含义；<br>秩表示以当前结点为根结点的子树的高度，即这里的「秩」表示 rank 含义（更合理，因为查询时候的时间性能主要决定于树的高度）。<br>4、如果同时使用「路径压缩」与「按秩合并」，这里的「秩」就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的「参考」。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近 $O(1)$。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35090745">为什么并查集在路径压缩之后的时间复杂度是阿克曼函数?</a></p>
<hr>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1559-二维网格图中探测环"><a href="#1559-二维网格图中探测环" class="headerlink" title="1559. 二维网格图中探测环"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">1559. 二维网格图中探测环</a></h4><p>给你一个二维字符网格数组 <code>grid</code> ，大小为 <code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 <strong>相同值</strong> 形成的环。</p>
<p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值</strong> 。</p>
<p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> 是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p>
<p>如果 <code>grid</code> 中有相同值形成的环，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png" srcset="/img/loading.gif" alt="img"></strong></p>
<pre><code class="hljs smalltalk">输入：grid = [[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;b&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>],[<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>]]
输出：<span class="hljs-keyword">true</span>
解释：如下图所示，有 <span class="hljs-number">2</span> 个用不同颜色标出来的环：</code></pre>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png" srcset="/img/loading.gif" alt="img"> </p>
<hr>
<p>利用并查集的思想，相同的字母可以形成一个连通区域，从左上角开始，遇到相同字母则进行合并，合并时若发现$x$和$y$与$parent$相同，即形成环。</p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">250100</span>;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> p[N];
    <span class="hljs-keyword">int</span> cnt[N];

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (p[x] != x) &#123;
            x = find(p[x]);
        &#125;
        <span class="hljs-keyword">return</span> p[x];
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (find(a) != find(b)) &#123;
            cnt[find(b)] += cnt[find(a)];
            p[find(a)] = find(b);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;
            p[i] = i;
            cnt[i] = <span class="hljs-number">1</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsCycle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = grid.size();
        <span class="hljs-keyword">int</span> m = grid[<span class="hljs-number">0</span>].size();
        init();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;
                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>&lt; n &amp;&amp; grid[i][j] == grid[i + <span class="hljs-number">1</span>][j]) &#123;
                    <span class="hljs-keyword">if</span> (find(i * m + j) == find((i + <span class="hljs-number">1</span>) * m + j)) &#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        p[find(i * m + j)] = find((i + <span class="hljs-number">1</span>) * m + j);
                    &#125;
                &#125;
                <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i][j] == grid[i][j + <span class="hljs-number">1</span>]) &#123;
                    <span class="hljs-keyword">if</span> (find(i * m + j) == find(i * m + j + <span class="hljs-number">1</span>)) &#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        p[find(i * m + j)] = find(i * m + j + <span class="hljs-number">1</span>);
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;
</code></pre>
<h2 id="685-冗余连接II"><a href="#685-冗余连接II" class="headerlink" title="685. 冗余连接II"></a>685. 冗余连接II</h2><p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N-1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</p>
<p>树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：</p>
<ul>
<li><p>附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；</p>
</li>
<li><p>附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。</p>
</li>
</ul>
<blockquote>
<p><code>parent</code>用于保存上一个指向它的节点，仅此而已。</p>
</blockquote>
<p>在遍历图中的所有边之后，根据是否存在导致冲突的边和导致环路出现的边，得到附加的边。</p>
<ul>
<li><p>如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。</p>
</li>
<li><p>如果有导致冲突的边，记这条边为 $[u,v]$，则有两条边指向 v，另一条边为 $[\textit{parent}[v],v]$需要通过判断是否有导致环路的边决定哪条边是附加的边。</p>
</li>
<li><p>如果有导致环路的边，则附加的边不可能是 $[u,v]$（因为 $[u,v] $已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 $[\textit{parent}[v],v]$。</p>
</li>
<li><p>如果没有导致环路的边，则附加的边是后被访问到的指向 v 的边，因此附加的边是 $[u,v]$。</p>
</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;
    <span class="hljs-keyword">int</span> conflict;<span class="hljs-comment">//记录具有多个父节点的边编号</span>
    <span class="hljs-keyword">int</span> loop;<span class="hljs-comment">//记录生成环路的边编号</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
            fa.emplace_back(i);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>( x == fa[x])
        &#123;
            <span class="hljs-keyword">return</span> x;
        &#125;
        fa[x] = find(fa[x]);
        <span class="hljs-keyword">return</span> fa[x];
    &#125;
    

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;
        <span class="hljs-comment">//思路：并查集</span>
        <span class="hljs-comment">//此题与全连接I的区别是，无向图变为有向图</span>
        <span class="hljs-keyword">int</span> n = edges.size();
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//专门用于保存父节点，与并查集无关</span>
        init(n+<span class="hljs-number">1</span>);
        conflict = loop = <span class="hljs-number">-1</span>;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
        &#123;<span class="hljs-comment">//u -&gt; v</span>
            <span class="hljs-keyword">int</span> u = edges[i][<span class="hljs-number">0</span>], v = edges[i][<span class="hljs-number">1</span>]; 
            <span class="hljs-keyword">int</span> pu = find(u), pv = find(v);            
            <span class="hljs-keyword">if</span>(pv!=v) <span class="hljs-comment">// 说明 e[1]已经有父节点，存在冲突</span>
                conflict = i;
            <span class="hljs-keyword">else</span> 
            &#123;
                parent[v] = u;
                <span class="hljs-keyword">if</span>(pv == pu)<span class="hljs-comment">//表示有环</span>
                &#123;
                    loop = i;
                &#125;
                <span class="hljs-keyword">else</span> fa[pv] = pu;
            
            &#125;
        &#125;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conf:%d,loop:%d\n&quot;</span>,conflict,loop);
        <span class="hljs-comment">//接下来需要判断哪个边导致了冗余</span>
        <span class="hljs-keyword">if</span>(conflict&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//说明没有冲突，附加的边为环路最后出现的边</span>
        &#123;
            <span class="hljs-keyword">return</span> edges[loop];
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若存在冲突，</span>
        &#123;
            <span class="hljs-keyword">if</span>(loop &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//没有环	</span>
            <span class="hljs-keyword">return</span> edges[conflict];
            <span class="hljs-keyword">else</span> <span class="hljs-comment">//既有冲突也有环，则不可能是冲突的那一条边</span>
            <span class="hljs-keyword">return</span> &#123;parent[edges[conflict][<span class="hljs-number">1</span>]],edges[conflict][<span class="hljs-number">1</span>]&#125;;

        &#125;

        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;
    &#125;
&#125;;
</code></pre>
<p>时间复杂度: $O(N \log N)$</p>
<p>空间复杂度：$O(N)$</p>
<hr>
<h2 id="952-按公因式计算最大组件的大小"><a href="#952-按公因式计算最大组件的大小" class="headerlink" title="952.按公因式计算最大组件的大小"></a>952.按公因式计算最大组件的大小</h2><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：</p>
<p>有 <code>A.length</code> 个节点，按从 <code>A[0]</code>到 <code>A[A.length - 1]</code> 标记；<br>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j]</code>之间才有一条边。<br>返回图中最大连通组件的大小。</p>
<p>示例 1：</p>
<p>输入：[4,6,15,35]<br>输出：4</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex1.png" srcset="/img/loading.gif" alt="img" style="zoom:33%;" /></p>
<p>示例 2：</p>
<p>输入：[20,50,9,63]<br>输出：2</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex2.png" srcset="/img/loading.gif" alt="img" style="zoom:33%;" /></p>
<p>示例 3：</p>
<p>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex3.png" srcset="/img/loading.gif" alt="img" style="zoom:33%;" /></p>
<p>提示：</p>
<p><code>1 &lt;= A.length &lt;= 20000
1 &lt;= A[i] &lt;= 100000</code></p>
<hr>
<p>按照并查集的思路求解</p>
<p>设$W = max(A[i]), R = \sqrt{W}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+A.length$个不同的质因数。质因数为本身的最多$A.length$个，非本身的质因数一定比$R$小，最多$R$个。</p>
<p>我们可以提取$A$中每个数的质因数，对每个质因数建立索引，然后利用并查集。</p>
<p><img src=".\img\dsu_4.png" srcset="/img/loading.gif" alt="952-1.png"></p>
<p><strong>代码</strong></p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;
    <span class="hljs-keyword">int</span> res;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
            fa.emplace_back(i);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function">    </span>&#123;<span class="hljs-comment">//路径压缩</span>
        <span class="hljs-keyword">while</span>(x != fa[x])
        &#123;
            fa[x] = fa[fa[x]];
            x = fa[x];
        &#125;
        <span class="hljs-keyword">return</span> fa[x];

    &#125;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">int</span> x = find(i), y = find(j);
        fa[x] = y;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestComponentSize</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;
    <span class="hljs-keyword">int</span> n = A.size();
    <span class="hljs-comment">//这题是并查集的经典应用</span>
    <span class="hljs-comment">//因为A的长度很大，不能采用双重循环遍历</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; factor[n];<span class="hljs-comment">//质因数索引</span>
    <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a :A) maxVal = max(maxVal,a);
    init(maxVal+<span class="hljs-number">1</span>);
    res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:A)
    &#123;
        <span class="hljs-keyword">double</span> r = <span class="hljs-built_in">sqrt</span>(a);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= r; i++)
        <span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>) 
        &#123;
            merge(a,i);
            merge(a,a/i);
        &#125;
    &#125;
    <span class="hljs-comment">//将A中的数映射为代表元,看那一些出现过</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(maxVal+<span class="hljs-number">1</span>)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)
    &#123;
        cnt [find(A[i])]++;
        res = max(res, cnt [find(A[i])]);
    &#125;
    <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre>
<p>时间复杂度：$O(N \sqrt{W})$，其中 $N$ 是 A 的长度，$W = \max(A[i])$。</p>
<p>空间复杂度： $O(M)$, 分别用了$fa$和$cnt$数组，$M$表示数组最大值。</p>
<hr>
<h2 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a>765. 情侣牵手</h2><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p>
<p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p>
<p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p>
<p><strong>示例 1:</strong></p>
<pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]
输出: <span class="hljs-number">1</span>
解释: 我们只需要交换row[<span class="hljs-number">1</span>]和row[<span class="hljs-number">2</span>]的位置即可。</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code class="hljs angelscript">输入: row = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
输出: <span class="hljs-number">0</span>
解释: 无需交换座位，所有的情侣都已经可以手牵手了。</code></pre>
<p><strong>说明:</strong></p>
<ol>
<li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li>
<li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li>
</ol>
<hr>
<ol>
<li><strong>贪心解法</strong></li>
</ol>
<p>我们考虑每队情侣都由奇数编号和偶数编号组成，因为情侣数量有限，我们可以遍历所有情侣中编号为偶数的<code>1,2,4,6...2*N</code>， 对相应的奇数情侣交换，每交换一次则<code>res++</code>。具体地，如果偶数情侣位于偶数位置$i$，则奇数情侣位置一定是$i+1$, 否则，奇数情侣位置为$i-1$。</p>
<p><strong>代码</strong></p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span>  Map&lt;Integer,Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="hljs-comment">//记录数字的位置</span>
   
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> direct)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">int</span> temp, temp2;
        temp = memo.get(i+<span class="hljs-number">1</span>);
        memo.put(row[memo.get(i)+direct],temp);
        memo.put(i+<span class="hljs-number">1</span>,memo.get(i)+direct);
        temp2 = row[temp];
        row[temp] = row[memo.get(i)+direct] ;
        row[memo.get(i)+direct] = temp2;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span> </span>&#123;
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = row.length;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) memo.put(row[i],i);
        <span class="hljs-comment">//我们只移动奇数，如果偶数位置是偶数，那么相邻奇数位置在右边，否则在左边</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i += <span class="hljs-number">2</span>)
        &#123;
            <span class="hljs-keyword">if</span>(memo.get(i) %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)+<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;
                swap(row,i,<span class="hljs-number">1</span>);
                res ++;
            &#125;
            <span class="hljs-keyword">else</span>
            &#123;
                <span class="hljs-keyword">if</span>(memo.get(i+<span class="hljs-number">1</span>) == memo.get(i)-<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;
                swap(row,i,-<span class="hljs-number">1</span>);
                res ++;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> res;

    &#125;
&#125;</code></pre>
<p><strong>时间复杂度</strong>:$O(N)$.</p>
<p>空间复杂度:$O(N)$,使用了一个长度为$N$哈希表。</p>
<ol>
<li><strong>并查集</strong></li>
</ol>
<p>我们重点放在并查集解法上。</p>
<p>我们设想一下加入有两对情侣互相坐错了位置，我们至多只需要换一次。<br>如果3对情侣相互坐错了位置，$A1+B2,B1+C2,C1+A2$。他们三个之间形成了一个连通图，我们只需要交换两次。<br>如果4对情侣相互坐错了位置，即这4对情侣不与其他情侣坐在一起，$A1+B2,B1+C2,C1+D2,D1+A2$.他们四个之间形成了一个连通图，他们只需要交换三次并且不用和其他情侣交换，就可以将这四对情侣交换好，<br>以此类推，其实就是假设k对情侣形成一个环状的错误链，我们<strong>最少</strong>需要交换k - 1次就可以将这k对情侣的位置排好。</p>
<blockquote>
<p>所以问题转化成$N$对情侣中，有几个这样的错误环。我们可以使用并查集来处理，每次遍历相邻的两个位置，如果他们本来就是情侣，他们处于大小为1的错误环中，只需要交换0次。如果不是情侣，说明他们两对处在同一个错误环中，我们将他们合并（union），将所有的错坐情侣合并和后，答案就是情侣对 - 环个数。<br>这也说明，最差的情况就是所有N对情侣都在一个环中，这时候我们需要$N - 1$调换。<br>最好情况每对情侣已经坐好了，已经有N个大小为1的环，这时候我们需要$N - N$次调换。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa,rank;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span>(x != fa[x]) fa[x] = getfa(fa[x]);
        <span class="hljs-keyword">return</span> fa[x];
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uni</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y )</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">int</span> fx = getfa(x),fy = getfa(y);
        <span class="hljs-keyword">if</span>(fx != fy)
        &#123;
            <span class="hljs-keyword">if</span>(rank[fx] &lt; rank[fy])
            &#123;
                fa[fx] = fy;
                rank[fy] += rank[fx];
            &#125;<span class="hljs-keyword">else</span>
            &#123;
                fa[fy] = fx;
                rank[fx] += rank[fy];
            &#125;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; row)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n = row.size(),m = n / <span class="hljs-number">2</span>,res = <span class="hljs-number">0</span>,circle = <span class="hljs-number">0</span>;
        fa = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>),rank = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++) fa[i] = i;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i += <span class="hljs-number">2</span>)
            uni(row[i] / <span class="hljs-number">2</span>,row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>);<span class="hljs-comment">//本来是情侣的话，两者肯定相等，不会合并</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i ++)
            <span class="hljs-keyword">if</span>(i == getfa(i))
                circle ++;
        <span class="hljs-keyword">return</span> m - circle;
    &#125;
&#125;;
</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/08/23/2020-8-23-bitoperation/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">一句能打败99.99999%的程序员的位操作代码</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/10/2020-9-12-minimal-Spanning-tree/">
                        <span class="hidden-mobile">专题:DFS&BFS</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "优雅而巧妙的并查集&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
