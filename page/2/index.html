<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ML4_DecisionTree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/ML4_DecisionTree/" class="article-date">
  <time datetime="2020-09-23T10:16:45.067Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="机器学习算法I-决策树"><a href="#机器学习算法I-决策树" class="headerlink" title="机器学习算法I: 决策树"></a>机器学习算法I: 决策树</h1><p>决策树的基本算法是「<strong>分而治之</strong>」。</p>
<p>设有训练集$D$以及属性集$A$. 函数<code>TreeGenerate(D,A)</code>算法如下：</p>
<ul>
<li><p>我们生成树节点node，若D中样本全部属于同一类别C.就将node标记为C类叶节点。</p>
</li>
<li><p>如果A为空集或者D中样本在A上取值相同，那么将node标记为叶节点，其类别标记为D中样本数最多的类。然后返回。</p>
</li>
<li><p>从A中选择最优划分属性$a^*$.</p>
</li>
<li><p>对最优划分属性的每个子属性$a_i$:</p>
<ul>
<li>为node生成一个分支，令$D_v$表示$D$在$a^*$上取值为$a_i$的样本子集；<ul>
<li>如果$D_v$为空，那么将分支节点标记为叶节点，其类别标记为$D$中样本最多的类。并返回。</li>
<li>以$TreeGenrate(D_v,A/(a_*))为分支节点$</li>
</ul>
</li>
</ul>
<p>最后输出一棵以node为根节点的决策树。</p>
</li>
</ul>
<h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><p>如何选择最优划分属性？我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即纯度（purity）越来越高。</p>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k=1,2,..n)$，则$D$的信息熵定义为<br>$$<br>Entropy(D)=-\sum_\limits{k=1}^{n}p_k\log_2 p_k<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/23/ML4_DecisionTree/" data-id="ckfj5lo6l00193osc0ft2diny" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/hello-world/" class="article-date">
  <time datetime="2020-09-23T09:35:13.854Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/23/hello-world/" data-id="ckfj5lo6p001b3osc0b2h4tb7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-8-17-recognition-monostack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/14/2020-8-17-recognition-monostack/" class="article-date">
  <time datetime="2020-08-14T02:23:45.000Z" itemprop="datePublished">2020-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/14/2020-8-17-recognition-monostack/">初认识-单调栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="初认识-单调栈"><a href="#初认识-单调栈" class="headerlink" title="初认识-单调栈"></a>初认识-单调栈</h1><ul>
<li><ol start="84">
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大矩形（Hard）</a></li>
</ol>
</li>
<li>85.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-rectangle/">求最大矩形(Hard)</a></li>
<li>739.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度(Medium)</a></li>
<li>多重背包问题III【详见背包九讲】</li>
</ul>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<pre><code>                                                                                   ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)</code></pre>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<hr>
<p>这道题无论是暴力还是枚举均会超时（时间复杂度$O(N^2)$），最初的想法是用一个哈希表存<code>heights</code>中每一个高度「最长的横向距离」，最大面积等于<code>max(maxArea,heights[i]×len)</code>后来发现过于麻烦。但是直觉告诉我这是可行的，题解采用单调栈也验证了我的想法。</p>
<p>有一个<em>事实</em>需要注意：</p>
<ul>
<li>若后一个高度小于前一个高度，那么前一个高度将不会对后续的求最大面积操作产生影响。</li>
</ul>
<p>我们需要对$i$左右进行扩展，我们需要找到<strong>左右两侧最近且高度小于$h$的柱子，这和接雨水那一题非常相似</strong>。以</p>
<p>$[6,7,5,2,4,5,9,3]$为例，</p>
<ol>
<li>将6入栈，6左侧为哨兵，位置-1；</li>
<li>将7入栈，由于7&gt;6，故7不会被移除；</li>
<li>将5入栈，由于7&gt;5且6&gt;5，故6，7会被移除。此时栈为空，5左侧为哨兵，位置-1.</li>
<li>将2入栈，由于2&lt;5，5会被移除，2左侧为哨兵-1.</li>
<li>将4入栈</li>
<li>将5入栈</li>
<li>将9入栈</li>
<li>不断出栈直到遇到2&lt;3</li>
</ol>
<p>$$<br>\begin{array}\<br>1.[6(0)]\<br>2.[6(0),7(1)]\<br>3.[5(2)]\<br>4.[2(3)]\<br>5.[2(3),4(4)]\<br>6.[2(3),4(4),5(5)]\<br>7.[2(3),4(4),5(5),9(6)]\<br>8.[2(3),3(7)]<br>\end{array}<br>$$</p>
<p>这样以来我们得到左侧柱子的编号为$[-1,0,-1,-1,3,4,5,3]$，同样地，我们可以得到右侧柱子的编号$[2,2,3,8,7,7,7,8]$。  因而根据$(l_height-r_height-1)*height[i]$得到最大面积。</p>
<p>代码如下：</p>
<p>​     </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!heights.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> n = heights.size();</span><br><span class="line">     <span class="keyword">int</span> maxArea = INT32_MIN;</span><br><span class="line">    <span class="comment">//采用单调栈的思想，分别找到i左右两侧最近且高度小于h的柱子</span></span><br><span class="line">    vector&lt;int&gt; lbound(n,0),rbound(n,0);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; lstack,rstack;<span class="comment">//存放高度位置和下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lstack.empty()) lbound[i] = <span class="number">-1</span>;<span class="comment">//哨兵 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(heights[i] &gt; lstack.back().first) </span><br><span class="line">        &#123;</span><br><span class="line">            lbound[i] = lstack.back().second;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!lstack.empty()&amp;&amp;heights[i]&lt;=lstack.back().first)lstack.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(lstack.empty()) lbound[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> lbound[i] = lstack.back().second;</span><br><span class="line">        &#125;</span><br><span class="line">        lstack.push_back(&#123;heights[i],i&#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rstack.empty()) rbound[j] = n;<span class="comment">//哨兵 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(heights[j] &gt; rstack.back().first) </span><br><span class="line">        &#123;</span><br><span class="line">            rbound[j] = rstack.back().second;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!rstack.empty()&amp;&amp;heights[j]&lt;=rstack.back().first) rstack.pop_back();</span><br><span class="line">            <span class="keyword">if</span>(rstack.empty()) rbound[j] = n;</span><br><span class="line">            <span class="keyword">else</span> rbound[j] = rstack.back().second;</span><br><span class="line">        &#125;</span><br><span class="line">        rstack.push_back(&#123;heights[j],j&#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(auto &amp;c:lbound)</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d,&quot;,c);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// for(auto &amp;c:rbound)</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d,&quot;,c);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n;c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lbound[c]==<span class="number">-1</span>) maxArea = max(maxArea,rbound[c]*heights[c]);</span><br><span class="line">        <span class="keyword">else</span> maxArea = max(maxArea,(rbound[c]-lbound[c]<span class="number">-1</span>)*heights[c]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea&lt;<span class="number">0</span>?<span class="number">0</span>:maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(2N)$</p>
<p>空间复杂度: $O(4N)$，左右边界以及栈</p>
<p>但是此代码可以简化，把寻找左边界和寻找右边界放在一次迭代中完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//84求柱状图的最大矩形，O(N)</span></span><br><span class="line">           <span class="keyword">int</span> n = heights.size();</span><br><span class="line">           vector&lt;int&gt; left(n), right(n, n);</span><br><span class="line">           <span class="comment">//左右边界数组，维护每个矩形的最大左右宽度</span></span><br><span class="line">           <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mono_stack;<span class="comment">//单调栈</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">while</span> (!mono_stack.empty() &amp;&amp; heights[mono_stack.top()] &gt;= heights[i]) &#123;</span><br><span class="line">                   right[mono_stack.top()] = i;</span><br><span class="line">                   mono_stack.pop();</span><br><span class="line">               &#125;</span><br><span class="line">               left[i] = (mono_stack.empty() ? <span class="number">-1</span> : mono_stack.top());</span><br><span class="line">               mono_stack.push(i);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">               ans = max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);<span class="comment">//计算最大面积</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>可能看代码有些复杂，我们制作一个动画方便理解：</p>
<p>[动画正在制作之中。。。]</p>
<hr>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<hr>
<p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<p>正向遍历温度列表。对于温度列表中的每个元素 T[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 T[prevIndex] 和当前温度 T[i]，如果 T[i] &gt; T[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
<p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 T[i] 一定是 T[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p>
<p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p>
<ul>
<li><p><strong>时间复杂度</strong>：$O(n)$，其中 n是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p>
</li>
<li><p><strong>空间复杂度</strong>：$O(n)$，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/14/2020-8-17-recognition-monostack/" data-id="ckfj5lo67000q3osc4xsmarpl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-8-14-what-is-UnionSet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/14/2020-8-14-what-is-UnionSet/" class="article-date">
  <time datetime="2020-08-14T02:23:45.000Z" itemprop="datePublished">2020-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/14/2020-8-14-what-is-UnionSet/">什么是并查集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是并查集（UnionSet）"><a href="#什么是并查集（UnionSet）" class="headerlink" title="什么是并查集（UnionSet）"></a>什么是并查集（UnionSet）</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">岛屿的数量</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">二维网格中探测环</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-division/">除法求值</a>（带权值）            </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a>（无向图）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection-ii">冗余连接II</a>(Hard)（有向图）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a>(DFS,BFS,UnionSet均可以做,DFS,BFS更优)</p>
</li>
<li><p><del>句子相似性2(VIP)</del></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">等式方程可满足性</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">连通网络操作次数</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/">按公因数计算最大组件大小</a>（hard）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/couples-holding-hands/">情侣牵手</a>（Hard）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/accounts-merge/">账户合并</a></p>
</li>
</ol>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">知乎传送门</a></p>
</blockquote>
<p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。</p>
<ul>
<li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合</li>
<li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合之中</li>
</ul>
<p>在连通性问题中（如岛屿问题），并查集很有作用。<strong>核心思想</strong>是连通区域内所有点的根节点其实是同一个。将每个点映射为一个数字。先假设每个点的根节点就是它们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋给另一个点的根节点，这样两个点所在的连通区域又相互连通了。</p>
<p>好的我们一步一步来画板子（ddrdd）：</p>
<p>并查集的主要操作有：</p>
<ul>
<li><code>find(int m)</code> :查找$m$的根节点</li>
<li><code>isConnected(int m, int n)</code>：判断$m,n$两个点是否在同一个连通区域。</li>
<li><code>Union(int m, int n)</code>:合并$m,n$两个点所在的连通区域。</li>
</ul>
<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n;i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p>
<p><strong>合并</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[find(i)] = find(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者.</p>
<p><strong>更新</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	<span class="keyword">if</span>(fa[i] != i) fa[i] = find(fa[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般在对所有节点merge之后需要整体更新，避免漏掉连通分支。</p>
<hr>
<p>初级并查集效率较低，我们需要进行<strong>路径压缩</strong>。</p>
<p>我们添加元素可能会形成长链，想要从底部寻找根节点会越来越难。路径压缩是这样一种算法，每个元素到根节点的路径尽可能短。</p>
<p>我们可以在查找的过程中，<u>把沿途每个节点的父节点都设为根节点</u>。</p>
<p><strong>路径压缩后合并</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==find(x)? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://picb.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg" alt="img"></p>
<p>我们得到的并查集是这样的，很像一棵二叉树。</p>
<p><strong>按秩合并</strong></p>
<p>按路径压缩后的并查集结构仍是毕竟复杂的，比如现在我们有一棵较复杂的树，与一个单元素进行合并：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg" alt="img"></p>
<p>那么是把7作为8的父节点好呢，还是8作为7父节点好呢：</p>
<p>当然是前者，因为后者会使树的深度加深。所以要<strong>把简单树往复杂树上合并。</strong></p>
<p>我们用于一个数组<code>rank[]</code>记录每个根节点对应树的深度。一开始，所有节点的秩设为1.合并时比较两个根节点，把秩小的往秩的根节点合并。</p>
<p><strong>初始化（按秩合并）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并（按秩合并）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i),y = find(j);</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &lt;= rank[y]) </span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span>(rank[x]==rank[y]&amp;&amp;x!=y)</span><br><span class="line">    &#123;<span class="comment">//如果秩相同，则新节点深度++</span></span><br><span class="line">        rank[y]++;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么根秩相同，深度要加1呢，如下图，我们有两个秩均为2 的树，现在要合并。</p>
<p><img src="https://picb.zhimg.com/80/v2-de356190829600f438058e8615c7a5ac_720w.jpg" alt="img"></p>
<p>我们把2的父节点设为5，这里深度加1，同样另一种合并方式也会使深度加1.</p>
<p><img src="https://pic2.zhimg.com/80/v2-a829932f008f000440942cb8df393662_720w.jpg" alt="img"></p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；</p>
<p>2、代表元法：采用 parent 数组实现，以每个结点的根结点作为代表元；</p>
<p>3、并查集的优化有两种策略：</p>
<p>（1）<strong>路径压缩</strong>；</p>
<p>有「隔代压缩」与「完全压缩」。</p>
<ul>
<li>「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。</li>
<li>「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/369467f220fbe37910fde8f354f59884f487210dc77a7d8bf6fd4edb467bdf6b-image.png" alt="image.png"></p>
<p>（2）按秩合并。</p>
<p>秩也有两种含义：</p>
<p>秩表示以当前结点为根结点的子树结点总数，即这里的「秩」表示 size 含义；<br>秩表示以当前结点为根结点的子树的高度，即这里的「秩」表示 rank 含义（更合理，因为查询时候的时间性能主要决定于树的高度）。<br>4、如果同时使用「路径压缩」与「按秩合并」，这里的「秩」就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的「参考」。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近 $O(1)$。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35090745">为什么并查集在路径压缩之后的时间复杂度是阿克曼函数?</a></p>
<hr>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1559-二维网格图中探测环"><a href="#1559-二维网格图中探测环" class="headerlink" title="1559. 二维网格图中探测环"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">1559. 二维网格图中探测环</a></h4><p>给你一个二维字符网格数组 <code>grid</code> ，大小为 <code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 <strong>相同值</strong> 形成的环。</p>
<p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值</strong> 。</p>
<p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> 是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p>
<p>如果 <code>grid</code> 中有相同值形成的环，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]</span><br><span class="line">输出：true</span><br><span class="line">解释：如下图所示，有 2 个用不同颜色标出来的环：</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png" alt="img"> </p>
<hr>
<p>利用并查集的思想，相同的字母可以形成一个连通区域，从左上角开始，遇到相同字母则进行合并，合并时若发现$x$和$y$与$parent$相同，即形成环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250100</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> p[N];</span><br><span class="line">    <span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">            x = find(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merget</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (find(a) != find(b)) &#123;</span><br><span class="line">            cnt[find(b)] += cnt[find(a)];</span><br><span class="line">            p[find(a)] = find(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span>&lt; n &amp;&amp; grid[i][j] == grid[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (find(i * m + j) == find((i + <span class="number">1</span>) * m + j)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p[find(i * m + j)] = find((i + <span class="number">1</span>) * m + j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j+<span class="number">1</span> &lt; m &amp;&amp; grid[i][j] == grid[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (find(i * m + j) == find(i * m + j + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p[find(i * m + j)] = find(i * m + j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="685-冗余连接II"><a href="#685-冗余连接II" class="headerlink" title="685. 冗余连接II"></a>685. 冗余连接II</h2><p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N-1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。</p>
<p>树中的每个节点都有一个父节点，除了根节点没有父节点。在多了一条附加的边之后，可能有以下两种情况：</p>
<ul>
<li><p>附加的边指向根节点，则包括根节点在内的每个节点都有一个父节点，此时图中一定有环路；</p>
</li>
<li><p>附加的边指向非根节点，则恰好有一个节点（即被附加的边指向的节点）有两个父节点，此时图中可能有环路也可能没有环路。</p>
</li>
</ul>
<blockquote>
<p><code>parent</code>用于保存上一个指向它的节点，仅此而已。</p>
</blockquote>
<p>在遍历图中的所有边之后，根据是否存在导致冲突的边和导致环路出现的边，得到附加的边。</p>
<ul>
<li><p>如果没有导致冲突的边，说明附加的边一定导致环路出现，而且是在环路中的最后一条被访问到的边，因此附加的边即为导致环路出现的边。</p>
</li>
<li><p>如果有导致冲突的边，记这条边为 $[u,v]$，则有两条边指向 v，另一条边为 $[\textit{parent}[v],v]$需要通过判断是否有导致环路的边决定哪条边是附加的边。</p>
</li>
<li><p>如果有导致环路的边，则附加的边不可能是 $[u,v]$（因为 $[u,v] $已经被记为导致冲突的边，不可能被记为导致环路出现的边），因此附加的边是 $[\textit{parent}[v],v]$。</p>
</li>
<li><p>如果没有导致环路的边，则附加的边是后被访问到的指向 v 的边，因此附加的边是 $[u,v]$。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    <span class="keyword">int</span> conflict;<span class="comment">//记录具有多个父节点的边编号</span></span><br><span class="line">    <span class="keyword">int</span> loop;<span class="comment">//记录生成环路的边编号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            fa.emplace_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x == fa[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路：并查集</span></span><br><span class="line">        <span class="comment">//此题与全连接I的区别是，无向图变为有向图</span></span><br><span class="line">        <span class="keyword">int</span> n = edges.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(n+<span class="number">1</span>)</span></span>; <span class="comment">//专门用于保存父节点，与并查集无关</span></span><br><span class="line">        init(n+<span class="number">1</span>);</span><br><span class="line">        conflict = loop = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;<span class="comment">//u -&gt; v</span></span><br><span class="line">            <span class="keyword">int</span> u = edges[i][<span class="number">0</span>], v = edges[i][<span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">int</span> pu = find(u), pv = find(v);            </span><br><span class="line">            <span class="keyword">if</span>(pv!=v) <span class="comment">// 说明 e[1]已经有父节点，存在冲突</span></span><br><span class="line">                conflict = i;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                <span class="keyword">if</span>(pv == pu)<span class="comment">//表示有环</span></span><br><span class="line">                &#123;</span><br><span class="line">                    loop = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> fa[pv] = pu;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;conf:%d,loop:%d\n&quot;</span>,conflict,loop);</span><br><span class="line">        <span class="comment">//接下来需要判断哪个边导致了冗余</span></span><br><span class="line">        <span class="keyword">if</span>(conflict&lt;<span class="number">0</span>)<span class="comment">//说明没有冲突，附加的边为环路最后出现的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> edges[loop];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//若存在冲突，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(loop &lt; <span class="number">0</span>)<span class="comment">//没有环	</span></span><br><span class="line">            <span class="keyword">return</span> edges[conflict];</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//既有冲突也有环，则不可能是冲突的那一条边</span></span><br><span class="line">            <span class="keyword">return</span> &#123;parent[edges[conflict][<span class="number">1</span>]],edges[conflict][<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度: $O(N \log N)$</p>
<p>空间复杂度：$O(N)$</p>
<hr>
<h2 id="952-按公因式计算最大组件的大小"><a href="#952-按公因式计算最大组件的大小" class="headerlink" title="952.按公因式计算最大组件的大小"></a>952.按公因式计算最大组件的大小</h2><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：</p>
<p>有 <code>A.length</code> 个节点，按从 <code>A[0] </code>到 <code>A[A.length - 1]</code> 标记；<br>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j] </code>之间才有一条边。<br>返回图中最大连通组件的大小。</p>
<p>示例 1：</p>
<p>输入：[4,6,15,35]<br>输出：4</p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex1.png" alt="img" style="zoom:33%;" />

<p>示例 2：</p>
<p>输入：[20,50,9,63]<br>输出：2</p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex2.png" alt="img" style="zoom:33%;" />

<p>示例 3：</p>
<p>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex3.png" alt="img" style="zoom:33%;" />

<p>提示：</p>
<p><code>1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 100000</code></p>
<hr>
<p>按照并查集的思路求解</p>
<p>设$W = max(A[i]), R = \sqrt{W}$，对于数组中每个数，最多只有一个非本身的质因数$p$满足$p\ge R$。这就意味最多只有$R+A.length$个不同的质因数。质因数为本身的最多$A.length$个，非本身的质因数一定比$R$小，最多$R$个。</p>
<p>我们可以提取$A$中每个数的质因数，对每个质因数建立索引，然后利用并查集。</p>
<p><img src="https://pic.leetcode-cn.com/ca07130ef4f7e002de91efa0b9962cbf18d8277ffa7f744023c4f64c16d78cb4-952-1.png" alt="952-1.png"></p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            fa.emplace_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">while</span>(x != fa[x])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(i), y = find(j);</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestComponentSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="comment">//这题是并查集的经典应用</span></span><br><span class="line">    <span class="comment">//因为A的长度很大，不能采用双重循环遍历</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factor[n];<span class="comment">//质因数索引</span></span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a :A) maxVal = max(maxVal,a);</span><br><span class="line">    init(maxVal+<span class="number">1</span>);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a:A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            merge(a,i);</span><br><span class="line">            merge(a,a/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将A中的数映射为代表元,看那一些出现过</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(maxVal+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt [find(A[i])]++;</span><br><span class="line">        res = max(res, cnt [find(A[i])]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(N \sqrt{W})$，其中 $N$ 是 A 的长度，$W = \max(A[i])$。</p>
<p>空间复杂度： $O(M)$, 分别用了$fa$和$cnt$数组，$M$表示数组最大值。</p>
<hr>
<h2 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a>765. 情侣牵手</h2><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p>
<p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p>
<p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: row &#x3D; [0, 2, 1, 3]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 我们只需要交换row[1]和row[2]的位置即可。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: row &#x3D; [3, 2, 0, 1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 无需交换座位，所有的情侣都已经可以手牵手了。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li>
<li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li>
</ol>
<hr>
<ol>
<li><strong>贪心解法</strong></li>
</ol>
<p>我们考虑每队情侣都由奇数编号和偶数编号组成，因为情侣数量有限，我们可以遍历所有情侣中编号为偶数的<code>1,2,4,6...2*N</code>， 对相应的奇数情侣交换，每交换一次则<code>res++</code>。具体地，如果偶数情侣位于偶数位置$i$，则奇数情侣位置一定是$i+1$, 否则，奇数情侣位置为$i-1$。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Map&lt;Integer,Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="comment">//记录数字的位置</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] row, <span class="keyword">int</span> i, <span class="keyword">int</span> direct)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp, temp2;</span><br><span class="line">        temp = memo.get(i+<span class="number">1</span>);</span><br><span class="line">        memo.put(row[memo.get(i)+direct],temp);</span><br><span class="line">        memo.put(i+<span class="number">1</span>,memo.get(i)+direct);</span><br><span class="line">        temp2 = row[temp];</span><br><span class="line">        row[temp] = row[memo.get(i)+direct] ;</span><br><span class="line">        row[memo.get(i)+direct] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="keyword">int</span>[] row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = row.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) memo.put(row[i],i);</span><br><span class="line">        <span class="comment">//我们只移动奇数，如果偶数位置是偶数，那么相邻奇数位置在右边，否则在左边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(memo.get(i) %<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(memo.get(i+<span class="number">1</span>) == memo.get(i)+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                swap(row,i,<span class="number">1</span>);</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(memo.get(i+<span class="number">1</span>) == memo.get(i)-<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                swap(row,i,-<span class="number">1</span>);</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>:$O(N)$.</p>
<p>空间复杂度:$O(N)$,使用了一个长度为$N$哈希表。</p>
<ol start="2">
<li><strong>并查集</strong></li>
</ol>
<p>我们重点放在并查集解法上。</p>
<p>我们设想一下加入有两对情侣互相坐错了位置，我们至多只需要换一次。<br>如果3对情侣相互坐错了位置，$A1+B2,B1+C2,C1+A2$。他们三个之间形成了一个连通图，我们只需要交换两次。<br>如果4对情侣相互坐错了位置，即这4对情侣不与其他情侣坐在一起，$A1+B2,B1+C2,C1+D2,D1+A2$.他们四个之间形成了一个连通图，他们只需要交换三次并且不用和其他情侣交换，就可以将这四对情侣交换好，<br>以此类推，其实就是假设k对情侣形成一个环状的错误链，我们<strong>最少</strong>需要交换k - 1次就可以将这k对情侣的位置排好。</p>
<blockquote>
<p>所以问题转化成$N$对情侣中，有几个这样的错误环。我们可以使用并查集来处理，每次遍历相邻的两个位置，如果他们本来就是情侣，他们处于大小为1的错误环中，只需要交换0次。如果不是情侣，说明他们两对处在同一个错误环中，我们将他们合并（union），将所有的错坐情侣合并和后，答案就是情侣对 - 环个数。<br>这也说明，最差的情况就是所有N对情侣都在一个环中，这时候我们需要$N - 1$调换。<br>最好情况每对情侣已经坐好了，已经有N个大小为1的环，这时候我们需要$N - N$次调换。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa,rank;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != fa[x]) fa[x] = getfa(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = getfa(x),fy = getfa(y);</span><br><span class="line">        <span class="keyword">if</span>(fx != fy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rank[fx] &lt; rank[fy])</span><br><span class="line">            &#123;</span><br><span class="line">                fa[fx] = fy;</span><br><span class="line">                rank[fy] += rank[fx];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fa[fy] = fx;</span><br><span class="line">                rank[fx] += rank[fy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.size(),m = n / <span class="number">2</span>,res = <span class="number">0</span>,circle = <span class="number">0</span>;</span><br><span class="line">        fa = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>),rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i ++) fa[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i += <span class="number">2</span>)</span><br><span class="line">            uni(row[i] / <span class="number">2</span>,row[i + <span class="number">1</span>] / <span class="number">2</span>);<span class="comment">//本来是情侣的话，两者肯定相等，不会合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i ++)</span><br><span class="line">            <span class="keyword">if</span>(i == getfa(i))</span><br><span class="line">                circle ++;</span><br><span class="line">        <span class="keyword">return</span> m - circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/14/2020-8-14-what-is-UnionSet/" data-id="ckfj5lo78001t3osc8e7n61xk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A2%ABOiers%E8%A7%86%E4%BD%9C%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%97%E6%B3%95/" rel="tag">被Oiers视作优雅的算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-8-20-what-is-Trie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/14/2020-8-20-what-is-Trie/" class="article-date">
  <time datetime="2020-08-14T02:23:45.000Z" itemprop="datePublished">2020-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/14/2020-8-20-what-is-Trie/">什么是前缀树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="lt-面试热点-gt-什么是前缀树Trie和前缀和？如何实现？"><a href="#lt-面试热点-gt-什么是前缀树Trie和前缀和？如何实现？" class="headerlink" title="&lt;面试热点&gt;什么是前缀树Trie和前缀和？如何实现？"></a>&lt;面试热点&gt;什么是前缀树Trie和前缀和？如何实现？</h1><blockquote>
<p>前缀树又名<strong>Tries树</strong>、<strong>字典</strong>树、单词查找树等，常用于快速检索，大量字符串的排序和统计等。</p>
<p>LC208.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现前缀树</a> - 制作板子</p>
<p>LC336.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-pairs/">回文对</a> - 结合回文</p>
<p>LC212.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search-ii/">单词搜索 II </a>- 类似 Boggle 的游戏。</p>
</blockquote>
<p><strong>三个基本性质</strong></p>
<ol>
<li>根节点不包含字符，除根节点外每个节点只包含一个字符</li>
<li>从根节点到某个节点，路径上所有的字符连在一起，就是这个节点所对应的字符串</li>
<li>每个节点的子节点所包含的字符都不同</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1038472-736d2bc3ddd4b1cc.png?imageMogr2/auto-orient/strip" alt="Trie"></p>
<p><strong>应用场景</strong>：</p>
<p>1.自动补全</p>
<p><img src="https://pic.leetcode-cn.com/963cd3fc83e9618aba9cb78365c8a5bf6b7cef8967da0d204dede7844f6738f2-file_1562596867150" alt="自动补全"></p>
<p align="center" style="font:italic;color:gray"><i>图1. 谷歌的搜索建议</i></p>

<ol start="2">
<li>拼写检查</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/4d18efbdd4d51ae3935b42cd59b11d66fb62f1586b9638f9499d2a18fa8919d0-image.png" alt="image.png"></p>
<p align="center" style="font:italic;color:gray"><i>图2. 拼写检查</i></p>

<p>3.IP路由（最长前缀匹配）</p>
<p><img src="https://pic.leetcode-cn.com/e3f22b3ab2df82e6c0a7880996749b5e62707e9ef925876e583d666343644526-file_1562596867150" alt="无效的图片地址"></p>
<p align="center"><i>图 3. 使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</i></p>

<ol start="4">
<li>T9打字预测</li>
<li>Boggle单词游戏</li>
</ol>
<p>还有现成的高效结构如哈希表和平衡树，但为什么我们还要用前缀树呢，因为它有如下优势：</p>
<ul>
<li>找到具有同一前缀的全部键值</li>
<li>按词典枚举字符串的数据集</li>
</ul>
<p>Trie相比于哈希表的另一个优势是，随着哈希表长度增加，会出现大量冲突，时间复杂度可能会增加到$O(N)$. trie树子存储多个具有相同前缀的键时所用空间较少。因此前缀树只需要$O(m)$的空间，m为键长度。而在平衡树中需要$O(m\log n)$。</p>
<h2 id="设计Trie树"><a href="#设计Trie树" class="headerlink" title="设计Trie树"></a><strong>设计Trie树</strong></h2><p><strong>初始化</strong></p>
<p>我们设计一个Trie节点<code>node</code>具有如下属性：</p>
<ul>
<li>子树数组：因为字母表长度为26，所以数组长度为26；</li>
<li>结束标记，bool型表示，比如”apple”和”app”,后者是前者一个前缀，所以需要结束标记。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie()</span><br><span class="line">    &#123;</span><br><span class="line">		isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>插入键值</strong></p>
<p>我们从字符串头开始，如果字符<code>s[i]</code>存在于当前节点的子树数组中，那么我们直接递归进入该节点，否则我们创造新节点，再进入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie *node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c:word)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)</span><br><span class="line">        node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie(c);</span><br><span class="line">        node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里我们把this作为根节点。所以每次new一个node都会产生一个根节点。  </p>
<ul>
<li>时间复杂度：$O(m)$，其中 $m$ 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 $m$ 次操作。</li>
</ul>
<ul>
<li>空间复杂度：$O(m)$。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 $m$ 个结点，使用 $O(m)$ 空间。</li>
</ul>
<p><strong>查找键值</strong></p>
<p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始。检查当前节点中与键字符对应的链接。有两种情况：</p>
<p>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。<br>不存在链接。若已无键字符，且当前结点标记为 End，则返回 true。否则有两种可能，均返回 false :<br>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。<br>没有键字符剩余，但当前结点没有标记为 End。也就是说，待查找键只是Trie树中另一个键的前缀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c:word)</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 : $O(m)$。算法的每一步均搜索下一个键字符。最坏的情况下需要 $m$ 次操作。</li>
<li>空间复杂度 : $O(1)$。</li>
</ul>
<p><strong>查找 Trie 树中的键前缀</strong><br>该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “End” 标记，因为我们搜索的是键的前缀，而不是整个键。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> startWith&#123;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="keyword">this</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   Trie* node = <span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c:word)</span><br><span class="line">   &#123;</span><br><span class="line">   node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">   <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 : $O(m)$。算法的每一步均搜索下一个键字符。最坏的情况下需要 $m$ 次操作。</li>
<li>空间复杂度 : $O(1)$。</li>
</ul>
<hr>
<h2 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a>336. 回文对</h2><p>给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]</span><br><span class="line">输出：[[0,1],[1,0],[3,2],[2,4]] </span><br><span class="line">解释：可拼接成的回文串为 [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]</span><br><span class="line">输出：[[0,1],[1,0]] </span><br><span class="line">解释：可拼接成的回文串为 [&quot;battab&quot;,&quot;tabbat&quot;]</span><br></pre></td></tr></table></figure>

<hr>
<p>假设存在两个字符串$s1和s2$, $s1+s2$是一个回文串，记它们的长度分别为$len1和len2$.分情况进行讨论：</p>
<ol>
<li>$len1==len2$，此时$s1$是$s2$的翻转。</li>
<li>$len1&gt;len2$，此时仍然可以在$s1$找到一个前缀$s1’==s2$.</li>
<li>$len2&lt;len1$，同上。</li>
</ol>
<p><strong>注意</strong>：空串也是回文串。比如$s1=”aa”,s2=””$.</p>
<p>要实现这些操作，我们只需要设计一种能够在一系列字符串中查询「某个字符串的子串的翻转」是否存在的数据结构，有两种实现方法：</p>
<ol>
<li>我们可以使用字典树存储所有的字符串。在进行查询时，我们将待查询的子串<strong>逆序</strong>地在字典树上进行遍历，即可判断其是否存在。</li>
<li>我们可以使用哈希表存储所有字符串的翻转。在进行查询时，我们判断查询串是否在哈希表中出现，就可以判断其翻转子串是否存在。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; child;</span><br><span class="line">    <span class="keyword">bool</span> end;<span class="comment">//结束的标志，表示在该节点结束</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//该字符的下标，与end对应，默认-1，表示不存在</span></span><br><span class="line">    <span class="keyword">char</span> val; </span><br><span class="line">    Trie() &#123;</span><br><span class="line">        val = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        end = <span class="literal">false</span>;</span><br><span class="line">        index = <span class="number">-1</span>;</span><br><span class="line">        child.resize(<span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Trie(<span class="keyword">char</span> c) &#123;</span><br><span class="line">        val = c;</span><br><span class="line">        end = <span class="literal">false</span>;</span><br><span class="line">        index = <span class="number">-1</span>;</span><br><span class="line">        child.resize(<span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _insert(Trie* node, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=word.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;end = <span class="literal">true</span>;</span><br><span class="line">            node-&gt;index = index;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">auto</span> &amp;n = node-&gt;child[(<span class="keyword">int</span>)(word[i]-<span class="string">&#x27;a&#x27;</span>)];</span><br><span class="line">         n = (n == <span class="literal">nullptr</span>)?<span class="keyword">new</span> Trie(word[i]):n;</span><br><span class="line">        _insert(n,word,i+<span class="number">1</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//root does not save char</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>) <span class="keyword">return</span>;</span><br><span class="line">        _insert(<span class="keyword">this</span>,word,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="keyword">void</span> _search(<span class="built_in">string</span> mode, Trie *node, <span class="built_in">string</span> s, <span class="keyword">int</span> i,<span class="keyword">bool</span> &amp;isExist,<span class="keyword">int</span> &amp;index)</span><br><span class="line">    &#123;<span class="comment">//递归搜索，s为字符串，i为编号</span></span><br><span class="line">      <span class="comment">// 上一个字符搜索到了才进行下一次搜索</span></span><br><span class="line">       <span class="keyword">if</span>(i&lt;s.size()&amp;&amp;node-&gt;child[(<span class="keyword">int</span>)(s[i]-<span class="string">&#x27;a&#x27;</span>)] &amp;&amp;node-&gt;child[(<span class="keyword">int</span>)(s[i]-<span class="string">&#x27;a&#x27;</span>)]-&gt;val==s[i]&amp;&amp;!isExist) </span><br><span class="line">        _search(mode,node-&gt;child[(<span class="keyword">int</span>)(s[i]-<span class="string">&#x27;a&#x27;</span>)],s,i+<span class="number">1</span>,isExist,index);</span><br><span class="line">        <span class="keyword">if</span>(!isExist)</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="string">&quot;search&quot;</span>) isExist = (i==s.size()&amp;&amp;node-&gt;end);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="string">&quot;prefix&quot;</span>) isExist = (i==s.size());</span><br><span class="line">        <span class="keyword">if</span>(isExist&amp;&amp;index==<span class="number">-1</span>) </span><br><span class="line">        index = node-&gt;index;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isExist = <span class="literal">false</span>; <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">        _search(<span class="string">&quot;search&quot;</span>,<span class="keyword">this</span>,word,<span class="number">0</span>,isExist,i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isExist = <span class="literal">false</span>;<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        _search(<span class="string">&quot;prefix&quot;</span>,<span class="keyword">this</span>,prefix,<span class="number">0</span>,isExist,i);</span><br><span class="line">        <span class="keyword">return</span> isExist;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//字典树版本</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;a,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n/<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i+left]!=a[right-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">palindromePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!words.size()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        Trie  tr;</span><br><span class="line">        <span class="comment">//将所有单词加入前缀树中</span></span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">         tr.insert(words[i],i);</span><br><span class="line">        <span class="comment">//遍历任意两个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m = words[i].size();</span><br><span class="line">            <span class="built_in">string</span> sub = words[i];</span><br><span class="line">            reverse(sub.begin(),sub.end());</span><br><span class="line">            <span class="keyword">int</span> index = tr.search(sub);</span><br><span class="line">            <span class="keyword">if</span>(index!=<span class="number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;i,index&#125;);</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(words[i],<span class="number">0</span>,m<span class="number">-1</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> index = tr.search(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(index!=<span class="number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;index,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(j&amp;&amp;isPalindrome(words[i],<span class="number">0</span>,j<span class="number">-1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> sub = words[i].substr(j,m-j);</span><br><span class="line">                    reverse(sub.begin(),sub.end());</span><br><span class="line">                    <span class="keyword">int</span> index = tr.search(sub);</span><br><span class="line">                    <span class="keyword">if</span>(index!=<span class="number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;index,i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(words[i],j,m<span class="number">-1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> sub = words[i].substr(<span class="number">0</span>,j);</span><br><span class="line">                    reverse(sub.begin(),sub.end());</span><br><span class="line">                    <span class="keyword">int</span> index = tr.search(sub);</span><br><span class="line">                    <span class="keyword">if</span>(index!=<span class="number">-1</span>&amp;&amp;index!=i) res.push_back(&#123;i,index&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: $O(N*M^2)$, $N$为字符数组总长度，$M$为字符串平均长度。</p>
<p>空间复杂度: $O(N*M)$。实际上由于字符前缀重合，用不到这么多空间。</p>
<hr>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><ul>
<li><ol start="560">
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为k的子数组</a>(Medium)</li>
</ol>
</li>
<li><ol start="1371">
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含最长的子字符串</a>(Medium)</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></li>
</ul>
<hr>
<h2 id="560-和为k的子数组-Medium"><a href="#560-和为k的子数组-Medium" class="headerlink" title="560.和为k的子数组(Medium)"></a><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560.和为k的子数组</a>(Medium)</strong></h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</p>
<hr>
<p>定义$pre[i]$表示$[0…i]$所有数之和,那么范围$[j-i]$可以表示为: $pre[i]-pre[j-1]$,  且$pre[i] = pre[i-1] + nums[i]$ , 问题转化为,</p>
<p>找到有多少个区间,满足$pre[i]-pre[j-1]==k$. 所以我们考虑以 $i$ 结尾的和为 $k$ 的连续子数组个数时只要统计有多少个前缀和为 $\textit{pre}[i]-k$的 $\textit{pre}[j]$ 即可。我们建立哈希表 $\textit{mp}$，以和为键，出现次数为对应的值，记录 $\textit{pre}[i]$ 出现的次数，从左往右边更新 $\textit{mp}$边计算答案，那么以 $i$ 结尾的答案 $\textit{mp}[\textit{pre}[i]-k]$ 即可在 $O(1)$ 时间内得到。最后的答案即为所有下标结尾的和为 $k$ 的子数组个数之和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数组长度和k都非常大，因此要尽量在线性时间复杂度解决</span></span><br><span class="line">        <span class="comment">//我们尝试动态规划解决,</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]==k;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; memo;<span class="comment">//记录和的个数</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(memo.count(pre-k))</span><br><span class="line">            res += memo[pre-k];</span><br><span class="line">            memo[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1371-每个元音包含最长的子字符串-Medium"><a href="#1371-每个元音包含最长的子字符串-Medium" class="headerlink" title="1371,每个元音包含最长的子字符串(Medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371,每个元音包含最长的子字符串</a>(Medium)</h2><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcodeisgreat&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p><code>1 &lt;= s.length &lt;= 5 x 10^5 s 只包含小写英文字母。</code></p>
<p>定义$pre[i][k]$表示前$i$个字母，第$k$个元音字母总出现的次数。那么在$[i-1,j-1]$区间内，元音字母出现次数为$pre[j][k]-pre[i][k]$，在$O(1)$时间内得到第$k$个元音字母出现的次数。</p>
<p>同时我们要考虑避免枚举所有的$i$，计算以它结尾的满足条件的最长子字符串长度，我们要找到最小$i$使得$pre[j][k]-pre[i][k]$均为偶数。 我们需要利用【所有元音出现偶数次】这个条件，对于满足条件的子串而言，$pre[i][k]$和$pre[j][k]$的奇偶性一定相同，因为偶数一定是奇数+奇数，或者偶数+偶数组成。所以我们可以把$pre[i][k]$改为表示$[0,i-1]$的<strong>元音奇偶性</strong>。</p>
<p>此外我们还需要进行「状态压缩」：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: cnta, &#x2F;&#x2F; a 出现次数的奇偶性</span><br><span class="line">  e: cnte, &#x2F;&#x2F; e 出现次数的奇偶性</span><br><span class="line">  i: cnti, &#x2F;&#x2F; i 出现次数的奇偶性</span><br><span class="line">  o: cnto, &#x2F;&#x2F; o 出现次数的奇偶性</span><br><span class="line">  u: cntu  &#x2F;&#x2F; u 出现次数的奇偶性</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以用二进制表示这些奇偶。</p>
<p>举一个例子，假如到第 $i $个位置，<code>u o i e a </code>出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 $(11001)<em>2=(25)</em>{10}$ 作为它的状态。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), res = <span class="number">0</span>, status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; vowel&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;e&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;i&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;o&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">3</span>&#125;,&#123;<span class="string">&#x27;u&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">4</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 我们用pre[status]表示status状态对应的位置i，不断更新</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">5</span>,<span class="number">-1</span>)</span></span>;<span class="comment">//初始均为偶</span></span><br><span class="line">        pre[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始状态，所有元音为偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vowel.count(s[i<span class="number">-1</span>]))</span><br><span class="line">            status ^= vowel[s[i<span class="number">-1</span>]];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(~pre[status]) res = max(res,i - pre[status]); <span class="comment">//pre[status]!=-1</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                pre[status] = i ;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 18行的 ~pre[status]表示<strong>按位取反</strong>，包含了符号位，所以只有pre[status]不为-1，才为True。</p>
<p>$ \text{~} 0 = -1$， </p>
</blockquote>
<p>时间复杂度: $O(N)$. $N$为字符串长度。</p>
<p>空间复杂度: $O(1)$.</p>
<h2 id="扩展：删除元素"><a href="#扩展：删除元素" class="headerlink" title="扩展：删除元素"></a>扩展：删除元素</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uDar0F7x9w5F3sHOB5tIDA">https://mp.weixin.qq.com/s/uDar0F7x9w5F3sHOB5tIDA</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/14/2020-8-20-what-is-Trie/" data-id="ckfj5lo7a001v3osc9dfl26yk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E6%A0%91/" rel="tag">前缀树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">经典数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-8-12-dfs-bfs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/2020-8-12-dfs-bfs/" class="article-date">
  <time datetime="2020-08-10T05:23:45.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/2020-8-12-dfs-bfs/">专题:DFS&amp;BFS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="专题-DFS-amp-BFS"><a href="#专题-DFS-amp-BFS" class="headerlink" title="专题:DFS&amp;BFS"></a>专题:DFS&amp;BFS</h1><blockquote>
<p> DFS:深度优先搜索，BFS：广度优先搜索，是最频繁被考察的算法知识点之一。我们来找一些例题专门研究一下。</p>
</blockquote>
<p>二叉树里面的三种遍历既可以用DFS（递归写法），也可以用BFS（迭代+栈），而层序遍历对应的就是BFS。</p>
<p>在图论中，DFS是万金油算法，其衍生的如Dijisktra(优先队列)，SPFA算法是<strong>最短路</strong>的主流算法。</p>
<p>下面介绍一类二维矩阵中典型的「岛屿问题」，来加深理解，在整体DFS框架中又隐藏一些彩蛋，加以利用的话可以极大的优化算法。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">L200. 岛屿数量</a> （Easy）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">L130.被围绕的区域 (Medium)</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a> （Easy）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> （Medium）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a> （Hard）</li>
</ul>
<hr>
<h2 id="1-被围绕的区域"><a href="#1-被围绕的区域" class="headerlink" title="1.被围绕的区域"></a>1.被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<hr>
<p><strong>思路</strong>：常规的想法是在矩阵中找到所有湖然后判断其是否与边界0相连，显然，这不是一个很好的注意，有可能一开碰到边界，也有可能最后找到边界，也有可能中间碰到边界。</p>
<p>所以此时需要换一种思路，我们找到一个「DFS触发条件」，以减少任务量，一种思路是从四个边界出发，如果为<code>&#39;O&#39;</code>，则进入DFS，将所有的<code>&#39;O&#39;</code>改为<code>&#39;A&#39;</code>，之后遍历完之后，将所有剩余的<code>&#39;O&#39;</code>改为<code>&#39;X&#39;</code>即可。</p>
<h2 id="2-岛屿的数量"><a href="#2-岛屿的数量" class="headerlink" title="2. 岛屿的数量"></a>2. 岛屿的数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>



<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
<hr>
<p><strong>思路：</strong>同样地，我们判断一个岛屿与哪些1相连是很困难的，因此需要转换思路，我们把「DFS触发条件」设定为<code>grid[x][y]==&#39;1&#39;</code>，此时岛屿数量加1，把遍历过的点改为0.即可。</p>
<p><strong>时间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。</p>
<p><strong>空间复杂度：</strong>$O(N×M)$，$N,M$分别为矩阵的大小。在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 $M×N$。</p>
<h2 id="3-最大人工岛（Hard）"><a href="#3-最大人工岛（Hard）" class="headerlink" title="3. 最大人工岛（Hard）"></a>3. 最大人工岛（Hard）</h2><p>在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。</p>
<p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 0], [0, 1]]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 1], [1, 0]]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 将一格0变成1，岛屿的面积扩大为 4。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1, 1], [1, 1]]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 没有0可以让我们变成1，面积依然为 4。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; grid.length &#x3D; grid[0].length &lt;&#x3D; 50</span><br><span class="line">0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 1</span><br></pre></td></tr></table></figure>

<hr>
<p>在解这道题之前，我们需要想到一些边界情况;</p>
<ol>
<li>全为陆地，则无法填海，<code>maxArea = m*n</code>,m,n分别为地图横纵尺寸。</li>
<li>全为海洋，则仍可以填岛，<code>maxArea = 1</code>.</li>
<li>只有一座连通岛，那么此时填充的作用仅仅是扩大面积而不是连通相邻的岛，<code>maxArea = maxArea+1</code>.</li>
</ol>
<p>那么如何填充使得面积最大，这个通过题目的简单例子是无法感受到的，比如下面这种情况<br>$$<br>[[0,0,1,0,0,0,0,1,0,0,0,0,0],\<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],\<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],\<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],\<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],\<br> [0,0,0,0,0,0,0,0,0,@,*,0,0],\<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],\<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]\<br>$$<br>（1）<code>@=0,*=0</code>,此时可以把@变为1，最大面积为<code>5+5+1=11</code>。</p>
<p>（2）<code>@=0,*=1</code>,此时可以把@变为1或者*下方的0变为1，最大面积为<code>6+5+1=12</code>。</p>
<p><strong>思路</strong>：把连通岛编号<code>index(&gt;=2)</code>。统计每个人工岛的最大面积（通过dfs）。然后再遍历地图，把所有为<code>0</code>的地方，<u>研究其是否连接<em>至少</em>两个岛，即上下左右方向链接不同<code>index</code>的岛屿。</u></p>
<p>这样的话，我们就能兼顾所有情况。C++代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m,n,maxArea,index;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; base_area;<span class="comment">//基础面积哈希表</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; d = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">outRange</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;=m||y&gt;=n||x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>) ;<span class="comment">//越界检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> &amp;area)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//找到至少两个index不相等的岛屿，并统计它们的面积</span></span><br><span class="line">        <span class="keyword">int</span> base_index = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!outRange(x+d[i][<span class="number">0</span>],y+d[i][<span class="number">1</span>])&amp;&amp;grid[x+d[i][<span class="number">0</span>]][y+d[i][<span class="number">1</span>]]) </span><br><span class="line">            &#123;</span><br><span class="line">                base_index = grid[x+d[i][<span class="number">0</span>]][y+d[i][<span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span>(!count(temp.begin(),temp.end(),base_index))area += base_area[base_index];</span><br><span class="line">                temp[i] = base_index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> &amp;area)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot;,y:&quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(outRange(x,y)|| grid[x][y]!=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[x][y] = index;<span class="comment">//已经走过的陆地标记为index</span></span><br><span class="line">        area+=<span class="number">1</span>;</span><br><span class="line">        dfs(x+<span class="number">1</span>,y,grid,area); </span><br><span class="line">        dfs(x<span class="number">-1</span>,y,grid,area); </span><br><span class="line">        dfs(x,y+<span class="number">1</span>,grid,area); </span><br><span class="line">        dfs(x,y<span class="number">-1</span>,grid,area); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!grid.size()||!grid[<span class="number">0</span>].size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.size();</span><br><span class="line">        n = grid[<span class="number">0</span>].size();</span><br><span class="line">        maxArea = <span class="number">0</span>;</span><br><span class="line">        index = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1.研究基础未填岛情况，把各个岛屿的面积保存再哈希表中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">            dfs(i,j,grid,area);</span><br><span class="line">            base_area[index] = area;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;,area:&quot;</span>&lt;&lt;base_area[index]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            index++;   </span><br><span class="line">            maxArea = max(maxArea,area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.研究填岛情况，遍历所有的0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//如果&lt;u&gt;研究其是否连接*至少*两个岛，即上下左右方向链接不同`index`的岛屿</span></span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">            connect(i,j,grid,area);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;,area:&quot;</span>&lt;&lt;area&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            maxArea = max(area,maxArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//研究几种需要填岛的特殊情况</span></span><br><span class="line">        <span class="comment">//1.没有陆地 maxArea==0</span></span><br><span class="line">        <span class="comment">//2.最大面积岛屿旁边没有相邻岛maxArea!=0, max_fillArea==0</span></span><br><span class="line">        <span class="keyword">if</span>(maxArea==(m*n)) <span class="keyword">return</span> m*n;</span><br><span class="line">        <span class="keyword">return</span> maxArea+<span class="number">1</span>;<span class="comment">//没有海洋或没有岛</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间和空间可以根据代码进行分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/10/2020-8-12-dfs-bfs/" data-id="ckfj5lo65000o3osccr3d170h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS-BFS/" rel="tag">DFS&BFS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-9-12-minimal-Spanning-tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/10/2020-9-12-minimal-Spanning-tree/" class="article-date">
  <time datetime="2020-08-10T05:23:45.000Z" itemprop="datePublished">2020-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/10/2020-9-12-minimal-Spanning-tree/">专题:DFS&amp;BFS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="最小生成树的两种方法（Kruskal算法和Prim算法）"><a href="#最小生成树的两种方法（Kruskal算法和Prim算法）" class="headerlink" title="最小生成树的两种方法（Kruskal算法和Prim算法）"></a>最小生成树的两种方法（Kruskal算法和Prim算法）</h1><hr>
<ul>
<li><ol start="1584">
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点最小费用</a></li>
</ol>
</li>
</ul>
<blockquote>
<p>最小生成树（$Minimal \ Spanning \ Tree,MST$）：有 n 个结点的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。比较常用的有两种算法：$Kruskal$算法和$Prim$算法。</p>
</blockquote>
<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>被称为“加边法”，初始最小生成树的边数是0，每迭代一次就寻找满足条件的最小代价边，加入到最小生成树集合中去。</p>
<ol>
<li>把图中所有边按照<strong>从小到大</strong>的顺序排序。</li>
<li>把图中$n$个顶点看成独立的$n$棵树组成的森林。</li>
<li>按权值从小到大选择边，所选的边连接的两个顶点$u_i,v_i$应该属于两个不同的树（否则会形成环），则称为最小生成树的一条边，并将这两棵树作为一棵树。</li>
<li>重复<code>3.</code>。直到所有的顶点都在一棵树内，或者有$n-1$条边为止。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1599997366-bsvjKQ-file_1599997368379" alt="MST示意图"></p>
<p>和并查集的概念非常相似。Kruskal算法可以看成是基于并查集的贪心算法。    </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> res,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> e1, e2;<span class="comment">//两个端点的编号</span></span><br><span class="line">        <span class="keyword">int</span> Mahattan_dis;<span class="comment">//曼哈顿距离</span></span><br><span class="line">        edge(<span class="keyword">int</span> e1,<span class="keyword">int</span> e2, <span class="keyword">int</span> m):e1(e1),e2(e2),Mahattan_dis(m)&#123;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> edge&amp; other) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Mahattan_dis &lt; other.Mahattan_dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mahattan</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = points.size();</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line">    res  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        edges.emplace_back(i,j,Mahattan(points,i,j)); </span><br><span class="line">    &#125;   </span><br><span class="line">    sort(edges.begin(),edges.end());<span class="comment">//按从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> num = n;<span class="comment">//独立的子树的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(merge(e.e1,e.e2))</span><br><span class="line">        &#123;</span><br><span class="line">            res += e.Mahattan_dis;</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> res;<span class="comment">//最后只有一个连通图则返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) </span><br><span class="line">            fa.emplace_back(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x] == x) </span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        fa[x] = find(fa[x]); </span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//合并的两条边必须是不同子树</span></span><br><span class="line">        <span class="keyword">int</span> x = find(i),y = find(j);</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：为了使得自定义结构体edge能够进行排序操作，我们不能把数组edges写成<code>vector&lt;edge*&gt; edges</code>这样的话是对指针指向的地址进行排序，而不是对曼哈顿距离排序。</p>
</blockquote>
<p>时间复杂度：$O(V^2)$,$V$为边的个数，等于$N-1$。</p>
<p>空间复杂度：$O(N)$, 包括并查集用的父数组和自定义数据结构edge。</p>
<hr>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>此算法又被称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树之中，算法从某一个顶点开始，逐渐扩散覆盖整个网络。比较适合<strong>稠密网络</strong>。</p>
<ol>
<li>图的所有顶点集合为V；初始令集合$u=s,v=V-u$.</li>
<li>在两个集合$u,v$所构成的边中，选择一条代价最小的边。</li>
<li>重复上述步骤，直到最小生成树有$n-1$条边，或者只有一棵树为止。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1599997366-aPWWkJ-file_1599997368384" alt="这里写图片描述"></p>
<p>我们注意到我们每次添加的都是最小边，因此可以用小顶堆来存储。 Prim算法更像是Dijkstra算法。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> res,n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mahattan</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="keyword">const</span> &amp;left, T <span class="keyword">const</span> &amp;right)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="comment">// 以y比较。输出结果为y较大的在前y相同时，先进入队列的元素在前。</span></span><br><span class="line">            <span class="keyword">return</span> (left.second &gt; right.second); <span class="comment">// left.first在后面，顶部元素first最大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Prim 算法又被称为加点法</span></span><br><span class="line">    <span class="keyword">int</span> n = points.size();</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//任选一个点作为起始点，没有必要构建边，</span></span><br><span class="line">    <span class="comment">//遍历小顶堆，每次从中取出代价最小的边，（需判断点是否已经取过，需要标记列表）</span></span><br><span class="line">    <span class="comment">//若最后只有一个树，或者 小顶堆为空，说明已构建完MST</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;data,<span class="built_in">vector</span>&lt;data&gt;,cmp&lt;data&gt;&gt; lheap;<span class="comment">//p1:点序号，p2:Mahattan距离，</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, edge = <span class="number">0</span>;</span><br><span class="line">    lheap.push(data(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!lheap.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> next = lheap.top().first;</span><br><span class="line">        <span class="keyword">if</span>(vis[next]) &#123;lheap.pop();<span class="keyword">continue</span>;&#125;<span class="comment">//如果访问过则直接跳过</span></span><br><span class="line">        vis[next] = <span class="literal">true</span>; edge+=<span class="number">1</span>;</span><br><span class="line">        res += lheap.top().second;</span><br><span class="line">        lheap.pop();</span><br><span class="line">        <span class="keyword">if</span>(edge == n) <span class="keyword">break</span>; <span class="comment">//如果边的数量达到n则break</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            lheap.push(data(i,Mahattan(points,i,next)));</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(N^2)$, N为点的个数。</p>
<p>空间复杂度：$O(N)$,需要一个优先队列来存储所有的可能边。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/10/2020-9-12-minimal-Spanning-tree/" data-id="ckfj5lo6b000y3osc9o05df1d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MST/" rel="tag">MST</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-8-1-sliding-windows" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/01/2020-8-1-sliding-windows/" class="article-date">
  <time datetime="2020-08-01T06:27:56.000Z" itemprop="datePublished">2020-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/01/2020-8-1-sliding-windows/">滑动窗口法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>滑动窗口是面试中一大难点，幸运的是我们有模板</p>
</blockquote>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote>
<p>Sliding Windows，是一类很看重细节的问题，题目通常为<code>Medium</code>或者<code>hard</code></p>
</blockquote>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">最小区间</a>(hard)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列</a></p>
</li>
</ol>
<hr>
<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>
<hr>
<p>在滑动窗口中有两个指针，一个指针静止，而另一个指针保持移动。我们在s上滑动窗口，如果能够包含整个T（<strong>注意</strong>，T可能有重复字符），如果能收缩，我们就收缩窗口直到得到最小窗口。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="fig1"></p>
<p>下面介绍一下滑动窗口法思路：</p>
<ol>
<li><p>我们在字符串S中使用左右指针技巧，初始化<code>left=right=0</code>，把索引<strong>左闭右开区间</strong><code>[left,right)</code>称为一个<code>窗口</code>。</p>
</li>
<li><p>我们先不断增加<code>right</code>指针扩大窗口，直到窗口中的字符串满足要求。</p>
</li>
<li><p>此时我们停止增加 <code>right</code>，转而不断增加<code>left</code>指针缩小窗口，直到窗口中的字符串不再满足要求。同时，每增加<code>left</code>，我们都要更新一轮结果。</p>
</li>
<li><p>重复2,3直到<code>right</code>到达字符串S的尽头。</p>
</li>
</ol>
<p>滑动窗口的基本框架</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right&lt;s.size())</span><br><span class="line">&#123;</span><br><span class="line">window.add(s[right])</span><br><span class="line">right++</span><br><span class="line"><span class="keyword">while</span>(the window needs shrink)</span><br><span class="line">&#123;</span><br><span class="line">window.pop(s[left])</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>比较难的问题</p>
<h2 id="LC-632最小区间"><a href="#LC-632最小区间" class="headerlink" title="LC.632最小区间"></a>LC.632<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists">最小区间</a></h2><p>你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</span><br><span class="line">输出: [20,24]</span><br><span class="line">解释: </span><br><span class="line">列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。</span><br><span class="line">列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。</span><br><span class="line">列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。</span><br></pre></td></tr></table></figure>



<p>注意:</p>
<ol>
<li>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。</li>
<li>1 &lt;= k &lt;= 3500</li>
<li>-105 &lt;= 元素的值 &lt;= 105</li>
<li>对于使用Java的用户，请注意传入类型已修改为List&lt;List<Integer>&gt;。重置代码模板后可以看到这项改动。</li>
</ol>
<hr>
<p>在讲这个方法之前我们先思考这样一个问题：有一个序列 $$A = { a_1, a_2, \cdots, a_n }$$ 和一个序列 $$B = {b_1, b_2, \cdots, b_m}$$，请找出一个 B 中的一个最小的区间，使得在这个区间中 A 序列的每个数字至少出现一次，请注意 A 中的元素可能重复，也就是说如果 A 中有 p 个 u，那么你选择的这个区间中 u 的个数一定不少于 p。</p>
<p>回到这道题，我们发现这两道题的相似之处在于都要求我们找到某个符合条件的最小区间，我们可以借鉴「76. 最小覆盖子串」的做法：这里序列 $${ 0, 1, \cdots , k - 1 }$$ 就是上面描述的 A 序列，即 k 个列表，我们需要在一个 B 序列当中找到一个区间，可以覆盖 A序列。这里的 B 序列是什么？我们可以用一个哈希映射来表示 B 序列—— B[i]表示 ii 在哪些列表当中出现过，这里哈希映射的键是一个整数，表示列表中的某个数值，哈希映射的值是一个数组，这个数组里的元素代表当前的键出现在哪些列表里。也许文字表述比较抽象，大家可以结合下面这个例子来理解。</p>
<p>如果列表集合为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: [-1, 2, 3]</span><br><span class="line">1: [1]</span><br><span class="line">2: [1, 2]</span><br><span class="line">3: [1, 1, 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么可以得到这样一个哈希映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1: [0]</span><br><span class="line"> 1: [1, 2, 3, 3]</span><br><span class="line"> 2: [0, 2]</span><br><span class="line"> 3: [0, 3]</span><br></pre></td></tr></table></figure>

<p>我们得到的这个哈希映射就是这里的 BB 序列。我们要做的就是在 B 序列上使用双指针维护一个滑动窗口，并用一个哈希表维护当前窗口中已经包含了哪些列表中的元素，记录它们的索引。遍历 B 序列的每一个元素：</p>
<p>指向窗口右边界的指针右移当且仅当每次遍历到新的元素，并将这个新的元素对应的值数组中的每一个数加入到哈希表中<br>指向窗口左边界的指针右移当且仅当当前窗口内的元素包含 A中所有的元素，同时将原来左边界对应的值数组的元素们从哈希表中移除<br>答案更新当且仅当当前窗口内的元素包含 A 中所有的元素。</p>
<blockquote>
<p> 个人理解是，这题也一样可以套用模板，need（即B）哈希表的键为nums中出现的所有数字，值为该数字所在的所有数组在nums中的序号。window为一个长度为n的数组，只有当前的区间覆盖了所有nums中子数组，才能进行窗口缩小操作。注意,这里的left和right分别是nums中所有数的最大值和最小值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> n = nums.size();</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; B;<span class="comment">//B数组</span></span><br><span class="line"><span class="keyword">int</span> xMin = INT32_MAX, xMax = INT32_MIN;<span class="comment">//区间最大值和最小值</span></span><br><span class="line"><span class="comment">//这里的need包含了nums中所有数及其所在列表序号的映射对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c:nums[i])</span><br><span class="line">&#123;</span><br><span class="line">    B[c].push_back(i);</span><br><span class="line">    xMin = min(c,xMin);</span><br><span class="line">    xMax = max(c,xMax);</span><br><span class="line">&#125;<span class="comment">// sort(need.begin(),need.end());</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inside = <span class="number">0</span>; <span class="comment">// 表示包含最小区间的数组的个数,等于n表示窗口可以开始缩小</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(n)</span></span>;<span class="comment">//A中每个子数组，被最小区间包含的次数</span></span><br><span class="line"><span class="keyword">int</span> left = xMin, right = xMin<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ansL = INT32_MAX, ansR = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> min_inter = INT32_MAX;</span><br><span class="line"><span class="keyword">while</span> (right &lt; xMax) &#123;</span><br><span class="line">    <span class="comment">// 右移窗口</span></span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(B.count(right))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:B[right])</span><br><span class="line">    &#123;</span><br><span class="line">        freq[c]++;</span><br><span class="line">        <span class="keyword">if</span>(freq[c]==<span class="number">1</span>) inside++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">    <span class="comment">/********************/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">while</span> (inside==n) &#123;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; min_inter||(right-left+<span class="number">1</span> == min_inter&amp;&amp;left&lt;ansL))</span><br><span class="line">        &#123;</span><br><span class="line">            min_inter = right-left+<span class="number">1</span>;</span><br><span class="line">            ansL = left;</span><br><span class="line">            ansR = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(B.count(left))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:B[left])</span><br><span class="line">        &#123;</span><br><span class="line">            freq[c]--;</span><br><span class="line">            <span class="keyword">if</span>(freq[c]==<span class="number">0</span>) inside--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左移窗口，注意要放在后面，否则无法更新freq中左区间</span></span><br><span class="line">        left++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;ansL,ansR&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/01/2020-8-1-sliding-windows/" data-id="ckfj5lo64000m3osc66g18jwi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">算法 - 滑动窗口</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-8-1-common-way-solve-big-problem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/01/2020-8-1-common-way-solve-big-problem/" class="article-date">
  <time datetime="2020-07-31T16:00:00.000Z" itemprop="datePublished">2020-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/01/2020-8-1-common-way-solve-big-problem/">解空间极大问题通用策略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="解空间极大问题通用策略"><a href="#解空间极大问题通用策略" class="headerlink" title="解空间极大问题通用策略"></a>解空间极大问题通用策略</h1><hr>
<ul>
<li><ol start="78">
<li>子集</li>
</ol>
</li>
<li><ol start="60">
<li>第k个排列</li>
</ol>
</li>
<li><ol start="1371">
<li>每个元音包含偶数次的最长子字符串</li>
</ol>
</li>
<li><ol start="46">
<li>全排列</li>
</ol>
</li>
<li><ol start="47">
<li>全排列2</li>
</ol>
</li>
<li><ol start="90">
<li>子集2</li>
</ol>
</li>
<li><ol start="491">
<li>递增子序列</li>
</ol>
</li>
<li><ol start="301">
<li>删除无效括号</li>
</ol>
</li>
<li><ol start="77">
<li>组合</li>
</ol>
</li>
<li><ol start="40">
<li>组合总和II</li>
</ol>
</li>
<li>216.组合总和III</li>
</ul>
<blockquote>
<p>通常来说这类问题的解规模较大，很容易漏掉解，为此笔者提出一种解决问题的思路。</p>
</blockquote>
<p>比如全排列问题，组合问题等。让我们以78.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">子集</a>为例引入到情景中。</p>
<ul>
<li>全排列  $N!$</li>
<li>组合 $N!$</li>
<li>子集 $2^N$，每个元素可能存在或者不存在</li>
</ul>
<p>要确保结果<strong>完整</strong>且不<strong>重复</strong>，有多种策略：</p>
<ol>
<li><strong>递归</strong></li>
<li><strong>回溯</strong></li>
<li><strong>字典</strong></li>
<li><strong>数学</strong></li>
<li><strong>状态压缩</strong></li>
<li><strong>【补充】剪枝技巧</strong></li>
</ol>
<h2 id="I-递归"><a href="#I-递归" class="headerlink" title="I. 递归"></a>I. 递归</h2><p>递归不一定是递归函数，而是逐层次的把nums下一个数与前面的数融合起来。</p>
<p>比如：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvcmVjdXJzaW9uLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    res.push_back(&#123;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> _res = res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;k :_res)</span><br><span class="line">        &#123;</span><br><span class="line">            k.push_back(c);</span><br><span class="line">            res.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>剪枝及技巧</strong></p>
<p>很多时候dfs会经历不需要的中间状态，因此需要设计代码，避免不必要的递归。</p>
<p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p>
<p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p>
<p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p>
<h2 id="II-回溯"><a href="#II-回溯" class="headerlink" title="II. 回溯"></a>II. 回溯</h2><blockquote>
<p>注意：在大规模问题上，回溯法<strong>极容易</strong>超时。</p>
<p>正例：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301.删除无效括号</a>(Hard)</p>
<p>反例：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>(Medium)(正确的解法是动态规划，而不是回溯)</p>
</blockquote>
<blockquote>
<p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6/1783021">条件</a>的某个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8A%B6%E6%80%81/33204">状态</a>的点称为“回溯点”。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvY29tYmluYXRpb25zLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>以该题为例，比如我们要在<code>[1,2,3]</code>中找到所有子集，思路是这样的：</p>
<p>定义一个回溯方法 backtrack(first, curr)，第一个参数为索引 first，第二个参数为当前子集 curr。</p>
<ul>
<li><p>如果当前子集构造完成，将它添加到输出集合中。</p>
</li>
<li><p>否则，从 first 到 n 遍历索引 i。</p>
<ul>
<li>将整数 nums[i] 添加到当前子集 curr。</li>
<li>继续向子集中添加整数：backtrack(i + 1, curr)。</li>
<li>从 curr 中删除 nums[i] 进行回溯。</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvYmFja3RyYWNraW5nLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> first, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;curr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            backtrack(i+<span class="number">1</span>, curr);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//回溯法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = nums.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">            </span><br><span class="line">        backtrack(<span class="number">0</span>, curr);</span><br><span class="line">        res.push_back(&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里的第六行<code>for (int i = first; i &lt; n; i++)</code>非常关键，它保证各个子集是单调增的，避免了重复。</p>
</blockquote>
<p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p>
<p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p>
<p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p>
<h2 id="III-字典"><a href="#III-字典" class="headerlink" title="III. 字典"></a>III. 字典</h2><blockquote>
<p>该方法思路来自于Donald E. Knuth</p>
</blockquote>
<p>将每个子集映射到长度为n的掩码中，其中第i位掩码<code>nums[i]</code>为<code>1</code>，表示第i个元素在子集中， 如果第i位掩码<code>nums[i]</code>位<code>0</code>，表明第i位元素不在子集中。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzgvYml0bWFzazQucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>乍看起来生成二进制数很简单，但如何处理左边填充 0 是一个问题。因为必须生成固定长度的位掩码：例如 <code>001</code>，而不是 <code>1</code>。因此可以使用一些位操作技巧：<br>$python$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nth_bit = <span class="number">1</span> &lt;&lt; n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**n):</span><br><span class="line">    <span class="comment"># generate bitmask, from 0..00 to 1..11</span></span><br><span class="line">    bitmask = bin(i | nth_bit)[<span class="number">3</span>:]</span><br></pre></td></tr></table></figure>
<p>$C++$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        output = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**n, <span class="number">2</span>**(n + <span class="number">1</span>)):</span><br><span class="line">            <span class="comment"># generate bitmask, from 0..00 to 1..11</span></span><br><span class="line">            bitmask = bin(i)[<span class="number">3</span>:]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># append subset corresponding to that bitmask</span></span><br><span class="line">            output.append([nums[j] <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> bitmask[j] == <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：$\mathcal{O}(N \times 2^N)$，生成所有子集，并复制到输出结果中。</p>
<p>空间复杂度：$\mathcal{O}(N \times 2^N)$，这是子集的数量。</p>
<p>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，N个数字共有 $2^N$ 个子集。</p>
<hr>
<h2 id="IV-数学"><a href="#IV-数学" class="headerlink" title="IV. 数学"></a>IV. 数学</h2><blockquote>
<p>60.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-sequence/">第k个排列</a></p>
</blockquote>
<p>这里我们将题目稍微变形一下。来讲解数学知识如何发挥巨大的作用的。</p>
<p>给你一个排列$s$，由数字<code>1-9</code>组成，在<strong>不求全排列</strong>的前提下，返回它是正序的第k个排列。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 213</span><br><span class="line">输出: k &#x3D; 3</span><br><span class="line">解释：123全部的排列为 123， 132， 213， 231， 312， 321</span><br></pre></td></tr></table></figure>

<p>要想解决本题，首先需要了解一个简单的结论：</p>
<blockquote>
<p>对于 $n$ 个不同的元素（例如数 $1,2,⋯,n$），它们可以组成的排列总数目为 $n!$。</p>
</blockquote>
<p>对于给定的 $n$ 和 $k$，我们不妨从左往右确定第 $k$ 个排列中的每一个位置上的元素到底是什么。</p>
<p>我们首先确定排列中的首个元素 $a_1$ 。根据上述的结论，我们可以知道：</p>
<ul>
<li>以 1 为 $a_1$ 的排列一共有 $(n-1)!$ 个；<br>以 2 为 $a_1 $ 的排列一共有 $(n-1)!$ 个；<br>$\cdots⋯$<br>以 n 为 $a_1$ 的排列一共有 $(n-1)!$个。<br>由于我们需要求出从小到大的第 k 个排列，因此：</li>
</ul>
<p>如果 $k \leq (n-1)!$，我们就可以确定排列的首个元素为 1；<br>如果 $(n-1)! &lt; k \leq 2 \cdot (n-1)!$，我们就可以确定排列的首个元素为 2；<br>$\cdots⋯$<br>如果 $(n-1) \cdot (n-1)! &lt; k \leq n \cdot (n-1)!$，我们就可以确定排列的首个元素为 n。<br>因此，第 k 个排列的首个元素就是：<br>$$ {a_1 = \lfloor \frac{k-1}{(n-1)!} \rfloor + 1}<br>a_1 = \lfloor \frac{k-1}{(n-1)!} \rfloor + 1<br>$$<br>其中 $\lfloor x \rfloor$ 表示将 x 向下取整。</p>
<p>当我们确定了 $a_1$后，如何使用相似的思路，确定下一个元素 $a_2$呢？实际上，我们考虑以 $a_1$为首个元素的所有排列：</p>
<p>第 k 个排列实际上就对应着这其中的第<br>$$<br>k’ = (k-1) \bmod (n-1)! + 1<br>$$<br>个排列。这样一来，我们就把原问题转化成了一个完全相同但规模减少 1的子问题.</p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">factorial</span><span class="params">(n)</span></span>;</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --k;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">valid</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> order = k / factorial[n - i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                order -= valid[j];</span><br><span class="line">                <span class="keyword">if</span> (!order) &#123;</span><br><span class="line">                    ans += (j + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    valid[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k %= factorial[n - i];</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> ans;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="V-状态压缩"><a href="#V-状态压缩" class="headerlink" title="V. 状态压缩"></a>V. 状态压缩</h2><p>可以使用二进制或者,$bitset$进行状态压缩.</p>
<p>状态压缩经典问题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. 每个元音包含偶数次的最长子字符串</a></p>
<p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcodeisgreat&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>
<li>s 只包含小写英文字母。</li>
</ul>
<p>定义$pre[i][k]$表示前$i$个字母，第$k$个元音字母总出现的次数。那么在$[i-1,j-1]$区间内，元音字母出现次数为$pre[j][k]-pre[i][k]$，在$O(1)$时间内得到第$k$个元音字母出现的次数。</p>
<p>同时我们要考虑避免枚举所有的$i$，计算以它结尾的满足条件的最长子字符串长度，我们要找到最小$i$使得$pre[j][k]-pre[i][k]$均为偶数。 我们需要利用【所有元音出现偶数次】这个条件，对于满足条件的子串而言，$pre[i][k]$和$pre[j][k]$的奇偶性一定相同，因为偶数一定是奇数+奇数，或者偶数+偶数组成。所以我们可以把$pre[i][k]$改为表示$[0,i-1]$的<strong>元音奇偶性</strong>。</p>
<p>此外我们还需要进行「状态压缩」：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: cnta, &#x2F;&#x2F; a 出现次数的奇偶性</span><br><span class="line">  e: cnte, &#x2F;&#x2F; e 出现次数的奇偶性</span><br><span class="line">  i: cnti, &#x2F;&#x2F; i 出现次数的奇偶性</span><br><span class="line">  o: cnto, &#x2F;&#x2F; o 出现次数的奇偶性</span><br><span class="line">  u: cntu  &#x2F;&#x2F; u 出现次数的奇偶性</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以用二进制表示这些奇偶。</p>
<p>举一个例子，假如到第 $i $个位置，<code>u o i e a </code>出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 $(11001)<em>2=(25)</em>{10}$ 作为它的状态。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), res = <span class="number">0</span>, status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; vowel&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;e&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;i&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;o&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">3</span>&#125;,&#123;<span class="string">&#x27;u&#x27;</span>,<span class="number">1</span>&lt;&lt;<span class="number">4</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 我们用pre[status]表示status状态对应的位置i，不断更新</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">5</span>,<span class="number">-1</span>)</span></span>;<span class="comment">//初始均为偶</span></span><br><span class="line">        pre[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始状态，所有元音为偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vowel.count(s[i<span class="number">-1</span>]))</span><br><span class="line">            status ^= vowel[s[i<span class="number">-1</span>]];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(~pre[status]) res = max(res,i - pre[status]); <span class="comment">//pre[status]!=-1</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                pre[status] = i ;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 18行的 ~pre[status]表示<strong>按位取反</strong>，包含了符号位，所以只有pre[status]不为-1，才为True。</p>
<p>$ \text{~} 0 = -1$， </p>
</blockquote>
<p>时间复杂度: $O(N)$. $N$为字符串长度。</p>
<p>空间复杂度: $O(1)$.</p>
<hr>
<blockquote>
<p> 一些子母问题（数字重复与不重复）</p>
</blockquote>
<ul>
<li>46 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">全排列</a></li>
</ul>
<p>数字不重复，求全排列，回溯法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; output, <span class="keyword">int</span> first, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(res, output, first + <span class="number">1</span>, len);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>47 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">全排列2</a></li>
</ul>
<p>数字重复，求全排列【此时一定要用hash表】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dict;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:dict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c.second&gt;<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                arr.push_back(c.first);</span><br><span class="line">                c.second--;</span><br><span class="line">                dfs(n<span class="number">-1</span>);</span><br><span class="line">                c.second++;</span><br><span class="line">                arr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:nums)</span><br><span class="line">            dict[c]++;</span><br><span class="line">        dfs(nums.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<ul>
<li><p>78 子集（上面作为例子讲了）</p>
</li>
<li><p>90 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">子集2</a></p>
</li>
</ul>
<p>求包含重复元素的所有子集</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">           res.push_back(tmp);</span><br><span class="line">           <span class="keyword">return</span> ; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//i是从n-1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data[i].second; j ++) &#123;</span><br><span class="line">            tmp.push_back(data[i].first);</span><br><span class="line">            dfs(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data[i].second; j ++) tmp.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;<span class="comment">//统计nums每个数字的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            mp[x] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : mp) &#123;</span><br><span class="line">            data.push_back(x);<span class="comment">//相当于把哈希表存到数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = data.size();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><ol start="491">
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列</a></li>
</ol>
</li>
</ul>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>给定数组的长度不会超过15。</li>
<li>数组中的整数范围是 [-100,100]。</li>
<li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li>
</ul>
<hr>
<p><strong>方法1：二进制枚举+哈希</strong></p>
<p>我们用二进制0，1表示解选中或者不被选中。那么长度为$n$的序列，对应有$2^n$种可能，对于序列去重，我们可以采用串哈希算法，（Rabin-Karp算法），即对于一个序列${a_0,a_1,…,a_{n-1}}$，我们可以认为是一个$\max(a_i)+1$（记为b）进制的数。<br>$$<br>f(a)=\sum\limits_{i=0}^{n-1}b^i×a_i<br>$$<br>在实际使用种，我们发现这个编码可能非常的大，我们可以把它模上一个大素数$P$，再映射到$int$范围。<br>$$<br>f(a)=\sum\limits_{i=0}^{n-1}b^i×a_i(mod \ P)<br>$$<br>Rabin-karp编码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN_VAL = <span class="number">-100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_VAL = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHash</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//这里的base为数组的最大值, min_val 为数组可能最小值，题目给出,为了避免负数的情况</span></span><br><span class="line"><span class="comment">//这里的mod 是一个大素数</span></span><br><span class="line"><span class="comment">//时间复杂度 O(N) 慎用</span></span><br><span class="line">    <span class="keyword">int</span> hashVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:temp)</span><br><span class="line">    &#123;</span><br><span class="line">        hashVal = <span class="number">1L</span>L*hashVal*base % mod + (c - MIN_VAL + <span class="number">1</span>);  </span><br><span class="line">        hashVal %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashVal;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hashValue = getHash(MAX_VAL, (<span class="keyword">int</span>)(<span class="number">1E9</span>)+<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p>数组编码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&amp;<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串编码</strong></p>
<p>在该方法中，我们将字符串看成一个 $\textit{base}$ 进制的数，它对应的十进制值就是哈希值。显然，两个字符串的哈希值相等，当且仅当这两个字符串本身相同。然而如果字符串本身很长，其对应的十进制值在大多数语言中无法使用内置的整数类型进行存储。因此，我们会将十进制值对一个大质数 $\textit{mod}$ 进行取模。此时：</p>
<ul>
<li><p>如果两个字符串的哈希值在取模后不相等，那么这两个字符串本身一定不相同；</p>
</li>
<li><p>如果两个字符串的哈希值在取模后相等，并不能代表这两个字符串本身一定相同。例如两个字符串的哈希值分别为 2 和 15，模数为 13，虽然 $2 \equiv 15 <del>~ (\bmod</del>13)$，但它们不相同。</p>
</li>
</ul>
<p>一般来说，我们选取一个大于字符集大小（即字符串中可能出现的字符种类的数目）的质数作为 $base$，再选取一个在字符串长度平方级别左右的质数作为 $mod$，产生哈希碰撞的概率就会很低。</p>
<p><strong>复杂度分析</strong></p>
<p>假设序列的长度是 $n$。</p>
<ul>
<li>时间复杂度：$O(2^n \cdot n)$。这里枚举所有子序列的时间代价是 $O(2^n)$，每次检测序列是否合法和获取哈希值的时间代价都是 $O(n)$.</li>
<li>空间复杂度：$O(2^n)$。最坏情况下整个序列都是递增的，每个长度大于等于 2 的子序列都要加入答案，这里哈希表中要加入 $2^n$<br>  个元素，空间代价为 $O(2^n)$,用一个临时的数组来存当前答案，空间代价为 $O(n)$。</li>
</ul>
<p><strong>方法2：递归+剪枝</strong></p>
<p>这是一个递归枚举子序列的通用模板，即用一个临时数组 $\rm temp$ 来保存当前选出的子序列，使用 $\rm cur$ 来表示当前位置的下标，在 dfs(cur, nums) 开始之前，$[0, {\rm cur} - 1]$这个区间内的所有元素都已经被考虑过，而$ [{\rm cur}, n]$ 这个区间内的元素还未被考虑。在执行 dfs(cur, nums) 时，我们考虑 ${\rm cur}$ 这个位置选或者不选，如果选择当前元素，那么把当前元素加入到 $\rm temp$ 中，然后递归下一个位置，在递归结束后，应当把 $\rm temp$的最后一个元素删除进行回溯；如果不选当前的元素，直接递归下一个位置。</p>
<p>当然，如果我们简单地这样枚举，对于每一个子序列，我们还需要做一次 $O(n)$ 的合法性检查和哈希判重复，在执行整个程序的过程中，我们还需要使用一个空间代价 $O(2^n) $的哈希表来维护已经出现的子序列的哈希值。我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的都是合法的并且不重复：</p>
<p>使序列合法的办法非常简单，即给「选择」做一个限定条件，只有当前的元素大于等于上一个选择的元素的时候才能选择这个元素，这样枚举出来的所有元素都是合法的</p>
<p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p>
<ul>
<li><p>前者被选择，后者被选择</p>
</li>
<li><p>前者被选择，后者不被选择</p>
</li>
<li><p>前者不被选择，后者被选择</p>
</li>
<li><p>前者不被选择，后者不被选择</p>
<p>其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.size()) &#123;<span class="comment">//当前序号达到末尾才进行答案归纳</span></span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] &gt;= last) &#123;</span><br><span class="line">            temp.push_back(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != last) &#123;<span class="comment">//只有前后元素不相同才考虑不选</span></span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>, INT32_MIN, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="剪枝技巧"><a href="#剪枝技巧" class="headerlink" title="剪枝技巧"></a><strong>剪枝技巧</strong></h2><ul>
<li>一种常见的技巧是让生成子序列是单增顺序的，如 216. 组合总和III。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>&amp;&amp;target==<span class="number">0</span>) &#123;res.push_back(sub);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(<span class="number">9</span>,target);i++)</span><br><span class="line">        <span class="keyword">if</span>(!sub.size()||i &gt; sub.back())</span><br><span class="line">        &#123;</span><br><span class="line">            sub.emplace_back(i);</span><br><span class="line">            dfs(k<span class="number">-1</span>,target-i,sub);</span><br><span class="line">            sub.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当题目不能出现重复项时，有两种方法。如40.组合总和II</li>
<li><ol>
<li>使用哈希表天然去重功能，但是需要编码。</li>
<li>先对<code>candidates</code>进行排序，然后每次dfs取下一项，遇到<code>candidates</code>重复项就跳过。这里我们分<code>candidates</code>能否被选无限次进行讨论。</li>
</ol>
</li>
</ul>
<p>A. Candidates只能选取一次【40题】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        path.push_back(candidates[i]);</span><br><span class="line">        <span class="comment">// 元素不可重复利用，使用下一个即i+1</span></span><br><span class="line">        DFS(i + <span class="number">1</span>, target - candidates[i]);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>B. Candidates选取无限次【39题】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;</span><br><span class="line">             i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            DFS(i, target - candidates[i]);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>区别在于<code>dfs(i)</code>还是<code>dfs(i+1)</code>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/01/2020-8-1-common-way-solve-big-problem/" data-id="ckfj5lo77001s3oscfb48e6s6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/" rel="tag">通用策略</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-07-27-backpack-problem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/2020-07-27-backpack-problem/" class="article-date">
  <time datetime="2020-07-26T16:00:00.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/2020-07-27-backpack-problem/">背包问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="做一只可爱的小🐖背包"><a href="#做一只可爱的小🐖背包" class="headerlink" title="做一只可爱的小🐖背包"></a>做一只可爱的小🐖背包</h1><blockquote>
<p>  推荐观看dd大牛：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲的传送门</a>, <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av33930433">「背包九讲」视频教程</a></p>
<p>  0-1 背包    </p>
<blockquote>
<p> 完全背包</p>
</blockquote>
<blockquote>
<blockquote>
<p>多重背包 I II III</p>
</blockquote>
<p>混合背包问题</p>
<blockquote>
<p>二维费用的背包问题</p>
</blockquote>
<p>分组背包问题</p>
<blockquote>
<p>背包问题求解方案数</p>
</blockquote>
<p>求背包问题的方案</p>
<blockquote>
<p>有依赖的背包问题</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="I-0-1背包问题"><a href="#I-0-1背包问题" class="headerlink" title="I. 0-1背包问题"></a>I. 0-1背包问题</h2><blockquote>
<p><u><strong>注意</strong>解空间极大问题有时可以转化0-1背包,从而避免TLE!</u></p>
</blockquote>
<p>题目：有一个容量为 V 的背包，和一些物品。这些物品分别有两个属性，体积 w 和价值 v，每种物品只有一个。要求用这个背包装下价值尽可能多的物品，求该最大价值，背包可以不被装满。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">背包最大容量：50</span><br><span class="line">物品重量为：&#123;10,20,30,40,60&#125;</span><br><span class="line">物品价值为：&#123;1,3,5,7,9&#125;</span><br><span class="line">输出：8</span><br><span class="line">解释：当选择物品重量为20，30或者10，40对应的价值最大。</span><br></pre></td></tr></table></figure>

<p>我们适当作一些约定：$dp[i][j]或dp[j]$表示最大价值，$i$为具体问题下物品编号或组编号，$j$为体积。$W_i$为价值数组，$V_i$为体积数组。</p>
<p>$N$表示物品数量，$C$表示背包容积，$Q$表示背包最大重量。</p>
<p>0-1 背包问题中，物品只有两种状态，装载或者不装载，因此被称为<strong>0-1背包</strong>。除此之外还有<strong>完全背包</strong>和<strong>多重背包</strong>。</p>
<ol>
<li><strong>找子问题</strong>，第一，包的当前容量比物品小，装不下，这时的最大价值和前$$i-1$$个物品的最大价值是一样的。我们令$$dp[i][j]$$表示前$$i$$个物品在背包容量为$$j$$所能达到的最大价值。第二，包的当前可用容量比物品大，这个时候要决定是否添加下一个物品，因为在体积相同的情况下，总价值不一定更大。</li>
<li>找到<strong>状态转移方程</strong>，我们用辅助函数$sumWeight(i)$表示当前物品的总重量。</li>
</ol>
<p>$$<br>dp[i][j]=\begin{cases}<br>dp[i-1][j],\ sumWeight(i-1)+w[i-1]&gt;j<br>\<br>\max(dp[i-1][j-w[i-1]]+v[i-1], dp[i-1][j])，otherwise<br>\end{cases}<br>$$</p>
<ol start="3">
<li><p>确定<strong>边界条件</strong>：</p>
<p>$$dp[0][j]=0$$，不装物品时最大价值为0.，同理$$dp[i][0]=0$$，即背包容量为0时，最大价值也为0. </p>
</li>
</ol>
<p>时间复杂度：$$O(V<em>N)$$，状态数量为V</em>N, V为背包容量，N为物品数目，状态转移复杂度为$$O(1)$$。</p>
<p>空间复杂度：$$O(V*N)$$, 为dp数组大小。</p>
<blockquote>
<p>变式：要求完全装满背包。</p>
</blockquote>
<p>我们令$$dp[0][j]=0$$，不装物品时最大价值为0.，$$dp[0][j]=-\infin$$，这样的话，在$$dp[n][V]$$刚好大于0.</p>
<blockquote>
<p>优化：用一维数组表示</p>
</blockquote>
<p>因为dp的物品数量维度i，仅与前一项有关，因此可以优化。<u>为保证每个物品只能使用一次，我们倒序遍历所有的值，类似于贪心的思路，而反过来就变成了<strong>完全背包</strong>问题。想想为什么？</u><br>$$<br>dp[j] = \max(dp[j-w[i-1]]+v[i-1],dp[j])<br>$$<br>注意后面的dp[j]其实是上一次的结果，这相当于滚动数组。优化后空间复杂度为$$O(V)$$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span></span><br><span class="line">    <span class="keyword">int</span> N = val.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(V+<span class="number">1</span>)</span></span>; <span class="comment">//dp[j]表示容量为j的最大价值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= V;i++) dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= weight[i<span class="number">-1</span>];j--)</span><br><span class="line">        dp[j] = max(dp[j],dp[j-weight[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="II-完全背包问题"><a href="#II-完全背包问题" class="headerlink" title="II. 完全背包问题"></a>II. 完全背包问题</h2><p>我们让每种物品数量可以无限$$0-\infty$$。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">背包最大容量：60</span><br><span class="line">物品重量为：&#123;10,20,30,40,60&#125;</span><br><span class="line">物品价值为：&#123;1,2,5,7,8&#125;</span><br><span class="line">输出：10</span><br><span class="line">解释：当选择物品重量为两个30对应的价值最大。</span><br></pre></td></tr></table></figure>

<p>我们将上述优化算法由<strong>倒序遍历</strong>J变为<strong>正序遍历</strong>J即可实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;val, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//V为背包最大容量，val为物品价值数组，weig为物品重量数组</span></span><br><span class="line">    <span class="keyword">int</span> N = val.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(V+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//dp[j]表示容量为j的最大价值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i<span class="number">-1</span>]; j &lt;= V;j++)</span><br><span class="line">    <span class="keyword">if</span>(dp[j-weight[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>]&gt;dp[j])</span><br><span class="line">    dp[j] = dp[j-weight[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="III-多重背包问题"><a href="#III-多重背包问题" class="headerlink" title="III. 多重背包问题"></a>III. 多重背包问题</h2><p>多重背包问题介于0-1背包和完全背包之间。</p>
<p>我们除了给出背包的最大容量，物品的体积V和价值W，还给出物品的最大数量S。</p>
<p><u>我们可以将多重背包问题转化为0-1背包，即将每种物品视为k种不同的物品</u>，这样的时间复杂度为$$O(s×\sum k_i)$$，由此可见，降低每件物品的数量可以大大降低其时间复杂度。我们运用一些tricky技巧，将原来数量为k的物品拆分为若干组，每组物品看成一件物品，其价值和重量为该组所有物品之和。$\color{red}{每组物品包含原物品数目分别为: 1,2,4···k-2^c+1}，其中k为使得k-2^c+1大于0的最大整数$.得到新的时间复杂度为$$O(s×\sum \log k_i)$$。</p>
<p><strong>二进制优化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//分别表示物品数量和背包容量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;<span class="comment">//用于分组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;object&gt; objects;</span><br><span class="line">    <span class="keyword">int</span> a,b,s,line = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k*=<span class="number">2</span>)</span><br><span class="line">        &#123;<span class="comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span></span><br><span class="line">            s -= k;</span><br><span class="line">            objects.push_back(&#123;k*b,k*a&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) objects.push_back(&#123;s*b,s*a&#125;);</span><br><span class="line">        line ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[C+<span class="number">1</span>];<span class="comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;object:objects)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= object.v;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">        <span class="comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单调队列优化(Hard)</strong></p>
<p><code>0&lt;N≤10000&lt;N≤1000 0&lt;V≤200000&lt;V≤20000 0&lt;vi,wi,si≤20000</code></p>
<p>当数据范围变得极大，使用二进制将<code>TLE</code>，我们必须优化，这里有一种优化方式是单调队列优化。</p>
<p>因为我们需要的是${ dp[j], dp[v+j], dp[2<em>v+j], dp[3</em>v+j], … , dp[k*v+j] }$ 中的最大值，我们通过维护一个单调队列来维护这些数中最大值。</p>
<p>单调队列问题，最重要的两点<br>1）维护队列元素的个数，如果不能继续入队，弹出队头元素<br>2）维护队列的单调性，即：$尾值 &gt;= dp[j + k<em>v] - k</em>w$</p>
<p>本题中，队列中元素的个数应该为 $s+1$ 个，即 $0 - s $个物品 $i$. 为了方便大家理解，我举例进行说明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N_MAX],pre[N_MAX],Q[N_MAX];<span class="comment">//分别表示物品数量和背包容量</span></span><br><span class="line"><span class="comment">//单调队列存的是体积，末尾存储最大价值。</span></span><br><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//物品数量和背包容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,s,l=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pre,dp,<span class="keyword">sizeof</span> dp);<span class="comment">//copy dp-&gt;pre</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; v;j++)</span><br><span class="line">        &#123;<span class="comment">//j是余数，即C%k</span></span><br><span class="line">            <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;<span class="comment">//队列头部和尾部</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j;k &lt;= C;k += v)</span><br><span class="line">            &#123;<span class="comment">// j+n*k==C</span></span><br><span class="line">                <span class="keyword">if</span>(head&lt;=tail)</span><br><span class="line">                &#123;<span class="comment">//如果容量超过了S,则单调队列应该缩小 head++</span></span><br><span class="line">                <span class="keyword">if</span>((k-s*v) &gt; Q[head]) head++;</span><br><span class="line">                <span class="comment">//如果k对应价值大于头部价值，那么不断，相当于把体积插入到使得队列单增的位置，tail--</span></span><br><span class="line">                <span class="keyword">while</span>(head&lt;=tail&amp;&amp;(pre[k] - (k - j)/v*w) &gt;= (pre[Q[tail]] - (Q[tail] - j)/v*w)) tail--;</span><br><span class="line">                dp[k] = max(dp[k],pre[Q[head]] + (k-Q[head])/v*w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">                &#125;</span><br><span class="line">                Q[++tail] =  k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，笔者单调队列这里也不是很明白，需要再仔细讲究一下。</p>
<hr>
<h2 id="IV-混合背包"><a href="#IV-混合背包" class="headerlink" title="IV. 混合背包"></a>IV. 混合背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<ul>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 $s_i$ 次（多重背包）；</li>
</ul>
<p>每种体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 NN 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 种物品的体积、价值和数量。</p>
<ul>
<li>$si=−1$ 表示第 $i$ 种物品只能用1次；</li>
<li>$si=0$ 表示第 $i$ 种物品可以用无限次；</li>
<li>$si&gt;0$ 表示第 $i$ 种物品可以使用 $si$ 次；</li>
</ul>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000<br>−1≤si≤1000$</p>
<blockquote>
<hr>
</blockquote>
<p>我们直接分类讨论，状态转移直接分为<strong>无限个</strong>和<strong>非无限</strong>即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//分别表示物品数量和背包容量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> kind;</span><br><span class="line">    <span class="keyword">int</span> w,v;<span class="comment">//用于分组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;object&gt; objects;</span><br><span class="line">    <span class="keyword">int</span> v,w,s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">-1</span>) objects.push_back(&#123;<span class="number">-1</span>,w,v&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>) objects.push_back(&#123;<span class="number">0</span>,w,v&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k*=<span class="number">2</span>)</span><br><span class="line">        &#123;<span class="comment">//按照二进制1，2，4，8.。进行分组，保存每组的体积和价值</span></span><br><span class="line">            s -= k;</span><br><span class="line">            objects.push_back(&#123;<span class="number">1</span>,k*w,k*v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>) objects.push_back(&#123;<span class="number">1</span>,s*w,s*v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[C+<span class="number">1</span>];<span class="comment">//dp[i][j]表示 装入第i个物品，背包重量最大为j对应的最大价值</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;object:objects)</span><br><span class="line">    <span class="keyword">if</span>(object.kind == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = object.v;k &lt;= C;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= object.v;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - object.v] +object.w);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="V-二维费用的背包问题"><a href="#V-二维费用的背包问题" class="headerlink" title="V. 二维费用的背包问题"></a>V. 二维费用的背包问题</h2><p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p>
<p>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N≤1000\<br>0&lt;V,M≤100\0&lt;v_i,m_i≤100\<br>0&lt;w_i≤1000$</p>
<p>其实非常容易进行扩展，将数组维度扩大，再加一层循环即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C,Q;<span class="comment">//分别表示物品数量，背包体积容量，背包最大重量</span></span><br><span class="line"><span class="keyword">int</span> V[<span class="number">1001</span>],W[<span class="number">1001</span>],M[<span class="number">1001</span>];<span class="comment">//体积，价值和重量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,m,line = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C&gt;&gt;Q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;m&gt;&gt;w)</span><br><span class="line">    &#123;</span><br><span class="line">        V[line] = v;</span><br><span class="line">        M[line] = m;</span><br><span class="line">        W[line] = w;</span><br><span class="line">        </span><br><span class="line">        line ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[C+<span class="number">1</span>][Q+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= V[i<span class="number">-1</span>];k--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = Q;j &gt;= M[i<span class="number">-1</span>];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k][j] = max(dp[k][j],dp[k - V[i<span class="number">-1</span>]][j - M[i<span class="number">-1</span>]] + W[i<span class="number">-1</span>]);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">        <span class="comment">// printf(&quot;dp:%d\n&quot;,dp[k][j]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C][Q];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="VI-分组背包问题"><a href="#VI-分组背包问题" class="headerlink" title="VI. 分组背包问题"></a>VI. 分组背包问题</h2><p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$用空格隔开，分别表示物品组数和背包容量。</p>
<p>接下来有 $N$ 组数据：</p>
<ul>
<li>每组数据第一行有一个整数 $S_i$，表示第 $i $个物品组的物品数量；</li>
<li>每组数据接下来有 $Si$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；</li>
</ul>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0&lt;N,V≤100 0&lt;Si≤100 0&lt;vij,wij≤100</code></p>
<blockquote>
<hr>
</blockquote>
<p>我们只需要对每组每一个物品进行讨论。求每组的dp是并列的关系，注意循环之间位置关系。枚举体积的循环在外面，而枚举组内物品循环在里面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C,v,w;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//每组物品的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;V[j]&gt;&gt;W[j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= <span class="number">0</span>;k--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; num; s++)</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= V[s])</span><br><span class="line">    &#123;</span><br><span class="line">        dp[k] = max(dp[k],dp[k - V[s]] + W[s]);<span class="comment">//考虑选第i件物品和不选第i件物品</span></span><br><span class="line">        <span class="comment">// printf(&quot;dp:%d\n&quot;,dp[k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="VII-有依赖的背包问题（hard）-树形dp"><a href="#VII-有依赖的背包问题（hard）-树形dp" class="headerlink" title="VII. 有依赖的背包问题（hard）[树形dp]"></a>VII. 有依赖的背包问题（hard）[树形dp]</h2><p>有 $N$ 个物品和一个容量是 $V$ 的背包。</p>
<p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p>
<p>如下图所示：<br><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt="QQ图片20181018170337.png"></p>
<p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p>
<p>每件物品的编号是 $i$，体积是 $vi$，价值是 $wi$，依赖的父节点编号是 $pi$。物品的下标范围是 $1…N$。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数 $N，V$，用空格隔开，分别表示物品个数和背包容量。</p>
<p>接下来有 $N$ 行数据，每行数据表示一个物品。<br>第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>如果 $p_i=−1$，表示根节点。 <strong>数据保证所有物品构成一棵树。</strong></p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N,V≤100\1≤v_i,w_i≤100$</p>
<p>父节点编号范围：</p>
<ul>
<li>内部结点：$1≤p_i≤N$;</li>
<li>根节点 $pi=−1$;</li>
</ul>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7</span><br><span class="line">2 3 -1</span><br><span class="line">2 2 1</span><br><span class="line">3 5 1</span><br><span class="line">4 7 2</span><br><span class="line">3 6 2</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们选择根节点,价值为&#123;2,3&#125;，</span><br><span class="line">编号为1的叶节点，我们选择&#123;2,2&#125;或&#123;3,5&#125;。</span><br><span class="line">编号为2的叶节点，我们选择&#123;4,7&#125;或&#123;3,6&#125;。 </span><br><span class="line">最大容积7， 我们选择&#123;2,2&#125;和&#123;3,6&#125;,这样总体积就是2+3+2 &#x3D; 7. 总价值为 2+6+3&#x3D;11.</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
</blockquote>
<p>这道题其实是分组背包和<u>树形dp</u>的结合。先考虑节点的数据表示我们用<code>vector&lt;int&gt; g[N_MAX]</code>表示二叉树。$dp[i][j]$表示，<strong>我们选择节点$i$为根节点，并且体积为$j$的最大价值。</strong></p>
<p>既然是树，我们就需要深度优先搜索（DFS）。由于子节点依赖于根节点，那么根节点必定占据一定空间，且初始价值应该等于根节点。</p>
<blockquote>
<p>初始条件：$ dp[root][j] = W_{root}, V_{root} \le j \le C$ , $C$表示背包容积。</p>
</blockquote>
<p>按照0-1背包思路，我们在$k \in[V_{root},C]$区间内逆向遍历，那么子节点的可用空间为$m \in [0,k-V_{root}]$. 可以类比分组背包的$k\in[0,C],s \in [0,num],where \ k &gt; V_s$, $num$为组号。之后我们将每个子节点分别进行搜索，对$dp[root][k]$进行更新。<br>$$<br>dp[root][k] = \max(dp[root][k],dp[root][k-m]+dp[son][m])<br>$$</p>
<blockquote>
<p>返回值：$dp[root][C]$</p>
</blockquote>
<p>弄清楚这一层写代码就不难了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,C,p;<span class="comment">//物品数量，背包容积，父节点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> V[N_MAX],W[N_MAX],dp[N_MAX][N_MAX];<span class="comment">//体积数组，价值数组，dp[i][j]选择第i个节点为根节点在体积为j对应最大价值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N_MAX];<span class="comment">//保存子节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//cap表示容量，no表示节点编号</span></span><br><span class="line">    <span class="comment">//root必选，所以我们初始化dp[root][V[root]~C] 为 W[root]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V[root];j &lt;= C;i++) dp[root][j] = W[root];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;son:g[root]) </span><br><span class="line">    &#123;</span><br><span class="line">        dfs(son);<span class="comment">//遍历子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = C; k &gt;= V[root]; k--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= (k-V[root]);m++)<span class="comment">//分配给子树的空间不能大于C-V[son]</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[root][k] = max(dp[root][k], dp[root][k-m] + dp[son][m]);<span class="comment">//根据不同的子节点更新父节点的值</span></span><br><span class="line">            <span class="comment">// if(dp[root][k]) printf(&quot;rt:%d,sn:%d,dp[%d]:%d\n&quot;,root,son,k,dp[root][k]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="comment">//dp[i][j]表示 装入第i-1个物品，背包重量最大为j对应的最大价值，此处用滚动数组表示</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(~p) g[p].emplace_back(i);</span><br><span class="line">        <span class="keyword">else</span> root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[root][C];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="VIII-背包求解方案数"><a href="#VIII-背包求解方案数" class="headerlink" title="VIII.背包求解方案数"></a>VIII.背包求解方案数</h2><p>有 $N$件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$, 用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <strong>方案数</strong> 模 $10^9+7$ 的结果。</p>
<h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\<br>0&lt;v_i,w_i≤1000$</p>
<blockquote>
<p>我们除了需要对价值$dp[j]$进行状态转移（同0-1背包），还需要对方案数进行转移，设$M[j]$表示物品总体积为$j$对应的方案数。</p>
<p>那么有：<br>$$<br>M[j] = \begin{cases}<br>        M[j], M[j]&gt;M[j-v_i]\<br>        M[j-v_i], M[j]&lt;M[j-v_i]\<br>        M[j]+M[j-v_i], M[j]=M[j-v_i]\<br>        \end{cases}.<br>$$<br>初始条件： $M[0] = 1$， 背包为空只有一种方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">1010</span>, MOD = (<span class="keyword">int</span>)<span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//物品数量和容积</span></span><br><span class="line"><span class="keyword">int</span> dp[N_MAX],M[N_MAX];<span class="comment">//方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w,line = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="built_in">memset</span>(dp,INT_MIN,<span class="keyword">sizeof</span>(dp));<span class="comment">//为了使价值从0开始计数，我们把dp数组初始化为-inf</span></span><br><span class="line">    M[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//价值为0的方案为1，即全不放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = C;k &gt;= v;k--)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> t  = max(dp[k],dp[k - v] + w);<span class="comment">//考虑选第i件物品和不选第i件物品，注意它们价值可能相同</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;<span class="comment">// 不是M[k]，否则三种方案叠加</span></span><br><span class="line">            <span class="keyword">if</span>(t == dp[k-v]+w) s += M[k-v];</span><br><span class="line">            <span class="keyword">if</span>(t == dp[k]) s += M[k];<span class="comment">//这里不能写成else if ，两种路径分开考虑，求的是总方案数</span></span><br><span class="line">            dp[k] = t;</span><br><span class="line">            M[k] =s%MOD;</span><br><span class="line">            <span class="comment">// printf(&quot;i:%d,k:%d,dp:%d,M:%d\n&quot;,i,k,dp[k],M[k]);</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, maxw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= C;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dp[j]&lt;&lt;&quot;,&quot;&lt;&lt;M[j]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dp[j] == dp[C])</span><br><span class="line">        &#123;</span><br><span class="line">            res += M[j];</span><br><span class="line">            res %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="IX-背包问题求具体方案"><a href="#IX-背包问题求具体方案" class="headerlink" title="IX. 背包问题求具体方案"></a>IX. 背包问题求具体方案</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p>
<p>物品编号范围是 $1…N$。</p>
<h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N,V≤1000\<br>0&lt;v_i,w_i≤1000$</p>
<blockquote>
<hr>
</blockquote>
<p>我们用一个二维dp数组$dp[i][j]$表示选取$i$个物品，体积为$j$对应的最大价值。这里的$i$是用来反推具体方案的。我们思考如何反推。</p>
<p>$dp[i][j] == dp[i-1][j]$说明不选第$i$个物品就能得到最大价值。</p>
<p>$dp[i][j]==dp[i-1][j-v[i-1]]+w[i-1]$表示选择第$i$个物品得到最大价值。</p>
<p>为了得到最小的字典序，我们可以采用贪心的策略。在进行状态转移的时候，我们按编号从大到小进行遍历。为了更直观的理解，我们举例：</p>
<p>设物品数4，背包容积5.  物品的体积$v_i$和价值$w_i$分别为: $[1,2],[2,4],[3,4],[4,6]$.  编号$i$的范围$[1,4]$</p>
<p>从$i=4$开始，我们从体积为0开始进行状态转移。最后的结果一定是最大价值。如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">i:4,k:0,dp:0 ←</span><br><span class="line">i:4,k:1,dp:0</span><br><span class="line">i:4,k:2,dp:0</span><br><span class="line">i:4,k:3,dp:0</span><br><span class="line">i:4,k:4,dp:6</span><br><span class="line">i:4,k:5,dp:6</span><br><span class="line">i:3,k:0,dp:0</span><br><span class="line">i:3,k:1,dp:0</span><br><span class="line">i:3,k:2,dp:0</span><br><span class="line">i:3,k:3,dp:4</span><br><span class="line">i:3,k:4,dp:6 ←</span><br><span class="line">i:3,k:5,dp:6</span><br><span class="line">i:2,k:0,dp:0</span><br><span class="line">i:2,k:1,dp:0</span><br><span class="line">i:2,k:2,dp:4</span><br><span class="line">i:2,k:3,dp:4</span><br><span class="line">i:2,k:4,dp:6 ←</span><br><span class="line">i:2,k:5,dp:8</span><br><span class="line">i:1,k:0,dp:0</span><br><span class="line">i:1,k:1,dp:2</span><br><span class="line">i:1,k:2,dp:4</span><br><span class="line">i:1,k:3,dp:6</span><br><span class="line">i:1,k:4,dp:6</span><br><span class="line">i:1,k:5,dp:8  ←</span><br></pre></td></tr></table></figure>

<p>用$sum$表示剩余体积，开始$sum=5. $然后我们考虑 $dp[i][sum]==dp[i-1][sum-v[i]]+w[i]$ ，如果为True则选择第i个。<br>$$<br>dp[1][5]=8→dp[2][4]=6→dp[3][4]=6→dp[4][0]=0.<br>$$<br>最后$sum==0$，表示找到字典序最小的方案。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> N,C;<span class="comment">//物品数量和容积</span></span><br><span class="line"><span class="keyword">int</span> dp[N_MAX][N_MAX];<span class="comment">//方案数</span></span><br><span class="line"><span class="keyword">int</span> v[N_MAX], w[N_MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;i++) <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N;i &gt;= <span class="number">1</span> ;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= C;k++)</span><br><span class="line">        &#123; </span><br><span class="line">            dp[i][k] = dp[i+<span class="number">1</span>][k];    <span class="comment">//这句话作用是使得k&lt;v[i]仍可进行反推</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt;= v[i]) </span><br><span class="line">            dp[i][k]  = max(dp[i][k],dp[i+<span class="number">1</span>][k - v[i]] + w[i]);<span class="comment">//如果选和不选价值相同，那么我们贪心的进行选择</span></span><br><span class="line">            <span class="comment">// printf(&quot;i:%d,k:%d,dp:%d\n&quot;,i,k,dp[i][k]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据结果反推具体方案</span></span><br><span class="line">    <span class="keyword">int</span> sum = C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][sum]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= v[i]&amp;&amp;dp[i][sum]==(dp[i+<span class="number">1</span>][sum-v[i]]+w[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            sum -= v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="经典题目分析、"><a href="#经典题目分析、" class="headerlink" title="经典题目分析、"></a>经典题目分析、</h2><p><strong>例题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a>(Medium)</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</li>
</ul>
<hr>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494.目标和</a>(Medium)</strong></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>数组非空，且长度不会超过 20 。</li>
<li>初始的数组的和不会超过 1000 。</li>
<li>保证返回的最终结果能被 32 位整数存下。</li>
</ul>
<blockquote>
<p>这道题看起来简单,实际上非常<code>Disgusting</code>.因为它给了三个提示,每一条都杀人诛心. </p>
</blockquote>
<p>这一次,我们每一个”物品”都必须选. <strong>我们考虑$dp[i][j]$表示$0-i$区间内组成$j$的方案数</strong>. 那么相应的状态方程为:<br>$$<br>dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]<br>$$<br>很多时候我们会因为惯性思维写成<code>nums[i-1]</code>但这是不对的,因为我们定义区间<code>[0,i]</code>.</p>
<p>然后很糟糕的是, 或者更糟糕的是, 中间可能产生负数目标的情况,为了避免数组越界,我们需要将数组整体搬移, 这时候第二个提示发挥作用.我们设这个$offset=1000$. </p>
<p>关于边界条件. 一开始我们很容易写成:<br>$$<br>dp[0][nums[0]+sum] = 1;         \<br>            dp[0][-nums[0]+sum] = 1;<br>$$<br>第一个数可能为负或者正嘛. 但是如果第一个数为$0$.那么上面的式子将失效, 0 的相反数是其自身. 所以边界条件应该为:<br>$$<br>\left{<br>\begin{array}{cr}<br>\begin{cases}dp[0][nums[0]+sum] = 1;\<br>dp[0][-nums[0]+sum] = 1;\<br>\end{cases},nums[0]!=0<br>\<br>2,otherwise<br>\end{array}<br>\right.<br>$$<br>然后,你这样就以为大功告成了就大错特错了.</p>
<p>在双重循环中,我们必须要考虑$j$的范围,即$dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]$的适用条件. 并不是所有情况都可以用这个式子表示.</p>
<p>经过很长时间的摸索, $-sum \le j \le sum$, $sum$表示数组和,为了节省空间,我们也可以把1000改为$sum$:<br>$$<br>dp[i][j] =\left{ \begin{array}{lcc}<br>dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]],sum-nums[i] &gt;=j&gt;=nums[i]-sum\<br>dp[i-1][j-nums[i]],j&gt;nums[i]-sum\<br>dp[i-1][j+nums[i]],j&lt;sum-nums[i]<br>\end{array}<br>\right.<br>$$<br>做完此题,深感出题人的恐怖.</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//子集问题，转换为0-1背包，动态规划解决。</span></span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">//我们用dp[i][j]表示 0-i区间内组成j的方案数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:nums) sum+= c;</span><br><span class="line">        S = S&gt;=<span class="number">0</span>?S:-S;</span><br><span class="line">        <span class="keyword">if</span>(S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//为了使得负数也能被索引，我们必须加上它自身的绝对值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*sum+<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!nums[<span class="number">0</span>]) dp[<span class="number">0</span>][sum] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>]+sum] = <span class="number">1</span>;         </span><br><span class="line">            dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+sum] = <span class="number">1</span>;        </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = -sum;j &lt;= sum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(j+nums[i] &lt;= sum &amp;&amp; j-nums[i]&gt;=-sum)</span><br><span class="line">                dp[i][j+sum] = dp[i<span class="number">-1</span>][j-nums[i]+sum] + dp[i<span class="number">-1</span>][j+nums[i]+sum];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j-nums[i]&gt;=-sum)</span><br><span class="line">                dp[i][j+sum] = dp[i<span class="number">-1</span>][j-nums[i]+sum];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j+nums[i]&lt;=sum)</span><br><span class="line">                dp[i][j+sum] = dp[i<span class="number">-1</span>][j+nums[i]+sum];</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;dp[i][j+sum]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][S+sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:$O(1)$, 因为题目已经告诉了具体范围不超过$O(20*2000)=O(40000)$,所以时间复杂度是常数.</p>
<p>空间复杂度:$O(N(2sum+1))$, 这里的$N$表示数组大小, $sum$表示数组之和. </p>
<p>同类题目还有416. 分割等和子数组.</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/27/2020-07-27-backpack-problem/" data-id="ckfj5lo76001r3osc4y7r212m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS-BFS/" rel="tag">DFS&BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/" rel="tag">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E6%A0%91/" rel="tag">前缀树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E6%8C%87%E9%92%88/" rel="tag">多指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E7%94%A8%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="tag">实用用技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%91%E5%90%90%F0%9F%A4%AE%E4%BA%86/" rel="tag">我吐🤮了</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">算法 - 滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">经典数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A2%ABOiers%E8%A7%86%E4%BD%9C%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%97%E6%B3%95/" rel="tag">被Oiers视作优雅的算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/" rel="tag">通用策略</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/" rel="tag">面试基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">高级数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16.67px;">C++</a> <a href="/tags/DFS-BFS/" style="font-size: 10px;">DFS&BFS</a> <a href="/tags/MST/" style="font-size: 10px;">MST</a> <a href="/tags/%E5%89%8D%E7%BC%80%E6%A0%91/" style="font-size: 10px;">前缀树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%A4%9A%E6%8C%87%E9%92%88/" style="font-size: 10px;">多指针</a> <a href="/tags/%E5%AE%9E%E7%94%A8%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">实用用技巧</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" style="font-size: 13.33px;">平衡树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E6%88%91%E5%90%90%F0%9F%A4%AE%E4%BA%86/" style="font-size: 10px;">我吐🤮了</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 13.33px;">机器学习</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">算法 - 滑动窗口</a> <a href="/tags/%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16.67px;">经典数据结构</a> <a href="/tags/%E8%A2%ABOiers%E8%A7%86%E4%BD%9C%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%97%E6%B3%95/" style="font-size: 10px;">被Oiers视作优雅的算法</a> <a href="/tags/%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5/" style="font-size: 10px;">通用策略</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">面试基础</a> <a href="/tags/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">高级数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/23/2020-8=23-string/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/2020-8-30-prefix_sum/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/2020-9-2-fsm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/Curriculum%20Selection/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/09/23/CS_heap_stack/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>