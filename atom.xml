<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Durant Thorvalds 的米奇妙妙屋</title>
  
  <subtitle>在这里，您能感受算法和大数据及存储的魅力！</subtitle>
  <link href="http://durantthorvalds.top/atom.xml" rel="self"/>
  
  <link href="http://durantthorvalds.top/"/>
  <updated>2021-02-11T04:35:18.747Z</updated>
  <id>http://durantthorvalds.top/</id>
  
  <author>
    <name>Durant</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「置顶」本博客导航！</title>
    <link href="http://durantthorvalds.top/2025/12/31/2020-10-8-article_navigator/"/>
    <id>http://durantthorvalds.top/2025/12/31/2020-10-8-article_navigator/</id>
    <published>2025-12-30T16:00:00.000Z</published>
    <updated>2021-02-11T04:35:18.747Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>若您的网页显示mathjax公式出现问题，导致无法阅读，请在任意Mathjax公式上点击右键，<code>Math settings</code>-&gt;<code>Math renderer</code>-&gt;更改为<code>HTML-CSS</code>即可解决。</p>          </div><div class="note note-primary">            <p>因博主水平有限，不足之处请直接在评论区指出，博主将感激不尽！</p>          </div><p>欢迎您光顾本博客！</p><p>本博客 包括<strong>LeetCode</strong>刷题记录和经验，机器学习，以及硕士专业研究课题方面。</p><p>本人硕士研究课题是 <u><strong>纠删码</strong>及<strong>去重</strong>在Ceph分布式存储集群上的应用</u>。对此研究方向感兴趣的道友欢迎一起交流。</p><hr><h2 id="👌LeetCode刷题记录"><a href="#👌LeetCode刷题记录" class="headerlink" title="👌LeetCode刷题记录"></a>👌LeetCode刷题记录</h2><h3 id="A-动态规划"><a href="#A-动态规划" class="headerlink" title="A. 动态规划"></a>A. 动态规划</h3><ul><li>动态规划 <a href="https://durantthorvalds.top/2020/07/21/2020-07-21-dynamic-planning/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>动态规划是将问题分解为更易解决的子问题的一类方法，本blog由浅入深介绍动态规划的常见题型，dp是笔试最常考的问题之一。</p></blockquote><ul><li>做一只可爱的小🐖背包 Cover「背包九讲」 <a href="https://durantthorvalds.top/2020/07/25/2020-07-27-backpack-problem/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>背包问题是很经典的一类dp问题。本blog介绍9种类型的背包问题。面试者若能举一反三，必将事半功倍。</p></blockquote><h3 id="B-树类问题"><a href="#B-树类问题" class="headerlink" title="B. 树类问题"></a>B. 树类问题</h3><ul><li>必须掌握的数据结构-树 <a href="https://durantthorvalds.top/2020/09/23/2020-9-23-binary_tree/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>如果你还不知道什么是树，没有关系！我们将从零开始介绍，1. 二叉树的表示 2.二叉树的遍历 3. 二叉树序列化以及反序列化 4. 树形dp  5.线索二叉树 等。使得你对树类问题有基本认识。</p></blockquote><ul><li>树状数组和线段树 <a href="https://durantthorvalds.top/2020/07/17/2020-07-17-fenwicktree-segmentTree/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>树状数组和线段树都是用于维护数列信息的数据结构，支持单点/区间修改，单点/区间询问信息。以增加权值与询问区间权值和为例，其余的信息需要维护也都类似。时间复杂度均为$O(logn)$。</p></blockquote><ul><li>Google划词搜索的秘密——前缀树 <a href="https://durantthorvalds.top/2020/07/21/2020-8-20-what-is-Trie/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>前缀树又名<strong>Tries树</strong>、<strong>字典</strong>树、单词查找树等，常用于快速检索，大量字符串的排序和统计等。Trie相比于哈希表存储多个具有相同前缀的键时所用空间较少。因此前缀树只需要$O(m)$的空间，m为键长度。在字符串问题中很常见。</p></blockquote><ul><li>花拳绣腿学红黑树 <a href="https://durantthorvalds.top/2020/05/10/2020-05-10-red-black-tree/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>红黑树的结点增删改查效率非常优良，都为$log(n) $, 应用方面：1. Linux内核进程调度由红黑树管理进程控制块。 2. Epoll用红黑树管理事件块。 3. nginx服务器用红黑树管理定时器。 4. C++ STL中的map和set的底层实现为红黑树。 5. Java中的TreeMap和TreeSet由红黑树实现。 6. Java8开始，HashMap中，当一个桶的链表长度超过8，则会改用红黑树。红黑树在面试中会出现，笔试中可不会出现哦。</p></blockquote><ul><li>全手写实现AVL树 <a href="https://durantthorvalds.top/2020/05/10/2020-04-30-avl-tree/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>AVL树是严格平衡的二叉树，红黑树是弱平衡的二叉树。和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此相同节点数的前提下，AVL树的高度往往低于红黑树。同样，在笔试中不会出现，面试时可能会问概念。有兴趣的读者可以自己实现。</p></blockquote><h3 id="C-模拟问题"><a href="#C-模拟问题" class="headerlink" title="C. 模拟问题"></a>C. 模拟问题</h3><ul><li>神奇的多指针 <a href="https://durantthorvalds.top/2020/07/21/2020-7-30-pointers/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>很多时候多指针（双指针，三指针，快慢指针）能极大的帮助我们降低时间复杂度和空间复杂度，比如从$O(n^2)$降低到$O(n)$。例如求链表到数第N个节点，以及判断链表中是否有环，神奇的Floyd判圈法。</p></blockquote><ul><li>「面试向」排序算法 <a href="https://durantthorvalds.top/2020/07/21/2020-7-30-sorting-magic/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>包括冒泡排序，选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序，计数排序，桶排序，基数排序。研究它们算法，以及最好最坏平均时间复杂度和空间复杂度，是否为就地替换以及稳定性。</p></blockquote><ul><li>解空间极大问题通用策略 <a href="https://durantthorvalds.top/2020/08/01/2020-8-1-common-way-solve-big-problem/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>如果输出有非常的项（比如求子集，全排列），要确保结果<strong>完整</strong>且不<strong>重复</strong>，有多种策略：1. 递归，2. 回溯，3. 字典， 4. 数学， 5. 状态压缩， 6. 剪枝技巧</p></blockquote><ul><li>滑动窗口，滑动的艺术 <a href="https://durantthorvalds.top/2020/07/21/2020-8-1-sliding-windows/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>在滑动窗口中有两个指针，一个指针静止，而另一个指针保持移动。我们在s上滑动窗口，如果能够包含整个T（<strong>注意</strong>，T可能有重复字符），如果能收缩，我们就收缩窗口直到得到最小窗口。</p></blockquote><ul><li>红尘客栈之单调栈 <a href="https://durantthorvalds.top/2020/07/21/2020-8-17-recognition-monostack/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>单调栈内元素保持<strong>非递减顺序</strong>，在特定的应用背景下，比如一维参量在一个<strong>连续</strong>范围变化，温度在一段时间变化，股价的增减，柱状图。请考虑单调栈。</p></blockquote><ul><li>数组和字符串的🆒skr操作——前缀和 <a href="https://durantthorvalds.top/2020/10/16/2020-10-16-prefix_sum/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>前缀和的本质是一维或二维差分数组，对区间的查询和修改，比树状数组和线段树相比，不需要特定的数据结构，更加容易使用。</p></blockquote><ul><li>一句话能打败 99.99999%的程序员的位操作代码 <a href="https://durantthorvalds.top/2020/08/23/2020-8-23-bitoperation/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>位操作是计算机最基本的操作之一，它可以与很多问题进行结合，从而优化解法空间复杂度，比如在状态压缩中利用左移，数组low_bit以及<strong>Brian kernighan算法</strong>.</p></blockquote><h3 id="D-贪心算法"><a href="#D-贪心算法" class="headerlink" title="D. 贪心算法"></a>D. 贪心算法</h3><ul><li>贪婪而巧妙的贪心算法 <a href="https://durantthorvalds.top/2020/09/02/2020-8-25-greedy/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p></blockquote><h3 id="E-数学"><a href="#E-数学" class="headerlink" title="E. 数学"></a>E. 数学</h3><ul><li>数学和线性代数用于解题 <a href="https://durantthorvalds.top/2020/09/02/2020-8-25-math/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>数论，求质因数,最大公因数（GCD）,最小公倍数（LCM）, 快速幂算法, Gauss消元法, 几何，排列组会问题等</p></blockquote><h3 id="F-字符串"><a href="#F-字符串" class="headerlink" title="F. 字符串"></a>F. 字符串</h3><ul><li>臭名昭著的KMP算法<a href="https://durantthorvalds.top/2020/07/21/2020-8-29-KMP/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p><strong>KMP</strong>算法是用于字符串匹配，十分巧妙，也极难理解。</p></blockquote><ul><li>东方不败——回文问题<a href="https://durantthorvalds.top/2020/07/21/2020-08-19-manacher/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>回文指正反读都一样的字符串，<strong>Manacher</strong>算法专门用于解决回文问题。当然，<strong>Rabin-Karp</strong>编码在一定条件下也是不错的解决问题的方法。</p></blockquote><h3 id="G-图论"><a href="#G-图论" class="headerlink" title="G. 图论"></a>G. 图论</h3><ul><li>再也不想做图类题目了 <a href="https://durantthorvalds.top/2020/07/21/2020-08-1-representation_of_graph/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>本博客介绍了四种图的表示方法，包括 邻接矩阵表示法，关联矩阵表示法，邻接表表示法，弧表示法，星形表示法。以及图的典型算法，包括Dijkstra, Floyd, Bellman-Ford以及SPFA算法。</p></blockquote><ul><li>双胞胎DFS与BFS <a href="https://durantthorvalds.top/2020/09/27/2020-8-12-dfs-bfs/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>二叉树里面的三种遍历既可以用DFS（递归写法），也可以用BFS（迭代+栈），而层序遍历对应的就是BFS。</p><p>在图和树类型题目，以及部分数组题目，都可以时不时看到两种算法同时出现。递归注意1. 触发条件 2. 终止条件 3. 剪枝问题。</p></blockquote><ul><li>浅析最小生成树  <a href="https://durantthorvalds.top/2020/09/18/2020-9-12-minimal-Spanning-tree/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>最小生成树（$Minimal  Spanning  Tree,MST$）：有 n 个结点的<a href="https://baike.baidu.com/item/连通图/6460995">连通图</a>的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。比较常用的有两种算法：$Kruskal$算法和$Prim$算法。</p></blockquote><ul><li>优雅而巧妙的并查集 <a href="https://durantthorvalds.top/2020/08/14/2020-8-14-what-is-UnionSet/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题，它管理一系列<strong>不相交</strong>的集合，并支持两种操作。即<strong>查询</strong>和<strong>合并</strong>。在求联通/合并问题能大显身手。</p></blockquote><ul><li>求解欧拉通路<a href="https://durantthorvalds.top/2020/08/27/2020-8-27-some_tricks/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>给定一个 <em>n</em> 个点 <em>m</em> 条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。常见算法有$Hierholzer$算法。</p></blockquote><ul><li>抛砖引玉析回溯 <a href="https://durantthorvalds.top/2020/08/02/2020-8-2-trackback-demo/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>回溯法，通常以dfs或bfs为载体，在特定的问题下，通过试错，得到所有可能状态，当然有些状态是多余的，因此<strong>剪枝</strong>显得极为重要。</p></blockquote><ul><li>距离向量路由选择算法——DV <a href="https://durantthorvalds.top/2020/12/15/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95DV/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>目前的路由器都在运行的算法，你一定不想不知道！</p></blockquote><h3 id="H-综合应用"><a href="#H-综合应用" class="headerlink" title="H. 综合应用"></a>H. 综合应用</h3><ul><li>买股票问题 <a href="https://durantthorvalds.top/2020/08/26/2020-8-26-lotus/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>这类问题涉及很多知识，可能包括dp，单调栈，有限状态自动机等。</p></blockquote><ul><li>权力的游戏之零和博弈  <a href="https://durantthorvalds.top/2020/07/21/2020-9-1-what-is-zero-sum/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>在零和博弈中，让自己最优和让对手最差其实是相同的目标！原因还是那句话，两人的总得分不会变化，自己多了，对手必然减少。没有人是傻子，但是赢者通常会利用游戏规则!</p></blockquote><h3 id="G-其它"><a href="#G-其它" class="headerlink" title="G. 其它"></a>G. 其它</h3><ul><li>有限状态自动机（DSA）<a href="https://durantthorvalds.top/2020/09/02/2020-9-2-fsm/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：有一个特殊的状态，被称作「初始状态」。还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</p></blockquote><ul><li>代码优化系列<a href="https://durantthorvalds.top/2020/09/18/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>包括C++,Java, Python代码中很容易遇见的坑，类似于错别字和陷阱，一定要注意。</p></blockquote><ul><li>设计类问题 <a href="">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>Leetcode 上典型设计问题的赏析。举一反三，触类旁通。</p></blockquote><ul><li>「研究向」Redis中跳表实现原理<a href="https://durantthorvalds.top/2020/12/01/%E3%80%90%E7%A0%94%E7%A9%B6%E5%90%91%E3%80%91Redis%E4%B8%AD%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>在分布式存储系统Redis中一个非常优秀的算法，跳表，LC上也有对应的题目。</p></blockquote><ul><li>「阅读」程序员的有趣题目🎨<a href="">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>刷题之暇，整点好活！</p></blockquote><h2 id="🤖机器学习系列"><a href="#🤖机器学习系列" class="headerlink" title="🤖机器学习系列"></a>🤖机器学习系列</h2><blockquote><p>以周志华老师《机器学习》为基准，力争从算法角度解释机器学习的所有问题。</p></blockquote><ul><li>机器学习I 基本概念 <a href="https://durantthorvalds.top/2020/08/04/2020-05-10-ML1/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习II 模型评估与选择<a href="https://durantthorvalds.top/2020/08/04/2020-08-4-ML2/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习III 线性模型 <a href="https://durantthorvalds.top/2020/08/23/2020-08-23-ML3/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习算法I 决策树 <a href="https://durantthorvalds.top/2020/09/27/ML4_DecisionTree/">&gt;&gt;传送门&lt;&lt;</a></li><li>机器学习算法II 神经网络 <a href="[https://durantthorvalds.top/2020/10/02/20201002-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95II-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/](https://durantthorvalds.top/2020/10/02/20201002-机器学习算法II-神经网络/">&gt;&gt;传送门&lt;&lt;</a>)</li></ul><h2 id="🚀大数据与分布式存储系列"><a href="#🚀大数据与分布式存储系列" class="headerlink" title="🚀大数据与分布式存储系列"></a>🚀大数据与分布式存储系列</h2><blockquote><p>以云存储和大数据为研究背景。辐射包括Ceph，Hadoop，纠删码研究等方方面面。</p><p>其中「入门部署」表示初始部署集群，「高级部署」表示有一定挑战性的部署，比如手动部署，「参考」表示一些非核心的帮助理解的内容，「核心」表示深入理解原理，并且熟练操作。「综述」表示一些学术性总结内容。「研究向」表示需要很多时间和兴趣来研究的内容，面试一般不会考到，但很经典。</p></blockquote><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>「高级部署」ceph手动部署集群<a href="https://durantthorvalds.top/2020/10/21/Ceph%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>包括手动部署，存储集群配置以及<strong>源码编译</strong>等。</p></blockquote><ul><li>「入门理论」ceph基础理论——<a href="https://durantthorvalds.top/2020/11/22/CEPH%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph的基本原理，供读者有一个大致了解。</p></blockquote><ul><li>「入门部署」ceph-ansible部署踩坑日记——<a href="https://durantthorvalds.top/2020/11/25/Ceph-ansible%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph-ansible是目前用的最广的ceph部署工具，功能远超ceph-deploy。建议采用此方式。</p></blockquote><ul><li>「入门部署」Ceph-deploy流程 <a href="https://durantthorvalds.top/2020/11/19/Ceph-deploy%E6%B5%81%E7%A8%8B/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>完整的ceph-deploy部署流程。</p></blockquote><ul><li>「综述」纠删码在存储系统的应用——<a href="https://durantthorvalds.top/2020/11/15/%E7%BA%A0%E5%88%A0%E7%A0%81%E5%9C%A8%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E7%94%A8/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>最最最最最最新的纠删码综述，包括RS码，包括RS码，MSR，LRC等。不断更新，引领前沿。</p></blockquote><ul><li>「探秘」Jerasure那些事——<a href="">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>经典的Jerasure库，源码分析，经典必看！</p></blockquote><ul><li>「理论」最小密度RAID-6编码<a href="">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>Blaum-Roth\Liberation\Liber8tion介绍和理论。</p></blockquote><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li>「核心」Ceph三部曲之一：浅析CRUSH算法———<a href="https://durantthorvalds.top/2020/11/27/A%20first%20glance%20at%20CRUSH/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>介绍Ceph核心算法，CRUSH算法。以及相关实践。</p></blockquote><ul><li>「核心」Ceph三部曲之二：ceph纠删码部署——<a href="https://durantthorvalds.top/2020/11/26/ceph%E7%BA%A0%E5%88%A0%E7%A0%81%E9%83%A8%E7%BD%B2/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph中纠删码部署。从原理到五种库源码，笔者研究重点，因为目前Ceph纠删码还有很多待完善的地方。</p></blockquote><ul><li>「核心」Ceph三部曲之三：迁移之美——PG读写流程与状态迁移详解 ———<a href="https://durantthorvalds.top/2020/12/15/%E8%BF%81%E7%A7%BB%E4%B9%8B%E7%BE%8EPG%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E8%AF%A6%E8%A7%A3/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph最难理解也最有趣的概念，PG。深入学习必看!</p></blockquote><ul><li>「核心」Ceph三部曲之四:下一代对象存储引擎BlueStore ———<a href="https://durantthorvalds.top/2020/12/27/%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EBlueStore/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>目前的存储介质已经由传统的机械硬盘hdd升级到SSD和NVME，这为下一代对象存储BlueStore提供了基础，相比于目前FileStore，BlueStore拥有无与伦比的优势。</p></blockquote><ul><li>「核心」Ceph学习三部曲之五:控制先行——Ceph的QoS策略<a href="https://durantthorvalds.top/2020/12/28/%E6%8E%A7%E5%88%B6%E5%85%88%E8%A1%8C-Ceph%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0QoS/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>详细介绍Ceph QoS策略，讲解dmClock等算法实现和操作。</p></blockquote><ul><li>「核心」Ceph学习三部曲之六：分布式块存储RBD<a href="https://durantthorvalds.top/2020/12/29/20201220-%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E5%85%AD%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%9D%97%E5%AD%98%E5%82%A8RBD/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>介绍Ceph分布式块存储，包括快照克隆等功能的理解。</p></blockquote><ul><li>「核心」Ceph学习三部曲之七：对象存储网关RGW<a href="https://durantthorvalds.top/2021/01/03/%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3RGW/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>Ceph对象存储使用Ceph对象网关守护进程（<code>radosgw</code>），它是一个用于与Ceph存储群集进行交互的HTTP服务器。由于它提供与OpenStack Swift和Amazon S3兼容的接口，因此Ceph对象网关具有自己的用户管理。</p></blockquote><ul><li>「核心」Ceph学习三部曲之八：分布式文件系统CephFS</li></ul><blockquote><p>Ceph文件系统或<strong>CephFS</strong>是在Ceph的分布式对象存储<strong>RADOS</strong>之上构建的POSIX兼容文件系统。CephFS致力于为各种应用程序提供最新，多用途，高可用性和高性能的文件存储，包括传统用例（如共享主目录，HPC暂存空间和分布式工作流共享存储）。</p></blockquote><ul><li>「参考」Ceph pool  ———<a href="https://durantthorvalds.top/2020/12/14/ceph%20pool/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>Ceph的池是理解PG，OSD的桥梁，可以直接操作的对象！</p></blockquote><ul><li>「参考」Ceph配置文件conf ———<a href="https://durantthorvalds.top/2020/12/15/Ceph%20%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>ceph文件配置参考。</p></blockquote><ul><li>「参考」Ceph-Mon详解 ———<a href="https://durantthorvalds.top/2020/11/03/2020113-Ceph-Mon-%E8%AF%A6%E8%A7%A3/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>对Ceph的管理者Monitor进行理解。监视器们维护着集群运行图的“主副本”，就是说客户端连到一个监视器并获取当前运行图就能确定所有监视器、 OSD 和元数据服务器的位置。</p></blockquote><ul><li>「应用」Ceph应用实战————<a href="">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>应用实战！</p></blockquote><h2 id="大师"><a href="#大师" class="headerlink" title="大师"></a>大师</h2><h2 id="🍜文化"><a href="#🍜文化" class="headerlink" title="🍜文化"></a>🍜文化</h2><blockquote><p>看看就好，笔者的一些随笔和感想。涵盖方面及其广泛。</p></blockquote><ul><li>小白投资入门（煎炸卤炖）———<a href="https://durantthorvalds.top/2020/12/14/%E5%B0%8F%E7%99%BD%E6%8A%95%E8%B5%84%E5%85%A5%E9%97%A8/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>看知乎，学炒股。</p></blockquote><ul><li>日语名谚语系列 ———<a href="https://durantthorvalds.top/2020/11/19/%E6%AF%8E%E6%97%A5%E6%94%BE%E9%80%81%EF%BC%8D%E6%97%A5%E6%9C%AC%E3%81%AE%E8%AB%BA/">&gt;&gt;传送门&lt;&lt;</a></li></ul><blockquote><p>笔者对日语文化有浓厚兴趣，立志考过N1，いしょうに頑張ってなあ！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note note-warning&quot;&gt;
            &lt;p&gt;若您的网页显示mathjax公式出现问题，导致无法阅读，请在任意Mathjax公式上点击右键，&lt;code&gt;Math settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Math rend</summary>
      
    
    
    
    <category term="导航" scheme="http://durantthorvalds.top/categories/%E5%AF%BC%E8%88%AA/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://durantthorvalds.top/2021/04/11/%E6%89%BE%E8%A7%84%E5%BE%8B%E9%97%AE%E9%A2%98/"/>
    <id>http://durantthorvalds.top/2021/04/11/%E6%89%BE%E8%A7%84%E5%BE%8B%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-11T03:15:14.215Z</published>
    <updated>2021-04-11T03:15:14.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找规律问题"><a href="#找规律问题" class="headerlink" title="找规律问题"></a>找规律问题</h1><h4 id="264-丑数-II-（小顶堆-去重）"><a href="#264-丑数-II-（小顶堆-去重）" class="headerlink" title="264. 丑数 II （小顶堆+去重）"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II （小顶堆+去重）</a></h4><h4 id="1792-最大平均通过率（小顶堆）"><a href="#1792-最大平均通过率（小顶堆）" class="headerlink" title="1792. 最大平均通过率（小顶堆）"></a><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">1792. 最大平均通过率（小顶堆）</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;找规律问题&quot;&gt;&lt;a href=&quot;#找规律问题&quot; class=&quot;headerlink&quot; title=&quot;找规律问题&quot;&gt;&lt;/a&gt;找规律问题&lt;/h1&gt;&lt;h4 id=&quot;264-丑数-II-（小顶堆-去重）&quot;&gt;&lt;a href=&quot;#264-丑数-II-（小顶堆-去重）&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>「面试」B树和B+树</title>
    <link href="http://durantthorvalds.top/2021/03/20/B%E6%A0%91%E5%92%8CB+%E6%A0%91/"/>
    <id>http://durantthorvalds.top/2021/03/20/B%E6%A0%91%E5%92%8CB+%E6%A0%91/</id>
    <published>2021-03-19T16:00:00.000Z</published>
    <updated>2021-04-11T09:41:22.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试向-B树和B-树"><a href="#面试向-B树和B-树" class="headerlink" title="[面试向]B树和B+树"></a>[面试向]B树和B+树</h1><blockquote><p>转载于：<a href="https://segmentfault.com/a/1190000020416577">https://segmentfault.com/a/1190000020416577</a></p></blockquote><h2 id="1-B树（B-树）"><a href="#1-B树（B-树）" class="headerlink" title="1. B树（B-树）"></a>1. B树（B-树）</h2><p>我们先把定义抛出来，好让大家有个直观的认识，设B树的阶数为m，阶数就是一个节点有多少个孩子：</p><ul><li>每个节点最多有m-1个关键字；</li><li>根节点最少可以只有1个关键字；</li><li>非根节点至少有m/2个关键字；</li><li>每个节点中的关键字都按照从小到大的顺序排列。每个关键字的左子树中的所有关键字都小于它，每个关键字的右子树中的所有关键字都大于它；</li><li>所有叶子节点都位于同一层；</li><li>每个节点存储KV键值对。</li></ul><p>根节点的关键字数量范围为$1\le k\le m-1$，非根节点的关键字数量范围：$m/2\le k \le m-1$。</p><h3 id="1-1-B树的插入"><a href="#1-1-B树的插入" class="headerlink" title="1.1 B树的插入"></a>1.1 B树的插入</h3><p>我们只需要记住一个原则即可：<strong>插入的时候判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点之间的key分为左右两个部分，中间节点放到父节点即可。</strong></p><p>例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。</p><ul><li>插入18，70，50,40</li></ul><p><img src="/img/1460000020416580" alt="img"></p><ul><li>插入22</li></ul><p><img src="/img/1460000020416581" alt="img"></p><p>插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。</p><p><img src="/img/1460000020416582" alt="img"></p><ul><li>接着插入23，25，39</li></ul><p><img src="/img/1460000020416584" alt="img"></p><p>分裂，得到下面的。</p><p><img src="/img/1460000020416585" alt="img"></p><p>更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。</p><h3 id="1-2-B树的删除操作"><a href="#1-2-B树的删除操作" class="headerlink" title="1.2 B树的删除操作"></a>1.2 B树的删除操作</h3><ul><li>现在有一个初始状态是下面这样的B树，然后进行删除操作。</li></ul><p><img src="/img/1460000020416586" alt="img"></p><ul><li>删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于<code>m/2</code>，这种情况只要直接删除即可。</li></ul><p><img src="/img/1460000020416587" alt="img"></p><p><img src="/img/1460000020416588" alt="img"></p><ul><li>接着，我们把22删除，这种情况的规则：22是非叶子节点，<strong>对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key</strong>。对于删除22，需要将后继元素24移到被删除的22所在的节点。</li></ul><p><img src="/img/1460000020416589" alt="img"></p><p><img src="/img/1460000020416590" alt="img"></p><p>此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：<strong>如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点</strong>。这样就满足要求了。</p><p>我们看看操作过程就更加明白了。</p><p><img src="/img/1460000020416591" alt="img"></p><p><img src="/img/1460000020416592" alt="img"></p><ul><li>接着删除28，<strong>删除叶子节点</strong>，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，<strong>首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点</strong>。</li></ul><p><img src="/img/1460000020416593" alt="img"></p><p>移动之后，跟兄弟节点合并。</p><p><img src="/img/1460000020416594" alt="img"></p><p>删除就只有上面的几种情况，根据不同的情况进行删除即可。</p><p>上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。</p><h2 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h2><p>B+树和B树其实非常相似，我们先看看相同点：</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：$m/2 \le k \le m-1$</li></ul><p>再看看不同点：</p><ul><li><p>B+树有两种类型的节点：<strong>内部结点</strong>（也称索引结点）和<strong>叶子结点</strong>。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</p></li><li><p>内部结点中的key都按照<strong>从小到大</strong>的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</p></li></ul><p>下面我们看一个B+树的例子，感受感受它吧！</p><p><img src="/img/1460000020416595" alt="img"></p><h3 id="2-1-B-树的插入"><a href="#2-1-B-树的插入" class="headerlink" title="2.1 B+树的插入"></a>2.1 B+树的插入</h3><p>插入操作也需要铭记一个原则：<strong>当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的</strong>。</p><ul><li>插入5，10，15，20</li></ul><p><img src="/img/1460000020416596" alt="img"></p><ul><li>插入25，此时元素数量大于4个了，分裂</li></ul><p><img src="/img/1460000020416597" alt="img"></p><ul><li>接着插入26，30，继续分裂</li></ul><p><img src="/img/1460000020416598" alt="img"></p><p><img src="/img/1460000020416599" alt="img"></p><p>有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。</p><h3 id="2-2-删除操作"><a href="#2-2-删除操作" class="headerlink" title="2.2 删除操作"></a>2.2 删除操作</h3><p>对于删除操作是比B树简单一些的，因为<strong>叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key</strong>，下面我们看看具体的实例。</p><ul><li>初始状态</li></ul><p><img src="/img/1460000020416600" alt="img"></p><ul><li>删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引</li></ul><p><img src="/img/1460000020416601" alt="img"></p><ul><li>删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引</li></ul><p><img src="/img/1460000020416602" alt="img"></p><ul><li>发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作</li></ul><p><img src="/img/1460000020416603" alt="img"></p><p>这样，B+树的删除操作也就完成了，是不是看完之后，觉得非常简单！</p><h3 id="3-B树和B-树总结"><a href="#3-B树和B-树总结" class="headerlink" title="3 B树和B+树总结"></a>3 B树和B+树总结</h3><p>B+树相对于B树有一些自己的优势，可以归结为下面几点。</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li><li>所有的查询都要查找到叶子节点，<strong>查询性能</strong>是<strong>稳定</strong>的，而B树，每个节点都可以查找到数据，所以<strong>不稳定</strong>。</li><li>所有的叶子节点形成了一个有序链表，更加便于查找。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试向-B树和B-树&quot;&gt;&lt;a href=&quot;#面试向-B树和B-树&quot; class=&quot;headerlink&quot; title=&quot;[面试向]B树和B+树&quot;&gt;&lt;/a&gt;[面试向]B树和B+树&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;转载于：&lt;a href=&quot;https://se</summary>
      
    
    
    
    <category term="数据结构" scheme="http://durantthorvalds.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://durantthorvalds.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="面试" scheme="http://durantthorvalds.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="数据库" scheme="http://durantthorvalds.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis 入门</title>
    <link href="http://durantthorvalds.top/2021/03/19/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://durantthorvalds.top/2021/03/19/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-18T16:00:00.000Z</published>
    <updated>2021-03-22T08:11:45.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><ul><li>Redis是什么？</li></ul><p>一个基于key-value的高性能数据库。Redis支持数据的<strong>持久化</strong>，可以将<strong>内存</strong>中的数据保存在磁盘中，再次上电的时候自动加载。Redis不仅支持简单的key-value存储，还支持list、set、zset、hash等数据结构。Redis支持数据备份，即master-slave模式的数据备份。</p><ul><li>Redis性能高的离谱！</li></ul><p>Redis能读的速度高达11万次每秒，而写的速度是8万一千次每秒；丰富的数据类型——Redis支持二进制的Strings，Lists，Hashes，Sets及Ordered Sets数据结构类型。</p><ul><li>哈，原子！</li></ul><p>Redis的所有操作都是原子的，要么成功执行，要么完全不执行，不存在中间状态。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</p><ul><li>丰富的特性</li></ul><p>支持publish/Subscribe，通知，key过期等许多特性。</p><p>Redis运行在内存中，但是可以持久化到磁盘，所以在对不同的数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存中数据库方面的另一个优点是，相比在磁盘上相同的数据结构，在内存中操作简单很多。</p><h2 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h2><p>Redis支持五种数据类型：Strings，Lists，Hashes，Sets及Ordered Sets（Zset）。</p><ul><li>string是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者其它什么东西。</li><li><strong>注意string最大存储512MB</strong>。</li><li><p>Hash存储键值对，可以存储<code>2^32-1</code>键值对。</p></li><li><p>List是简单的字符串列表，你可以添加一个元素到列表的头部或者尾部。</p></li><li>HyperLogLog可以快速计算集合基数（不重复元素个数）。</li></ul><p>Redis 事务</p><p>Redis事务可以一次执行多个命令：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis入门&quot;&gt;&lt;a href=&quot;#Redis入门&quot; class=&quot;headerlink&quot; title=&quot;Redis入门&quot;&gt;&lt;/a&gt;Redis入门&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Redis是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个基于key-value的高性能数据库</summary>
      
    
    
    
    <category term="Redis" scheme="http://durantthorvalds.top/categories/Redis/"/>
    
    <category term="CLI" scheme="http://durantthorvalds.top/categories/Redis/CLI/"/>
    
    
    <category term="Storage" scheme="http://durantthorvalds.top/tags/Storage/"/>
    
    <category term="DB" scheme="http://durantthorvalds.top/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://durantthorvalds.top/2021/03/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://durantthorvalds.top/2021/03/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-03-13T02:28:22.580Z</published>
    <updated>2021-03-13T02:41:14.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入了解哈希表"><a href="#深入了解哈希表" class="headerlink" title="深入了解哈希表"></a>深入了解哈希表</h1><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：</p><ul><li>哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</li><li>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：<ul><li>链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</li><li>开放地址法：当发现哈希值 h 处产生冲突时，根据某种策略，从 h 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 $h+1,h+2,h+3,\ldots$ 这些整数对应的位置。</li><li>再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</li></ul></li><li>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</li></ul><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>​    那么可以定义$hash(x)=x\%base$，为了尽可能避免冲突，取base为质数。</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; data;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base = <span class="hljs-number">769</span>;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">return</span> key % base;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/** Initialize your data structure here. */</span>    MyHashSet(): data(base) &#123;&#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = hash(key);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;            <span class="hljs-keyword">if</span> ((*it) == key) &#123;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        data[h].push_back(key);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = hash(key);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;            <span class="hljs-keyword">if</span> ((*it) == key) &#123;                data[h].erase(it);                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;        <span class="hljs-comment">/** Returns true if this set contains the specified element */</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h = hash(key);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;            <span class="hljs-keyword">if</span> ((*it) == key) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><p>如果输入是字符串，也可以对每个字符的ASCA码作哈希。</p><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Created on Fri Mar 27 14:25:54 2020</span><span class="hljs-string"></span><span class="hljs-string">A good hash func should satisfy:</span><span class="hljs-string">    1. with minimal collison</span><span class="hljs-string">    2. with least calculation cost</span><span class="hljs-string">    3. with effcient hashed data</span><span class="hljs-string">The most famous hash func: SHA and MD5</span><span class="hljs-string">https://www.cnblogs.com/cheng10/p/9995668.html</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> hashlibprint(hashlib.md5(<span class="hljs-string">&quot;Hello World!&quot;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest())print(hashlib.sha1(<span class="hljs-string">&quot;Hello World!&quot;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest())<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTable</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,table_size</span>):</span><span class="hljs-comment">#table_size should be prime numbers</span>        self.size = table_size        self.slots = [<span class="hljs-literal">None</span>]*self.size        self.data = [<span class="hljs-literal">None</span>]*self.size                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hashfunc</span>(<span class="hljs-params">self, key</span>):</span>        sum_ = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> key:            sum_ = sum_ + ord(str(i))        sum_ = sum_ % self.size        <span class="hljs-keyword">return</span> sum_        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rehash</span>(<span class="hljs-params">self,oldhash,step</span>):</span>        <span class="hljs-keyword">return</span> (oldhash+step)%self.size        <span class="hljs-comment">#Activate the [] usage</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self,key</span>):</span>        <span class="hljs-keyword">return</span> self.get(key)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self,key,data</span>):</span>        self.put(key,data)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span>(<span class="hljs-params">self, key,data</span>):</span>        hashvalue = self.hashfunc(key)        <span class="hljs-keyword">if</span> self.slots[hashvalue] == <span class="hljs-literal">None</span>:            self.slots[hashvalue] = key             self.data[hashvalue] = data        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> self.slots[hashvalue] == key:                self.data[hashvalue] = data            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># solve collision</span>                rehash =self.rehash(hashvalue,<span class="hljs-number">1</span>)                <span class="hljs-keyword">while</span> self.slots[rehash] != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> \                        self.slots[rehash] != key:rehash =self.rehash(rehash,<span class="hljs-number">1</span>)                <span class="hljs-keyword">if</span> self.slots[rehash] == <span class="hljs-literal">None</span>:                    self.slots[rehash] = key                    self.data[rehash] = data                <span class="hljs-keyword">else</span>:                    self.data[rehash] = data    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self,key</span>):</span>        hash_start = self.hashfunc(key)        <span class="hljs-keyword">if</span> self.slots[hash_start] == key:            <span class="hljs-keyword">return</span> self.data[hash_start]        next_hash = hash_start        <span class="hljs-keyword">while</span> self.slots[next_hash]!=key:              next_hash = self.rehash(next_hash,<span class="hljs-number">1</span>)              <span class="hljs-keyword">if</span> self.slots[next_hash] == key:                  <span class="hljs-keyword">return</span> self.data[next_hash]              <span class="hljs-keyword">elif</span>  next_hash==hash_start:                  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>                                h = HashTable(<span class="hljs-number">11</span>)h.put(<span class="hljs-string">&#x27;Alice&#x27;</span>,<span class="hljs-number">24</span>)h.put(<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-number">30</span>)h.put(<span class="hljs-string">&#x27;Carter&#x27;</span>,<span class="hljs-number">26</span>)h.put(<span class="hljs-string">&#x27;Durant&#x27;</span>,<span class="hljs-number">17</span>)h.put(<span class="hljs-string">&#x27;Elizabeth&#x27;</span>,<span class="hljs-number">26</span>)h.put(<span class="hljs-string">&#x27;Aceli&#x27;</span>,<span class="hljs-number">39</span>)h[<span class="hljs-string">&#x27;Zibetahe&#x27;</span>] = <span class="hljs-number">26</span>print(h.slots)print(h.data)print(h.get(<span class="hljs-string">&#x27;Alice&#x27;</span>))print(h.get(<span class="hljs-string">&#x27;Elizabeth&#x27;</span>))print(h[<span class="hljs-string">&#x27;Suzuki Mifukura&#x27;</span>])<span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">In the optimal case, the hash provides time performance of O(1).</span><span class="hljs-string">The Loadfactor is lambda, indicating how full a hash table is , whereby the &quot;linear detection&quot; comparing times is 0.5*(1+1/(1-lambda))</span><span class="hljs-string">the &quot;block chain&quot; is likewise, 0.5*(1+1/(1-lambda)^2)</span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入了解哈希表&quot;&gt;&lt;a href=&quot;#深入了解哈希表&quot; class=&quot;headerlink&quot; title=&quot;深入了解哈希表&quot;&gt;&lt;/a&gt;深入了解哈希表&lt;/h1&gt;&lt;p&gt;为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希函数：能够</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://durantthorvalds.top/2021/03/10/Makefile%20%E6%95%99%E7%A8%8B/"/>
    <id>http://durantthorvalds.top/2021/03/10/Makefile%20%E6%95%99%E7%A8%8B/</id>
    <published>2021-03-10T08:48:58.099Z</published>
    <updated>2021-03-10T08:59:14.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Makefile-教程"><a href="#Makefile-教程" class="headerlink" title="Makefile 教程"></a>Makefile 教程</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/haoel/article/details/2886">https://blog.csdn.net/haoel/article/details/2886</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>———————</p><p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。</p><p>因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p>———————</p><p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p><p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p><p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p><p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</p><p>好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。</p><h2 id="Makefile-介绍"><a href="#Makefile-介绍" class="headerlink" title="Makefile 介绍"></a>Makefile 介绍</h2><p>———————</p><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：<br>    1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br>    2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br>    3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p><p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p><h2 id="一、Makefile的规则"><a href="#一、Makefile的规则" class="headerlink" title="一、Makefile的规则"></a>一、Makefile的规则</h2><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p><pre><code>target ... : prerequisites ...        command        ...        ...target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。prerequisites就是，要生成那个target所需要的文件或是目标。command也就是make需要执行的命令。（任意的Shell命令）</code></pre><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p><p>说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p><h2 id="二、一个示例"><a href="#二、一个示例" class="headerlink" title="二、一个示例"></a>二、一个示例</h2><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p><pre><code>edit : main.o kbd.o command.o display.o /       insert.o search.o files.o utils.o        cc -o edit main.o kbd.o command.o display.o /                   insert.o search.o files.o utils.omain.o : main.c defs.h        cc -c main.ckbd.o : kbd.c defs.h command.h        cc -c kbd.ccommand.o : command.c defs.h command.h        cc -c command.cdisplay.o : display.c defs.h buffer.h        cc -c display.cinsert.o : insert.c defs.h buffer.h        cc -c insert.csearch.o : search.c defs.h buffer.h        cc -c search.cfiles.o : files.c defs.h buffer.h command.h        cc -c files.cutils.o : utils.c defs.h        cc -c utils.cclean :        rm edit main.o kbd.o command.o display.o /           insert.o search.o files.o utils.o</code></pre><p>反斜杠（/）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p><p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p><p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><p>下一页-&gt;</p><p>（版权所有，转载时请注明作者和出处） </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Makefile-教程&quot;&gt;&lt;a href=&quot;#Makefile-教程&quot; class=&quot;headerlink&quot; title=&quot;Makefile 教程&quot;&gt;&lt;/a&gt;Makefile 教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>「模块」Ceph-OSD 集群的奠基石</title>
    <link href="http://durantthorvalds.top/2021/03/09/%E3%80%8C%E6%A8%A1%E5%9D%97%E3%80%8DCeph-OSD-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A5%A0%E5%9F%BA%E7%9F%B3/"/>
    <id>http://durantthorvalds.top/2021/03/09/%E3%80%8C%E6%A8%A1%E5%9D%97%E3%80%8DCeph-OSD-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A5%A0%E5%9F%BA%E7%9F%B3/</id>
    <published>2021-03-08T16:00:00.000Z</published>
    <updated>2021-03-09T09:41:17.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ceph-OSD"><a href="#Ceph-OSD" class="headerlink" title="Ceph OSD"></a>Ceph OSD</h1><p>OSD是Ceph存储集群最关键的组件之一，相比传统对象存储具有革命性的创新：</p><ul><li>资源精确控制——每个OSD可以对其消耗的CPU、内存、网络带宽等资源进行精确控制。从而避免资源浪费。</li><li>实例化对象存储——OSD定义了一整套完备和具有强一致性的语义的对象操作接口API。</li><li>高度自治——Ceph OSD是高度去中心化的，除了数据读写外，还能进行数据重平衡，自动恢复等酷炫特性。OSD之间相互通信，将心跳等信息上报至Monitor，点对点传播OSDMap。从而最小化对用户请求的影响。</li></ul><h2 id="网络通信——Messenger"><a href="#网络通信——Messenger" class="headerlink" title="网络通信——Messenger"></a>网络通信——Messenger</h2><p>Ceph将整个RADOS集群分为两个网络平面，公共网络和集群网络。因为集群网络的流量远远大于公共网络（内部数据恢复和平衡等），所以集群网络负载远远大于公共网络。</p><p>OSD内的Messenger主要功能有：1. 客户端与OSD之间进行通信，2. OSD之间进行通信，3. OSD之间链路检测（心跳检测等），以及Cache-Tier等。</p><p>osd状态</p><div class="table-container"><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Up</td><td style="text-align:center">正常状态</td></tr><tr><td style="text-align:center">Down</td><td style="text-align:center">异常状态（对应临时性故障，不会引起PG迁移）</td></tr><tr><td style="text-align:center">Out</td><td style="text-align:center">OSD处于Down超过一定时间，会被设置为永久性故障，导致PG迁移。</td></tr><tr><td style="text-align:center">In</td><td style="text-align:center">OSD恢复正常。</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ceph-OSD&quot;&gt;&lt;a href=&quot;#Ceph-OSD&quot; class=&quot;headerlink&quot; title=&quot;Ceph OSD&quot;&gt;&lt;/a&gt;Ceph OSD&lt;/h1&gt;&lt;p&gt;OSD是Ceph存储集群最关键的组件之一，相比传统对象存储具有革命性的创新：&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="ceph" scheme="http://durantthorvalds.top/categories/ceph/"/>
    
    <category term="分布式存储" scheme="http://durantthorvalds.top/categories/ceph/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="系统架构" scheme="http://durantthorvalds.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="ceph" scheme="http://durantthorvalds.top/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://durantthorvalds.top/2021/02/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://durantthorvalds.top/2021/02/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T03:28:14.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式Regex"><a href="#正则表达式Regex" class="headerlink" title="正则表达式Regex"></a>正则表达式Regex</h1><p>首先我们用一张图了解一下正则表达式的基本语法，再以C++为例具体讲解。</p><p><img src="Regex.png" alt="Regex"></p><h2 id="1-导入正则表达式库"><a href="#1-导入正则表达式库" class="headerlink" title="1 导入正则表达式库"></a>1 导入正则表达式库</h2><p>​    C++可以支持ECMAScript正则，也可以支持grep正则。</p><p>头文件</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span></code></pre><p>其中的函数<code>regex_search</code>和<code>regex_match</code>均可以完成匹配，返回bool类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式Regex&quot;&gt;&lt;a href=&quot;#正则表达式Regex&quot; class=&quot;headerlink&quot; title=&quot;正则表达式Regex&quot;&gt;&lt;/a&gt;正则表达式Regex&lt;/h1&gt;&lt;p&gt;首先我们用一张图了解一下正则表达式的基本语法，再以C++为例具体讲解。&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="http://durantthorvalds.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="分治" scheme="http://durantthorvalds.top/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>分治策略：Divide and Conquer</title>
    <link href="http://durantthorvalds.top/2021/02/27/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%EF%BC%9ADivide-and-Conquer/"/>
    <id>http://durantthorvalds.top/2021/02/27/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%EF%BC%9ADivide-and-Conquer/</id>
    <published>2021-02-26T16:00:00.000Z</published>
    <updated>2021-03-05T07:05:39.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治：Divide-and-Conquer"><a href="#分治：Divide-and-Conquer" class="headerlink" title="分治：Divide and Conquer"></a>分治：Divide and Conquer</h1><p>在计算机科学中，分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>这个技巧是很多高效算法的基础，如二分查找、排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。</p><p><img src="../img/4f492f90ae0561f73291f48b3b87ee895392da9bbfb49277fb8fec6024a86634-image.png" alt="image.png"></p><p>另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个理论，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。</p><p>分治法这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的折半搜索算法。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用尾部递归的话，便能转换成简单的循环。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用减治法这个名称。</p><p>分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。【摘自<a href="https://leetcode-cn.com/tag/divide-and-conquer/">力扣分治标签</a>】</p><p>例题：</p><p> <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II(Medium)</a>[二维矩阵的二分查找]</p><p> <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素(Medium)</a>[快速排序板子]</p><p> <a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串(Medium)</a>[分治+dfs]</p><p> <a href="https://leetcode-cn.com/problems/reverse-pairs/">493. 翻转对(Hard)</a></p><p> <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表(Hard)</a></p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>二分查找对于那种具有<strong>单调特性</strong>的变量十分适用，然后我们需要找到变量的lower_bound 和up_bound然后注意边界条件，进行结果的更新即可。其代码有类似以下的结构：</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> low = LOWER_BOUND, up = UP_BOUND;<span class="hljs-keyword">while</span>(low &lt;= up)&#123;<span class="hljs-keyword">int</span> mid = (low+up)/<span class="hljs-number">2</span>;<span class="hljs-keyword">int</span> y = get_y();<span class="hljs-comment">//y是具有单调特性的变量,随着mid增大而减小</span><span class="hljs-keyword">if</span>(y &lt;= MAXY)<span class="hljs-comment">//比如我们希望找到一个小于MAXY的最大的y对应的最小的mid</span>&#123;high = mid<span class="hljs-number">-1</span>;res = min(res,mid);&#125;<span class="hljs-keyword">else</span>&#123;low = mid+<span class="hljs-number">1</span>;&#125;&#125;</code></pre><blockquote><p>关于C++库函数lower_bound和up_bound；</p><p>在从小到大的排序数组中，</p><p><code>lower_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个<strong>大于或等于</strong>num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><code>upper_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个<strong>大于</strong>num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>在从大到小的排序数组中，</p><p><code>lower_bound( begin,end,num,greater&lt;type&gt;() )</code>:从数组的begin位置到end-1位置二分查找第一个<strong>小于或等于</strong>num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><code>upper_bound( begin,end,num,greater&lt;type&gt;() )</code>:从数组的begin位置到end-1位置二分查找第一个<strong>小于</strong>num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p></blockquote><h4 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h4><h4 id="1760-袋子里最少数目的球"><a href="#1760-袋子里最少数目的球" class="headerlink" title="1760. 袋子里最少数目的球"></a><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">1760. 袋子里最少数目的球</a></h4><p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>注意</strong>：不允许旋转信封。</p><p><strong>示例 1：</strong></p><pre><code class="hljs angelscript">输入：envelopes = [[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]输出：<span class="hljs-number">3</span>解释：最多信封的个数为 <span class="hljs-number">3</span>, 组合为: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] =&gt; [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>] =&gt; [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs angelscript">输入：envelopes = [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]输出：<span class="hljs-number">1</span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= envelopes.length &lt;= 5000</code></li><li><code>envelopes[i].length == 2</code></li><li><code>1 &lt;= wi, hi &lt;= 10^4</code></li></ul><hr><p>此题是300.最长递增子序列的二维扩展版，设$dp[j]$表示envelopes前i个元素可以组成长度为j的最长严格递增子序列末尾元素，如果不存在对应的最长递增子序列，那么$dp[j]$无定义。在定义的范围内，$dp[j]$是严格单调增的。</p><p>对于元素$h_j$，如果$h_j&gt;dp[j]$，那么可以直接加在后面，否则我们要在序列中找到<strong>最小的大于</strong>$h_j$的数$f[j_0]$。然后进行更新：</p><script type="math/tex; mode=display">dp[j_0+1] = h_j;</script><p>可以用二分查找$j_0$。</p><hr><h3 id="精选题目讲解"><a href="#精选题目讲解" class="headerlink" title="精选题目讲解"></a>精选题目讲解</h3><h2 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h2><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例 1：</strong></p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;aaabb&quot;</span>, k = <span class="hljs-number">3</span>输出：<span class="hljs-number">3</span>解释：最长子串为 <span class="hljs-string">&quot;aaa&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">3</span> 次。</code></pre><p><strong>示例 2：</strong></p><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;ababbc&quot;</span>, k = <span class="hljs-number">2</span>输出：<span class="hljs-number">5</span>解释：最长子串为 <span class="hljs-string">&quot;ababb&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">2</span> 次， &#x27;b&#x27; 重复了 <span class="hljs-number">3</span> 次。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅由小写英文字母组成</li><li><code>1 &lt;= k &lt;= 10^5</code></li></ul><hr><p>思路，如果存在某个字符串c，它出现的次数大于0且小于k，则任何包含c的子串不可能满足要求，我们在其附近搜索，递归，如果存在满足条件的子串就返回其最大长度，否则返回0.</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> dfs(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> k)    &#123;<span class="hljs-comment">//尝试用分治法</span>        <span class="hljs-comment">// dfs返回s[l:r]中所有字符频次均不小于k的最大长度子串</span>        vector&lt;<span class="hljs-built_in">int</span>&gt; cnt(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//统计每个字母出现的次数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = l;i &lt;= r;i++)            cnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;        <span class="hljs-comment">//接下来我们按照字母表顺序找第一个不满足要求的字母</span>        char split = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(cnt[i] &gt; <span class="hljs-number">0</span> &amp;&amp; cnt[i] &lt; k)            &#123;                split = i + <span class="hljs-string">&#x27;a&#x27;</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(split == <span class="hljs-number">0</span>)        &#123;<span class="hljs-comment">//证明所有字符均满足要求，我们直接返回该子串长度即可</span>            <span class="hljs-keyword">return</span> r-l+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">int</span> i = l, ret = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &lt;= r)        &#123;            <span class="hljs-comment">//对一个子串跳过前面不符合要求的字符</span>            <span class="hljs-keyword">while</span>(i&lt;=r &amp;&amp; s[i] == split)            &#123;                i++;            &#125;            <span class="hljs-built_in">int</span> start = i;            <span class="hljs-keyword">while</span>(i&lt;=r &amp;&amp; s[i]!=split)            &#123;                i++;            &#125;            <span class="hljs-built_in">int</span> length = dfs(s,start,i<span class="hljs-number">-1</span>,k);            ret = max(ret, length);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-built_in">int</span> longestSubstring(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> k) &#123;        <span class="hljs-built_in">int</span> n = s.size();        <span class="hljs-keyword">return</span> dfs(s,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,k);    &#125;&#125;;</code></pre><p>复杂度分析</p><p>时间复杂度：$O(N\cdot |\Sigma|)$，其中 $N$ 为字符串的长度，$\Sigma$ 为字符集，本题中字符串仅包含小写字母，因此$ |\Sigma| = 26$。由于每次递归调用都会完全去除某个字符，因此递归深度最多为 $|\Sigma|$。</p><p>空间复杂度：$O(|\Sigma|^2)$。递归的深度为 $O(|\Sigma|)$，每层递归需要开辟 $O(|\Sigma|)$ 的额外空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分治：Divide-and-Conquer&quot;&gt;&lt;a href=&quot;#分治：Divide-and-Conquer&quot; class=&quot;headerlink&quot; title=&quot;分治：Divide and Conquer&quot;&gt;&lt;/a&gt;分治：Divide and Conquer&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="http://durantthorvalds.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="分治" scheme="http://durantthorvalds.top/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://durantthorvalds.top/2021/02/21/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://durantthorvalds.top/2021/02/21/Docker%E5%85%A5%E9%97%A8/</id>
    <published>2021-02-21T04:09:04.964Z</published>
    <updated>2021-02-25T07:25:33.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><blockquote><p>参考：<a href="https://www.runoob.com/docker/docker-hello-world.html">https://www.runoob.com/docker/docker-hello-world.html</a></p><p><a href="https://cr.console.aliyun.com/repository/">https://cr.console.aliyun.com/repository/</a></p></blockquote><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker架构</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>一些常用的命令：</p><ol><li>容器创建, <code>ubuntu:20.10</code>是容器 名称，如果本机没有则会去公共镜像下载。</li></ol><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run ubuntu:<span class="hljs-number">20</span>.<span class="hljs-number">10</span></code></pre><p>并且运行一个很小的脚本(打印hello world)</p><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> ubuntu:20.10 /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span></span></code></pre><p>2.进入容器交互式环境</p><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -i -t ubuntu:<span class="hljs-number">20</span>.<span class="hljs-number">10</span> /bin/bash</code></pre><ul><li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li><li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li><li><strong>-d</strong>: 容器在后台运行。</li></ul><p>我们在容器中运行命令 <strong>cat /proc/version</strong>和<strong>ls</strong>分别查看当前系统的版本信息和当前目录下的文件列表。</p><p>退出容器<code>exit</code>或者<code>ctrl+D</code>，如果我们退出容器但不想关闭，可以用<code>ctrl+P+Q</code>。</p><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker run -d <span class="hljs-symbol">ubuntu:</span><span class="hljs-number">15.10</span> /bin/sh -c</code></pre><p>会输出一串哈希码，指定容器唯一ID。</p><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running 或 Up（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><ol><li>查看容器标准输出</li></ol><pre><code class="hljs lisp">docker logs (<span class="hljs-name">ID</span>或NAMES)</code></pre><ol><li>检查容器状态</li></ol><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps</span></code></pre><ol><li>停止容器</li></ol><pre><code class="hljs sql">docker <span class="hljs-keyword">stop</span> &lt;容器<span class="hljs-keyword">ID</span>&gt;</code></pre><p>重新启动一个容器</p><pre><code class="hljs xml">docker restart <span class="hljs-tag">&lt;<span class="hljs-name">容器ID</span>&gt;</span></code></pre><ol><li>查看所有的容器</li></ol><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps -a</span></code></pre><ol><li>在后台模式进入容器</li></ol><pre><code class="hljs arcade">docker exec -it &lt;ID&gt; <span class="hljs-regexp">/bin/</span>bash</code></pre><p>导入和导出</p><pre><code class="hljs elm">$ docker ex<span class="hljs-keyword">port</span> 1e560fca3906 &gt; ubuntu.tar</code></pre><pre><code class="hljs awk">cat docker<span class="hljs-regexp">/ubuntu.tar | docker import - test/u</span>buntu:v1</code></pre><p>删除容器</p><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rm -f <span class="hljs-number">1</span>e<span class="hljs-number">560</span>fca<span class="hljs-number">3906</span></code></pre><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>查看本机已安装的镜像。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span></code></pre><p>搜索包含指定关键字的镜像</p><pre><code class="hljs xml">docker search <span class="hljs-tag">&lt;&gt;</span></code></pre><p>下载运行一个镜像</p><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> &lt;&gt;</span></code></pre><p>删除一个镜像</p><pre><code class="hljs xml">docker rmi <span class="hljs-tag">&lt;&gt;</span></code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p><ul><li>1、从已经创建的容器中更新镜像，并且提交这个镜像</li><li>2、使用 Dockerfile 指令来创建一个新的镜像</li></ul><p>提交镜像</p><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker commit -m=<span class="hljs-string">&quot;has update&quot;</span> -a=<span class="hljs-string">&quot;runoob&quot;</span> e<span class="hljs-number">218</span>edb<span class="hljs-number">10161</span> runoob/ubuntu:v<span class="hljs-number">2</span><span class="hljs-attribute">sha256</span>:<span class="hljs-number">70</span>bf<span class="hljs-number">1840</span>fd<span class="hljs-number">7</span>c<span class="hljs-number">0</span>d<span class="hljs-number">2</span>d<span class="hljs-number">8</span>ef<span class="hljs-number">0</span>a<span class="hljs-number">42</span>a<span class="hljs-number">817</span>eb<span class="hljs-number">29</span>f<span class="hljs-number">854</span>c<span class="hljs-number">1</span>af<span class="hljs-number">8</span>f<span class="hljs-number">7</span>c<span class="hljs-number">59</span>fc<span class="hljs-number">03</span>ac<span class="hljs-number">7</span>bdee<span class="hljs-number">9545</span>aff<span class="hljs-number">8</span></code></pre><p>更灵活和高效的方式是通过Dockerfile构建镜像</p><pre><code class="hljs dockerfile">runoob@runoob:~$ cat Dockerfile <span class="hljs-keyword">FROM</span>    centos:<span class="hljs-number">6.7</span><span class="hljs-keyword">MAINTAINER</span>      Fisher <span class="hljs-string">&quot;fisher@sudops.com&quot;</span><span class="hljs-keyword">RUN</span><span class="bash">     /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:123456&#x27;</span> |chpasswd</span><span class="hljs-keyword">RUN</span><span class="bash">     useradd runoob</span><span class="hljs-keyword">RUN</span><span class="bash">     /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;runoob:123456&#x27;</span> |chpasswd</span><span class="hljs-keyword">RUN</span><span class="bash">     /bin/<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="hljs-built_in">local</span></span><span class="hljs-keyword">EXPOSE</span>  <span class="hljs-number">22</span><span class="hljs-keyword">EXPOSE</span>  <span class="hljs-number">80</span><span class="hljs-keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span></code></pre><p>之后使用docker build</p><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker build -t runoob/<span class="hljs-symbol">centos:</span><span class="hljs-number">6.7</span> .</code></pre><ul><li><strong>-t</strong> ：指定要创建的目标镜像名</li><li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li></ul><p>此外我们可以设置镜像的标签</p><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker tag <span class="hljs-number">860</span>c<span class="hljs-number">279</span>d<span class="hljs-number">2</span>fec runoob/centos:dev</code></pre><h2 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h2><h2 id="阿里云Docker"><a href="#阿里云Docker" class="headerlink" title="阿里云Docker"></a>阿里云Docker</h2><h3 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h3><pre><code class="hljs pgsql">$ sudo docker <span class="hljs-keyword">login</span> <span class="hljs-comment">--username=durantbonjour registry.cn-shanghai.aliyuncs.com</span></code></pre><p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p><p>您可以在访问凭证页面修改凭证密码。</p><h3 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h3><pre><code class="hljs awk">$ sudo docker pull registry.cn-shanghai.aliyuncs.com<span class="hljs-regexp">/durant2021/</span>flappy_thunderbird:[镜像版本号]</code></pre><h3 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h3><pre><code class="hljs stylus">$ sudo docker login --username=durantbonjour registry<span class="hljs-selector-class">.cn-shanghai</span><span class="hljs-selector-class">.aliyuncs</span>.com$ sudo docker tag [ImageId] registry<span class="hljs-selector-class">.cn-shanghai</span><span class="hljs-selector-class">.aliyuncs</span>.com/durant2021/flappy_thunderbird:[镜像版本号]$ sudo docker push registry<span class="hljs-selector-class">.cn-shanghai</span><span class="hljs-selector-class">.aliyuncs</span>.com/durant2021/flappy_thunderbird:[镜像版本号]</code></pre><p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p><h3 id="4-选择合适的镜像仓库地址"><a href="#4-选择合适的镜像仓库地址" class="headerlink" title="4. 选择合适的镜像仓库地址"></a>4. 选择合适的镜像仓库地址</h3><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p><p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-shanghai.aliyuncs.com 作为Registry的域名登录。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p><pre><code class="hljs angelscript">$ sudo docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com/acs/agent                                    <span class="hljs-number">0.7</span>-dfb6816         <span class="hljs-number">37</span>bb9c63c8b2        <span class="hljs-number">7</span> days ago          <span class="hljs-number">37.89</span> MB$ sudo docker tag <span class="hljs-number">37</span>bb9c63c8b2 registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:<span class="hljs-number">0.7</span>-dfb6816</code></pre><p>使用 “docker push” 命令将该镜像推送至远程。</p><pre><code class="hljs gradle">$ sudo docker <span class="hljs-keyword">push</span> registry-vpc.cn-shanghai.aliyuncs.com<span class="hljs-regexp">/acs/</span>agent:<span class="hljs-number">0.7</span>-dfb6816</code></pre><p>成功之后是酱紫的</p><pre><code class="hljs angelscript"><span class="hljs-number">025970692128</span>: Pushed b0643e258249: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">4</span>d64a8bbbc06: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">35f</span>f166c35a9: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch c0cb45b106e8: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">486</span>a27d7fdcd: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">1</span>db09913a256: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">2e282f</span>599fd6: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch e6f174f76be4: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">808f</span>d332a58a: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch b16af11cbf29: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">37</span>b9a4b22186: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch e0b3afb09dc3: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">6</span>c01b5a53aac: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch <span class="hljs-number">2</span>c6ac8e5063e: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch cc967c529ced: Mounted <span class="hljs-keyword">from</span> tcc-<span class="hljs-keyword">public</span>/pytorch v1: digest: sha256:e978f3f50876f12a8840dfbb87f1c083cfb23ca00c8ebc7a06203f05e1d855f8 size: <span class="hljs-number">3685</span></code></pre><h3 id="6-问题"><a href="#6-问题" class="headerlink" title="6.问题"></a>6.问题</h3><p>push的时候出现</p><pre><code class="hljs routeros">denied: requested access <span class="hljs-keyword">to</span> the<span class="hljs-built_in"> resource </span>is denied</code></pre><p>原因，没有加sudo，或者没有用tag该镜像名字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker入门&quot;&gt;&lt;a href=&quot;#Docker入门&quot; class=&quot;headerlink&quot; title=&quot;Docker入门&quot;&gt;&lt;/a&gt;Docker入门&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.runoob.co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>「阅读」程序员的有趣题目🎨</title>
    <link href="http://durantthorvalds.top/2021/02/11/%E3%80%8C%E9%98%85%E8%AF%BB%E3%80%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%9C%89%E8%B6%A3%E9%A2%98%E7%9B%AE%F0%9F%8E%A8/"/>
    <id>http://durantthorvalds.top/2021/02/11/%E3%80%8C%E9%98%85%E8%AF%BB%E3%80%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%9C%89%E8%B6%A3%E9%A2%98%E7%9B%AE%F0%9F%8E%A8/</id>
    <published>2021-02-10T16:00:00.000Z</published>
    <updated>2021-02-11T04:34:44.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「阅读」程序员的有趣题目🎨"><a href="#「阅读」程序员的有趣题目🎨" class="headerlink" title="「阅读」程序员的有趣题目🎨"></a>「阅读」程序员的有趣题目🎨</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「阅读」程序员的有趣题目🎨&quot;&gt;&lt;a href=&quot;#「阅读」程序员的有趣题目🎨&quot; class=&quot;headerlink&quot; title=&quot;「阅读」程序员的有趣题目🎨&quot;&gt;&lt;/a&gt;「阅读」程序员的有趣题目🎨&lt;/h1&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://durantthorvalds.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://durantthorvalds.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣推荐书目" scheme="http://durantthorvalds.top/tags/%E5%8A%9B%E6%89%A3%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>「探秘」Jerasure那些事</title>
    <link href="http://durantthorvalds.top/2021/02/11/%E3%80%8C%E6%8E%A2%E7%A7%98%E3%80%8DJerasure%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://durantthorvalds.top/2021/02/11/%E3%80%8C%E6%8E%A2%E7%A7%98%E3%80%8DJerasure%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-02-10T16:00:00.000Z</published>
    <updated>2021-02-18T09:10:31.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="libJerasure"><a href="#libJerasure" class="headerlink" title="libJerasure"></a>libJerasure</h1><div class="note note-warning">            <p>2007 James给出了RS-RAID一个开源实现。<u><a href="http://jerasure.org/jerasure/jerasure">official</a> ，<a href="https://github.com/ceph/Jerasure">github</a></u>，目前的版本是2014年发行的2.0版本，是各种纠删码库的开山之作。</p>          </div><p>Jerasure库包括以下5个模块：</p><ul><li><code>galois.h/.c</code>提供伽罗华域的算术运算。</li><li><code>jerasure.h/.c</code>提供了绝大部分的核心函数。包括矩阵的编解码，位矩阵变换，矩阵转置和位矩阵转置。</li><li><code>reedsol.h/.c</code>支持RS编解码和优化和的RS码。</li><li><code>cauchy.h/.c</code> 支持cauchy RS编解码和最优cauchy编码。</li><li><code>cauchy_best_r6.h/.c</code> 基于cauchy矩阵的RAID-6优化。</li><li><code>liberation.h/.c</code> 支持Liberartion RAID-6编码, Blaum-Roth 编码，和Liber8tion RAID-6编码。 Liberation是一种低密度MDS。这三种编码采用位矩阵来实现，其性能<strong>远优于</strong>现有的RS和EVENNODD，在某种情况下也优于目前已知的最好的RDP编码。</li></ul><p>下标汇总了Jerasure-2.0库常见的参数和其含义：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数名</th><th style="text-align:center">数据类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">k</td><td style="text-align:center">int</td><td style="text-align:left">数据盘个数</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">int</td><td style="text-align:left">校验盘个数</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">int</td><td style="text-align:left">字长</td></tr><tr><td style="text-align:center">packetsize</td><td style="text-align:center">int</td><td style="text-align:left">包大小（必须是<code>sizeof(long)</code>的整数倍）</td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">int</td><td style="text-align:left">每个设备要编码/解码的字节总数。 这必须是<code>sizeof(long)</code>的倍数。 如果使用位矩阵，则它必须是<code>packetssize * w</code>的倍数。 如果希望对不符合这些限制的数据块进行编码，则必须用零填充数据块，以便满足这些限制。</td></tr><tr><td style="text-align:center">matrix</td><td style="text-align:center">int  *</td><td style="text-align:left">这是一个具有k * m个元素的数组，表示编码矩阵-即分布矩阵的最后m行。 它的元素必须在0到$2^w -1$之间。第i行和第j列中的元素在`matrix [i * k + j]中。</td></tr><tr><td style="text-align:center">bitmatrix</td><td style="text-align:center">int *</td><td style="text-align:left">这是$w \cdot m \cdot w \cdot k$元素的数组，组成二进制分配矩阵BDM的最后$wm$行。 第i行和第j列中的元素位于<code>bitmatrix [i * k * w + j]</code>中</td></tr><tr><td style="text-align:center">dataptrs</td><td style="text-align:center">char **</td><td style="text-align:left">这是k个指针数组，指向大小为字节的编码数据。 其中每一个必须是长字对齐的。</td></tr><tr><td style="text-align:center">coding_ptrs</td><td style="text-align:center">char **</td><td style="text-align:left">这是m个指针数组，指向大小为字节的编码数据。 其中每一个必须是长字对齐的。</td></tr><tr><td style="text-align:center">erasures</td><td style="text-align:center">int *</td><td style="text-align:left">这是一组ID已删除的设备。 如第4.1节所述，Id是介于0到k + m-1之间的数字。 如果擦除数为$e$，则擦除的元素$0$到$e -1$标识被擦除的设备，并且<code>erasures [e]</code>必须等于-1。</td></tr><tr><td style="text-align:center">erased</td><td style="text-align:center">int *</td><td style="text-align:left">这是指定擦除的替代方法。 它是一个$k + m$的元素数组。 数组的元素$i$代表ID为$i$的设备。 如果<code>erased[i]</code>等于0，则设备i正在工作;如果等于1，则其被擦除。</td></tr><tr><td style="text-align:center">schdule</td><td style="text-align:center">int **</td><td style="text-align:left">这是一个5元素整数数组，用于优化位矩阵的编码计算。  如果计划中有o个操作，则计划必须至少包含o + 1个元素，并且<code>schedule [o][0]</code>应当等于-1。</td></tr><tr><td style="text-align:center">cache</td><td style="text-align:center">int <em>*</em></td><td style="text-align:left">三维数组，用于保存一系列缓存地址，用于对RAID6解码进行优化。</td></tr><tr><td style="text-align:center">row_k_ones</td><td style="text-align:center">bool</td><td style="text-align:left">布尔类型，用于对满足$m&gt;1$的解码过程进行优化。解码时，如果对应编码矩阵第一行全部为1或者对应的二进制编码矩阵前w行构成k个单位矩阵，则设置此标志位有助于提升解码速度。</td></tr><tr><td style="text-align:center">decoding_matrix</td><td style="text-align:center">int *</td><td style="text-align:left">这是用于解码的$k×k$矩阵或$wk×wk$位矩阵。 它是通过使用分布矩阵的相关行并将其求逆而构造的矩阵。</td></tr><tr><td style="text-align:center">dm_ids</td><td style="text-align:center">int *</td><td style="text-align:left">一维数组，用于指定仍然正常的磁盘编号，帮助生成解码矩阵。</td></tr></tbody></table></div><p>针对RAID-6，Jerasure作了两类优化：</p><ul><li><p>对乘2运算进行优化</p></li><li><p>直接对编码矩阵进行改造，得到最小密度RAID6. 这类矩阵很稀疏，计算量较少。目前有三种</p><ul><li>Liberation: 要求W必须是素数</li><li>Blaum-Roth: 要求W+1必须是素数</li><li>Lber8tion: 要求W必须等于8</li></ul><p>这三种编码效率相当。</p></li></ul><blockquote><p>在安装jerasure库之前，我们得安装<a href="https://github.com/ceph/gf-complete">GF-Complete库</a>，注意如果根目录下没有<code>./configure</code>，我们可以先运行<code>./configure.ac</code></p><p>关于安装jerasure库的一些步骤和经验可以看<a href="https://blog.csdn.net/qq_40611993/article/details/108560346">这篇非常好的博客</a>。</p><p>make完成后<code>/usr/local/lib</code>下应该有这些库。</p><pre><code class="hljs css"><span class="hljs-selector-tag">libgf_complete</span><span class="hljs-selector-class">.a</span>   <span class="hljs-selector-tag">libgf_complete</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.1</span>      <span class="hljs-selector-tag">libJerasure</span><span class="hljs-selector-class">.so</span>        <span class="hljs-selector-tag">python3</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-tag">libgf_complete</span><span class="hljs-selector-class">.la</span>  <span class="hljs-selector-tag">libgf_complete</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span>  <span class="hljs-selector-tag">libJerasure</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-tag">libgf_complete</span><span class="hljs-selector-class">.so</span>  <span class="hljs-selector-tag">libJerasure</span><span class="hljs-selector-class">.la</span>           <span class="hljs-selector-tag">libJerasure</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span></code></pre><p>自己写的代码在编译时需指定动态链接库：</p><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">-lJerasure</span> <span class="hljs-selector-tag">-lgf_complete</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span></code></pre><p>库默认安装在<code>/usr/local/lib</code>，否则你需要用<code>-L &#123;path&#125;</code>指定库文件目录。</p></blockquote><hr><h2 id="S1-1-Galois域算术运算"><a href="#S1-1-Galois域算术运算" class="headerlink" title="$\S1.1 $ Galois域算术运算"></a>$\S1.1 $ Galois域算术运算</h2><p>库：<code>galois.h\galois.c</code></p><ul><li><p><code>galois_single_multiply(int a, int b, int w)</code> 以及<code>galois_single_divide(int a ,int b, int w)</code></p><p>在$GF(2^w)$上执行单元素的乘法和除法。</p></li></ul><ul><li><p><code>galois_region_xor(char *r1, char *r2, char *r3, int nbytes)</code></p><p>此XOR对字节的两个区域<code>r1</code>和<code>r2</code>进行求和，并将总和放入<code>r3</code>。 请注意，如果我们用总和替换区域之一，则r3可能等于r1或r2。<br> <code>Nbytes</code>必须是机器长字大小的倍数。</p></li></ul><ul><li><p><code>galois_w08_region_multiply(char *region, int multby, int nbytes, char *r2, int add)</code>: </p><p>这将整个字节区域乘以$GF(2^8)$中的常数<code>multby</code>。 如果<code>r2</code>为NULL，则区域将被覆盖。 否则，如果<code>add</code>为零，则将乘积放在<code>r2</code>中。 如果<code>add</code>不为零，则将乘积与<code>r2</code>中的字节进行异或。</p></li></ul><ul><li><code>galois_w16_region_multiply()</code>和<code>galois_w32_region_multiply()</code>与上述函数类似，分别对应$GF(2^{16})$和$GF(2^{32})$.</li></ul><ul><li><p><code>galois_change_technique(gf_t *gf, int w)</code></p><p>这使您可以从GF-Complete创建自己的Galois Field算术的自定义实现。 为此，请参阅GF-Complete手册中的<code>create_gf_from_argv()</code>和<code>gf_init_hard()</code>。 这些过程允许您创建<code>gf_t</code>，然后调用<code>galois_change _technique()</code>实现。</p></li></ul><ul><li><p><code>galois_init_field()</code>和<code>glois_init_composite_field()</code></p><p>会从GF-Complete创建<code>gf_t</code>指针。我们建议，使用<code>create_gf_from_argv()</code>和<code>gf_init_hard()</code>代替。</p></li></ul><ul><li><p><code>galois_get_field_ptr(int w)</code></p><p>返回一个目前jerasure使用中的指向<code>gf_t</code>的指针，针对指定的w。</p></li></ul><h3 id="1-1-1-内核操作"><a href="#1-1-1-内核操作" class="headerlink" title="1.1.1 内核操作"></a>1.1.1 内核操作</h3><p>库：<code>jerasure.c\jerasure.h</code></p><ul><li><p><code>void jerasure_do_parity(k,data_ptrs, char *parity_ptr, size)</code></p><p>这将从数据ptrs访问的k个内存区域中的每个区域计算数据大小字节的奇偶校验。 它将结果放入奇偶校验ptr指向的大小字节中。 像每个数据ptrs一样，奇偶校验ptr必须是长字对齐的，并且大小必须是sizeof（long）的倍数。</p></li><li><p><code>void jerasure_matrix_encode(k,m,w,bitmatrix,data_ptrs,coding_ptrs,size,packetsize)</code></p><p>这使用位矩阵进行编码。 现在w可以是1到32之间的任何数字。</p></li><li><p><code>void jerasure_schedule_encode(k, m, w, schedule, data ptrs, coding ptrs, size, packetsize)</code>:</p><p>此编码使用从<code>jerasure_dumb_bitmatrix_to_schedule()</code>或<code>jerasure_smart_bitmatrix_schedule()</code>创建的调度进行编码。</p></li></ul><h3 id="1-1-2-解码操作"><a href="#1-1-2-解码操作" class="headerlink" title="1.1.2 解码操作"></a>1.1.2 解码操作</h3><p>这些函数中的每一个都返回一个整数，如果成功则返回0，否则返回-1。 如果擦除太多，则解码可能会失败。</p><ul><li><strong>int jerasure_matrix_decode(k, m, w matrix, row_k_ones, erasures, data ptrs, coding ptrs, size)</strong></li></ul><p>此函数使用$GF(2^w)$中的矩阵进行解码。 通过创建解码矩阵并执行矩阵/矢量乘积，然后对所有已擦除的编码设备进行重新编码，可以完成此工作。 完成后，将丢弃解码矩阵。 如果要访问解码矩阵，则应使用下面的<strong>jerasure make decoding matrix()</strong>。</p><ul><li><strong>int jerasure_bitmatrix_decode(k, m, w bitmatrix, row k ones, erasures, data ptrs, coding ptrs, size, pack)</strong></li></ul><p><strong>etsize)</strong></p><p>​    注意，它不做任何调度-它只是创建解码位矩阵，并直接使用它来进行解码。 同样，完成后它会丢弃解码位矩阵。</p><ul><li><p><strong>int jerasure_schedule_decode_lazy(k, m, w bitmatrix, erasures, data ptrs, coding ptrs, size, packetsize, int</strong></p><p><strong>smart)</strong></p><p>这是通过根据解码矩阵创建一个schedule并将其解码来进行解码的。 如果smart是1，则使用 bitmatrix来创建计划。 否则，将使用dumb bitmatrix。 请注意，没有使用变量row_k_ones，因为如果smart为1，则创建的schedule无论如何都会找到该优化。  此过程完成后，将释放计划和分配给解码的所有数据结构。</p></li></ul><ul><li><p><strong>int jerasure_schedule_decode_cache(k, m, w cache, erasures, data ptrs, coding ptrs, size, packetsize)</strong></p><p>当m = 2时，使用schedule缓存进行解码。</p></li><li><p><strong>int jerasure_make_decoding_matrix(k, m, w matrix, erased, decoding_matrix, dm_ids)</strong>:</p><p>创建解码矩阵。 请注意，解码矩阵和dm id均应分配并传递给此过程，以填充它们。解码矩阵应具有$k^2$个整数，而$dm_ids$应具有$k$整数。</p></li><li><p><strong>int jerasure_make_decoding_bitmatrix(k, m, w matrix, erased, decoding_matrix, dm_ids)</strong></p></li></ul><p>​    创建解码位矩阵。 同样，应同时定位解码矩阵和dm_id，并将其传递给此过程，以填充它们。此时间解码矩阵应具有$k^2w^2$整数，而$dm_id$仍具有$k$个整数。</p><ul><li><p><strong>int jerasure_erasures_to_erased(k, m, erasures)</strong></p><p>将上面定义的<code>erasure</code>规范转换为上面定义的<code>erased</code>规范。</p></li></ul><h3 id="1-1-3-点积操作"><a href="#1-1-3-点积操作" class="headerlink" title="1.1.3 点积操作"></a>1.1.3 点积操作</h3><ul><li><strong>void jerasure_matrix_dotprod(k, w, int<em> matrix_row, int</em> src_ids, int dest_id, data_ptrs, coding_ptrs, size)</strong></li></ul><p>这将一行编码/解码矩阵乘以数据/幸存者。 源设备的ID（与矢量元素的ID相对应）位于<code>src_id</code>中。 目标设备的ID在目标ID中。  当矩阵中遇到一个1时，将执行正确的XOR /复制操作。 </p><ul><li><strong>void jerasure bitmatrix dotprod(k, w, int  bitmatrix row, int *src ids, int dest id, data ptrs, coding ptrs,size, packetsize)</strong></li></ul><p>这是位矩阵的类似过程。 它根据由bitmatrix行指定的矩阵的w行执行w点乘积。</p><ul><li><strong>void jerasure_do_scheduled_operations(char \</strong>ptrs, schedule, packetsize)**:</li></ul><p>这将对ptrs指定的指针执行计划。 尽管未指定w，但它以w（packetsize）个字节执行调度。 假定ptrs是与计划匹配的正确大小。 通常，这是k + m。</p><h3 id="1-1-4-基础矩阵操作"><a href="#1-1-4-基础矩阵操作" class="headerlink" title="1.1.4 基础矩阵操作"></a>1.1.4 基础矩阵操作</h3><ul><li><strong>int jerasure_invert_matrix(int\</strong> mat, int<em> inv, int rows, int w)*</em></li></ul><p>这求一个$rows\times rows$矩阵的逆，结果保存在inv中。如果矩阵不可逆，返回-1，否则返回0.</p><ul><li><strong>int jerasure_invert_bitmatrix(int<em> mat, int</em> inv, int rows)</strong>:</li></ul><p>这是求位矩阵的逆，对应$w=1$，也可以用上面那个函数，不过这个函数明显要快些。它会回收mat。</p><p>​    • <strong>int jerasure_invertible_matrix(int *mat, int rows, int w)</strong>:</p><p>判断矩阵是否可逆，可逆返回1，否则返回0.</p><ul><li><strong>void jerasure print matrix(int* matrix, int rows, int cols, int w)</strong>:</li></ul><p>这个函数会打印矩阵。$w$是用来确定间距的。</p><ul><li><strong>int*  jerasure matrix multiply(int</strong> <strong>m1, int</strong> <strong>m2, int r1, int c1, int r2, int c2, int w)</strong>:</li></ul><p>此函数执行矩阵乘法，矩阵m1大小为$r1\times c1$，m2为$r2\times c2$。</p><h3 id="1-1-5-统计"><a href="#1-1-5-统计" class="headerlink" title="1.1.5 统计"></a>1.1.5 统计</h3><ul><li>jerasures.c 会记录三种类型的数据</li></ul><ol><li>使用<code>galois_region_xor()</code>中进行XOR操作的字节数；</li><li>在$GF(2^w)$域中乘上常数的字节数，使用<code>galois_w08_region_multiply</code>,<code>galois_w16_region_multiply</code>和<code>galois_w32_region_multiply</code>。</li><li>使用<code>memcpy</code>的字节数量。</li></ol><p>我们使用函数<strong>void jerasure_get_stats(double* fill_in)</strong>就可以读到这些数据。在调用这个函数后，用于记录的计数器会被置零。比如 fill_in[0]表示异或的数目。</p><hr><h2 id="S1-2-基础应用教程"><a href="#S1-2-基础应用教程" class="headerlink" title="$\S1.2$ 基础应用教程"></a>$\S1.2$ 基础应用教程</h2><h3 id="例1：构造编码矩阵"><a href="#例1：构造编码矩阵" class="headerlink" title="例1：构造编码矩阵"></a>例1：构造编码矩阵</h3><p><code>\Example\jerasure_01.c</code></p><p>这里输入参数是r,c,w，分别代表矩阵的行数，列数，以及有限域大小。对于$(i,j)$的元素对应于$GF(2^w)$中的$2^{ci+j}$。</p><p>例如</p><pre><code class="hljs angelscript">./jerasure_01 <span class="hljs-number">3</span> <span class="hljs-number">15</span> <span class="hljs-number">8</span></code></pre><p>我们可以得到：</p><pre><code class="hljs apache"><span class="hljs-section">&lt;HTML&gt;</span><span class="hljs-section">&lt;TITLE&gt;</span><span class="hljs-attribute">jerasure_01</span> <span class="hljs-number">3</span> <span class="hljs-number">15</span> <span class="hljs-number">8</span>&lt;/TITLE&gt;<span class="hljs-section">&lt;h3&gt;</span><span class="hljs-attribute">jerasure_01</span> <span class="hljs-number">3</span> <span class="hljs-number">15</span> <span class="hljs-number">8</span>&lt;/h<span class="hljs-number">3</span>&gt;<span class="hljs-section">&lt;pre&gt;</span>  <span class="hljs-attribute">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span>   <span class="hljs-number">8</span>  <span class="hljs-number">16</span>  <span class="hljs-number">32</span>  <span class="hljs-number">64</span> <span class="hljs-number">128</span>  <span class="hljs-number">29</span>  <span class="hljs-number">58</span> <span class="hljs-number">116</span> <span class="hljs-number">232</span> <span class="hljs-number">205</span> <span class="hljs-number">135</span>  <span class="hljs-number">19</span> <span class="hljs-attribute">38</span>  <span class="hljs-number">76</span> <span class="hljs-number">152</span>  <span class="hljs-number">45</span>  <span class="hljs-number">90</span> <span class="hljs-number">180</span> <span class="hljs-number">117</span> <span class="hljs-number">234</span> <span class="hljs-number">201</span> <span class="hljs-number">143</span>   <span class="hljs-number">3</span>   <span class="hljs-number">6</span>  <span class="hljs-number">12</span>  <span class="hljs-number">24</span>  <span class="hljs-number">48</span> <span class="hljs-attribute">96</span> <span class="hljs-number">192</span> <span class="hljs-number">157</span>  <span class="hljs-number">39</span>  <span class="hljs-number">78</span> <span class="hljs-number">156</span>  <span class="hljs-number">37</span>  <span class="hljs-number">74</span> <span class="hljs-number">148</span>  <span class="hljs-number">53</span> <span class="hljs-number">106</span> <span class="hljs-number">212</span> <span class="hljs-number">181</span> <span class="hljs-number">119</span> <span class="hljs-number">238</span></code></pre><p>我们分析一下结果，对于<code>matrix</code>从(0,0)开始，构造$GF(2^8)$上的45个元素（每个都不超过256），至于为什么128后面是29，参考<a href="https://durantthorvalds.top/2020/11/15/%E7%BA%A0%E5%88%A0%E7%A0%81%E5%9C%A8%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BA%94%E7%94%A8/">纠删码在存储中的应用</a>关于伽罗华域讲解部分。</p><h3 id="例2：构造位编码矩阵"><a href="#例2：构造位编码矩阵" class="headerlink" title="例2：构造位编码矩阵"></a>例2：构造位编码矩阵</h3><p><code>\Example\jerasure_02.c</code></p><p>我们运行</p><pre><code class="hljs angelscript">./jerasure_02 <span class="hljs-number">3</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span></code></pre><pre><code class="hljs angelscript"><span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0110</span> <span class="hljs-number">1101</span> <span class="hljs-number">1010</span> <span class="hljs-number">0101</span><span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0110</span> <span class="hljs-number">1101</span> <span class="hljs-number">1010</span> <span class="hljs-number">0101</span> <span class="hljs-number">1011</span> <span class="hljs-number">0111</span> <span class="hljs-number">1111</span><span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0110</span> <span class="hljs-number">1101</span> <span class="hljs-number">1010</span> <span class="hljs-number">0101</span> <span class="hljs-number">1011</span> <span class="hljs-number">0111</span><span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0110</span> <span class="hljs-number">1101</span> <span class="hljs-number">1010</span> <span class="hljs-number">0101</span> <span class="hljs-number">1011</span> <span class="hljs-number">1011</span> <span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1110</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span><span class="hljs-number">1110</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0110</span> <span class="hljs-number">1101</span><span class="hljs-number">1111</span> <span class="hljs-number">1110</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0110</span><span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1110</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0100</span> <span class="hljs-number">1001</span> <span class="hljs-number">0011</span><span class="hljs-number">0011</span> <span class="hljs-number">0110</span> <span class="hljs-number">1101</span> <span class="hljs-number">1010</span> <span class="hljs-number">0101</span> <span class="hljs-number">1011</span> <span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1110</span> <span class="hljs-number">1100</span><span class="hljs-number">1010</span> <span class="hljs-number">0101</span> <span class="hljs-number">1011</span> <span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1110</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0010</span><span class="hljs-number">1101</span> <span class="hljs-number">1010</span> <span class="hljs-number">0101</span> <span class="hljs-number">1011</span> <span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1110</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> <span class="hljs-number">0001</span></code></pre><p>整个矩阵的大小为 $rw\times cw$。我们好好看下这个位矩阵是怎么来的。</p><p><img src="/img/image-20210126211602293.png" alt="image-20210126211602293" style="zoom:67%;" /></p><p>所以每个$w\times w$子块是不断左移的，。每次移动的距离为1。</p><h3 id="例3：构造柯西矩阵以及判断矩阵可逆性"><a href="#例3：构造柯西矩阵以及判断矩阵可逆性" class="headerlink" title="例3：构造柯西矩阵以及判断矩阵可逆性"></a>例3：构造柯西矩阵以及判断矩阵可逆性</h3><p><code>\Example\jerasure_03.c</code></p><p>这会创建一个$k\times k$的柯西矩阵，且$k<2^w$，矩阵$(i,j)$的元素为：$1/\{i\oplus(2^w-j-1)\}$，这儿的减号是普通减法。当$k>2^{w-1}$，存在分母为0 的可能性，这个时候元素被设为0。</p><p>我们顺便测试该矩阵是否可逆，如果$k\le 2^{w-1}$就是可逆的，否则不可逆。</p><p>运行下列命令</p><pre><code class="hljs angelscript">./jerasure_03 <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre><p>我们得到</p><pre><code class="hljs yaml"><span class="hljs-string">&lt;HTML&gt;&lt;TITLE&gt;jerasure_03</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-string">&lt;/TITLE&gt;</span><span class="hljs-string">&lt;h3&gt;jerasure_03</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-string">&lt;/h3&gt;</span><span class="hljs-string">&lt;pre&gt;</span><span class="hljs-attr">The Cauchy Matrix:</span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-attr">Invertible:</span> <span class="hljs-literal">Yes</span><span class="hljs-attr">Inverse:</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-string">Inverse</span> <span class="hljs-string">times</span> <span class="hljs-string">matrix</span> <span class="hljs-string">(should</span> <span class="hljs-string">be</span> <span class="hljs-string">identity):</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span></code></pre><h3 id="例4：构造位柯西矩阵以及判断矩阵可逆性"><a href="#例4：构造位柯西矩阵以及判断矩阵可逆性" class="headerlink" title="例4：构造位柯西矩阵以及判断矩阵可逆性"></a>例4：构造位柯西矩阵以及判断矩阵可逆性</h3><p>与例三作用相同，只不过是求位矩阵。</p><p>我们得到的结果如下</p><pre><code class="hljs yaml"><span class="hljs-string">&lt;HTML&gt;&lt;TITLE&gt;jerasure_04</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-string">&lt;/TITLE&gt;</span><span class="hljs-string">&lt;h3&gt;jerasure_04</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-string">&lt;/h3&gt;</span><span class="hljs-string">&lt;pre&gt;</span><span class="hljs-attr">The Cauchy Bit-Matrix:</span><span class="hljs-number">010</span> <span class="hljs-number">101</span> <span class="hljs-number">001</span> <span class="hljs-number">111</span><span class="hljs-number">011</span> <span class="hljs-number">111</span> <span class="hljs-number">101</span> <span class="hljs-number">100</span><span class="hljs-number">101</span> <span class="hljs-number">011</span> <span class="hljs-number">010</span> <span class="hljs-number">110</span><span class="hljs-number">101</span> <span class="hljs-number">010</span> <span class="hljs-number">111</span> <span class="hljs-number">001</span><span class="hljs-number">111</span> <span class="hljs-number">011</span> <span class="hljs-number">100</span> <span class="hljs-number">101</span><span class="hljs-number">011</span> <span class="hljs-number">101</span> <span class="hljs-number">110</span> <span class="hljs-number">010</span><span class="hljs-number">001</span> <span class="hljs-number">111</span> <span class="hljs-number">010</span> <span class="hljs-number">101</span><span class="hljs-number">101</span> <span class="hljs-number">100</span> <span class="hljs-number">011</span> <span class="hljs-number">111</span><span class="hljs-number">010</span> <span class="hljs-number">110</span> <span class="hljs-number">101</span> <span class="hljs-number">011</span><span class="hljs-number">111</span> <span class="hljs-number">001</span> <span class="hljs-number">101</span> <span class="hljs-number">010</span><span class="hljs-number">100</span> <span class="hljs-number">101</span> <span class="hljs-number">111</span> <span class="hljs-number">011</span><span class="hljs-number">110</span> <span class="hljs-number">010</span> <span class="hljs-number">011</span> <span class="hljs-number">101</span><span class="hljs-attr">Invertible:</span> <span class="hljs-literal">Yes</span><span class="hljs-string">...</span></code></pre><p>$k=4,w=3$，这个位矩阵如何理解，</p><h3 id="例5：基础RS码构造"><a href="#例5：基础RS码构造" class="headerlink" title="例5：基础RS码构造"></a>例5：基础RS码构造</h3><p><code>\Example\jerasure_05.c</code></p><p>输入参数: k , m, w , size, seed</p><p>约束：w必须在8，16，32中取，$k+m\le 2^w$，每个设备的总字节数size必须是sizeof(long)的整数倍，seed是随机数种子。</p><p>它首先由<code>jerasure_matrix_encode</code>建立一个$m\times k$柯西编码矩阵：每个元素为$\frac{1}{i\oplus (j+m)}$，接下来，它从数据和编码设备的集合中删除m个随机设备。接下来，它使用<code>jerasure_matrix_decode</code>解码并打印恢复后的矩阵。 该矩阵是分布矩阵的最后k行的逆矩阵。 最后，它使用<code>jerasure_matrix_dotprod()</code>演示了如何在擦除前m个设备后从其他数据显式计算第一个数据设备。<br>   这是w = 8的示例，其中有3个数据设备和4个编码设备，每个设备的大小为8个字节：</p><p>输出：十六-十进制（一个字节由两个十六进制位表示）。</p><pre><code class="hljs angelscript">./jerasure_05 <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">100</span></code></pre><pre><code class="hljs apache"><span class="hljs-section">&lt;HTML&gt;</span><span class="hljs-section">&lt;TITLE&gt;</span><span class="hljs-attribute">jerasure_05</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">100</span>&lt;/TITLE&gt;<span class="hljs-section">&lt;h3&gt;</span><span class="hljs-attribute">jerasure_05</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">100</span>&lt;/h<span class="hljs-number">3</span>&gt;<span class="hljs-section">&lt;pre&gt;</span><span class="hljs-attribute">The</span> Coding Matrix (the last m rows of the Generator Matrix G^T): <span class="hljs-attribute">71</span> <span class="hljs-number">167</span> <span class="hljs-number">122</span><span class="hljs-attribute">167</span>  <span class="hljs-number">71</span> <span class="hljs-number">186</span><span class="hljs-attribute">122</span> <span class="hljs-number">186</span>  <span class="hljs-number">71</span><span class="hljs-attribute">186</span> <span class="hljs-number">122</span> <span class="hljs-number">167</span><span class="hljs-attribute">Encoding</span> Complete:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b e<span class="hljs-number">3</span> eb <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">5</span>f c<span class="hljs-number">5</span> <span class="hljs-number">99</span>    C<span class="hljs-number">0</span> : ab <span class="hljs-number">09</span> <span class="hljs-number">6</span>d <span class="hljs-number">49</span> <span class="hljs-number">24</span> e<span class="hljs-number">2</span> <span class="hljs-number">6</span>e ae<span class="hljs-attribute">D1</span> : <span class="hljs-number">14</span> <span class="hljs-number">2</span>f f<span class="hljs-number">4</span> <span class="hljs-number">2</span>b e<span class="hljs-number">7</span> <span class="hljs-number">72</span> <span class="hljs-number">85</span> b<span class="hljs-number">3</span>    C<span class="hljs-number">1</span> : ee ee bb <span class="hljs-number">70</span> <span class="hljs-number">26</span> c<span class="hljs-number">2</span> b<span class="hljs-number">3</span> <span class="hljs-number">9</span>c<span class="hljs-attribute">D2</span> : <span class="hljs-number">85</span> eb <span class="hljs-number">30</span> <span class="hljs-number">9</span>a ee d<span class="hljs-number">4</span> <span class="hljs-number">5</span>d b<span class="hljs-number">1</span>    C<span class="hljs-number">2</span> : <span class="hljs-number">69</span> c<span class="hljs-number">0</span> <span class="hljs-number">33</span> e<span class="hljs-number">8</span> <span class="hljs-number">1</span>a d<span class="hljs-number">8</span> c<span class="hljs-number">8</span> e<span class="hljs-number">3</span>                                <span class="hljs-attribute">C3</span> : <span class="hljs-number">4</span>b b<span class="hljs-number">3</span> <span class="hljs-number">6</span>c <span class="hljs-number">32</span> <span class="hljs-number">45</span> ae <span class="hljs-number">92</span> <span class="hljs-number">5</span>b<span class="hljs-attribute">Erased</span> <span class="hljs-number">4</span> random devices:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b e<span class="hljs-number">3</span> eb <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">5</span>f c<span class="hljs-number">5</span> <span class="hljs-number">99</span>    C<span class="hljs-number">0</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    C<span class="hljs-number">1</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-attribute">D2</span> : <span class="hljs-number">85</span> eb <span class="hljs-number">30</span> <span class="hljs-number">9</span>a ee d<span class="hljs-number">4</span> <span class="hljs-number">5</span>d b<span class="hljs-number">1</span>    C<span class="hljs-number">2</span> : <span class="hljs-number">69</span> c<span class="hljs-number">0</span> <span class="hljs-number">33</span> e<span class="hljs-number">8</span> <span class="hljs-number">1</span>a d<span class="hljs-number">8</span> c<span class="hljs-number">8</span> e<span class="hljs-number">3</span>                                <span class="hljs-attribute">C3</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-attribute">State</span> of the system after decoding:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b e<span class="hljs-number">3</span> eb <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">5</span>f c<span class="hljs-number">5</span> <span class="hljs-number">99</span>    C<span class="hljs-number">0</span> : ab <span class="hljs-number">09</span> <span class="hljs-number">6</span>d <span class="hljs-number">49</span> <span class="hljs-number">24</span> e<span class="hljs-number">2</span> <span class="hljs-number">6</span>e ae<span class="hljs-attribute">D1</span> : <span class="hljs-number">14</span> <span class="hljs-number">2</span>f f<span class="hljs-number">4</span> <span class="hljs-number">2</span>b e<span class="hljs-number">7</span> <span class="hljs-number">72</span> <span class="hljs-number">85</span> b<span class="hljs-number">3</span>    C<span class="hljs-number">1</span> : ee ee bb <span class="hljs-number">70</span> <span class="hljs-number">26</span> c<span class="hljs-number">2</span> b<span class="hljs-number">3</span> <span class="hljs-number">9</span>c<span class="hljs-attribute">D2</span> : <span class="hljs-number">85</span> eb <span class="hljs-number">30</span> <span class="hljs-number">9</span>a ee d<span class="hljs-number">4</span> <span class="hljs-number">5</span>d b<span class="hljs-number">1</span>    C<span class="hljs-number">2</span> : <span class="hljs-number">69</span> c<span class="hljs-number">0</span> <span class="hljs-number">33</span> e<span class="hljs-number">8</span> <span class="hljs-number">1</span>a d<span class="hljs-number">8</span> c<span class="hljs-number">8</span> e<span class="hljs-number">3</span>                                <span class="hljs-attribute">C3</span> : <span class="hljs-number">4</span>b b<span class="hljs-number">3</span> <span class="hljs-number">6</span>c <span class="hljs-number">32</span> <span class="hljs-number">45</span> ae <span class="hljs-number">92</span> <span class="hljs-number">5</span>b<span class="hljs-attribute">Suppose</span> we erase the first <span class="hljs-number">4</span> devices.  Here is the decoding matrix:<span class="hljs-attribute">130</span>  <span class="hljs-number">25</span> <span class="hljs-number">182</span><span class="hljs-attribute">252</span> <span class="hljs-number">221</span>  <span class="hljs-number">25</span><span class="hljs-attribute">108</span> <span class="hljs-number">252</span> <span class="hljs-number">130</span><span class="hljs-attribute">And</span> dm_ids:  <span class="hljs-attribute">4</span>   <span class="hljs-number">5</span>   <span class="hljs-number">6</span><span class="hljs-attribute">After</span> calling jerasure_matrix_dotprod, we calculate the value of device #<span class="hljs-number">0</span> to be:<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b e<span class="hljs-number">3</span> eb <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">5</span>f c<span class="hljs-number">5</span> <span class="hljs-number">99</span></code></pre><p>在这个例子中，</p><p>第一个编码块的0字节为：</p><script type="math/tex; mode=display">byte 0 of C_0 = (71 × byte 0 of D_0) ⊕ (167 × byte 0 of D_1) ⊕ (122 × byte 0 of D_2)</script><p>但是，请记住，该实现实际上一次对一组字节执行点积。 因此，在此示例中，每个设备包含8个字节，点积实际上是：</p><script type="math/tex; mode=display">8 bytes of C_0 = (71 × 8 bytes of D_0) ⊕ (167 × 8 bytes of D_1) ⊕ (122 × 8 bytes of D_2)</script><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="例6：基础位RS码构造"><a href="#例6：基础位RS码构造" class="headerlink" title="例6：基础位RS码构造"></a>例6：基础位RS码构造</h3><p><code>\Example\jerasure_06.c</code></p><p>输入参数：k,m,w,packet_size,seed.</p><p>其中packet_size必须是<code>sizeof(long)=4</code>的整数倍。</p><pre><code class="hljs angelscript">./jerasure_06 <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">100</span></code></pre><p><img src="/img/image-20210127170433218.png" alt="image-20210127170433218"></p><p><img src="/img/image-20210127170530595.png" alt="image-20210127170530595"></p><p><img src="/img/image-20210127170550129.png" alt="image-20210127170550129"></p><blockquote><p>疑问：为什么RS矩阵的w必须是8，16，32，而位矩阵则只要w在[0,32）以内就行？</p></blockquote><p>在这种编码中，根据编码矩阵第一行中的六个，计算出C0的第一个数据包：</p><script type="math/tex; mode=display">C_0p_0 = D_0p_0 ⊕ D_0p_1 ⊕ D_0p_2 ⊕ D_1p_2 ⊕ D_2p_0 ⊕ D_2p_2</script><h3 id="例7：带schedule的位RS码构造"><a href="#例7：带schedule的位RS码构造" class="headerlink" title="例7：带schedule的位RS码构造"></a>例7：带schedule的位RS码构造</h3><p><code>\Example\jerasure_07.C</code></p><p>它执行与jerasure 06中相同的编码/解码，除了它使用位矩阵schedule而不是位矩阵操作。 数据包的大小设置为sizeof（long）个字节。 它创建了一个“dumb”和“smart”的编码时间表，对其进行编码，并打印出每一个进行了多少XOR。<br>   接下来，它擦除m个随机设备，并使用<code>jerasure_schedule_decode_lazy()</code>进行解码。 最后，为了细致化操作，它调用了<code>jerasure_do_scheduled_operations()</code>。</p><pre><code class="hljs angelscript">./jerasure_07 <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">102</span></code></pre><p><img src="/img/image-20210127165645630.png" alt="image-20210127165645630"></p><p><img src="/img/image-20210127165723454.png" alt="image-20210127165723454"></p><p><img src="/img/image-20210127165746318.png" alt="image-20210127165746318"></p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="例8：带schedule-cache的简单RAID-6构造"><a href="#例8：带schedule-cache的简单RAID-6构造" class="headerlink" title="例8：带schedule cache的简单RAID-6构造"></a>例8：带schedule cache的简单RAID-6构造</h3><p>它建立一个RAID-6编码矩阵，该矩阵的第一行由1组成，第二行$j$列的元素等于$GF(2^w)$中的$2^j$。 它将其转换为位矩阵，并创建智能编码时间表和用于解码的时间表缓存。<br>   然后将其编码两次: 首先使用smart schedule，然后使用schedule 缓存，方法是将两个编码设备设置为已擦除设备。 接下来，它删除两个随机设备，并使用schedule缓存对其进行解码。 接下来，它删除第一个编码设备，并使用<code>jerasure do parity()</code>对其进行重新计算以演示该过程。 最后，它将释放schedule缓存。</p><hr><h2 id="S1-3-经典RS码"><a href="#S1-3-经典RS码" class="headerlink" title="$\S1.3$ 经典RS码"></a>$\S1.3$ 经典RS码</h2><p>依赖：<code>reed_sol.h</code>, <code>reed_sol.c</code></p><h3 id="1-3-1-Vandermonde分布矩阵"><a href="#1-3-1-Vandermonde分布矩阵" class="headerlink" title="1.3.1 Vandermonde分布矩阵"></a>1.3.1 Vandermonde分布矩阵</h3><ul><li><p><code>int *reed_sol_vandermonde_coding_matrix(k,m,w)</code></p><p>这将基于扩展的范德蒙德矩阵返回$GF(2^w)$中分布矩阵的最后$m$行。 这是一个$m×k$矩阵，可以与jerasure.c中的矩阵例程一起使用。 此矩阵的第一行保证全为1。 第一列也保证全为1。 </p></li><li><p><code>int *reed sol_extended_vandermonde_matrix(int rows, int cols, w)</code></p><p>这会创建一个扩展的范德蒙德矩阵。</p></li><li><p><code>int *reed_sol_big_vandermonde_distribution_matrix(int rows, int cols, w)</code></p><p>这将扩展矩阵转化为分布矩阵。</p></li></ul><h3 id="1-3-2-针对RAID-6的RS码优化"><a href="#1-3-2-针对RAID-6的RS码优化" class="headerlink" title="1.3.2 针对RAID-6的RS码优化"></a>1.3.2 针对RAID-6的RS码优化</h3><p>在RAID-6中，$m=2$，使用奇偶校验从其他编码设备中计算出第一编码设备P，使用以下数据从数据设备Di中计算出第二编码设备Q：</p><script type="math/tex; mode=display">Q=\sum\limits_{i=0}^{k-1}2^iD_i</script><ul><li><p><code>int reed_sol_r6_encode(k,w,data_ptr,coding_ptr,size)</code> 编码函数。</p></li><li><p><code>int *reed_sol_r6_coding_matrix(k,w)</code>:为了进行解码，该函数返回分布矩阵的最后两行。第一行全为1，第二行为$2^j$，$j$为列数。</p></li><li><code>reed_sol_galois_w08_region_multby_2(char *region, int nbytes)</code>:这会使用Anvin的优化[Anv07]在GF（2^8）中执行快速乘以2。 区域必须是长字对齐的，并且nbytes必须是字长的倍数。</li><li><p><code>reed_sol_galois_w16_region_multby_2(char *region, int nbytes)</code>:</p></li><li><p><code>reed_sol_galois_w32_region_multby_2(char *region, int nbytes)</code></p></li></ul><h3 id="1-3-3-实例"><a href="#1-3-3-实例" class="headerlink" title="1.3.3 实例"></a>1.3.3 实例</h3><h3 id="例8：传统RS编码"><a href="#例8：传统RS编码" class="headerlink" title="例8：传统RS编码"></a>例8：传统RS编码</h3><p><code>\Example\reed_sol_01.c</code></p><p>输入：k,m,w,seed</p><pre><code class="hljs angelscript">./reed_sol_01 <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">105</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">Last</span> m rows of the generator Matrix (G^T):  <span class="hljs-attribute">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>  <span class="hljs-attribute">1</span> <span class="hljs-number">217</span>  <span class="hljs-number">92</span> <span class="hljs-number">172</span>  <span class="hljs-attribute">1</span>  <span class="hljs-number">70</span> <span class="hljs-number">143</span> <span class="hljs-number">200</span><span class="hljs-attribute">Encoding</span> Complete:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">6</span>f c<span class="hljs-number">1</span> a<span class="hljs-number">7</span> <span class="hljs-number">58</span> a<span class="hljs-number">0</span> b<span class="hljs-number">4</span> <span class="hljs-number">17</span> <span class="hljs-number">74</span>    C<span class="hljs-number">0</span> : <span class="hljs-number">1</span>c <span class="hljs-number">28</span> <span class="hljs-number">9</span>e <span class="hljs-number">71</span> <span class="hljs-number">06</span> bb <span class="hljs-number">51</span> <span class="hljs-number">22</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">82</span> <span class="hljs-number">13</span> <span class="hljs-number">7</span>f c<span class="hljs-number">0</span> <span class="hljs-number">9</span>f <span class="hljs-number">3</span>f db a<span class="hljs-number">4</span>    C<span class="hljs-number">1</span> : <span class="hljs-number">7</span>c <span class="hljs-number">0</span>e <span class="hljs-number">9</span>d <span class="hljs-number">11</span> ee <span class="hljs-number">20</span> <span class="hljs-number">79</span> ef<span class="hljs-attribute">D2</span> : b<span class="hljs-number">5</span> <span class="hljs-number">90</span> <span class="hljs-number">6</span>d d<span class="hljs-number">0</span> <span class="hljs-number">92</span> ea ac <span class="hljs-number">98</span>    C<span class="hljs-number">2</span> : <span class="hljs-number">55</span> <span class="hljs-number">0</span>c a<span class="hljs-number">8</span> f<span class="hljs-number">2</span> <span class="hljs-number">99</span> dd <span class="hljs-number">25</span> e<span class="hljs-number">6</span><span class="hljs-attribute">D3</span> : <span class="hljs-number">44</span> <span class="hljs-number">6</span>a <span class="hljs-number">2</span>b <span class="hljs-number">39</span> ab da <span class="hljs-number">31</span> <span class="hljs-number">6</span>a    <span class="hljs-attribute">Erased</span> <span class="hljs-number">3</span> random devices:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    C<span class="hljs-number">0</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">82</span> <span class="hljs-number">13</span> <span class="hljs-number">7</span>f c<span class="hljs-number">0</span> <span class="hljs-number">9</span>f <span class="hljs-number">3</span>f db a<span class="hljs-number">4</span>    C<span class="hljs-number">1</span> : <span class="hljs-number">7</span>c <span class="hljs-number">0</span>e <span class="hljs-number">9</span>d <span class="hljs-number">11</span> ee <span class="hljs-number">20</span> <span class="hljs-number">79</span> ef<span class="hljs-attribute">D2</span> : b<span class="hljs-number">5</span> <span class="hljs-number">90</span> <span class="hljs-number">6</span>d d<span class="hljs-number">0</span> <span class="hljs-number">92</span> ea ac <span class="hljs-number">98</span>    C<span class="hljs-number">2</span> : <span class="hljs-number">55</span> <span class="hljs-number">0</span>c a<span class="hljs-number">8</span> f<span class="hljs-number">2</span> <span class="hljs-number">99</span> dd <span class="hljs-number">25</span> e<span class="hljs-number">6</span><span class="hljs-attribute">D3</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-attribute">State</span> of the system after decoding:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">6</span>f c<span class="hljs-number">1</span> a<span class="hljs-number">7</span> <span class="hljs-number">58</span> a<span class="hljs-number">0</span> b<span class="hljs-number">4</span> <span class="hljs-number">17</span> <span class="hljs-number">74</span>    C<span class="hljs-number">0</span> : <span class="hljs-number">1</span>c <span class="hljs-number">28</span> <span class="hljs-number">9</span>e <span class="hljs-number">71</span> <span class="hljs-number">06</span> bb <span class="hljs-number">51</span> <span class="hljs-number">22</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">82</span> <span class="hljs-number">13</span> <span class="hljs-number">7</span>f c<span class="hljs-number">0</span> <span class="hljs-number">9</span>f <span class="hljs-number">3</span>f db a<span class="hljs-number">4</span>    C<span class="hljs-number">1</span> : <span class="hljs-number">7</span>c <span class="hljs-number">0</span>e <span class="hljs-number">9</span>d <span class="hljs-number">11</span> ee <span class="hljs-number">20</span> <span class="hljs-number">79</span> ef<span class="hljs-attribute">D2</span> : b<span class="hljs-number">5</span> <span class="hljs-number">90</span> <span class="hljs-number">6</span>d d<span class="hljs-number">0</span> <span class="hljs-number">92</span> ea ac <span class="hljs-number">98</span>    C<span class="hljs-number">2</span> : <span class="hljs-number">55</span> <span class="hljs-number">0</span>c a<span class="hljs-number">8</span> f<span class="hljs-number">2</span> <span class="hljs-number">99</span> dd <span class="hljs-number">25</span> e<span class="hljs-number">6</span><span class="hljs-attribute">D3</span> : <span class="hljs-number">44</span> <span class="hljs-number">6</span>a <span class="hljs-number">2</span>b <span class="hljs-number">39</span> ab da <span class="hljs-number">31</span> <span class="hljs-number">6</span>a    </code></pre><h3 id="例9：三种重要矩阵"><a href="#例9：三种重要矩阵" class="headerlink" title="例9：三种重要矩阵"></a>例9：三种重要矩阵</h3><p><code>\Example\reed_sol_02.c</code></p><p>输入：k m w</p><p>输出：1. $(k+m)\times k $的扩展范德蒙德矩阵；2. 含单位矩阵块的分布矩阵；3. $m\times k$的编码矩阵，通过设置<code>row_k_ones</code>为1，可以进行提速。</p><p>注意：w可在1-32取任何值。</p><pre><code class="hljs angelscript">./reed_sol_02 <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span></code></pre><pre><code class="hljs yaml"><span class="hljs-attr">Extended Vandermonde Matrix:</span>  <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>  <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>  <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span>   <span class="hljs-number">8</span>  <span class="hljs-number">1</span>   <span class="hljs-number">3</span>   <span class="hljs-number">5</span>  <span class="hljs-number">15</span>  <span class="hljs-number">1</span>   <span class="hljs-number">4</span>  <span class="hljs-number">16</span>  <span class="hljs-number">64</span>  <span class="hljs-number">1</span>   <span class="hljs-number">5</span>  <span class="hljs-number">17</span>  <span class="hljs-number">85</span>  <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span><span class="hljs-string">Vandermonde</span> <span class="hljs-string">Generator</span> <span class="hljs-string">Matrix</span> <span class="hljs-string">(G^T):</span>  <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>  <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>  <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>  <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>  <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>  <span class="hljs-number">1</span> <span class="hljs-number">217</span>  <span class="hljs-number">92</span> <span class="hljs-number">172</span>  <span class="hljs-number">1</span>  <span class="hljs-number">70</span> <span class="hljs-number">143</span> <span class="hljs-number">200</span><span class="hljs-attr">Vandermonde Coding Matrix:</span>  <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>  <span class="hljs-number">1</span> <span class="hljs-number">217</span>  <span class="hljs-number">92</span> <span class="hljs-number">172</span>  <span class="hljs-number">1</span>  <span class="hljs-number">70</span> <span class="hljs-number">143</span> <span class="hljs-number">200</span></code></pre><h3 id="例10：使用Anvin优化的RAID-6矩阵"><a href="#例10：使用Anvin优化的RAID-6矩阵" class="headerlink" title="例10：使用Anvin优化的RAID-6矩阵"></a>例10：使用Anvin优化的RAID-6矩阵</h3><p><code>\Example\reed_sol_03.c</code></p><p>输入参数：k w seed</p><pre><code class="hljs angelscript">./reed_sol_03 <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">100</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">Last</span> <span class="hljs-number">2</span> rows of the Generator Matrix:  <span class="hljs-attribute">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>  <span class="hljs-attribute">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span>   <span class="hljs-number">8</span><span class="hljs-attribute">Encoding</span> Complete:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b <span class="hljs-number">03</span> <span class="hljs-number">14</span> e<span class="hljs-number">7</span> <span class="hljs-number">85</span> ee <span class="hljs-number">42</span> c<span class="hljs-number">5</span>    C<span class="hljs-number">0</span> : a<span class="hljs-number">4</span> <span class="hljs-number">24</span> <span class="hljs-number">86</span> dd f<span class="hljs-number">1</span> ab <span class="hljs-number">31</span> f<span class="hljs-number">6</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">7</span>d <span class="hljs-number">58</span> <span class="hljs-number">3</span>a <span class="hljs-number">05</span> ea b<span class="hljs-number">1</span> a<span class="hljs-number">7</span> <span class="hljs-number">77</span>    C<span class="hljs-number">1</span> : cc c<span class="hljs-number">1</span> fc de b<span class="hljs-number">5</span> <span class="hljs-number">61</span> <span class="hljs-number">80</span> <span class="hljs-number">7</span>a<span class="hljs-attribute">D2</span> : <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">26</span> <span class="hljs-number">69</span> c<span class="hljs-number">3</span> <span class="hljs-number">47</span> b<span class="hljs-number">9</span> <span class="hljs-number">49</span>    <span class="hljs-attribute">D3</span> : <span class="hljs-number">16</span> <span class="hljs-number">5</span>b <span class="hljs-number">8</span>e <span class="hljs-number">56</span> <span class="hljs-number">5</span>d b<span class="hljs-number">3</span> <span class="hljs-number">6</span>d <span class="hljs-number">0</span>d    <span class="hljs-attribute">Erased</span> <span class="hljs-number">2</span> random devices:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b <span class="hljs-number">03</span> <span class="hljs-number">14</span> e<span class="hljs-number">7</span> <span class="hljs-number">85</span> ee <span class="hljs-number">42</span> c<span class="hljs-number">5</span>    C<span class="hljs-number">0</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">7</span>d <span class="hljs-number">58</span> <span class="hljs-number">3</span>a <span class="hljs-number">05</span> ea b<span class="hljs-number">1</span> a<span class="hljs-number">7</span> <span class="hljs-number">77</span>    C<span class="hljs-number">1</span> : cc c<span class="hljs-number">1</span> fc de b<span class="hljs-number">5</span> <span class="hljs-number">61</span> <span class="hljs-number">80</span> <span class="hljs-number">7</span>a<span class="hljs-attribute">D2</span> : <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">26</span> <span class="hljs-number">69</span> c<span class="hljs-number">3</span> <span class="hljs-number">47</span> b<span class="hljs-number">9</span> <span class="hljs-number">49</span>    <span class="hljs-attribute">D3</span> : <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    <span class="hljs-attribute">State</span> of the system after decoding:<span class="hljs-attribute">Data</span>                            Coding<span class="hljs-attribute">D0</span> : <span class="hljs-number">8</span>b <span class="hljs-number">03</span> <span class="hljs-number">14</span> e<span class="hljs-number">7</span> <span class="hljs-number">85</span> ee <span class="hljs-number">42</span> c<span class="hljs-number">5</span>    C<span class="hljs-number">0</span> : a<span class="hljs-number">4</span> <span class="hljs-number">24</span> <span class="hljs-number">86</span> dd f<span class="hljs-number">1</span> ab <span class="hljs-number">31</span> f<span class="hljs-number">6</span><span class="hljs-attribute">D1</span> : <span class="hljs-number">7</span>d <span class="hljs-number">58</span> <span class="hljs-number">3</span>a <span class="hljs-number">05</span> ea b<span class="hljs-number">1</span> a<span class="hljs-number">7</span> <span class="hljs-number">77</span>    C<span class="hljs-number">1</span> : cc c<span class="hljs-number">1</span> fc de b<span class="hljs-number">5</span> <span class="hljs-number">61</span> <span class="hljs-number">80</span> <span class="hljs-number">7</span>a<span class="hljs-attribute">D2</span> : <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">26</span> <span class="hljs-number">69</span> c<span class="hljs-number">3</span> <span class="hljs-number">47</span> b<span class="hljs-number">9</span> <span class="hljs-number">49</span>    <span class="hljs-attribute">D3</span> : <span class="hljs-number">16</span> <span class="hljs-number">5</span>b <span class="hljs-number">8</span>e <span class="hljs-number">56</span> <span class="hljs-number">5</span>d b<span class="hljs-number">3</span> <span class="hljs-number">6</span>d <span class="hljs-number">0</span>d</code></pre><p>它主要使用的是<strong>reed sol r6 encode()</strong>, <strong>reed sol r6 coding matrix()</strong>, 两个函数。</p><h3 id="例11：快速乘法"><a href="#例11：快速乘法" class="headerlink" title="例11：快速乘法"></a>例11：快速乘法</h3><p><code>\Example\reed_sol_04.c</code></p><p>输入参数：w seed</p><pre><code class="hljs angelscript">./reed_sol_04 <span class="hljs-number">8</span> <span class="hljs-number">100</span></code></pre><pre><code class="hljs angelscript">Char  <span class="hljs-number">0</span>: <span class="hljs-number">139</span> *<span class="hljs-number">2</span> =  <span class="hljs-number">11</span>Char  <span class="hljs-number">1</span>:   <span class="hljs-number">3</span> *<span class="hljs-number">2</span> =   <span class="hljs-number">6</span>Char  <span class="hljs-number">2</span>:  <span class="hljs-number">20</span> *<span class="hljs-number">2</span> =  <span class="hljs-number">40</span>Char  <span class="hljs-number">3</span>: <span class="hljs-number">231</span> *<span class="hljs-number">2</span> = <span class="hljs-number">211</span>Char  <span class="hljs-number">4</span>: <span class="hljs-number">133</span> *<span class="hljs-number">2</span> =  <span class="hljs-number">23</span>Char  <span class="hljs-number">5</span>: <span class="hljs-number">238</span> *<span class="hljs-number">2</span> = <span class="hljs-number">193</span>Char  <span class="hljs-number">6</span>:  <span class="hljs-number">66</span> *<span class="hljs-number">2</span> = <span class="hljs-number">132</span>Char  <span class="hljs-number">7</span>: <span class="hljs-number">197</span> *<span class="hljs-number">2</span> = <span class="hljs-number">151</span>Char  <span class="hljs-number">8</span>: <span class="hljs-number">125</span> *<span class="hljs-number">2</span> = <span class="hljs-number">250</span>Char  <span class="hljs-number">9</span>:  <span class="hljs-number">88</span> *<span class="hljs-number">2</span> = <span class="hljs-number">176</span>Char <span class="hljs-number">10</span>:  <span class="hljs-number">58</span> *<span class="hljs-number">2</span> = <span class="hljs-number">116</span>Char <span class="hljs-number">11</span>:   <span class="hljs-number">5</span> *<span class="hljs-number">2</span> =  <span class="hljs-number">10</span>Char <span class="hljs-number">12</span>: <span class="hljs-number">234</span> *<span class="hljs-number">2</span> = <span class="hljs-number">201</span>Char <span class="hljs-number">13</span>: <span class="hljs-number">177</span> *<span class="hljs-number">2</span> = <span class="hljs-number">127</span>Char <span class="hljs-number">14</span>: <span class="hljs-number">167</span> *<span class="hljs-number">2</span> =  <span class="hljs-number">83</span>Char <span class="hljs-number">15</span>: <span class="hljs-number">119</span> *<span class="hljs-number">2</span> = <span class="hljs-number">238</span></code></pre><h2 id="1-4-柯西编码矩阵"><a href="#1-4-柯西编码矩阵" class="headerlink" title="1.4 柯西编码矩阵"></a>1.4 柯西编码矩阵</h2><p><code>cauchy.h/cauchy.c</code></p><ul><li>构建一个普通的柯西编码矩阵，$M[i,j]=\frac{1}{i\oplus(m+j)}$;</li><li>对每一列j，将每一列除以$M[0,j]$，这样的话，行0的每个元素就会变为1.</li><li>之后，对于行$i&gt;0$:<ul><li>计算二进制下，每行1的数目；</li><li>除以元素$M [i,j]$的1后，计算二进制下，每行1的数目；</li><li>只要j取值使得1的数目增加，就把行i除上$M[i,j]$；</li></ul></li></ul><p>例如$k=m=w=3$下，我们得到如下初始柯西矩阵：</p><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">7</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><blockquote><p>下面我们详细讲解一下包含最少1的cauchy good矩阵是如何得到的。</p><p>首先在前提下，我们写出位矩阵和对应的1的个数：</p><pre><code class="hljs yaml">  <span class="hljs-number">100</span> <span class="hljs-number">001</span> <span class="hljs-number">010</span><span class="hljs-number">101</span><span class="hljs-number">011</span><span class="hljs-number">111</span><span class="hljs-number">110</span>  <span class="hljs-number">010</span><span class="hljs-number">101</span><span class="hljs-number">011</span><span class="hljs-number">111</span><span class="hljs-number">110</span><span class="hljs-number">100</span><span class="hljs-number">001</span>  <span class="hljs-number">001</span><span class="hljs-number">010</span><span class="hljs-number">101</span><span class="hljs-number">011</span><span class="hljs-number">111</span><span class="hljs-number">110</span><span class="hljs-number">100</span><span class="hljs-string">&gt;(dec)</span>    <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span>  <span class="hljs-number">6</span>   <span class="hljs-number">7</span>  <span class="hljs-number">5</span><span class="hljs-string">&gt;(num_1&#x27;s)3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>  <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><span class="hljs-string">&gt;step1:原始矩阵，如果我们对第1行分别除上第一列的元素：</span><span class="hljs-string">&gt;1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-string">&gt;4</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">total</span> <span class="hljs-number">1</span><span class="hljs-string">&#x27;s = 5 + 7 + 7 = 19 </span><span class="hljs-string">&gt;3 7 2 </span><span class="hljs-string"></span><span class="hljs-string">&gt;step2:再对第二行除上每个元素以找到最少1的那个，</span><span class="hljs-string">&gt;(a) 除上4.</span><span class="hljs-string">&gt;1 1 1</span><span class="hljs-string">&gt;1 2 4 -&gt; total 1&#x27;</span><span class="hljs-string">s</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span> <span class="hljs-string">+</span> <span class="hljs-number">4</span> <span class="hljs-string">+</span> <span class="hljs-number">5</span> <span class="hljs-string">=</span> <span class="hljs-number">12</span> <span class="hljs-string">&gt;3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-string">&gt;(b)</span> <span class="hljs-string">除上3.</span><span class="hljs-string">&gt;1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-string">&gt;5</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">total</span> <span class="hljs-number">1</span><span class="hljs-string">&#x27;s = 4 + 3 + 4 = 11</span><span class="hljs-string">&gt;3 7 2 </span><span class="hljs-string"></span><span class="hljs-string">&gt;(c) 除上6.</span><span class="hljs-string">&gt;1 1 1 </span><span class="hljs-string">&gt;7 5 1 -&gt; total 1&#x27;</span><span class="hljs-string">s</span> <span class="hljs-string">=</span> <span class="hljs-number">6</span> <span class="hljs-string">+</span> <span class="hljs-number">4</span> <span class="hljs-string">+</span> <span class="hljs-number">3</span> <span class="hljs-string">=</span> <span class="hljs-number">13</span><span class="hljs-string">&gt;3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-string">&gt;可知除上3得到的矩阵1的数目最少。</span><span class="hljs-string">&gt;step3:对第三行也进行类似于第二步的操作，最终我们得到cauchy</span> <span class="hljs-string">good矩阵</span><span class="hljs-string">&gt;1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">+3+3=9</span><span class="hljs-string">&gt;5</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">4</span><span class="hljs-string">+3+4=11</span><span class="hljs-string">&gt;3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-string">-&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">+5+6=14</span><span class="hljs-string">&gt;一共是</span> <span class="hljs-number">9</span><span class="hljs-string">+13+14=34个1</span><span class="hljs-string">&gt;原始矩阵有46个1，而[PX06]给出</span> <span class="hljs-string">的矩阵有39个1，我们的矩阵明显更优秀一些。</span></code></pre></blockquote><ul><li><p><code>int *cauchy_original_coding_matrix(k,m,w)</code></p><p>返回柯西编码矩阵的原始形式。</p></li><li><p><code>int *cauchy_xy_coding_matrix(k,m,w,int*X, int *Y)</code></p><p>指定集合X，Y创建柯西矩阵。集合X拥有m个元素，集合Y有k个元素。集合没有重复元素，并且两个集合没有交集。</p></li><li><p><code>void cauchy_improve_coding_matrix(k,m,w,matrix)</code></p><p>这个提升在于，先将每一列除上0行元素。</p></li><li><p><code>int *cauchy_good_general_coding_matrix()</code></p><p>这会返回一个好矩阵，当$m=2，w\le 11, k\le 1023$，它会返回最优的RAID-6 矩阵。它会引用最前面两个函数。</p></li><li><p><code>int cauchy_n_ones(int n, int w)</code>:</p><p>这将返回$GF(2^w)$中数字n的位矩阵表示形式中的1。 它比生成位矩阵和计数位要有效得多。</p></li></ul><h3 id="例12：计算柯西位矩阵块1的个数"><a href="#例12：计算柯西位矩阵块1的个数" class="headerlink" title="例12：计算柯西位矩阵块1的个数"></a>例12：计算柯西位矩阵块1的个数</h3><p><code>\Example\cauchy_01.c</code></p><p>输入：n,w</p><p>输出：位矩阵和1的个数。</p><pre><code class="hljs angelscript">./cauchy_01 <span class="hljs-number">5</span> <span class="hljs-number">3</span></code></pre><pre><code class="hljs apache"><span class="hljs-section">&lt;HTML&gt;</span><span class="hljs-section">&lt;title&gt;</span><span class="hljs-attribute">cauchy_01</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>&lt;/title&gt;<span class="hljs-section">&lt;HTML&gt;</span><span class="hljs-section">&lt;h3&gt;</span><span class="hljs-attribute">cauchy_01</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>&lt;/h<span class="hljs-number">3</span>&gt;<span class="hljs-section">&lt;pre&gt;</span><span class="hljs-attribute">Converted</span> the value <span class="hljs-number">5</span> (<span class="hljs-number">0</span>x<span class="hljs-number">5</span>) to the following bitmatrix:<span class="hljs-attribute">110</span><span class="hljs-attribute">001</span><span class="hljs-attribute">100</span><span class="hljs-comment"># Ones: 4</span></code></pre><h3 id="例13：柯西位矩阵编解码"><a href="#例13：柯西位矩阵编解码" class="headerlink" title="例13：柯西位矩阵编解码"></a>例13：柯西位矩阵编解码</h3><p><code>\Example\cauchy_02.c</code></p><p>输入：k,m,w,seed</p><p>在该例子，packetsize为4. 它首先执行<code>cauchy_original_coding_matrix()</code>来创建一个柯西矩阵，之后转化为位矩阵并编码两次：第一次是<code>jerasure_matrix_encode()</code>，第二次是异或次数更少的<code>jerasure_schedule_encode()</code>。同样它也解码两次，分布调用<code>jerasure_bitmatrix_decode()</code>和<code>jerasure_schedule_decode_lazy()</code></p><pre><code class="hljs angelscript">./cauchy_02 <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">100</span></code></pre><p><img src="/img/image-20210131182921044.png" alt="image-20210131182921044"></p><p><img src="/img/image-20210131182947015.png" alt="image-20210131182947015"></p><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="例14：改进的柯西位矩阵编解码"><a href="#例14：改进的柯西位矩阵编解码" class="headerlink" title="例14：改进的柯西位矩阵编解码"></a>例14：改进的柯西位矩阵编解码</h3><p><code>\Example\cauchy_03.c</code></p><p>功能与例13相同。它使用<code>cauchy_xy_coding_matrix()</code>创建矩阵，并使用<code>cauchy_improve_coding_matrix</code>进行优化。</p><p><img src="/img/image-20210131184008267.png" alt="image-20210131184008267"></p><p><img src="/img/image-20210131184030092.png" alt="image-20210131184030092"></p><p>可以看到异或运算从296次减少到200次，优化效果明显。</p><h3 id="例15：最好的柯西编码矩阵"><a href="#例15：最好的柯西编码矩阵" class="headerlink" title="例15：最好的柯西编码矩阵"></a>例15：最好的柯西编码矩阵</h3><p><code>\Example\cauchy_04.c</code></p><p>功能与例13相同。它使用的是<code>cauchy_good_general_coding_matrix()</code>。注意：在$m = 2,w\le11, k\le 1023$这些都是最优的柯西编码矩阵（但不是最优的RAID-6矩阵）。</p><h3 id="1-4-1-扩展最优Cauchy-RAID-6矩阵的参数空间"><a href="#1-4-1-扩展最优Cauchy-RAID-6矩阵的参数空间" class="headerlink" title="1.4.1 扩展最优Cauchy RAID-6矩阵的参数空间"></a>1.4.1 扩展最优Cauchy RAID-6矩阵的参数空间</h3><p>很容易证明，只要$k &lt;2^w$，那么第0行中全为1并且第1行中具有不同非零元素的任何矩阵都是有效的MDS RAID-6 矩阵。 因此，对于给定值w的最佳RAID-6矩阵是这样的矩阵，其第1行中的k个元素是在其位矩阵中数量最少的k个元素。  <code>Cauchy.c</code>将这些元素存储在$k≤1023$和$w≤11$的全局变量中。文件<code>cauchy_best_r6.c</code>与<code>cauchy.c</code>相同，只不过它包括<code>w≤32</code>的这些值。<br>   这些值不在cauchy.c中的原因仅仅是为了减小目标文件的大小。</p><h2 id="1-5-最小密度RAID-6-编码"><a href="#1-5-最小密度RAID-6-编码" class="headerlink" title="1.5 最小密度RAID-6 编码"></a>1.5 最小密度RAID-6 编码</h2><p>最小密度RAID-6代码是基于位矩阵的MDS代码，该二进制矩阵满足非零数的下限。 与柯西编码不同，位矩阵元素不对应于GF(2^w)中的元素。 取而代之的是，位矩阵本身具有适当的MDS属性。 对于相同的参数，最小密度RAID-6代码的执行速度比Reed-Solomon和Cauchy Reed-Solomon代码快。  Liberation编码，Liber8tion编码和Blaum-Roth编码是jerasure支持的这种编码的三个示例。<br>   对于这些代码中的每一个，m必须等于2，k必须小于或等于w。  w的值受代码[PBV11]的限制：</p><p>​    •对于Liberation编码，w必须是质数。<br>   •对于Blaum-Roth编码，w +1必须是质数。<br>   •对于Liber8tion编码，w必须等于8。</p><p><code>liberation.c\liberation.h</code>实现了如下步骤：</p><ul><li><code>int *liberation_coding_bitmatrix(k,w)</code></li></ul><p>这分配并返回用于自由编码的位矩阵。 尽管w必须是大于2的质数，但此过程未强制执行。 如果给它一个非素数w，则将获得一个非MDS编码矩阵。</p><ul><li><code>int *liber8tion_coding_bitmatrix(int k)</code></li></ul><p>这会分配并且返回针对libera8tion编码的矩阵。liber8tion中的8表示$w=8$。</p><ul><li><code>int *blaum_roth_coding_matrix(int k, int w)</code></li></ul><p>这会分配并且返回针对Blaum Roth的编码矩阵。</p><h3 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h3><h3 id="例16：liberation编码矩阵"><a href="#例16：liberation编码矩阵" class="headerlink" title="例16：liberation编码矩阵"></a>例16：liberation编码矩阵</h3><p><code>\Example\liberation_01.c</code></p><p>输入参数：k, w, seed .</p><p>w是一个大于2的质数，且$k\le w$。</p><pre><code class="hljs angelscript">./liberation_01 <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">100</span></code></pre><p><img src="/img/image-20210201151829328.png" alt="image-20210201151829328"></p><p>可以看到同样的参数下，liberation码得到的矩阵明显更稀疏。编码产生的异或数更少，所以计算开销更少。</p><p>矩阵大小为$2w\times kw$，该码的特点为，前k+1个块都是单位矩阵，最后k-1个矩阵有些规律。</p><h3 id="例-17-文件编码解码"><a href="#例-17-文件编码解码" class="headerlink" title="例 17 文件编码解码"></a><strong>例 17</strong> 文件编码解码</h3><p><code>./Example/encode.c</code></p><ul><li>encoder.c编码文件：</li></ul><pre><code class="hljs 1c">./encoder &#x27;inputfile&#x27; k m &#x27;coding_technique&#x27; w (packetsize) (buffersize)</code></pre><p>‘inputfile’:  输入文件或负数S：要编码的文件或负数S，指示应使用大小为<code>-S</code>的随机文件而不是现有文件</p><p>k：将文件划分的数据块的数量</p><p>m：根据数据块生成的校验块的数量</p><p>coding_technique：使用的编码算法。</p><ul><li>“reed_sol_van”：范德蒙德RS码，w=8，16，32</li><li>“reed_sol_r6_op”：针对RAID-6优化的RS码，m=2，w=8，16，32</li><li>“cauchy_orig”：原生柯西编码</li><li>“cauchy_good”：优化的柯西编码</li><li>“liberation”：最小密度RAID-6中的liberation，k小于等于w，w大于2，且为质数</li><li>“blaum_roth”：最小密度RAID-6中的blaum roth，k小于等于w，w大于2，且w+1为质数</li><li>“liber8tion”：最小密度RAID-6中的liber8tion，k小于等于w，w=8，m=2</li><li>“no_coding”：无编码</li></ul><p>w：word size。</p><p>packet size：就是packet size 。一般为4的整数倍。</p><p>buffer size：每次处理的数据大小，例如1024。</p><p>例子：</p><pre><code class="hljs angelscript">./encoder /home/durantthorvalds/jerasure-master/test.pdf <span class="hljs-number">6</span> <span class="hljs-number">2</span> liberation <span class="hljs-number">7</span> <span class="hljs-number">1024</span> <span class="hljs-number">500000</span>Encoding (MB/sec): <span class="hljs-number">3294.5325077314</span>En_Total (MB/sec): <span class="hljs-number">372.5363687737</span></code></pre><pre><code class="hljs angelscript">drwxrwxrwx <span class="hljs-number">5</span> durantthorvalds durantthorvalds    <span class="hljs-number">4096</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> ..-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_k1.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_k2.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_k3.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_k4.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_k5.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_k6.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_m1.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds <span class="hljs-number">2637824</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_m2.pdf-rw-rw-r-- <span class="hljs-number">1</span> durantthorvalds durantthorvalds      <span class="hljs-number">90</span>  <span class="hljs-number">2</span>月  <span class="hljs-number">1</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span> test_meta.txt</code></pre><p>packetsize 为1k。这儿的6个数据文件大小刚好为源文件的大小.注意文件大小既是7的倍数，也是1024的倍数。</p><p>按照上述说明执行命令后，我们会发现在Examples文件夹中创建了一个Coding文件夹，顾名思义，这里存放着编码好的数据块和编码块，以及一个meta文件，存放文件的编码信息。每个数据块文件都会被命名为”_k#”（数据块）和”_m#”（校验块）然后跟着源文件的扩展名。例如 40kb-image.jpg 就会生成一个 40kb-image_k1.jpg。</p><p><code>test_meta.txt</code>是这次encoding的相关参数，这些参数将会用于decoding过程。</p><pre><code class="hljs angelscript">/home/durantthorvalds/jerasure-master/test.pdf<span class="hljs-number">15431554</span><span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">1024</span> <span class="hljs-number">688128</span>liberation<span class="hljs-number">4</span><span class="hljs-number">23</span></code></pre><ul><li>decoder解码文件：</li></ul><pre><code class="hljs 1c">./decoder &#x27;inputfile&#x27;</code></pre><p>在解码之前，我们假设一种不幸的情况，有两个文件块丢失了。</p><pre><code class="hljs elixir">durantthorvalds<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/jerasure-master/Examples/Coding</span><span class="hljs-variable">$ </span>rm test_k1.pdf test_m1.pdfdurantthorvalds<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/jerasure-master/Examples</span><span class="hljs-variable">$ </span>./decoder /home/durantthorvalds/jerasure-master/test.pdf Decoding (MB/sec): <span class="hljs-number">3815.5760207509</span>De_Total (MB/sec): <span class="hljs-number">818.9580808033</span>durantthorvalds<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/jerasure-master/Examples</span><span class="hljs-variable">$ </span>diff Coding/test_decoded.pdf /home/durantthorvalds/jerasure-master/test.pdf</code></pre><p><code>diff</code>没有输出表示两文件完全相同。</p><p>另外如果损坏文件数超过m，解码也会失败！</p><h2 id="1-6-合理地选择Buffer和Packetsize"><a href="#1-6-合理地选择Buffer和Packetsize" class="headerlink" title="1.6 合理地选择Buffer和Packetsize"></a>1.6 合理地选择Buffer和Packetsize</h2><p>在我们的测试中，缓冲区和数据包的大小对性能的影响与所使用的代码一样多。 多位作者（例如[PLS + 09，PGM13]）多次对此进行了演示。 以下时序使用Liberation代码对k = 6和w = 2的256MB随机创建的数据进行编码。这些时序于2014年在MacBook Pro上拍摄，并显示了数据包和缓冲区的大小如何影响性能。</p><pre><code class="hljs apache"><span class="hljs-attribute">UNIX</span>&gt; encoder -<span class="hljs-number">268435456</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> liberation <span class="hljs-number">7</span> <span class="hljs-number">1024</span> <span class="hljs-number">50000000</span><span class="hljs-attribute">Encoding</span> (MB/sec): <span class="hljs-number">1593</span>.<span class="hljs-number">9637842733</span><span class="hljs-attribute">En_Total</span> (MB/sec): <span class="hljs-number">672</span>.<span class="hljs-number">1876668353</span><span class="hljs-attribute">UNIX</span>&gt; encoder -<span class="hljs-number">268435456</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> liberation <span class="hljs-number">7</span> <span class="hljs-number">1024</span> <span class="hljs-number">5000000</span><span class="hljs-attribute">Encoding</span> (MB/sec): <span class="hljs-number">2490</span>.<span class="hljs-number">9393470499</span><span class="hljs-attribute">En_Total</span> (MB/sec): <span class="hljs-number">1383</span>.<span class="hljs-number">3866387346</span><span class="hljs-attribute">UNIX</span>&gt; encoder -<span class="hljs-number">268435456</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> liberation <span class="hljs-number">7</span> <span class="hljs-number">10240</span> <span class="hljs-number">5000000</span><span class="hljs-attribute">Encoding</span> (MB/sec): <span class="hljs-number">2824</span>.<span class="hljs-number">2836957036</span><span class="hljs-attribute">En_Total</span> (MB/sec): <span class="hljs-number">1215</span>.<span class="hljs-number">1816805228</span><span class="hljs-attribute">UNIX</span>&gt; encoder -<span class="hljs-number">268435456</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> liberation <span class="hljs-number">7</span> <span class="hljs-number">102400</span> <span class="hljs-number">5000000</span><span class="hljs-attribute">Encoding</span> (MB/sec): <span class="hljs-number">1969</span>.<span class="hljs-number">8973976058</span><span class="hljs-attribute">En_Total</span> (MB/sec): <span class="hljs-number">517</span>.<span class="hljs-number">6967197425</span></code></pre><p>结论是：</p><ul><li>在packetsize相同时，buffer越大，编码速度可能越快；</li><li>在buffersize相同时，packetsize越大，编码速度越快。</li></ul><h2 id="1-7-改变默认的伽罗华域"><a href="#1-7-改变默认的伽罗华域" class="headerlink" title="1.7 改变默认的伽罗华域"></a>1.7 改变默认的伽罗华域</h2><p>当我们需要改变本原多项式，或者其它类似操作就需要改参数。下面两个例子展示了这些。</p><p><code>reed_sol_test_gf</code>和<code>reed_sol_time_gf</code></p><p>输入：k，m，w，seed</p><p> 它至少需要五个命令行参数。 前四个是k，m，w和种子。 接下来是Galois字段的规范，该字段使用从GF-Complete的argv（）创建gf的过程。 如果给它一个短横线，它将选择默认值。 然后，程序创建用于Reed-Solomon编码的生成器矩阵，进行编码和解码，并确保解码成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;libJerasure&quot;&gt;&lt;a href=&quot;#libJerasure&quot; class=&quot;headerlink&quot; title=&quot;libJerasure&quot;&gt;&lt;/a&gt;libJerasure&lt;/h1&gt;&lt;div class=&quot;note note-warning&quot;&gt;
     </summary>
      
    
    
    
    <category term="纠删码" scheme="http://durantthorvalds.top/categories/%E7%BA%A0%E5%88%A0%E7%A0%81/"/>
    
    
    <category term="jerasure" scheme="http://durantthorvalds.top/tags/jerasure/"/>
    
    <category term="纠删码库" scheme="http://durantthorvalds.top/tags/%E7%BA%A0%E5%88%A0%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>「理论」最小密度RAID-6编码</title>
    <link href="http://durantthorvalds.top/2021/02/10/%E6%9C%80%E5%B0%8F%E5%AF%86%E5%BA%A6RAID-6%E7%BC%96%E7%A0%81/"/>
    <id>http://durantthorvalds.top/2021/02/10/%E6%9C%80%E5%B0%8F%E5%AF%86%E5%BA%A6RAID-6%E7%BC%96%E7%A0%81/</id>
    <published>2021-02-09T16:00:00.000Z</published>
    <updated>2021-02-27T06:42:27.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小密度RAID-6编码"><a href="#最小密度RAID-6编码" class="headerlink" title="最小密度RAID-6编码"></a>最小密度RAID-6编码</h1><p>我们的存储系统由n个磁盘阵列组成，每个磁盘大小相同。 在这n个磁盘中，其中k个保存数据，其余m = n-k个保存编码信息，通常称为奇偶校验。 在RAID-6系统中，m = 2，我们标记数据磁盘D0，…，Dk-1和奇偶校验磁盘P和Q。示例系统如图1所示。</p><p><img src="/img/image-20210204103652749.png" alt="image-20210204103652749"></p><p>编码性能的比较：</p><ul><li><strong>编码性能</strong>是根据D0 … Dk-1计算P和Q的速度。 最佳编码性能由每个编码元素k − 1个异或运算的下限定义。</li><li><strong>修改性能</strong>是当其中一个数据磁盘上的元素被修改时重新计算P和Q的相关部分的速度。 修改的计算开销通常很小，每个修改的数据字涉及三到四个XOR操作。 修改的真正代价来自对P和Qdisk的读写操作。 最佳修改开销是对两个编码盘中的每个进行一次读取和一次写入操作：必须读取对应于已更改数据的旧值，以便可以减去旧值并添加新值。 因此，我们将修改性能衡量为修改数据元素时必须修改的编码元素的数量。</li><li><strong>解码性能</strong>是在一两次失败之后重新计算丢失的数据或编码信息的速度。 与编码一样，最佳解码性能是每个解码元素k-1个异或运算。</li><li><strong>灵活性</strong>是从系统添加或减去数据驱动器的简便性。 如果需要灵活性，则必须选择一个固定值w，该值可以处理任意数量的数据磁盘，直到k的某个最大值。 然后，只要磁盘数量少于最大数量，就会假定系统包含前面所述的phantom磁盘。 因此，增加或减少磁盘只需要对P和Q驱动器进行一个磁盘的修改。 更改w的值需要重新编码整个系统。</li></ul><p><strong>位矩阵编码</strong></p><p><img src="/img/image-20210204104922659.png" alt="image-20210204104922659"></p><p><img src="/img/image-20210204105638403.png" alt="image-20210204105638403"></p><h2 id="Blaum-Roth编码"><a href="#Blaum-Roth编码" class="headerlink" title="Blaum-Roth编码"></a>Blaum-Roth编码</h2><p>作者在1999年的论文证明，对于$k\le w$，任何RAID-6 SCM矩阵至少有$2kw+k-1$个1。直觉上，P超级行包含k个单位矩阵，而Q超级行包括一个单位矩阵和k-1个含w+1个1的矩阵。所以$kw+w+(k-1)(w+1)=2kw+k-1$。</p><p>我们下面讨论$w$:</p><p>当$w+1$为质数时，下面是$w=4$和$w=16$的例子：</p><p><img src="/img/image-20210204114335107.png" alt="image-20210204114335107"></p><p>​    对于所有的w，$X_0^{BR}=I$，对于$i&gt;0$，我们对$X_0^{BR}[r,c]$：</p><ul><li>所有元素不是0就是1；</li><li>当$r\ne w - i$，$X_i^{BR}[r,(\overline{r+i})_{w+1}]=1$;上划线是取模符号。</li><li>当$r=w-i$且$i$为奇数，$X_i^{BR}[r,i-1]=1,X_i^{BR}[r,\frac{w+i-1}{2}]=1$;</li><li>当$r=w-i$并且$i$为偶数，$X_i^{BR}[r,i-1]=1,X_i^{BR}[r,\frac{i-2}{2}]=1$</li></ul><p>从直觉上，$X_i^{BR}$矩阵被分为三个部分，在$w-i$行之上的矩阵是一个向右平移$i$个单位的单位矩阵；在其之下的矩阵则是偏移$i-1$的单位矩阵;在$w-i$行的包括两个1。比较重要的两种Blaum-Roth矩阵是$w=4,w=16$。</p><p>例如k=4，w=4，在该函数下生成的矩阵为：</p><pre><code class="hljs basic"><span class="hljs-symbol">1000 </span><span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span><span class="hljs-symbol">0100 </span><span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span><span class="hljs-symbol">0010 </span><span class="hljs-number">0010</span> <span class="hljs-number">0010</span> <span class="hljs-number">0010</span><span class="hljs-symbol">0001 </span><span class="hljs-number">0001</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span><span class="hljs-symbol">1000 </span><span class="hljs-number">0100</span> <span class="hljs-number">0010</span> <span class="hljs-number">0001</span><span class="hljs-symbol">0100 </span><span class="hljs-number">0010</span> <span class="hljs-number">0001</span> <span class="hljs-number">0011</span><span class="hljs-symbol">0010 </span><span class="hljs-number">0001</span> <span class="hljs-number">1100</span> <span class="hljs-number">1000</span><span class="hljs-symbol">0001 </span><span class="hljs-number">1010</span> <span class="hljs-number">1000</span> <span class="hljs-number">0100</span></code></pre><p>前面的k个wxw矩阵块均为单位矩阵，下面的矩阵才是Blaum-Roth矩阵。</p><hr><h2 id="Liberation编码"><a href="#Liberation编码" class="headerlink" title="Liberation编码"></a>Liberation编码</h2><p>当w为质数时：</p><p>当$i=0$，$X_0^L=I_w$，对于$i&gt;0$：</p><ul><li>每个矩阵的元素不是0就是1；</li><li>对于所有$0\le r&lt;w$，$X_i^L[r,(\overline{r+i})_w]=1$;</li><li>令$y=\frac{i(w-1)}{2}$，我们有$X_i^L[(\overline y)_w,(\overline {y+i-1})_w]=1$.</li></ul><p><img src="/img/image-20210205154429483.png" alt="image-20210205154429483"></p><h2 id="Liber8tion编码"><a href="#Liber8tion编码" class="headerlink" title="Liber8tion编码"></a>Liber8tion编码</h2><p>该编码非常局限的地方是只能$w=8$。事实上，该编码是为了弥补Blaum-Roth编码没有$w=8$情况而设计的。</p><p>尽管我们没有为w = 8构造最小密度MDS代码的理论，但我们能够从所有可能的最小密度MDS代码的集合中进行合格代码的枚举，并将得到的代码分为48个不同的集合。 枚举的详细信息在其他地方提供[Plank 2008a]。<br>  这48个代码的解码性能有所不同，其中最好的如图6所示。</p><h2 id="各项性能"><a href="#各项性能" class="headerlink" title="各项性能"></a>各项性能</h2><h3 id="1-编码性能"><a href="#1-编码性能" class="headerlink" title="1 编码性能"></a>1 编码性能</h3><p>SCM的一行如果有$o$个1，那么对应的异或操作数是$o-1$。因此对于SCM一共$O$个1而言，每个字的异或操作数是$\frac{O-2w}{2w}$。对于最小密度RAID-6码，$O=2kw+k-1$，所以编码性能为：</p><script type="math/tex; mode=display">encoding\_performance=\frac{2kw+k-1-2w}{2w}=\frac{(k-1)(2w+1)}{2w} XOR's \ per\ encoded\ word</script><p>因为最优的编码对每个字需要$k-1$次异或，所以相对最优的编码惩罚因子为：</p><script type="math/tex; mode=display">Encoding\_penalty\_factor\_over\_optimal = 1+\frac{1}{2w}</script><p><img src="/img/image-20210206143455495.png" alt="image-20210206143455495" style="zoom:67%;" /></p><p>最小密度码的表现与k无关，而RDP和EVENODD对于小的k表现很差。理想状况下，w趋于无限时的惩罚因子最小，但是这会导致占用更多的内存，所以这之间存在一个tradeoff。</p><p>RDP码最优的时候是w+1为质数且$k\in\{w-1,w\}$。</p><h3 id="2-修复性能"><a href="#2-修复性能" class="headerlink" title="2 修复性能"></a>2 修复性能</h3><p>因为最低密度SCM有$2kw+k-1$个1和$kw$列，因此平均每行的1的数目就是修复性能：</p><script type="math/tex; mode=display">Modified\_performance=2+\frac{k-1}{kw}</script><p><img src="/img/image-20210206144732725.png" alt="image-20210206144732725" style="zoom:67%;" /></p><p>很显然，最低密度RAID-6编码要优秀。</p><h3 id="3-解码性能"><a href="#3-解码性能" class="headerlink" title="3 解码性能"></a>3 解码性能</h3><p><img src="/img/image-20210206144759014.png" alt="image-20210206144759014" style="zoom:67%;" /></p><p>通常，最小密度代码在最优值上会导致惩罚因子在1.13和1.18之间，并且表现不如EVENODD或RDP编码好。 因此，当评估最小密度码时，必须权衡良好的编码和修改性能与较差的解码性能。<br>  如果没有代码专用的混合重建算法，解码性能会很差（大约0.35w），并且会使最小密度的代码无法用于实际应用。</p><h2 id="证明Liberation码是MDS"><a href="#证明Liberation码是MDS" class="headerlink" title="证明Liberation码是MDS"></a>证明Liberation码是MDS</h2><p>RAID-6码仅需要满足以下两个条件就是MDS：</p><ul><li>每个$X_i$是可逆的；</li><li>$X_i$和$X_j$之和矩阵也是可逆的($i\ne j$)；</li></ul><p>$M^w$表示GF(2)上一个$w\times w$矩阵</p><p><img src="/img/image-20210207153241111.png" alt="image-20210207153241111"></p><p>首先介绍几类基本矩阵</p><ul><li>矩阵$T_d^w$</li></ul><p>其中$w&gt;1, 0&lt;d,s&lt;w$</p><p>她是由两个对角形加上一个额外的翻转位构成的矩阵，一个对角是主对角线（↘），另一个是从下标d列的对角线（↘）。可以表示为：</p><script type="math/tex; mode=display">T^w_d(x)=I_w+(I_w)_{\rightarrow d}+E^w_{x,x-1}\\T_d^w=\{T_d^w(x)|0\le x < w\}</script><p>如上图10的（a），（b）是这样两个例子，翻转的位分别是(1,0)和(10,9)【红色的部分】.</p><p><strong>引理1</strong>：所有$T_d^w$内的矩阵都是等价的。</p><p>通过简单地沿着对角线平移就可以证明。</p><ul><li>矩阵$S_{d,s}^w$</li></ul><p>她在$T_d^w$基础上又添加了一个1.这里的S是“same”的意思。</p><script type="math/tex; mode=display">S_{d,s}^w(x)=T^w_d+E^w_{x+s,x+s-1}\\S_{d,s}^w=\{S_{d,s}^w(x)|0\le x <w\}</script><p>如图10的（c）和（d）。</p><p><strong>引理2</strong>：所有$S_{d,s}^w$内的矩阵都是等价的。</p><ul><li>矩阵$D_{d,s}^w$</li></ul><p>她在$T_d^w$基础上又添加了一个1.这里的D是“different”的意思。</p><script type="math/tex; mode=display">D_{d,s}^w(x)=T^w_d+E^w_{x+s,x+d+s-1}\\D_{d,s}^w=\{D_{d,s}^w(x)|0\le x <w\}</script><p>如图10的（e）。</p><p><strong>引理3</strong>：所有$D_{d,s}^w$内的矩阵都是等价的。</p><p>下面我们罗列一些重要性质。</p><p><strong>性质1</strong>（平移性）：$T_d^w \equiv T_{w-d}^w$。</p><p><strong>性质2</strong>（放缩性）：若$d&lt;w/2,T_d^w\equiv T_d^{w-d}$。</p><p><img src="/img/image-20210207160345516.png" alt="image-20210207160345516"></p><p><strong>性质3</strong>（平移性）：$S_{d,s}^w=S^w_{d,w-s}$</p><p><strong>性质4</strong>（对角翻转性）：若$1&lt;s&lt;w-1,S_{d,s}^w\equiv S_{w-d,s}^w$。</p><p><img src="/img/image-20210207161201491.png" alt="image-20210207161201491"></p><p>比如上面这个例子，（b）表示1行加上0行，注意是异或；（c）表示6行加上5行；（d）表示整体左移3个单位。</p><p><strong>性质5</strong>（放缩性I）：若$d&lt;w/2$且$s&lt;w/2$，$S_{d,s}^w = S^{w-d}_{d,s}$.</p><p>证明类比性质2.</p><p><img src="/img/image-20210207163019001.png" alt="image-20210207163019001"></p><p><strong>性质6</strong>（放缩性II）：若$d&gt;w/2,s&lt;d$,$S^w_{d,s}=S^d_{2d-w,s}$.</p><p><img src="/img/image-20210208150619459.png" alt="image-20210208150619459"></p><p><strong>性质7</strong>（平移性）：$D^w_{d,s}\equiv D^w_{w-d,w-s}$</p><p><img src="/img/image-20210207163447752.png" alt="image-20210207163447752"></p><p><strong>性质8</strong>（转化性）：$s&gt;1,D_{d,s}^w\equiv S^w_{d,s}$</p><p>正式证明</p><p>步骤1：$X_i^L$是可逆的。</p><p>因为$(X_i^L)^T_{\leftarrow i}$是三角矩阵，所以一定是可逆的。</p><p>步骤2：$X_i$和$X_j$之和矩阵也是可逆的($i\ne j$)；</p><p>$X_0^L$是单位矩阵，因此$X_0^L+X_i^L=T_i^w$。我们定义$\mathcal A$为所有满足$GCD(w,d)=1$(w,d最大公因子为1)的$T^w_d$的集合。因此$X_0^L+X_i^L\in \mathcal A$。</p><p><strong>定理1</strong>：$\mathcal A$中所有的矩阵都是可逆的。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小密度RAID-6编码&quot;&gt;&lt;a href=&quot;#最小密度RAID-6编码&quot; class=&quot;headerlink&quot; title=&quot;最小密度RAID-6编码&quot;&gt;&lt;/a&gt;最小密度RAID-6编码&lt;/h1&gt;&lt;p&gt;我们的存储系统由n个磁盘阵列组成，每个磁盘大小相同。 在这n</summary>
      
    
    
    
    <category term="纠删码" scheme="http://durantthorvalds.top/categories/%E7%BA%A0%E5%88%A0%E7%A0%81/"/>
    
    
    <category term="纠删码" scheme="http://durantthorvalds.top/tags/%E7%BA%A0%E5%88%A0%E7%A0%81/"/>
    
    <category term="Jerasure" scheme="http://durantthorvalds.top/tags/Jerasure/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出学习Paxos</title>
    <link href="http://durantthorvalds.top/2021/01/23/PAXOS-Made-Simple%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0Paxos/"/>
    <id>http://durantthorvalds.top/2021/01/23/PAXOS-Made-Simple%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0Paxos/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-03-19T08:19:43.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🏆深入浅出学习Paxos"><a href="#🏆深入浅出学习Paxos" class="headerlink" title="🏆深入浅出学习Paxos"></a>🏆深入浅出学习Paxos</h1><blockquote><p>Google Chubby的作者Mike Burrows说过这个世界上<strong>只有一种</strong>一致性算法，那就是Paxos，其它的算法都是<strong>残次品</strong>。</p></blockquote><h2 id="①-问题产生的背景"><a href="#①-问题产生的背景" class="headerlink" title="① 问题产生的背景"></a>① 问题产生的背景</h2><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><p>注：这里<strong>某个数据的值</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场景不同，<strong>某个数据的值</strong>有不同的含义。</p><h2 id="②概念和术语"><a href="#②概念和术语" class="headerlink" title="②概念和术语"></a>②概念和术语</h2><p>在Paxos算法中有三种角色：</p><ul><li>Acceptors</li><li>Proposers</li><li><p>Learners</p></li><li><p>Proposal:提案，是由proposer提出的。</p></li></ul><p>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</p><p>Acceptor：只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</p><p>Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</p><h2 id="③-问题描述"><a href="#③-问题描述" class="headerlink" title="③ 问题描述"></a>③ 问题描述</h2><p>假设有一组可以<strong>提出（propose）value</strong>（value在提案Proposal里）的<strong>进程集合</strong>。一个一致性算法需要保证提出的这么多value中，<strong>只有一个</strong>value被选定（chosen）。如果没有value被提出，就不应该有value被选定。如果一个value被选定，那么所有进程都应该能<strong>学习（learn）</strong>到这个被选定的value。对于一致性算法，<strong>安全性（safaty）</strong>要求如下：</p><ul><li>只有被提出的value才能被选定。</li><li>只有一个value被选定，并且</li><li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li></ul><p>我们不去精确地定义其<strong>活性（liveness）</strong>要求。我们的目标是保证<strong>最终有一个提出的value被选定</strong>。当一个value被选定后，进程最终也能学习到这个value。</p><blockquote><p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>为了避免单点故障，我们需要指定多个Acceptor，并且我们指定一些约束，比如我们希望即使只有一个Proposer提出了一个value，它也能被选中。</p><blockquote><p> P1：<strong>一个Acceptor必须接受它受到的第一个proposal</strong>。</p></blockquote><p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。我们再加一个约束：</p><p>规定：<strong>一个提案被选定，必须要半数以上的Acceptor同意才行</strong>。</p><p>最开始讲的『<strong>提案=value</strong>』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『<strong>提案=提案编号+value</strong>』。于是乎</p><blockquote><p>P2：<strong>如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v</strong>。</p></blockquote><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><blockquote><p>P2a：<strong>如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</strong></p></blockquote><p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，编号2-5的Acceptor（半数以上）均接受了该提案，于是对于编号2-5的Acceptor和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p><ol><li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。</li><li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ol><p>所以我们要对P2a约束进行强化！</p><p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p><blockquote><p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p></blockquote><p>由P2b可以推出P2a进而推出P2。</p><p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p><p>只要满足P2c即可：</p><blockquote><p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p><ol><li>S中每个Acceptor都没有接受过编号小于N的提案。</li><li>S中Acceptor接受过的最大编号的提案的value为V。</li></ol></blockquote><p><strong>Proposer生成提案</strong></p><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p><p>于是我们得到了如下的<strong>提案生成算法</strong>：</p><ol><li><p>Proposer选择一个<strong>新的提案编号N</strong>，然后向某个Acceptor集合（半数以上）发送请求，要求该集合的每个Acceptor作出如下响应：</p><ul><li>向Proposer承诺不再接受任何≤N的提案。</li><li>如果Acceptor已经接受过提案，就向Proposer<strong>响应已经接受过的编号小于N</strong>的最大编号提案。</li></ul><p>我们将该请求称为编号为N 的Prepare请求。</p></li></ol><ol><li>如果Proposer收到了<strong>半数以上</strong>的Acceptor的<strong>响应</strong>，那么它就可以生成编号为N，Value为V的<strong>提案[N,V]</strong>。这里的V是所有的响应中<strong>编号最大的提案的Value</strong>。如果所有的响应中<strong>都没有提案</strong>，那 么此时V就可以由Proposer<strong>自己选择</strong>。<br>生成提案后，Proposer将该<strong>提案</strong>发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合<strong>不一定</strong>是之前响应Prepare请求的Acceptor集合）</li></ol><p><strong>Acceptor接受提案</strong></p><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p><p>我们对Acceptor接受提案给出如下约束：</p><blockquote><p>P1a：一个Acceptor只要尚<strong>未响应过</strong>任何<strong>编号大于N</strong>的<strong>Prepare请求</strong>，那么他就可以<strong>接受</strong>这个<strong>编号为N的提案</strong>。</p></blockquote><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p><p>因此，一个Acceptor<strong>只需记住</strong>：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p><h2 id="④-Paxos算法流程"><a href="#④-Paxos算法流程" class="headerlink" title="④ Paxos算法流程"></a>④ Paxos算法流程</h2><p>Paxos算法分为两个阶段，术语2PC(二阶段提交)。</p><p>阶段1</p><ol><li>proposer选择一个提案编号N，同时向超过半数的Acceptor发送编号为N的prepare请求；</li><li>如果有一个Acceptor接受到一个<strong>编号为N的prepare请求</strong>，且N大于Acceptor响应过的所有Acceptor已经响应过的prepare编号，那么将它<strong>已经接受过的最大的prepare编号</strong>（如果有的话）发送给Proposer，并承诺不再接受任何<strong>编号小于N</strong>的提案。</li></ol><p>阶段2</p><ol><li>如果proposer收到<strong>半数以上</strong>的acceptor对其prepare请求的响应，那么它就会发送一个<strong>针对[N,V]提案的prepare请求</strong>给<strong>半数以上</strong>的Acceptor。注意V就是acceptor对prepare请求响应的编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。</li><li>如果Acceptor收到一个针对<strong>编号为N的提案</strong>的Accept请求，只要该Acceptor<strong>没有</strong>对<strong>编号大于N</strong>的请求作出过响应，那么它就接受该提案。</li></ol><p><img src="/img/1752522-44c5a422f917bfc5.jpg" alt="Paxos算法流程"></p><p>Learner学习被选定的value也有三种方案</p><p><img src="/img/1752522-0fab48ed2bdf358a.png" alt="幻灯片17.png"></p><p>假定有两个Proposer依次提出编号递增的提案，最终会陷入死循环，没有value被选定。</p><p>例如Proposer P1提出了编号为M1的prepare请求，收到过半响应，完成了第一阶段流程。</p><p>同时Proposer P2发出了编号为M2(M2&gt;M1)的prepare请求，也受到了过半响应，于是Acceptor承诺不再接受编号小于M的提案。</p><p>P1进入第二阶段时，发出的Accept请求被Acceptor忽略，于是P1再次进入阶段1并发出编号为M3（M3&gt;M2）的请求。。。如此反复形成死循环。因此我们需要<strong>选取一个主Proposer</strong>。</p><blockquote><p>参考：</p><paxos-made-simple><p><a href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🏆深入浅出学习Paxos&quot;&gt;&lt;a href=&quot;#🏆深入浅出学习Paxos&quot; class=&quot;headerlink&quot; title=&quot;🏆深入浅出学习Paxos&quot;&gt;&lt;/a&gt;🏆深入浅出学习Paxos&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Google Chubby</summary>
      
    
    
    
    <category term="分布式" scheme="http://durantthorvalds.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="经典论文" scheme="http://durantthorvalds.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="分布式" scheme="http://durantthorvalds.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="一致性" scheme="http://durantthorvalds.top/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「应用」探秘FUSE，讲讲故事</title>
    <link href="http://durantthorvalds.top/2021/01/17/2021-1-3%E6%8E%A2%E7%A7%98FUSE%EF%BC%8C%E8%AE%B2%E8%AE%B2%E6%95%85%E4%BA%8B/"/>
    <id>http://durantthorvalds.top/2021/01/17/2021-1-3%E6%8E%A2%E7%A7%98FUSE%EF%BC%8C%E8%AE%B2%E8%AE%B2%E6%95%85%E4%BA%8B/</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2021-02-11T04:25:38.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探秘FUSE，讲讲故事"><a href="#探秘FUSE，讲讲故事" class="headerlink" title="探秘FUSE，讲讲故事"></a>探秘FUSE，讲讲故事</h1><blockquote><p>Github Release<a href="https://github.com/libfuse/libfuse/releases">下载</a></p><p>SourceForge </p></blockquote><p>FUSE,($Filesystem In Userspace$)，用户空间文件系统（Filesystem in Userspace），是Linux 中用于挂载某些<a href="https://baike.baidu.com/item/网络空间/7650101">网络空间</a>，如<a href="https://baike.baidu.com/item/SSH/10407">SSH</a>，到本地文件系统的模块。简单来说，FUSE在用户空间自定义来定制实现自己的文件系统。</p><p>完整的fuse包括三个层级：1. 用户customize文件系统 2. 用户态fuse库(libfuse) 3. 内核支持(fs /fuse/*)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;探秘FUSE，讲讲故事&quot;&gt;&lt;a href=&quot;#探秘FUSE，讲讲故事&quot; class=&quot;headerlink&quot; title=&quot;探秘FUSE，讲讲故事&quot;&gt;&lt;/a&gt;探秘FUSE，讲讲故事&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Github Release&lt;a href</summary>
      
    
    
    
    <category term="fuse" scheme="http://durantthorvalds.top/categories/fuse/"/>
    
    
    <category term="linux" scheme="http://durantthorvalds.top/tags/linux/"/>
    
    <category term="文件系统" scheme="http://durantthorvalds.top/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>「应用」Ceph应用实战</title>
    <link href="http://durantthorvalds.top/2021/01/17/%E3%80%8C%E5%BA%94%E7%94%A8%E3%80%8DCeph%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/"/>
    <id>http://durantthorvalds.top/2021/01/17/%E3%80%8C%E5%BA%94%E7%94%A8%E3%80%8DCeph%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2021-03-01T12:37:30.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「应用」Ceph应用实战"><a href="#「应用」Ceph应用实战" class="headerlink" title="「应用」Ceph应用实战"></a>「应用」Ceph应用实战</h1><p>本讲介绍一些常见的ceph应用场景，比如：</p><ul><li>ceph集群定时scrub</li><li>ceph集群对接OpenStack</li><li>Ceph数据重建配置策略</li><li>Ceph集群Full紧急处理</li><li>Ceph快照再增量备份的应用</li><li>Ceph集群异常watcher处理</li></ul><h2 id="1-集群定时Scrub"><a href="#1-集群定时Scrub" class="headerlink" title="1  集群定时Scrub"></a>1  集群定时Scrub</h2><p>Scrub操作是为了保证集群副本间数据的一致性，包括Scrub和DeepScrub，前者只会对元数据进行扫描，而后者会对元数据和数据进行扫描。</p><p>默认的扫描时间间隔是1d-7d。</p><p><strong>比如我们试着让集群在晚上22时到第二天7时进行scrub</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「应用」Ceph应用实战&quot;&gt;&lt;a href=&quot;#「应用」Ceph应用实战&quot; class=&quot;headerlink&quot; title=&quot;「应用」Ceph应用实战&quot;&gt;&lt;/a&gt;「应用」Ceph应用实战&lt;/h1&gt;&lt;p&gt;本讲介绍一些常见的ceph应用场景，比如：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="ceph" scheme="http://durantthorvalds.top/categories/ceph/"/>
    
    <category term="分布式存储" scheme="http://durantthorvalds.top/categories/ceph/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="系统架构" scheme="http://durantthorvalds.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="ceph" scheme="http://durantthorvalds.top/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>「核心」Ceph学习三部曲之八：分布式文件系统CephFS</title>
    <link href="http://durantthorvalds.top/2021/01/17/2021117-%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E5%85%AB%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FCephFS/"/>
    <id>http://durantthorvalds.top/2021/01/17/2021117-%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E5%85%AB%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FCephFS/</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2021-03-09T12:32:34.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ceph分布式文件系统：CephFS"><a href="#Ceph分布式文件系统：CephFS" class="headerlink" title="Ceph分布式文件系统：CephFS"></a>Ceph分布式文件系统：<em>CephFS</em></h1><p>​    Ceph文件系统或<strong>CephFS</strong>是在Ceph的分布式对象存储<strong>RADOS</strong>之上构建的POSIX兼容文件系统。CephFS致力于为各种应用程序提供最新，多用途，高可用性和高性能的文件存储，包括传统用例（如共享主目录，HPC暂存空间和分布式工作流共享存储）。</p><p>​    CephFS通过使用一些新颖的架构选择来实现这些目标。值得注意的是，文件元数据与文件数据存储在单独的RADOS池中，并通过可调整大小的<em>元数据服务器</em>或<strong>MDS</strong>集群提供服务，该集群可扩展以支持更高吞吐量的元数据工作负载。文件系统的客户端可以直接访问RADOS来读写文件数据块。</p><p>通过MDS集群协调对数据的访问，该集群充当客户端和MDS共同维护的分布式元数据缓存状态的授权机构。每个MDS都会将对元数据的改变写入到日志中。MDS不会在本地存储任何元数据状态。此模型允许在POSIX文件系统的上下文中客户端之间进行连贯且快速的协作。</p><p>CephFS基于MDS对元数据进行管理。它有如下特点:</p><ul><li><p>采用多实例消除性能瓶颈和提高可靠性；</p></li><li><p>采用大型日志文件和延迟删除日志机制来提升元数据的读写性能；</p></li><li><p>将Inode内嵌至Dentry中来提升文件索引效率；</p></li><li><p>采用目录分片来重新定义命名空间的层次结构，并且目录分片可以在MDS实例之间动态迁移，从而实现细粒度的流控和负载均衡机制</p></li></ul><p>  <img src="/img/cephfs-architecture.svg" alt=""></p><p>在正式介绍MDS前，我们先了解以下文件系统基础知识。</p><h2 id="0-了解文件系统"><a href="#0-了解文件系统" class="headerlink" title="0 了解文件系统"></a>0 了解文件系统</h2><p>常见的本地文件系统有：Ext2/3/4，XFS，BTRFS，FAT，NTFS；常见的网络文件系统有NFS，CIFS。随着互联网快速发展，数据规模越来越大，传统的文件系统已经不能满足要求。分布式文件系统应运而生，比如CephFS、Lustre、HDFS、GFS、GlusterFS。</p><p>为了适配不同的文件系统，Linux采用VFS（虚拟文件系统）。</p><p>例如用户写入一个文件，使用POSIX标准的write接口，会被操作系统接管，转调sys_write这个系统调用（属于SCI层）。然后VFS层接受到这个调用，通过自身抽象的模型，转换为对给定文件系统、给定设备的操作，这一关键性的步骤是VFS的核心，需要有统一的模型，使得对任意支持的文件系统都能实现系统的功能。这就是VFS提供的统一的文件模型（common file model），底层具体的文件系统负责具体实现这种文件模型，负责完成POSIX API的功能，并最终实现对物理存储设备的操作。</p><p><img src="/img/70.png" alt="img"></p><p>VFS在系统中的位置如下图。</p><p><img src="/img/image-20210119182434745.png" alt=""></p><h2 id="1-文件系统中的元数据"><a href="#1-文件系统中的元数据" class="headerlink" title="1 文件系统中的元数据"></a>1 文件系统中的元数据</h2><p>VFS为了适配不同类型的元数据，定义了4种基本类型：</p><ul><li>$Superblock$：用于管理某一类文件的系统信息；</li><li>$Inode$：索引节点。类Unix文件系统中的一种数据结构，每个Inode保存文件系统中的一个文件系统对象的概要信息，<strong>但不包括文件名和文件内容本身</strong>。<u>Inode和文件名是一对多的关系</u>。</li><li>$Dentry$：目录项。是一个内存结构，由文件系统在内存中直接创立，它是类Unix系统的某个Inode的链接，包含了文件名、文件的Inode号等信息；</li><li>$File$：文件操作句柄，和进程相关，表示一个打开的文件，<u>File和Inode之间是一对多的关系</u>，因为多个进程可以打开一个文件。</li></ul><p>由于Inode和Dentry需要后端文件系统提供服务功能，需要重点介绍：</p><p>具体而言：</p><p>$a$. Inode只记录数据块在存储介质上的位置和分布，以及文件对象属性（包括权限、数据块信息、时间戳等），不包括文件名和内容等变长数据。Inode结构大小固定，但我们发现要找到具体的存储位置，还缺少文件在目录树中的位置信息，因此需要引入Dentry。</p><p>$b$. Dentry在文件系统中起到链接不同Inode的作用。Dentry包含文件名、文件名Inode等信息。它们最终组成文件目录树的结构。它的原理是：本级的Dentry记录了本级目录或者文件名以及下一级目录或者文件的Dentry位置，此外，Dentry本身也需要在具体的Inode对象中，所以它也有自己的Inode号。<strong>Dentry本身像一张表，记录了Inode和文件名的对应关系</strong>。下面这张图很好的表示了inode和dentry的关系。</p><p><img src="/img/1055408-20161104001642736-837882075.png" alt="img"></p><blockquote><p>图片来源：<a href="https://www.cnblogs.com/mister-lv/p/6028836.html">https://www.cnblogs.com/mister-lv/p/6028836.html</a></p></blockquote><h2 id="2-硬链接和软链接"><a href="#2-硬链接和软链接" class="headerlink" title="2 硬链接和软链接"></a>2 硬链接和软链接</h2><blockquote><p>推荐阅读：<a href="https://www.cnblogs.com/fqnb001/p/8778790.html">什么是软链接，硬链接</a></p></blockquote><p>为了实现文件共享，隐藏文件路径、文件安全和节省存储空间等功能或特性，需要引入链接这个概念。</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接指多个文件名指向同一个Inode号(在MDS就是多个Dentry指向一个Inode)，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问（只有一个Inode的所有文件都被删除时，文件才会真正被删除），注意目录不能用于创建硬链接（防止形成环）。目录中的隐藏的.和..就是典型的硬链接。</p><pre><code class="hljs awk">ln 源文件 目标文件 <span class="hljs-regexp">//</span>创建硬链接ls -li <span class="hljs-regexp">//</span>查看链接</code></pre><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接是创建一个新的Inode，Inode的存储内容是另外一个文件路径名的指向，可以理解为<strong>windows的快捷方式</strong>。它的特点是可以灵活地实现诸多不做限制的要求：既可以对存在或者不存在的文件和目录创建软链接，也可以链接到不同的文件系统，还可以在删除链接时不影响指向的文件等。</p><pre><code class="hljs awk">ln -s 源文件 目标文件 <span class="hljs-regexp">//</span>查看软链接</code></pre><pre><code class="hljs awk">ll &#123;文件名&#125; <span class="hljs-regexp">//</span> 查看所有链接</code></pre><pre><code class="hljs awk">软链接创建好了，我们来看看怎么删除它正确的删除方式（删除软链接，但不删除实际数据）rm -rf  ./test_chk_ln错误的删除方式rm -rf .<span class="hljs-regexp">/test_chk_ln/</span> (这样就会把原来test_chk下的内容删除)</code></pre><blockquote><p>题外话：讲个笑话，各位小朋友千万不要模仿（除非你想删库跑路）！</p><p><img src="/img/image-20210119192857642.png" alt=""></p></blockquote><p>扩展：</p><p><a href="https://blog.csdn.net/qq_37806908/article/details/97686753">linux .so .o .a文件区别</a></p><h2 id="3-日志"><a href="#3-日志" class="headerlink" title="3 日志"></a>3 日志</h2><p>日志是一种特殊的文件，用于循环记录文件系统的修改，并定期提交到文件系统进行保存。一旦系统发生崩溃，日志可以起到<strong>存档点</strong>的作用。</p><p>常见的日志设计模式无外乎以下三种：</p><p>（1）writeback</p><p>writeback模式只有元数据被写入到数据中，这样虽然可以保证日志一致性，但是可能引起日志崩溃。</p><p>（2）ordered</p><p>ordered模式也是只将元数据写入到日志，但是前提是数据已经写入数据盘。但是在数据写入硬盘后而元数据写入前系统崩溃的情景，就会发生数据丢失。</p><p>（3）data</p><p>data模式将元数据和数据都写入日志，这样可以最大限度的防止文件系统崩溃所导致的数据丢失，但是因为数据写入两次，性能会下降。</p><p>日志提交有两种方式：超时提交和满时提交。超时提交，顾名思义指在规定时间之后，日志会自动同步；满时提交指日志存储空间到达上限才会触发同步。一般文件系统会同时采用这两种模式。</p><hr><h2 id="正式部分"><a href="#正式部分" class="headerlink" title="正式部分"></a>正式部分</h2><h2 id="S1-CephFS"><a href="#S1-CephFS" class="headerlink" title="$\S1$ CephFS"></a>$\S1$ CephFS</h2><p>分布式系统通过多服务器实现负载均衡，为了快速索引元数据，必须将元数据和用户数据进行分离，这是Ceph最杰出的贡献之一。</p><p>为了实现负载均衡，有如下几种方式：</p><p>（1）静态子树分区</p><p>即通过手工的方式进行数据分配，典型的有Sprite、StorageTnak和PanFS。</p><p>（2）Hash计算分区法</p><p>​    通过hash计算来分配数据存储位置。这种方式适合数据分布均衡且需要应对各种异常的场景，但不太适合数据分布固定的场景。</p><p>（3）动态子树分区</p><p>​    通过实时监控集群节点的负载，动态调整子树分布于不同节点，这是Ceph默认的方式。对于有大量数据迁移的场景不合适。</p><p>虽然元数据不适合通过Hash计算的方式，但是为什么CephFS的元数据仍然基于Hash方式？</p><p>答案是Ceph元数据访问并不是之间从RADOS获取，而是存在一个元数据缓存区，其中元数据基于动态子树分区的方式进行分配，元数据的存在哪里就不是那么重要。</p><p>在此基础，我们得到CephFS的架构图。</p><p><img src="/img/image-20210120231307670.png" alt=""></p><p>为了加快数据访问效率，MDS将热点数据缓存在内存中。</p><p>CephFS存在以下三种形式的客户端接口：</p><p>（1）CephFS Kernel Object</p><p>为内核态接口，它使用mount -t ceph命令将CephFS挂载在操作系统指定目录下。</p><p>（2）Ceph FUSE</p><p>FUSE的全称是Filesystem in Userspace，即用户空间文件系统。它完全是在内核态实现的。</p><p>（3）User Space Client</p><p>为直接通过客户端应用程序调用CephFS提供的文件系统接口，比如Hadoop调用CephFS提供的Java文件系统接口实现文件转储。</p><h2 id="S2-Ceph-MDS服务器特质"><a href="#S2-Ceph-MDS服务器特质" class="headerlink" title="$\S2 $  Ceph MDS服务器特质"></a>$\S2 $  Ceph MDS服务器特质</h2><p>​    当进程打开文件时，客户端将请求发送到MDS群集。  MDS遍历文件系统层次结构以将文件名转换为文件inode，其中包括唯一的inode编号，文件所有者，模式，大小以及其他每个文件元数据。 如果文件存在并且已授予访问权限，则MDS返回索引节点的数目，文件大小以及有关用于将文件数据映射到对象的分条策略的信息。  </p><p>​    MDS还可以向客户端发出一项功能，以指定允许哪些操作。 功能包括控制客户端读取，缓存读取，写入和缓冲区写入的能力和安全密钥。 随后的MDS参与文件I / O的工作仅限于管理功能，以保持文件一致性并获得适当的语义。</p><p>​    Ceph概括了一系列条带化策略，可将文件数据映射到一系列对象上。 为了避免文件分配元数据的任何需要，对象名称只需组合文件索引节点号和条带号即可。 然后使用CRUSH（见三部曲其一blog）将对象副本分配给OSD。 例如，如果一个或多个客户端打开文件进行读取访问，则MDS会授予他们读取和缓存文件内容的功能。 有了索引节点的数目，布局和文件大小，客户端可以命名和定位包含文件数据的所有对象，并直接从OSD集群读取。</p><h3 id="2-1客户端同步"><a href="#2-1客户端同步" class="headerlink" title="2.1客户端同步"></a>2.1客户端同步</h3><p>​    POSIX语义明智地要求读取反映先前写入的任何数据，并且写入是原子的（即，重叠的并发写入的结果将反映特定的发生顺序）。 当多个客户端同时使用多个写入器或混合使用读取器和写入器打开文件时，MDS将撤消以前发布的任何读取缓存和写入缓冲功能，从而强制该文件的客户端I / O同步。 也就是说，每个应用程序的读取或写入操作将一直阻塞，直到OSD确认为止，从而有效地将更新序列化和同步的负担与存储每个对象的OSD放在了一起。 当写入跨越对象边界时，客户端会在受影响的对象上获得排他锁（由其各自的OSD授予），并立即提交写入和解锁操作以实现所需的序列化。 对象锁类似地用于通过获取锁并异步刷新数据来掩盖大写操作的延迟。</p><h3 id="2-2-元数据动态性"><a href="#2-2-元数据动态性" class="headerlink" title="2.2 元数据动态性"></a>2.2 元数据动态性</h3><p>​    Ceph中的文件和目录元数据很小，几乎完全由目录条目（文件名）和索引节点（80字节）组成。 与常规文件系统不同，不需要文件分配元数据-使用索引节点号构造对象名称，并使用CRUSH将其分配给OSD。 这简化了元数据的工作量，并使我们的MDS可以有效地管理非常大的文件集，而与文件大小无关。<br>   我们的设计进一步寻求通过使用两层存储策略来最小化与元数据相关的磁盘I / O，并通过动态子树分区[30]来最大化本地性和缓存效率。</p><h3 id="2-3-元数据存储"><a href="#2-3-元数据存储" class="headerlink" title="2.3 元数据存储"></a><strong>2.3 元数据存储</strong></h3><p>   日志的设计使得在MDS发生故障的情况下，另一个节点可以快速重新扫描日志以恢复故障节点的内存高速缓存中的关键内容（用于快速启动） 并以此重新覆盖文件系统状态。</p><p>​    该策略提供了两全其美的优势：<strong>以高效（顺序）的方式将更新流式传输到磁盘，并大大减少了重写工作量，从而可以针对未来的读取优化磁盘上的长期存储布局访问</strong>。</p><p><img src="/img/image-20210120232711333.png" alt=""></p><blockquote><p>图1：Ceph根据当前工作负载将目录层次结构的子树动态映射到元数据服务器。 仅当多个目录成为热点时，它们才会在多个节点间以散列形式出现。</p></blockquote><h3 id="2-4-动态子树分区"><a href="#2-4-动态子树分区" class="headerlink" title="2.4 动态子树分区"></a>2.4 动态子树分区</h3><p>​    我们的主副本缓存策略使单个权威MDS负责管理缓存一致性并为任何给定的元数据片段序列化更新。 </p><p>​     目前有动态子树分区和静态子树分区两种方式。静态子树分区无法应对动态的工作负载和数据集，而散列则破坏了元数据的局部性和有效的元数据预取和存储的关键机会。</p><p>   Ceph的MDS集群基于动态子树分区策略，该策略可在一组节点上自适应地分层分配缓存的元数据，如图1所示。每个MDS使用计数器来度量目录层次结构中元数据的统计分布， 它随指数时间衰减。 <strong>任何操作都会将受影响的索引节点及其所有祖先上的计数器递增到根目录，为每个MDS提供一个加权树，描述最近的负载分布。 定期比较MDS负载值，并迁移目录层次结构的适当大小的子树以保持工作负载均匀分布。</strong></p><p>总结 MDS优势在于</p><ol><li>以较大块对象形式存储减少了元数据的数量；</li><li>每个MDS独立更新自己的日志；</li><li>动态子树分区实现了文件系统的动态负载均衡；</li><li>元数据复制保证了MDS节点之间缓存一致性和MDS失败和超载下，相应元数据被迁移到正常MDS上；</li><li>锁机制保证了元数据复制；</li><li>流量控制解决了大量不可预测的用户的请求。</li></ol><h2 id="S3-MDS实现原理"><a href="#S3-MDS实现原理" class="headerlink" title="$\S3$  MDS实现原理"></a>$\S3$  MDS实现原理</h2><h3 id="3-1-元数据与Object的关系"><a href="#3-1-元数据与Object的关系" class="headerlink" title="3.1 元数据与Object的关系"></a>3.1 元数据与Object的关系</h3><p>CephFS中将Inode编号设置为Object名称。而实际Object通常被设置为固定大小，如果Dentry大小大于这个大小，就需要多个object来保存。一个标准的Object集合是以相同Inode开头加上所有Stripe的Objects，它包括一个完整Dentry信息。</p><p>根目录默认Inode编号1，它存储目录下所有文件和目录的Dentry。查询文件的过程也是根据Inode编号从根目录搜索到叶子节点的过程。</p><p>需要注意的是，元数据不是直接写入到Object，而是先顺序写入到条带化、固定大小的日志中，再根据落盘政策写入到后端object。</p><pre><code class="hljs stata">rados -p <span class="hljs-keyword">meta</span> <span class="hljs-keyword">ls</span><span class="hljs-comment">//标准元数据集合</span></code></pre><h3 id="3-2-嵌入式Inode和Primary-Dentry"><a href="#3-2-嵌入式Inode和Primary-Dentry" class="headerlink" title="3.2 嵌入式Inode和Primary Dentry"></a>3.2 嵌入式Inode和Primary Dentry</h3><p>为了提升性能，文件系统通常将Inode放置再Dentry附近，这样读取Dentry时可以同时将Inode获取，这便是嵌入式Inode。</p><p>在没有硬链接时，Dentry就是Primary Dentry。一般情况下存储Dentry对应Inode只占用一个Object；超过一个Object大小的，其扩展的Object也是存储在一起，依次读就可以获得Dentry和Inode信息，将此信息缓存并使用LRU算法进行淘汰。</p><h3 id="3-3-Remote-Dentry和Anchor"><a href="#3-3-Remote-Dentry和Anchor" class="headerlink" title="3.3 Remote Dentry和Anchor"></a>3.3 Remote Dentry和Anchor</h3><p>当存在硬链接时，第一个指向Inode的Dentry被称为Primary Dentry，后续的被称为Remote Dentry。</p><p>为了访问Remote Dentry， 人们提出了Anchor，它包括Path，Inode，Parent，Ref.前三者显而易见，Ref是被Inode引用的次数（即2.4节提到的计数器）。当进行目录重命名时，可能会影响整个链上的Inode，此时就需要一个事务来保证整个链上相关的Inode同时进行更新，将旧的Ref计数减少，新的Ref计数删除。如果Ref为0，说明Inode已经没有硬链接，可以从Anchor表删除，对Dentry的增加修改同理。</p><h3 id="3-4-日志"><a href="#3-4-日志" class="headerlink" title="3.4 日志"></a>3.4 日志</h3><p>MDS日志使用的是混合模式：</p><p>1）更新首先会写入到MDS的日志中；</p><p>2）将有改变的元数据标记为“dirty”，并在MDS缓存中置为“pinned”。</p><p>3）最终修改会更新到具体元数据对象中，但同时也会做延时处理直到从日志中剪掉，这使得日志可以变得非常大（数百兆）。</p><p>引入日志是CephFS的巨大创新，它不但能获取延迟回写和分组提交等提升性能的方法。</p><p>而且还能减少Dentry的更新：1. 大多数负载，比如多次修改同一个地方，或者临时文件创建和删除，其实在日志并未创建；2. 在日志的生命周期内，对给定Dentry的所有更新都被有效提交，所有这些更新被一次性提交。</p><p>日志除了故障恢复还支持在恢复MDS时启用其缓存保存大量热元数据，热数据来自日志，避免从冷缓存（即从后端RADOS中随机读取到缓存中）开始的效率加载而导致的大量等待获取元数据的I/O，从而加快MDS恢复。</p><p>每一个MDS会维护一个日志系统，其日志保存了最近创建和修改，但还未提交到Object文件中的内容，日志被切分为固定大小且有序的Object。</p><p>日志条目，MDS用它来跟踪元数据的变化信息。日志条目使用Metablob来描述单个元数据更新，每一个Metablob包含一个或多个目录的Fragment ID、Dentry和Inode。</p><h3 id="3-5-MDS负载均衡的实现"><a href="#3-5-MDS负载均衡的实现" class="headerlink" title="3.5 MDS负载均衡的实现"></a>3.5 MDS负载均衡的实现</h3><p>许多分布式文件系统使用静态子树分区(Static Subtree Partition) 的方式来实现，即固定地将不同层目录树分配到不同的服务器上，这种方法需要人工调整，十分不灵活。</p><p>Ceph使用动态子树分区来实现横向扩展，动态子树能够根据负载状况来自动迁移目录树，同时为了实现多个MDS管理目录的负载而支持细粒度分区。Sage Weil重点研究了在MDS缓存中存储元数，并且具备伸缩性和容忍任意MDS节点异常。</p><h3 id="3-5-1-目录分区"><a href="#3-5-1-目录分区" class="headerlink" title="3.5.1 目录分区"></a>3.5.1 目录分区</h3><p>Ceph扩展了目录层次结构以允许单目录内容被分解为多个片段，称为Fragments。因为Inode和Fragments是一对多的关系，它存储在目录Inode的FragTree结构中，它基于一个内部顶点开始进行2的N次幂分割。如下图，目录树被分割为一个或者多个Fragments，其中树叶是单独的Fragments。</p><p><img src="/img/image-20210123211806521.png" alt="image-20210123211806521" style="zoom:67%;" /></p><p>​    每一个Fragments都通过bitmask值来进行描述，类似ip和掩码。通过哈希文件和在FragTree中查找结果值，来实现目录Inode到Fragments 的映射。由于子树元数据被定义在一组目录Fragment中，所以可以通过在MDS之间迁移Fragment来实现负载均衡，任何Fragments在变大或者繁忙时都能分裂为2^n个子fragment。</p><h3 id="3-5-2-子树分区"><a href="#3-5-2-子树分区" class="headerlink" title="3.5.2 子树分区"></a>3.5.2 子树分区</h3><p>​    Ceph支持在MDS集群中，任意和自适应的对子树进行分区。在某些情况下，诸如在同一个目录下有多个文件是热点对象，目录定义子树的方式无法进行负载分离，但Fragment的分割功能允许将这些热点文件进行动态分离。</p><p>​    根目录所在的MDS被标记为MDS-0，其它的MDS则根据当前整个集群元数据的负载进行子树分区。下图展现了MDS的缓存结构：</p><p><img src="../img/image-20210124193737077.png" alt="image-20210124193737077" style="zoom:67%;" /></p><h3 id="3-5-3-元数据复制"><a href="#3-5-3-元数据复制" class="headerlink" title="3.5.3 元数据复制"></a>3.5.3 元数据复制</h3><p>元数据复制的目的在于1. 保证各MDS节点缓存之间的一致性；MDS之间进行元数据复制操作，从而当MDS失败或者负载过重时能将元数据复制到其它正常的MDS上。</p><h3 id="3-5-4-锁机制"><a href="#3-5-4-锁机制" class="headerlink" title="3.5.4 锁机制"></a>3.5.4 锁机制</h3><p>每个Inode有5种锁状态，每一个控制不同的相关字段，例如：link计数和anchor状态字段，文件所有者模式字段、文件size、文件mtime和fragment字段。</p><p>总结一下，MDS负载均衡的实现原理。每个MDS会监视统计Inode和Fragment在缓存中的热度。每个Inode会从读和写来统计热度，而fragment会另外统计readdir操作情况、元数据获取频率、写入到对象存储的频率来统计热度。</p><p>在客户端请求时，受影响的元数据计数器会增加，元数据祖先也会受到影响，反过来又影响到复制和迁移的策略。MDS节点之间会定时分析它们的负载水平。如果某个节点负载过高，它将根据热度统计计数器来选择合适的子树进行迁移。</p><p>关于<strong>迁移</strong>，首先，目的MDS将所有需要迁移的子树元数据副本导入进来，然后源MDS通过日志导出事件提交迁移。在源MDS迁移之前，任何其他MDS会接收到要复制子树的元数据的信息，以此来获取被迁移子树的元数据信息。</p><h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><p>设想有成千上万的客户端想访问任何集群中存储的元数据，如果它们集中在一个MDS，那么很难有效的处理请求。理想的情形是 <strong>对非频繁访问的元数据之间到权威MDS获取，而频繁访问的条目分发到多个MDS中。</strong></p><p>这样做的关键在于客户端缓存了访问MDS的记录。首先利用客户端开始查询位置元数据的分布情况，然后再客户端访问后会收到MDS回复，即未来获取元数据的MDS编号。对非频繁访问的元数据之间到权威MDS获取，而频繁访问的条目则MDS集群会告知客户端随机到所有MDS中去获取，这样就实现了客户端访问MDS的流量控制。</p><h2 id="S4-MDS故障恢复"><a href="#S4-MDS故障恢复" class="headerlink" title="$\S4$ MDS故障恢复"></a>$\S4$ MDS故障恢复</h2><p>Ceph MDS元数据基于日志进行故障恢复。日志以segments的方式划分记录，并以子树事件作为segments开始部分，子树事件用于描述MDS在这个时间点对哪些权威子树进行了更改、新增操作。</p><p>在日志需要一个新的存储对象来保存新的修改时，Segment会被立即创建，新创建的Segment同样也会被链接到列表管理。当日志空间不够，需要修剪Segment时，则删除整个关联元数据对象Segment，以回收磁盘空间。由于Segment通过链接列表管理，因此MDS通过简单的遍历就可以找到所有相关的Segment，以最小的开销来修剪它的日志。</p><h3 id="4-1-故障检测"><a href="#4-1-故障检测" class="headerlink" title="4.1 故障检测"></a>4.1 故障检测</h3><p>每一个MDS会定期将心跳信息发送给集群的主Monitor。如果一个MDS超过规定时间未被检测到，会被声明为Down。如果MDS与Monitor交互中没有受到反馈，则会将自己置为无效状态。</p><h3 id="4-2-MDS恢复流程"><a href="#4-2-MDS恢复流程" class="headerlink" title="4.2 MDS恢复流程"></a>4.2 MDS恢复流程</h3><p>MDS利用RADOS作为共享存储后端，如果一个MDS被标记为Down，那么只需要在另外一个节点上启用新的MDS就可以恢复，包括四个节点，Replay、Resolve、Reconnect、Rejoin。</p><p>（1）Replay</p><p>这是日志回放阶段，它开始于日志最后一个截断点，每一个日志事件都会进行有序读取，并通过调用replay()方法恢复其状态。下一步进入Resolve状态。</p><p>（2）Resolve</p><p>这个阶段主要工作是解决跨多个MDS出现权威元数据分歧的场景。每个恢复MDS向其它的MDS广播Resolve信息，包括权威子树信息、失败是导入未知位置子树信息、从属节点向目标节点发起 更新请求等。</p><p>（3）Reconnected</p><p>恢复中MDS与之前的客户端重新建立链接，并且需要查询之前客户端发布的文件句柄、重新在MDS缓存中创建一致性功能和锁状态。</p><p>（4）Rejoin</p><p>最后阶段是恢复分布式缓存和锁状态。恢复中的MDS会发送弱Rejoin信息到所有MDS节点上，告诉其它节点本MDS恢复了哪些MDS信息；而正常MDS会发送强Rejoin信息到恢复节点，即自己拥有哪些元数据副本信息以及正确的锁状态信息。</p><hr><h1 id="部署和操作CephFS"><a href="#部署和操作CephFS" class="headerlink" title="部署和操作CephFS"></a>部署和操作CephFS</h1><p>一个Ceph文件系统至少需要两个RADOS池，一个用于数据，另一个用于元数据。配置这些池时，您可以考虑：</p><ul><li>对元数据池使用更高的<strong>复制级别</strong>，因为此池中的任何数据丢失都可能导致整个文件系统无法访问。</li><li>对元数据池使用较低延迟的存储（例如SSD），因为这将直接影响在客户端上观察到的文件系统操作的延迟。</li><li>用于创建文件系统的数据池是“默认”数据池，并且是用于存储所有inode追溯信息的位置，用于硬链接管理和灾难恢复。因此，在CephFS中创建的所有inode在默认数据池中至少具有一个对象。如果为文件系统计划了擦除编码的池，通常最好对默认数据池使用复制池，以提高小对象的读写性能以更新回溯。另外，可以添加另一个可擦除编码的数据池（另请参见<a href="https://docs.ceph.com/en/latest/rados/operations/erasure-code/#ecpool">擦除代码</a>），该数据池可用于目录和文件的整个层次结构（另请参见<a href="https://docs.ceph.com/en/latest/cephfs/file-layouts/#file-layouts">文件布局</a>）。</li></ul><p>请参阅<a href="https://docs.ceph.com/en/latest/rados/operations/pools/">池</a>以了解有关管理池的更多信息。例如，要使用文件系统使用默认设置创建两个池，可以运行以下命令：</p><pre><code class="hljs routeros">$ ceph osd<span class="hljs-built_in"> pool </span>create cephfs_data$ ceph osd<span class="hljs-built_in"> pool </span>create cephfs_metadata</code></pre><p>通常，元数据池最多具有几GB的数据。因此，通常建议使用较小的PG数量。实际上，大型群集通常使用64或128。</p><div class="note note-warning">            <p>注意:</p><p>文件系统，元数据池和数据池的名称在集合[a-zA-Z0-9_-。]中只能包含字符。</p>          </div><h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><p>创建池后，可以使用以下命令启用文件系统：<code>fs new</code></p><pre><code class="hljs vim">$ ceph fs <span class="hljs-keyword">new</span> <span class="hljs-symbol">&lt;fs_name&gt;</span> <span class="hljs-symbol">&lt;metadata&gt;</span> <span class="hljs-symbol">&lt;data&gt;</span></code></pre><p>例如：</p><pre><code class="hljs groovy">$ ceph fs <span class="hljs-keyword">new</span> cephfs cephfs_metadata cephfs_data$ ceph fs ls<span class="hljs-attr">name:</span> cephfs, metadata <span class="hljs-attr">pool:</span> cephfs_metadata, data <span class="hljs-attr">pools:</span> [cephfs_data ]</code></pre><p>创建文件系统后，您的MDS将能够进入<em>活动</em>状态。例如，在单个MDS系统中：</p><pre><code class="hljs angelscript">$ ceph mds statcephfs<span class="hljs-number">-1</span>/<span class="hljs-number">1</span>/<span class="hljs-number">1</span> up &#123;<span class="hljs-number">0</span>=a=up:active&#125;</code></pre><p>创建文件系统并且MDS处于活动状态之后，就可以挂载文件系统了。如果创建了多个文件系统，则将选择安装时使用的文件系统。</p><blockquote><ul><li><a href="https://docs.ceph.com/en/latest/cephfs/mount-using-kernel-driver">装载CephFS</a></li><li><a href="https://docs.ceph.com/en/latest/cephfs/mount-using-fuse">将CephFS挂载为FUSE</a></li></ul></blockquote><p>如果创建了多个文件系统，并且客户端在挂载时未指定文件系统，则可以使用ceph fs set-default命令控制它们将看到的文件系统。</p><h3 id="向文件系统添加数据池"><a href="#向文件系统添加数据池" class="headerlink" title="向文件系统添加数据池"></a>向文件系统添加数据池</h3><p>请参阅<a href="https://docs.ceph.com/en/latest/cephfs/file-layouts/#adding-data-pool-to-file-system">将数据池添加到文件系统</a>。</p><h2 id="在CEPHFS中使用擦除编码池"><a href="#在CEPHFS中使用擦除编码池" class="headerlink" title="在CEPHFS中使用擦除编码池"></a>在CEPHFS中使用擦除编码池</h2><p>您可以将擦除编码池用作CephFS数据池，只要它们启用了覆盖即可，操作如下：</p><pre><code class="hljs routeros">ceph osd<span class="hljs-built_in"> pool </span><span class="hljs-builtin-name">set</span> my_ec_pool allow_ec_overwrites <span class="hljs-literal">true</span></code></pre><p>请注意，仅当OSDS与BlueStore后端一起使用时才支持EC覆盖。</p><p>您不得将擦除编码池用作CephFS元数据池，因为CephFS元数据是使用EC池无法存储的RADOS <em>OMAP</em>数据结构存储的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ceph分布式文件系统：CephFS&quot;&gt;&lt;a href=&quot;#Ceph分布式文件系统：CephFS&quot; class=&quot;headerlink&quot; title=&quot;Ceph分布式文件系统：CephFS&quot;&gt;&lt;/a&gt;Ceph分布式文件系统：&lt;em&gt;CephFS&lt;/em&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="ceph" scheme="http://durantthorvalds.top/categories/ceph/"/>
    
    <category term="分布式存储" scheme="http://durantthorvalds.top/categories/ceph/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="系统架构" scheme="http://durantthorvalds.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="ceph" scheme="http://durantthorvalds.top/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>Csim 通用型仿真工具</title>
    <link href="http://durantthorvalds.top/2021/01/17/%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7Csim/"/>
    <id>http://durantthorvalds.top/2021/01/17/%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7Csim/</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2021-02-08T09:02:07.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Csim-通用型仿真工具"><a href="#Csim-通用型仿真工具" class="headerlink" title="Csim 通用型仿真工具"></a>Csim 通用型仿真工具</h1><blockquote><p>导师不久前给笔者安排了一个很不同寻常的任务，在一个拥有大量磁盘的主机中，仿真其I/O使用情况。</p><p>因此笔者开始学习Csim。将学习历程记录在此。</p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>什么是CSIM？</p><p>CSIM是通用目的的系统仿真环境：</p><ul><li>离散事件仿真——包括时间和序列</li><li>层次化框图仿真</li><li>模型函数均用C语言表示。</li><li>模型集成，包括并发（concurrency）和时间协调。</li></ul><p>它拥有大量模型库，可以快速建模以及测试。支持多种抽象层次结构。</p><h2 id="1-1-模型的描述"><a href="#1-1-模型的描述" class="headerlink" title="1.1 模型的描述"></a>1.1 模型的描述</h2><p>有三个维度的信息可以描述功能，结构和时间。</p><p><strong>结构</strong>：实例化模型，展示细节。</p><p><strong>功能</strong>：展示模型的功能，通过公式或者代码表述。</p><p><strong>时间</strong>：时延，速率，关系，序列…</p><h2 id="1-2-一般的仿真流程"><a href="#1-2-一般的仿真流程" class="headerlink" title="1.2 一般的仿真流程"></a>1.2 一般的仿真流程</h2><p><img src="../img/csim1.png" style="zoom:67%;" /></p><p>我们首先要配置模型需要使用的资源，包括两个部分：设备（单服务器，多服务器），存储单元。</p><p>它们通常倍声明为全局变量，在使用之前声明。</p><p>之后我们就要设计仿真的进程了：</p><ul><li>第一个进程一般是<code>sim</code>，如果它没有完成，我们就需要提供<code>main</code>进程。<code>sim</code>一般被两个参数调用<code>argc</code>和<code>argv</code>。</li><li>一个CSIM20进程是一个执行<code>create</code>的C进程。进程之间没有预定义的关系，一个进程随时可以打断另一个进程，除了<code>sim</code>只能被打断一次</li><li>CSIM20进程不是UNIX进程，它更像是一个线程或者轻量级进程，并且不能返回值。</li><li>一个CSIM20进程可以通过事件、邮箱、存储块来与其它进程同步。</li></ul><h2 id="1-3-安装和使用CSIM"><a href="#1-3-安装和使用CSIM" class="headerlink" title="1.3 安装和使用CSIM"></a>1.3 安装和使用CSIM</h2><p>笔者下载的是Mesquite公司的CSIM20。一般下载完成后就一个文件夹<code>csim20_linux</code>，里面有<code>Documentation</code>和<code>Linux</code>，里面有32位和64位的分别对应gcc，g++的库。比如我们进入<code>/csim20_linux/Linux/64-bit/gcc</code>.</p><pre><code class="hljs crystal">csim.<span class="hljs-keyword">out</span>  ex2.c  gensys.ccsim.gcc  ex1.c     ex3.c  <span class="hljs-class"><span class="hljs-keyword">lib</span></span></code></pre><p>然后在lib下面有</p><pre><code class="hljs css"><span class="hljs-selector-tag">csim</span><span class="hljs-selector-class">.gcc</span><span class="hljs-selector-class">.a</span>  <span class="hljs-selector-tag">csim</span><span class="hljs-selector-class">.h</span></code></pre><p>我们一般先运行<code>ex1.c</code>进行测试：</p><pre><code class="hljs jboss-cli"><span class="hljs-string">./csim.gcc</span> ex1.c</code></pre><p>如果你没有遇到错误说明一切正常。但如果像笔者一样遇到错误：</p><pre><code class="hljs crystal">/usr/bin/<span class="hljs-symbol">ld:</span> <span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">csim</span>.<span class="hljs-title">gcc</span>.<span class="hljs-title">a</span>(<span class="hljs-title">event</span>.<span class="hljs-title">o</span>): <span class="hljs-title">relocation</span> <span class="hljs-title">R_X86_64_32</span> <span class="hljs-title">against</span> `.<span class="hljs-title">rodata</span>&#x27; <span class="hljs-title">can</span> <span class="hljs-title">not</span> <span class="hljs-title">be</span> <span class="hljs-title">used</span> <span class="hljs-title">when</span> <span class="hljs-title">making</span> <span class="hljs-title">a</span> <span class="hljs-title">PIE</span> <span class="hljs-title">object</span>;</span> recompile <span class="hljs-keyword">with</span> -fPIE</code></pre><p>那么需要把编译命令需要改为：</p><pre><code class="hljs stylus">./csim<span class="hljs-selector-class">.gcc</span> ex1<span class="hljs-selector-class">.c</span> -no-pie./<span class="hljs-selector-tag">a</span>.out</code></pre><p>即可编译成功，<code>-no-pie</code>这里的意思是不生成fPIE可执行文件,详见<a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html。">https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html。</a></p><pre><code class="hljs yaml">             <span class="hljs-string">CSIM</span> <span class="hljs-string">Simulation</span> <span class="hljs-string">Report</span> <span class="hljs-string">(Version</span> <span class="hljs-number">20.0</span> <span class="hljs-string">for</span> <span class="hljs-string">Linux</span> <span class="hljs-string">x86-64)</span>                                  <span class="hljs-string">M/M/1</span> <span class="hljs-string">Queue</span>                           <span class="hljs-string">Wed</span> <span class="hljs-string">Feb</span>  <span class="hljs-number">3</span> <span class="hljs-number">20</span><span class="hljs-string">:43:52</span> <span class="hljs-number">2021</span>                     <span class="hljs-attr">Ending simulation time:</span>     <span class="hljs-number">10041.661</span>                     <span class="hljs-attr">Elapsed simulation time:</span>    <span class="hljs-number">10041.661</span>                     <span class="hljs-string">CPU</span> <span class="hljs-string">time</span> <span class="hljs-string">used</span> <span class="hljs-string">(seconds):</span>        <span class="hljs-number">0.003</span><span class="hljs-string">FACILITY</span> <span class="hljs-string">SUMMARY</span> <span class="hljs-string">facility</span>     <span class="hljs-string">service</span>    <span class="hljs-string">service</span>          <span class="hljs-string">through-</span>    <span class="hljs-string">queue</span>     <span class="hljs-string">response</span>   <span class="hljs-string">compl</span><span class="hljs-string">name</span>           <span class="hljs-string">disc</span>      <span class="hljs-string">time</span>    <span class="hljs-string">util.</span>     <span class="hljs-string">put</span>       <span class="hljs-string">length</span>      <span class="hljs-string">time</span>     <span class="hljs-string">count</span><span class="hljs-string">--------------------------------------------------------------------------------</span><span class="hljs-string">facility</span>     <span class="hljs-string">fcfs</span>       <span class="hljs-number">0.99206</span>  <span class="hljs-number">0.494</span>    <span class="hljs-number">0.49793</span>    <span class="hljs-number">0.99059</span>    <span class="hljs-number">1.98943</span>     <span class="hljs-number">5000</span><span class="hljs-attr">TABLE 1:</span>  <span class="hljs-string">resp</span> <span class="hljs-string">tms</span>      <span class="hljs-string">minimum</span>         <span class="hljs-number">0.000145</span>          <span class="hljs-string">mean</span>                    <span class="hljs-number">1.989433</span>      <span class="hljs-string">maximum</span>        <span class="hljs-number">14.273079</span>          <span class="hljs-string">variance</span>                <span class="hljs-number">3.813342</span>      <span class="hljs-string">range</span>          <span class="hljs-number">14.272934</span>          <span class="hljs-string">standard</span> <span class="hljs-string">deviation</span>      <span class="hljs-number">1.952778</span>      <span class="hljs-string">observations</span>        <span class="hljs-number">5000          </span><span class="hljs-string">coefficient</span> <span class="hljs-string">of</span> <span class="hljs-string">var</span>      <span class="hljs-number">0.981575</span><span class="hljs-attr">QTABLE 1:</span>  <span class="hljs-string">num</span> <span class="hljs-string">in</span> <span class="hljs-string">sys</span>      <span class="hljs-string">initial</span>       <span class="hljs-number">0</span>      <span class="hljs-string">minimum</span>       <span class="hljs-number">0</span>      <span class="hljs-string">mean</span>                    <span class="hljs-number">0.990590</span>      <span class="hljs-string">final</span>         <span class="hljs-number">0</span>      <span class="hljs-string">maximum</span>      <span class="hljs-number">13</span>      <span class="hljs-string">variance</span>                <span class="hljs-number">1.937727</span>      <span class="hljs-string">entries</span>    <span class="hljs-number">5000      </span><span class="hljs-string">range</span>        <span class="hljs-number">13</span>      <span class="hljs-string">standard</span> <span class="hljs-string">deviation</span>      <span class="hljs-number">1.392022</span>      <span class="hljs-string">exits</span>      <span class="hljs-number">5000                           </span><span class="hljs-string">coeff</span> <span class="hljs-string">of</span> <span class="hljs-string">variation</span>      <span class="hljs-number">1.405246</span>                                             <span class="hljs-string">cumulative</span>        <span class="hljs-string">number</span>    <span class="hljs-string">total</span> <span class="hljs-string">time</span>    <span class="hljs-string">proportion</span>   <span class="hljs-string">proportion</span>             <span class="hljs-number">0</span>    <span class="hljs-number">5081.38161     </span><span class="hljs-number">0.506030</span>     <span class="hljs-number">0.506030</span>   <span class="hljs-string">********************</span>             <span class="hljs-number">1</span>    <span class="hljs-number">2426.95194     </span><span class="hljs-number">0.241688</span>     <span class="hljs-number">0.747718</span>   <span class="hljs-string">**********</span>                       <span class="hljs-number">2</span>    <span class="hljs-number">1238.22169     </span><span class="hljs-number">0.123308</span>     <span class="hljs-number">0.871027</span>   <span class="hljs-string">*****</span>                            <span class="hljs-number">3</span>     <span class="hljs-number">667.95025</span>     <span class="hljs-number">0.066518</span>     <span class="hljs-number">0.937545</span>   <span class="hljs-string">***</span>                              <span class="hljs-number">4</span>     <span class="hljs-number">350.00001</span>     <span class="hljs-number">0.034855</span>     <span class="hljs-number">0.972399</span>   <span class="hljs-string">*</span>                                <span class="hljs-number">5</span>     <span class="hljs-number">152.62571</span>     <span class="hljs-number">0.015199</span>     <span class="hljs-number">0.987599</span>   <span class="hljs-string">*</span>                                <span class="hljs-number">6</span>      <span class="hljs-number">69.33696</span>     <span class="hljs-number">0.006905</span>     <span class="hljs-number">0.994504</span>   <span class="hljs-string">.</span>             <span class="hljs-number">7</span>      <span class="hljs-number">25.09331</span>     <span class="hljs-number">0.002499</span>     <span class="hljs-number">0.997003</span>   <span class="hljs-string">.</span>             <span class="hljs-number">8</span>       <span class="hljs-number">9.84005</span>     <span class="hljs-number">0.000980</span>     <span class="hljs-number">0.997982</span>   <span class="hljs-string">.</span>             <span class="hljs-number">9</span>      <span class="hljs-number">10.69388</span>     <span class="hljs-number">0.001065</span>     <span class="hljs-number">0.999047</span>   <span class="hljs-string">.</span> <span class="hljs-string">&gt;=</span>         <span class="hljs-number">10</span>       <span class="hljs-number">9.56521</span>     <span class="hljs-number">0.000953</span>     <span class="hljs-number">1.000000</span>   <span class="hljs-string">.</span><span class="hljs-string">M/M/1</span> <span class="hljs-string">Theoretical</span> <span class="hljs-string">Results</span><span class="hljs-string">Inter-arrival</span> <span class="hljs-string">time</span> <span class="hljs-string">=</span>      <span class="hljs-number">2.000</span><span class="hljs-string">Service</span> <span class="hljs-string">time</span>       <span class="hljs-string">=</span>      <span class="hljs-number">1.000</span><span class="hljs-string">Utilization</span>        <span class="hljs-string">=</span>      <span class="hljs-number">0.500</span><span class="hljs-string">Throughput</span> <span class="hljs-string">rate</span>    <span class="hljs-string">=</span>      <span class="hljs-number">0.500</span><span class="hljs-string">Mn</span> <span class="hljs-string">nbr</span> <span class="hljs-string">at</span> <span class="hljs-string">queue</span>    <span class="hljs-string">=</span>      <span class="hljs-number">1.000</span><span class="hljs-string">Mn</span> <span class="hljs-string">queue</span> <span class="hljs-string">length</span>    <span class="hljs-string">=</span>      <span class="hljs-number">0.500</span><span class="hljs-string">Response</span> <span class="hljs-string">time</span>      <span class="hljs-string">=</span>      <span class="hljs-number">2.000</span><span class="hljs-string">Time</span> <span class="hljs-string">in</span> <span class="hljs-string">queue</span>      <span class="hljs-string">=</span>      <span class="hljs-number">1.000</span><span class="hljs-string">CSIM</span> <span class="hljs-string">MODEL</span> <span class="hljs-string">STATISTICS</span><span class="hljs-string">CPU</span> <span class="hljs-string">time</span> <span class="hljs-string">used</span> <span class="hljs-string">(sec):</span>         <span class="hljs-number">0.003</span> <span class="hljs-attr">Events processed:</span>            <span class="hljs-number">17485</span> <span class="hljs-attr">Memory allocated:</span>            <span class="hljs-number">23026</span> <span class="hljs-string">bytes</span> <span class="hljs-attr">Calls to malloc:</span>                <span class="hljs-number">43</span> <span class="hljs-string">Processes</span>      <span class="hljs-attr">Started:</span>                 <span class="hljs-number">5001</span>      <span class="hljs-attr">Saved:</span>                   <span class="hljs-number">9105</span>      <span class="hljs-attr">Terminated:</span>              <span class="hljs-number">5000</span>      <span class="hljs-attr">High water mark:</span>           <span class="hljs-number">14</span> <span class="hljs-string">Stacks</span>      <span class="hljs-attr">Allocated:</span>               <span class="hljs-number">5001</span>      <span class="hljs-attr">High water mark:</span>          <span class="hljs-number">318</span> <span class="hljs-string">words</span>      <span class="hljs-attr">Average:</span>                   <span class="hljs-number">22</span> <span class="hljs-string">words</span>      <span class="hljs-attr">Maximum:</span>                   <span class="hljs-number">23</span> <span class="hljs-string">words</span>      <span class="hljs-attr">Current:</span>                   <span class="hljs-number">19</span> <span class="hljs-string">words</span></code></pre><p>这是一个仿真报告，里面的参数我们之后详细讲解。</p><h2 id="1-4-测试程序的方法"><a href="#1-4-测试程序的方法" class="headerlink" title="1.4 测试程序的方法"></a>1.4 测试程序的方法</h2><p>有三种方式可以完成调试：</p><ul><li>我们可以用<code>printf</code>打印我们感兴趣的变量。</li><li>事件追踪（event trace）可以对各个进程的行为进行描述。通过在CLI添加<code>-T</code>指令，或者在程序内部添加<code>trace-on</code></li></ul><p>或<code>traceoff</code>指令来开启或关闭。</p><ul><li>通过<code>dump_status</code>打印资源和进程的状态。</li></ul><p>CSIM20库的例子将输出打印到三个文件：1. <code>set_output_file</code>: 报告和状态信息，2. <code>set_trace_file</code>: 事件追踪，3. <code>set_error_file</code>: 错误信息。</p><hr><h1 id="C-编程案例"><a href="#C-编程案例" class="headerlink" title="C++编程案例"></a>C++编程案例</h1><ol><li>单服务队列模型</li></ol><p>最基本的仿真模型是单个服务器，并与到达的客户排队。 在某些限制下，这是众所周知的M / M / 1队列。 在此模型的CSIM 20版本中，存在由单个服务器和单个队列组成的功能。 此外，还有客户来源。 当客户到达时，如果服务器闲置（未使用），它将抓住（使用）服务器；如果服务器已经繁忙（正在使用），它将加入等待客户的队列。 当一个客户离开服务器时，队列中的下一个客户开始使用该服务器。<br>   此模型中的关键参数是：</p><ul><li>客户到达之间的时间间隔</li><li>服务器使用间隔</li></ul><p>该模型输出的结果是：</p><ul><li>客户的平均应答时间；</li><li>客户吞吐量（单位时间服务的客户数）；</li><li><p>服务器使用率（服务器忙的时间的占比）；</p></li><li><p>平均队列的长度。</p><p><img src="../img/csim2.png" alt=""></p></li></ul><pre><code class="hljs cpp"><span class="hljs-comment">//singleCS.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lib/cpp.h&quot;</span></span>facility *f;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">customer</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;create(<span class="hljs-string">&quot;custumer&quot;</span>);f-&gt;use(exponential(<span class="hljs-number">0.5</span>));&#125;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sim</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;create(<span class="hljs-string">&quot;sim&quot;</span>);f = <span class="hljs-keyword">new</span> facility(<span class="hljs-string">&quot;f&quot;</span>);<span class="hljs-keyword">while</span>(simtime() &lt; <span class="hljs-number">5000.0</span>)&#123;hold(exponential(<span class="hljs-number">1.0</span>));customer();&#125;report();&#125;</code></pre><pre><code class="hljs jboss-cli"><span class="hljs-string">./csim.gpp</span> singleCS.cpp -no-pie -o singleCS<span class="hljs-string">./singleCS.out</span></code></pre><p>输出结果如下</p><pre><code class="hljs routeros">           C++/CSIM Simulation Report (Version 20.0 <span class="hljs-keyword">for</span> Linux x86-64)                           Wed Feb  3 21:00:35 2021                     Ending simulation time:      5000.234                     Elapsed simulation time:     5000.234                     CPU time used (seconds):        0.004FACILITY SUMMARY facility    <span class="hljs-built_in"> service </span>  <span class="hljs-built_in"> service </span>         through-   <span class="hljs-built_in"> queue </span>    response   complname           disc      time    util.     put       length      time     count--------------------------------------------------------------------------------f            fcfs       0.49398  0.488    0.98815    0.99145    1.00334     4941</code></pre><p>我们可以在报告中看到，设备名称，服务描述，服务时间，使用率，吞吐量，队列长度，响应时间，完成计数等表项。</p><p>在这个例子中，我们有两个主要的进程：</p><ul><li>主要的<code>sim</code>进程，初始化模型并且保证客户来自于不同的间隔；</li><li><code>customer</code>进程，也就是f。</li></ul><p><code>create</code>的作用在于，建立将语句作为独立的，准备运行的过程执行的过程，以及将控制权返回给调用过程。</p><ul><li>一个设备由”new facility()” 创建；</li><li>CSIM变量<code>clock</code>包含当前的仿真时间。时间是double精度的。</li><li>“ hold”语句将执行给定的时间。<code>hold(exponential(1.0))</code> 报表对客户到达之间的时间间隔进行建模。</li><li>在许多仿真模型中，指定具有概率分布的时间间隔序列是适当的。 在M / M / 1队列中，从负指数分布“采样”到达间隔和服务间隔。 在CSIM中，<code>exponential()</code>函数提供了此类示例。</li><li>通过<code>f-&gt;use(exponential(0.0))</code>语句对设施的使用进行建模（在这种情况下，所使用的设备为f）</li><li>此外我们可以列一个时间表，看看每个进程在每个时间点到底在做什么：</li></ul><p><img src="../img/image-20210203231334076.png" alt="image-20210203231334076"></p><h2 id="CSIM的目标"><a href="#CSIM的目标" class="headerlink" title="CSIM的目标"></a>CSIM的目标</h2><ul><li><p>进程-用于对工作负载，客户端和服务器或系统的任何其他活动组件的元素进行建模</p></li><li><p>设备-用于对由流程占用（使用）的资源进行建模</p></li><li>存储-用于对部分分配给流程的资源进行建模 </li><li>缓冲区-用于对有限容量的缓冲区进行建模</li><li>事件-用于同步和控制进程之间的交互</li><li>邮箱-用于在进程之间交换信息</li><li>表，Qtables，计量器和框-用于收集显式统计信息（注意： 设施和存储块的使用情况会自动收集）</li><li>流程类-用于隔离设施使用情况统计信息</li><li>随机数流-用于根据指定的概率分布生成多个样本流</li></ul><h2 id="CSIM流程控制"><a href="#CSIM流程控制" class="headerlink" title="CSIM流程控制"></a>CSIM流程控制</h2><p>理解CSIM流程控制非常的重要，当程序调用<code>create()</code>指令，下列事件会发生：</p><ul><li>一个对应于程序的进程控制块被创建并且被放置于“下一个事件表”</li><li>控制权随即被返回给进程</li><li>只有父进程声明<code>hold</code>，新进程才会执行。</li></ul><p>关于设备（Facility）</p><h2 id="1-设施"><a href="#1-设施" class="headerlink" title="1 设施"></a>1 设施</h2><p>Facility可以被定义为：</p><ul><li>单服务器设备（同一时间只能服务一个进程）</li><li>多服务器设备（同一时间能服务n个进程）</li><li>一个但服务器设备数组</li></ul><p>（a）声明一个单服务器</p><pre><code class="hljs lisp">facility *single_server<span class="hljs-comment">;</span>single_server = new facility(<span class="hljs-string">&quot;nf&quot;</span>)<span class="hljs-comment">;</span>single_server-&gt;use(<span class="hljs-name">service_time</span>)<span class="hljs-comment">;//记录服务时间</span>single_server-&gt;reserve()<span class="hljs-comment">;</span>hold(<span class="hljs-name">service_time</span>)<span class="hljs-comment">;</span>single_server-&gt;release()<span class="hljs-comment">;</span></code></pre><p>  进程按其进程优先级的顺序排列在等待进程的队列中，其中头部优先级最高。优先级相同时采用FIFO。</p><p>（b）再比如定义多服务器：</p>  <pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> NUM_SERVER = <span class="hljs-number">10</span>facility_ms* multi_server = <span class="hljs-keyword">new</span> facility_ms(<span class="hljs-string">&quot;ms&quot;</span>,NUM_SERVER);multi_server-&gt;use(service_time);</code></pre><p>（c）单服务器数组</p><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> NUM_SERVER = <span class="hljs-number">10</span>facility_set* facs = <span class="hljs-keyword">new</span> facility_set(<span class="hljs-string">&quot;facs&quot;</span>,NUM_SERVER);(*facs)[i]-&gt;use(service_time);<span class="hljs-comment">//指定使用下标i的服务器</span></code></pre><p>（d）给定的时间预留</p><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> TIME_OUT = <span class="hljs-number">5.0</span>;st = single_server-&gt;time_reserve(TIME_OUT);<span class="hljs-keyword">if</span>(st!=TIME_OUT)&#123;<span class="hljs-comment">//如果设备被预留，就仿真客户service-time时间</span>hold(service_time);single_server-&gt;release();&#125;<span class="hljs-keyword">else</span>&#123;...&#125;</code></pre><p>（e）使用同步的facility</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PHASE = <span class="hljs-number">0.5</span> <span class="hljs-comment">//时钟相位</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PERIOD = <span class="hljs-number">1.0</span> <span class="hljs-comment">//时钟的周期</span>facility *bus = <span class="hljs-keyword">new</span> facility(<span class="hljs-string">&quot;bus&quot;</span>);bus-&gt;synchronize(PHASE,PERIIOD);bus-&gt;reserve();bus-&gt;release();</code></pre><p>（f）定义设施的抢占式恢复服务规则</p><pre><code class="hljs abnf">facility* cpu<span class="hljs-comment">;</span><span class="hljs-attribute">cpu</span> = new facility(<span class="hljs-string">&quot;cpu&quot;</span>)<span class="hljs-comment">;</span>cpu-&gt;set_servicefunc(pre_res)<span class="hljs-comment">;</span><span class="hljs-attribute">priprity</span> = <span class="hljs-number">100</span><span class="hljs-comment">;//设置高优先级以抢占低优先级</span>cpu-&gt;use(service_time)<span class="hljs-comment">;</span></code></pre><p>重要的是要注意，当在设施中使用调度顺序而不是FIFO时，则“ use（）”方法是使用设施的唯一方法。 这意味着进程无法保留此类设施，然后执行其他操作而不使用该设施。</p><h2 id="2-存储"><a href="#2-存储" class="headerlink" title="2 存储"></a>2 存储</h2><p>存储包括一个计数器，用于统计可用资源，以及一个队列，存储需要资源的请求。</p><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> STORE_AMT = <span class="hljs-number">100</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_STORES = <span class="hljs-number">5</span>;storage *mem;mem = <span class="hljs-keyword">new</span> storage(<span class="hljs-string">&quot;mem&quot;</span>, STORE_AMT);<span class="hljs-comment">//amt is to be allocated</span>mem-&gt;alloc(amt);<span class="hljs-comment">//unallocated</span>mem-&gt;alloc(amt);storage_set* mems;mems = <span class="hljs-keyword">new</span> storage_set(<span class="hljs-string">&quot;mems&quot;</span>,STORE_AMT,NUM_STORES);(*mems)[<span class="hljs-number">0</span>].alloc(amt);<span class="hljs-comment">//在指定时间分配资源</span>st = mem-&gt;timed_alloc(amt,<span class="hljs-number">1.0</span>);<span class="hljs-keyword">if</span>(st != TIMED_OUT)&#123;<span class="hljs-comment">//normal process</span>&#125;</code></pre><h2 id="3-缓冲器"><a href="#3-缓冲器" class="headerlink" title="3 缓冲器"></a>3 缓冲器</h2><p>缓冲器由一个计数器（指示缓冲区中的请求数量）和两个队列组成，一个队列用于等待从缓冲区中获取令牌的进程，另一个队列用于等待空间放入（或返回）到缓冲区。</p><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> BUFFER_AMT = <span class="hljs-number">100</span>;<span class="hljs-built_in">buffer</span>* buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">buffer</span>(<span class="hljs-string">&quot;buffer&quot;</span>, BUFFER_AMT);buff-&gt;<span class="hljs-built_in">get</span>(amt);buff-&gt;<span class="hljs-built_in">put</span>(amt);</code></pre><h2 id="4-事件"><a href="#4-事件" class="headerlink" title="4 事件"></a>4 事件</h2><p>事件被用于同步和控制不同的进程。事件（event）有两种状态：发生（OCC）和不发生（NOT_OCC），一个进程可以等待事件发生。</p><pre><code class="hljs xl">event *ev;ev = new event(<span class="hljs-string">&quot;ev&quot;</span>);<span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span>wait();<span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span>queue();<span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span>set();<span class="hljs-comment">//to monitor an event</span><span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span>monitor();event_set *evs;<span class="hljs-function"><span class="hljs-title">i</span> = ev_arr-&gt;</span>queue_any();</code></pre><h2 id="5-信箱"><a href="#5-信箱" class="headerlink" title="5 信箱"></a>5 信箱</h2><p>信箱运行CSIM进程之间同步交换数据。信箱包括两个队列，分别放置未接收的信息和等待的进程。在任意时间至少有一个队列是空的。</p><p>消息可以是单个整数，也可以是指向其他数据对象的指针。 如果某个进程发送了一个指针，则该进程负责维护被引用数据的完整性，直到接收和处理该数据为止。</p><pre><code class="hljs xl"><span class="hljs-comment">//声明创建一个信箱</span>mailbox * mb;long msg_r, msg_s;mb = new mailbox(<span class="hljs-string">&quot;mb&quot;</span>);<span class="hljs-function"><span class="hljs-title">mb</span>-&gt;</span>receive(&amp;msg_r);<span class="hljs-comment">//从信箱mb接收信息，这里是右值引用？</span><span class="hljs-function"><span class="hljs-title">mb</span>-&gt;</span>send(mb,msg_s);<span class="hljs-function"><span class="hljs-title">mb</span>-&gt;</span>monitor();<span class="hljs-comment">//声明信箱组</span>const long NUM_MBOXES = <span class="hljs-number">25</span>;mailbox_set *mbox_arr = new mailbox_set(<span class="hljs-string">&quot;mbox set&quot;</span>, NUM_MBOXES);<span class="hljs-function"><span class="hljs-title">i</span> = mbox_arr-&gt;</span>receieve_any(&amp;msg_r);(*mbox_arr)[<span class="hljs-number">3</span>].send(msg);<span class="hljs-function"><span class="hljs-title">st</span> = mbox_arr-&gt;</span>time_receieve_any(&amp;msg_r, <span class="hljs-number">1.0</span>);<span class="hljs-keyword">if</span>(st != TIME_OUT)<span class="hljs-comment">//发送消息，并且在对方接收之前一直等待</span><span class="hljs-function"><span class="hljs-title">mb</span>-&gt;</span>synchronize_send(msg);</code></pre><h2 id="6-Tables-amp-QTables"><a href="#6-Tables-amp-QTables" class="headerlink" title="6 Tables &amp; QTables"></a>6 Tables &amp; QTables</h2><p>Table，可以轻松的对不同数据进行统计。并且可以打印直方图，以及指定置信区间。</p><p>Qtable，记录状态变化（比如队列中的进程数），并且可以打印直方图，以及指定置信区间。</p><p>可以将表定义为永久性或非永久性。 永久表不受重置统计信息或重新运行模型的请求的影响，因此可以用于跨模型的多次运行收集数据。</p><pre><code class="hljs xl">table *tbl;tbl = new table(<span class="hljs-string">&quot;tbl&quot;</span>);<span class="hljs-function"><span class="hljs-title">tbl</span>-&gt;</span>add_histogram(<span class="hljs-number">10</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">20.0</span>);<span class="hljs-comment">//0-20,步长为2</span>t = clock;<span class="hljs-comment">//获取当前时间</span><span class="hljs-function"><span class="hljs-title">single_server</span>-&gt;</span>reserve();x = clock - t;<span class="hljs-function"><span class="hljs-title">tbl</span>-&gt;</span>calculate(x);qtable *qtbl;qtbl = new qtable(<span class="hljs-string">&quot;qtbl&quot;</span>);<span class="hljs-function"><span class="hljs-title">qtbl</span>-&gt;</span>add_histogram(<span class="hljs-number">20</span>,<span class="hljs-number">0</span>,<span class="hljs-number">20</span>);<span class="hljs-function"><span class="hljs-title">qtbl</span>-&gt;</span>note_entry();<span class="hljs-function"><span class="hljs-title">single_server</span>-&gt;</span>reserve();<span class="hljs-function"><span class="hljs-title">qtbl</span>-&gt;</span>note_exit();hold(exponential(<span class="hljs-number">2.5</span>));<span class="hljs-comment">//添加置信区间</span>table_confidence(tbl);qtable_confidence(qtbl);</code></pre><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NTERM 5500</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ND 92</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P_EXIT (1.0/11.0)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S_CPU 0.0005</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S_DISK 0.030</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Z 30.0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RUNTIME 200.0</span>FACILITY disk[ND],cpu;TABLE rt;EVENT done;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sim</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;create(<span class="hljs-string">&quot;sim&quot;</span>);init();<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;NTERM; i++)&#123;trans(i);&#125;wait(done);report();md1stat();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;max_processes(NTERM+<span class="hljs-number">1</span>);facility_set(disk,<span class="hljs-string">&quot;d&quot;</span>,ND);cpu = facility(<span class="hljs-string">&quot;cpu&quot;</span>);rt = TABLE(<span class="hljs-string">&quot;resp_tm&quot;</span>);done = EVENT(<span class="hljs-string">&quot;done&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nt)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">float</span> t,x;<span class="hljs-keyword">int</span> i;create(<span class="hljs-string">&quot;trans&quot;</span>);<span class="hljs-keyword">while</span>(clock&lt;RUNTIME)&#123;hold(expnt1(Z));t = clock;<span class="hljs-keyword">do</span> &#123;reserve(cpu);     hold(expnt1(S_CPU));    <span class="hljs-built_in">release</span>(cpu);x=prob();<span class="hljs-keyword">if</span>(x&gt;P_EXIT)&#123;i = <span class="hljs-built_in">random</span>(<span class="hljs-number">0</span>,ND<span class="hljs-number">-1</span>);reserve(disk[i]);    hold(expnt1(S_DISK));    <span class="hljs-built_in">release</span>(disk[i]);&#125;&#125;<span class="hljs-keyword">while</span>(x&gt;P_EXIT);record(clock-t,rt);&#125;<span class="hljs-built_in">set</span>(done);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Csim-通用型仿真工具&quot;&gt;&lt;a href=&quot;#Csim-通用型仿真工具&quot; class=&quot;headerlink&quot; title=&quot;Csim 通用型仿真工具&quot;&gt;&lt;/a&gt;Csim 通用型仿真工具&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;导师不久前给笔者安排了一个很不同寻</summary>
      
    
    
    
    <category term="仿真" scheme="http://durantthorvalds.top/categories/%E4%BB%BF%E7%9C%9F/"/>
    
    
    <category term="系统架构" scheme="http://durantthorvalds.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>逆向思维</title>
    <link href="http://durantthorvalds.top/2021/01/16/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4/"/>
    <id>http://durantthorvalds.top/2021/01/16/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4/</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-01-16T09:27:25.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向思维"><a href="#逆向思维" class="headerlink" title="逆向思维"></a>逆向思维</h1><h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/">174. 地下城游戏</a></h4><h4 id="803-打砖块-【打砖块——补砖块】"><a href="#803-打砖块-【打砖块——补砖块】" class="headerlink" title="803. 打砖块 【打砖块——补砖块】"></a><a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/">803. 打砖块</a> 【打砖块——补砖块】</h4><h4 id="312-戳气球【戳气球——放气球】"><a href="#312-戳气球【戳气球——放气球】" class="headerlink" title="312. 戳气球【戳气球——放气球】"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球</a>【戳气球——放气球】</h4><p>注意：一般而言，用到逆向思维的都是困难题。</p><p>所谓逆向思维就是我们要从题目的反面去考虑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逆向思维&quot;&gt;&lt;a href=&quot;#逆向思维&quot; class=&quot;headerlink&quot; title=&quot;逆向思维&quot;&gt;&lt;/a&gt;逆向思维&lt;/h1&gt;&lt;h4 id=&quot;174-地下城游戏&quot;&gt;&lt;a href=&quot;#174-地下城游戏&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="算法" scheme="http://durantthorvalds.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="困难" scheme="http://durantthorvalds.top/tags/%E5%9B%B0%E9%9A%BE/"/>
    
  </entry>
  
  <entry>
    <title>「核心」Ceph学习三部曲之七：对象存储网关RGW</title>
    <link href="http://durantthorvalds.top/2021/01/03/%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3RGW/"/>
    <id>http://durantthorvalds.top/2021/01/03/%E3%80%8C%E6%A0%B8%E5%BF%83%E3%80%8DCeph%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%BD%91%E5%85%B3RGW/</id>
    <published>2021-01-02T16:00:00.000Z</published>
    <updated>2021-01-17T12:28:12.946Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！</p><p>参考《Ceph设计与实现》谢型果等，第六章。以及<a href="https://docs.ceph.com/en/latest/man/8/rados/">官方RADOS指南</a>，以及<a href="https://docs.ceph.com/en/latest/radosgw/">官方RGW教程</a></p>          </div><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>前面我们讲过，Ceph集成了BlueStore分布式对象存储，针对非结构化的数据，比如静态数据，备份存储以及流媒体等场景。上一节，我们介绍了RADOS 中的RBD模块，并且rados提供了API接口librados供用户使用。这一节我们将介绍RADOS Gateway , 即RADOS网关，它主要支持两种类型的接口：</p><ul><li><strong>与S3兼容</strong>：为对象存储功能提供与Amazon S3 RESTful API的大部分子集兼容的接口。</li><li><strong>兼容Swift</strong>：为对象存储功能提供与OpenStack Swift API的大部分子集兼容的接口。</li></ul><p>因为Ceph核心模块RADOS提供的访问接口是私有接口，不支持通用的HTTP协议访问，因而为了支持HTTP协议访问，涉及了支持RESTful接口访问而设计的RADOS gateway.</p><blockquote><p><strong>官方定义</strong>：Ceph对象存储使用Ceph对象网关守护进程（<code>radosgw</code>），它是一个用于与Ceph存储群集进行交互的HTTP服务器。由于它提供与OpenStack Swift和Amazon S3兼容的接口，因此Ceph对象网关具有自己的用户管理。Ceph对象网关可以将数据存储在用于存储来自Ceph文件系统客户端或Ceph块设备客户端的数据的同一Ceph存储群集中。S3和Swift API共享一个公共的名称空间，因此可以使用一个API编写数据，而使用另一个API检索数据。</p><p>另外，<strong>Ceph对象存储也未使用MDS服务器！</strong></p></blockquote><p><img src="/img/1ae399f8fa9af1042d3e1cbf31828f14eb3fe01a6eb3352f88c3d2a04ac4dc50.png" alt=""></p><p>RGW作为对象存储网关系统，一方面扮演RADOS集群客户端角色，为对象存储应用提供RESTful接口；另一方面，扮演HTTP角色，接收并解析互联网传输数据。RGW目前支持主流的WEB服务器：Civetweb，Apache，Nginx等，其中Civetweb是一个C++库，可以内嵌到RGW框架中，是RGW默认的WEB服务器；Apache与Nginx需要以独立进程存在，收到应用请求后，通过RGW注册的监听端口号将请求转发到RGW上进行处理。</p><h2 id="1-1-数据组织"><a href="#1-1-数据组织" class="headerlink" title="1.1 数据组织"></a>1.1 数据组织</h2><p>一个对象存储系统包括三个部分：用户、存储桶和对象。</p><ul><li><strong>用户</strong>：指对象存储应用的使用者。一个用户拥有一个或多个存储桶。</li><li><p><strong>存储桶</strong>：是对象的容器，设置这一层级的目的是方便关联和操作具有同一属性的一类对象而引入的一层关联单元。</p></li><li><p><strong>对象</strong>：对象是存储的基本单位，包括数据和元数据两个部分。其中元数据在类型和数目上不受限制。与文件系统不同，对象存储系统中所有对象以扁平的方式存储，对象之间没有之间的关联。并且，对象存储不提供部分编辑功能，这意味着，即使更新一个字符，也必须将整个对象从云端下载下来，更新后上传。</p></li></ul><p>以Amazon S3为例，它数据实体包括user、bucket、object，如下图所示；而OpenStack将用户的概念细分为account和user，其中account对应一个项目或者租户，每个account可以被多个user共享，其他的集成实体比如container和object与以上的存储桶、对象概念相符。</p><p>RGW为了兼容Amazon S3和OpenStack接口，所以将用户分为user和subuser，分别对应S3用户和Swift用户。</p><p><img src="/img/image-20210103132412544.png" alt="image-20210103132412544" style="zoom:67%;" /></p><p><img src="/img/image-20210103132643135.png" alt="image-20210103132643135" style="zoom:67%;" /></p><p><img src="/img/image-20210103132828794.png" alt="image-20210103132828794" style="zoom:67%;" /></p><p>我们将详细讨论，这些数据实体所包含的信息和数据组织形式，由上一期我们知道，数据存在RADOS有三种方式，第一种是二进制；第二种是以键值对存在扩展属性xattr中；第三种是存在扩展属性omap中。</p><h2 id="1-2-用户"><a href="#1-2-用户" class="headerlink" title="1.2 用户"></a>1.2 用户</h2><p>对用户的设计管理主要包含以下几个方面：首先是为了对RESTful API进行请求认为，其次是为了控制用户对存储资源的访问权限，最后是为了控制用户的可用存储空间，因此一个用户包含的信息包括用户认证信息、访问认证控制权限信息和配额信息。</p><p>我们首先介绍RGW的认证机制，RGW针对S3 API和Swift API采用不同的认证机制。</p><p>S3用户认证兼容AWS2和AWS4两种认证机制，它们都是基于密匙认证。</p><p>认证过程如下：</p><p>1）应用在发送请求之前，使用用户私有密匙（secret_key）、请求内容等，采用与RGW网关约定好的算法计算出数字签名后，将数字签名以及用户访问密匙（access_key）封装在请求中发送给RGW网关。</p><p>2）RGW网关收到请求后，使用用户访问密匙作为索引从RADOS集群中读取用户信息，并从用户信息中获取用户私有密匙。</p><p>3）使用用户私有密匙、请求内容等，采用与约定好的算法计算数字签名。</p><p>4）判断RGW生成的数字签名与请求的签名是否匹配，如果是匹配的，则认为请求是真实的，用户认证通过。</p><p>对于Swift，采用的是令牌认证(token)。</p><p>1）应用在发出真正的操作请求前，向RGW网关请求一个有时限的令牌。</p><p>2）RGW收到令牌后，使用子用户ID作为索引从RADOS集群中读取出子用户信息，并使用子用户信息中获取到的Swift私有密匙生成一个令牌返回给应用。</p><p>3）应用在后续的操作中携带该令牌，RGW收到操作请求后，采用与（2）相同的方式生成一个令牌，并判断生成的令牌与请求中的令牌是否一致，如果一致，身份验证通过。</p><p>值得注意的是，对于每种资源所要求的权限是不同的，用户必须具备相应的权限。</p><p>此外，为了防止某些用户占用太多的存储空间，以及方便根据付费分配空间，RGW允许对用户进行配额限制。</p><p>RGW使用<code>RGWUserInfo</code>管理元数据。</p><div class="table-container"><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>users.uid</td><td>在“ <user>”对象中包含每个用户信息（RGWUserInfo），并在“ <user> .buckets”对象的omaps中包含存储桶的每个用户列表。如果非空，则“ &lt;用户&gt;”可以包含租户，例如：<code>prodtx$prodt test2.buckets prodtx$prodt.buckets test2</code></td></tr><tr><td>users.email</td><td></td></tr><tr><td>access_keys</td><td>用户认证。包括用户访问密匙Id，和私有密匙key</td></tr><tr><td>swift_keys</td><td>Swift用户认证。包括子用户ID：Subuser，以及子用户私有密匙Key。</td></tr><tr><td>subusers</td><td>子用户。包括Name和perm_mask（子用户访问权限）。</td></tr><tr><td>op_mask</td><td>用户访问权限。包括read、write、delete。</td></tr><tr><td>Caps</td><td>授权用户权限。由<caps-type,perm>组成</td></tr></tbody></table></div><p>RGW将用户信息保存在RADOS对象的数据部分，一个用户对应一个RADOS对象。由于大部分情况下，使用“pool名+对象名”来查询一个对象。</p><p>由于认证过程中需要使用用户访问密匙、子用户作为索引读取用户信息，并且在设置存储桶和对象的访问权限时，允许在存储桶和对象的访问权限授予email为xxx的用户，在操作进行鉴权检查时需要使用email作为索引获取用户信息。RGW采用了二级索引方式，即分别创建以用户访问密匙、子用户、email命名的三个RADOS对象，并将用户ID保存在对象的数据部分。当需要使用某个索引查询用户信息时，首先从索引对象读出用户ID，然后使用用户ID作为索引读取用户信息。</p><h2 id="1-3-存储桶"><a href="#1-3-存储桶" class="headerlink" title="1.3 存储桶"></a>1.3 存储桶</h2><p>一个存储桶对应一个RADOS对象。包含两类信息，一种是用户自定义的元数据信息，通常以键值对形式存储 。</p><p>另一类信息是对象存储策略、存储桶中索引对象的数目以及应用对象与索引对象的映射关系、存储桶的配额等，由RGWBucketInfo管理。</p><p>在创建存储桶的同时，RGW网关会同步创建一个或多个索引（index）对象，用于保存该存储桶下的对象列表，以支持查询存储桶对象列表（List Bucket）功能，因此在存储桶中有新的对象上传或者删除必须更新索引对象。</p><p>​    为了避免索引对象的更新成为对象上传删除的瓶颈，RGW采用了Ceph惯用的伎俩——shard，即分片，它的确会带来性能上的提升，但这也会影响查询存储桶对象列表操作的性能。</p><h3 id="存储桶的创建"><a href="#存储桶的创建" class="headerlink" title="存储桶的创建"></a>存储桶的创建</h3><p>流程如下：</p><ol><li>从HTTP请求解析出相关参数；</li><li>判断存储桶是否存在；若存在则依次判断已存在的bucket的拥有者是否为前用户，以及已存在bucket与带创建的bucket的存储策略是否相同，若为否，则返回bucket已存在；否则转到3；                                                                                                                                                                                                                                                                  </li><li>创建bucket实体；</li><li>更新user_id.buckets对象；</li><li>返回创建成功。</li></ol><blockquote><p>注意：同一租户下不同用户不能创建同名的存储桶。</p><p>我们知道OMAP由一个头部和多个KV条目组成，针对user_id.buckets对象，OMAP头部保存用户使用空间统计信息<code>cls_user_header</code>; OMAP的KV条目保存一个存储桶使用的空间统计信息<code>cls_user_bucket_entry</code>。</p></blockquote><h2 id="1-4-对象"><a href="#1-4-对象" class="headerlink" title="1.4 对象"></a>1.4 对象</h2><p>RGW对单个对象提供了两种上传接口：<strong>整体上传</strong>与<strong>分段上传</strong>。RGW限制了整体上传一个对象不能大于5GB（与Amazon S3）相同。用户上传的对象不能大于该限制，否则会上传失败。</p><p>我们介绍两个宏值：</p><ul><li><code>rgw_max_chunk_size</code>：该宏值用来表示RGW下发到RADOS集群单个I/O的大小，同时决定对象分成多个RADOS对象时首对象的大小，以下简称分块大小。</li><li><code>rgw_obj_stripe_size</code>：该宏值用来指定当一个对象被分为多个RADOS对象时中间对象的大小，以下简称条带大小。</li><li><code>Class RGWObjManifest</code>：用来管理用户上传的对象和RADOS对象的对应关系，以下简称manifest。</li></ul><p>用户上传一个大小小于分块的对象，那么很容易理解，该RADOS对象以应用对象名称命名，应用对象元数据也保存在该RADOS对象的扩展属性中；若用户上传的对象大于分块，那么将被分解为一个大小等于分块大小的首对象，多个大小等于条带大小的中间对象，和一个小于条带大小的尾对象。</p><p>当所有分段上传完成之后，RGW会生成一个RADOS对象，用于保存应用对象元数据和所有分段的manifest。</p><p>值得注意的是，用户上传的元数据的大小最好能被条带大小整除，否则会造成RADOS对象比每个分段条带数多且对象大小分布不均匀。从而数据管理复杂度增加。</p><h2 id="1-5-数据存储位置"><a href="#1-5-数据存储位置" class="headerlink" title="1.5 数据存储位置"></a>1.5 数据存储位置</h2><p>不同的用户数据最终以RADOS对象为单位存储到RADOS集群，RGW使用zone来管理用户数据的存储位置，zone由一组存储池（pool）组成，不同的存储池用来保存不同的数据，RGW使用RGWZoneParams来管理不同的存储池。</p><h2 id="1-6-I-O流程"><a href="#1-6-I-O流程" class="headerlink" title="1.6 I/O流程"></a>1.6 I/O流程</h2><p>如图所示，OP线程从HTTP前端接收到I/O请求后，首先在REST API通用处理层，从HTTP语义中解析出S3或Swift数据并进行一系列检查，之后再根据不同API请求执行不同处理流程，如需从RADOS集群获取数据或者往RADOS集群写入数据，则通过RGW与RADOS接口适配层调用librados接口来进行交互。</p><p><img src="/img/image-20210110211049069.png" alt="image-20210110211049069"></p><h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><p>对于S3 API，RGW支持认证用户和匿名用户访问。RGW V2支持本地认证、LDAP和keystone三种认证方式。</p><p>对于Swift，支持临URL认证、RGW本地认证、Keystone认证、匿名认证和匿名认证等五种认证引擎。</p><h3 id="用户、存储桶、对象访问ACL"><a href="#用户、存储桶、对象访问ACL" class="headerlink" title="用户、存储桶、对象访问ACL"></a>用户、存储桶、对象访问ACL</h3><p>对于S3 API：权限如下：</p><ul><li>READ：查询对象</li><li><p>WRITE：上传、删除对象</p></li><li><p>READ_ACP：允许读取存储桶访问控制表</p></li><li><p>WRITE_ACP：允许修改存储桶访问控制表</p></li><li><p>FULL_CONTROL: 完全控制权限</p></li></ul><p>对于Swift，则分为用户访问控制和存储桶访问控制：</p><ul><li>read-only: 读取本用户下所有内容，比如存储桶列表，对象列表等；</li><li>read-write：授权指定用户读或写任意一个存储桶；</li><li>admin：可以创建删除更新用户头部信息，并且授予其它用户权限。</li><li></li></ul><h3 id="配额"><a href="#配额" class="headerlink" title="配额"></a>配额</h3><p>用户和存储桶的配额分别用user_quota和bucket_quota表示。RGW实例的配额通过如下方式：</p><ul><li>全局配置，适用于所有用户；</li><li>创建用户或更新用户配置时设置；</li><li>对于Swift接口，可在更新用户数据时配置或修改user_quota，在更新存储桶元数据时，配置或修改bucket_quota。</li></ul><p>关于配额，开发者们也进行了富有工程价值的思考，为了避免I/O重复读写，RGW网关设计了一个LRU缓存，将用户和存储桶配额以一个map的形式保存在缓存中，优先从缓存中进行读写，然后再定时将缓存数据刷到对象中。</p><p>这样的话对于数据在缓存保存时间，刷新间隔都有要求。设计者提出了用三个参数进行控制：</p><ul><li><code>rgw_bucket_quota_ttl</code>: 存储桶配额缓存可信任时间段。在检查配额是否达到限制时，如果缓存中记录的使用量达到配额上限（默认95%）或者距离上次从RADOS集群中更新配额到缓存中的事件超过该时间时，则需要更新缓存，并重置该参数。</li><li><code>rgw_user_quota_bucket_sync_interval</code>：控制存储桶已用空间从缓存刷到RADOS集群的间隔时间。</li><li><code>rgw_user_quota_sync_interval</code>：控制用户已用空间从缓存刷到RADOS集群的间隔时间。</li></ul><h2 id="1-7-对象上传"><a href="#1-7-对象上传" class="headerlink" title="1.7 对象上传"></a>1.7 对象上传</h2><p>RGW针对对象上传设计了两个接口：<strong>整体上传接口</strong>和<strong>分段上传接口</strong>。</p><p>整体上传有三个步骤：</p><ol><li>prepare：初始化manifest数据结构；</li><li>handle_data：RGW每次从HTTP server中取出<code>rgw_max_chunk_size</code>字节数据，存放在一个bufferlist中，然后分成一个或多个I/O异步下发送到RADOS层，每个I/O的大小等于<code>min(rgw_max_chunk_size,next_part_ofs - data_ofs)</code> ，<code>next_part_ofs</code>表示下一个RADOS对象保存的用户数据偏移位置，<code>data_ofs</code>表示当前数据的偏移位置。</li></ol><p>以一个块大小为2MB，条带大小为5MB为例，用户上传一个9MB对象，那么应用对象先按照2MB进行分割，最后会余下1MB。其中0-2MB为对象1， 2MB-4MB和4MB-6MB，6MB-7MB共同拼接为对象2，最后的7MB-8MB以及8MB-9MB组成对象3.</p><ol><li>complete：该阶段主要是将对象元数据更新到head_obj，同时将对象条目更新到索引对象中。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note note-primary&quot;&gt;
            &lt;p&gt;本blog包括理论和实践两个部分，实践部分需要您事先部署成功Ceph集群！&lt;/p&gt;&lt;p&gt;参考《Ceph设计与实现》谢型果等，第六章。以及&lt;a href=&quot;https://docs.cep</summary>
      
    
    
    
    <category term="ceph" scheme="http://durantthorvalds.top/categories/ceph/"/>
    
    <category term="分布式存储" scheme="http://durantthorvalds.top/categories/ceph/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="系统架构" scheme="http://durantthorvalds.top/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="ceph" scheme="http://durantthorvalds.top/tags/ceph/"/>
    
  </entry>
  
</feed>
